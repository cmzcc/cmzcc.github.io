<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c++中关于深拷贝与重载赋值运算符的思考</title>
    <url>/2024/09/17/c-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h3 id="1-深拷贝"><a href="#1-深拷贝" class="headerlink" title="1.深拷贝"></a>1.深拷贝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class instance</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">	int* height;</span><br><span class="line">instance(int a,int h)</span><br><span class="line">&#123;</span><br><span class="line">	age = a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	height=new int(h);</span><br><span class="line">	cout &lt;&lt; *height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~instance()</span><br><span class="line">&#123;</span><br><span class="line">	if (height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete height;</span><br><span class="line">		height = NULL;</span><br><span class="line">		cout &lt;&lt; &quot;已清空&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">instance(const instance&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	age = p.age;</span><br><span class="line">	//height = p.height;编译器默认实现的就是这行代码</span><br><span class="line">	//深拷贝如下</span><br><span class="line">	height = new int(*p.height); </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//浅拷贝使两个height指向同一内存地址，会导致将已释放的内存再次释放，引发双重释放安全问题</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	instance p1(18,160);</span><br><span class="line">	instance p2(p1);</span><br><span class="line">	cout &lt;&lt; p2.age &lt;&lt;*p2.height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-重载赋值运算符"><a href="#2-重载赋值运算符" class="headerlink" title="2.重载赋值运算符"></a>2.重载赋值运算符</h2><p>众所周知，运算符重载后使运算符能实现原本无法完成的工作<br>赋值运算符，这里我们实现类对类的赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    char* data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数</span><br><span class="line">    MyClass(const char* str = &quot;&quot;) &#123;</span><br><span class="line">        data = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    MyClass(const MyClass&amp; other) &#123;</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重载赋值运算符</span><br><span class="line">    MyClass&amp; operator=(const MyClass&amp; other) &#123;</span><br><span class="line">        if (this == &amp;other) &#123;</span><br><span class="line">            return *this;  // 处理自赋值情况</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先释放原有资源</span><br><span class="line">        delete[] data;</span><br><span class="line"></span><br><span class="line">        // 分配新内存并拷贝数据</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line"></span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 析构函数</span><br><span class="line">    ~MyClass() &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印数据</span><br><span class="line">    void print() const &#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass a(&quot;Hello&quot;);</span><br><span class="line">    MyClass b(&quot;World&quot;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Before assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;Hello&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    a = b; // 使用重载的赋值运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;After assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;World&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="注意：一定要将被赋值对象中在堆中的数据释放掉。"><a href="#注意：一定要将被赋值对象中在堆中的数据释放掉。" class="headerlink" title="注意：一定要将被赋值对象中在堆中的数据释放掉。"></a>注意：一定要将被赋值对象中在堆中的数据释放掉。</h3><h3 id="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"><a href="#否则会导致旧资源直接被新资源赋值后，内存覆盖掉" class="headerlink" title="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"></a>否则会导致旧资源直接被新资源赋值后，内存覆盖掉</h3><h2 id="有内存泄露，资源浪费的风险，以及未定义行为的风险"><a href="#有内存泄露，资源浪费的风险，以及未定义行为的风险" class="headerlink" title="有内存泄露，资源浪费的风险，以及未定义行为的风险"></a>有内存泄露，资源浪费的风险，以及未定义行为的风险</h2><h4 id="具体会不会发生所谓的双重释放，个人认为不会"><a href="#具体会不会发生所谓的双重释放，个人认为不会" class="headerlink" title="具体会不会发生所谓的双重释放，个人认为不会"></a>具体会不会发生所谓的双重释放，个人认为不会</h4>]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>深拷贝</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
