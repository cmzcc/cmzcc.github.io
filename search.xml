<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Github拒绝push</title>
    <url>/2024/09/19/Github%E6%8B%92%E7%BB%9Dpush/</url>
    <content><![CDATA[<h2 id="Github-拒绝了你的push"><a href="#Github-拒绝了你的push" class="headerlink" title="Github 拒绝了你的push"></a>Github 拒绝了你的push</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ! [remote rejected] HEAD -&gt; main (push declined due to repository rule violations)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/cmzcc/cmzcc.github.io.git&#x27;</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教。"><a href="#今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教。" class="headerlink" title="今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教。"></a>今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教。</h4><h3 id="1-出现问题的原因"><a href="#1-出现问题的原因" class="headerlink" title="1.出现问题的原因"></a>1.出现问题的原因</h3><h4 id="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用。"><a href="#出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用。" class="headerlink" title="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用。"></a>出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用。</h4><h4 id="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用。"><a href="#我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用。" class="headerlink" title="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用。"></a>我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用。</h4><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><h4 id="（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下。"><a href="#（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下。" class="headerlink" title="（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下。"></a>（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下。</h4><h4 id="（2）找到你放网站的仓库，add-file看到没有"><a href="#（2）找到你放网站的仓库，add-file看到没有" class="headerlink" title="（2）找到你放网站的仓库，add file看到没有"></a>（2）找到你放网站的仓库，add file看到没有<img src="C:\Users\27215\Desktop\md.png" alt="md"></h4><h4 id="然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去。（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"><a href="#然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去。（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）" class="headerlink" title="然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去。（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"></a>然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去。（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）</h4><h4 id="等上传完毕后，不要退出！！！"><a href="#等上传完毕后，不要退出！！！" class="headerlink" title="等上传完毕后，不要退出！！！"></a>等上传完毕后，不要退出！！！</h4><h4 id="点下面的提交即可，你的网站就水灵灵的更新啦。"><a href="#点下面的提交即可，你的网站就水灵灵的更新啦。" class="headerlink" title="点下面的提交即可，你的网站就水灵灵的更新啦。"></a>点下面的提交即可，你的网站就水灵灵的更新啦。</h4>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>error</tag>
        <tag>hexo</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中关于深拷贝与重载赋值运算符的思考</title>
    <url>/2024/09/17/c-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class instance</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">	int* height;</span><br><span class="line">instance(int a,int h)</span><br><span class="line">&#123;</span><br><span class="line">	age = a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	height=new int(h);</span><br><span class="line">	cout &lt;&lt; *height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~instance()</span><br><span class="line">&#123;</span><br><span class="line">	if (height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete height;</span><br><span class="line">		height = NULL;</span><br><span class="line">		cout &lt;&lt; &quot;已清空&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">instance(const instance&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	age = p.age;</span><br><span class="line">	//height = p.height;编译器默认实现的就是这行代码</span><br><span class="line">	//深拷贝如下</span><br><span class="line">	height = new int(*p.height); </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//浅拷贝使两个height指向同一内存地址，会导致将已释放的内存再次释放，引发双重释放安全问题</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	instance p1(18,160);</span><br><span class="line">	instance p2(p1);</span><br><span class="line">	cout &lt;&lt; p2.age &lt;&lt;*p2.height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h1><p>众所周知，运算符重载后使运算符能实现原本无法完成的工作<br>赋值运算符，这里我们实现类对类的赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    char* data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数</span><br><span class="line">    MyClass(const char* str = &quot;&quot;) &#123;</span><br><span class="line">        data = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    MyClass(const MyClass&amp; other) &#123;</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重载赋值运算符</span><br><span class="line">    MyClass&amp; operator=(const MyClass&amp; other) &#123;</span><br><span class="line">        if (this == &amp;other) &#123;</span><br><span class="line">            return *this;  // 处理自赋值情况</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先释放原有资源</span><br><span class="line">        delete[] data;</span><br><span class="line"></span><br><span class="line">        // 分配新内存并拷贝数据</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line"></span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 析构函数</span><br><span class="line">    ~MyClass() &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印数据</span><br><span class="line">    void print() const &#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass a(&quot;Hello&quot;);</span><br><span class="line">    MyClass b(&quot;World&quot;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Before assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;Hello&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    a = b; // 使用重载的赋值运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;After assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;World&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="注意：一定要将被赋值对象中在堆中的数据释放掉。"><a href="#注意：一定要将被赋值对象中在堆中的数据释放掉。" class="headerlink" title="注意：一定要将被赋值对象中在堆中的数据释放掉。"></a>注意：一定要将被赋值对象中在堆中的数据释放掉。</h3><h3 id="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"><a href="#否则会导致旧资源直接被新资源赋值后，内存覆盖掉" class="headerlink" title="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"></a>否则会导致旧资源直接被新资源赋值后，内存覆盖掉</h3><h2 id="有内存泄露，资源浪费的风险，以及未定义行为的风险"><a href="#有内存泄露，资源浪费的风险，以及未定义行为的风险" class="headerlink" title="有内存泄露，资源浪费的风险，以及未定义行为的风险"></a>有内存泄露，资源浪费的风险，以及未定义行为的风险</h2><h4 id="具体会不会发生所谓的双重释放，个人认为不会"><a href="#具体会不会发生所谓的双重释放，个人认为不会" class="headerlink" title="具体会不会发生所谓的双重释放，个人认为不会"></a>具体会不会发生所谓的双重释放，个人认为不会</h4>]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>重载</tag>
        <tag>深拷贝</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity（一）</title>
    <url>/2024/09/19/Unity%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="平动和转动"><a href="#平动和转动" class="headerlink" title="平动和转动"></a>平动和转动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class instance : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public float moveSpeed = 10f;</span><br><span class="line">    public float turnSpeed = 50f;</span><br><span class="line">    private void Update()//update是每帧更新的函数</span><br><span class="line">    &#123;</span><br><span class="line">        if(Input.GetKey(KeyCode.UpArrow))</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Translate(Vector3.forward * moveSpeed*Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        //translate是平移，vector3是一个三维数组，forward代表（0，0，1)</span><br><span class="line">        //deltatime是两帧之间的时间间隔</span><br><span class="line">        //没有使用 Time.deltaTime 的问题</span><br><span class="line">        //如果你只是使用 moveSpeed 来移动物体，而不使用 Time.deltaTime，</span><br><span class="line">        //物体每帧的移动量将是恒定的。如果帧率提高，物体移动的频率就会增加</span><br><span class="line">        //移动速度就会变快；如果帧率降低，物体的移动频率减小，移动速度就会变慢。</span><br><span class="line">        //使用 Time.deltaTime</span><br><span class="line">        //通过乘以 Time.deltaTime，可以保证物体每秒的移动量保持一致，不受帧率影响。</span><br><span class="line">        if (Input.GetKey(KeyCode.LeftArrow)) </span><br><span class="line">        &#123;</span><br><span class="line">            transform.Rotate(Vector3.up,turnSpeed*Time.deltaTime); </span><br><span class="line">        &#125;</span><br><span class="line">        //rotate是旋转，vector3.up表示（0，1，0），这里是转动的轴</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="摄像机的平滑跟随和视角锁定"><a href="#摄像机的平滑跟随和视角锁定" class="headerlink" title="摄像机的平滑跟随和视角锁定"></a>摄像机的平滑跟随和视角锁定</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SerializeField] Transform target;</span><br><span class="line">[SerializeField] Vector3 offset;</span><br><span class="line">[SerializeField] float transitionSpeed = 2;</span><br><span class="line"></span><br><span class="line">private void LateUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    if (target != null)</span><br><span class="line">    &#123;</span><br><span class="line">       Vector3 targetPos = target.position + offset;</span><br><span class="line">        transform.position = Vector3.Lerp(transform.position, targetPos, transitionSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Transform target;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.LookAt(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两种对摄像头的设置<br>第一种是摄像机的平滑跟随，第二种是视角锁定（摄像机不动，只转动）</p>
<h1 id="GetAxis"><a href="#GetAxis" class="headerlink" title="GetAxis"></a>GetAxis</h1><p>在 <strong>Unity</strong> 的 <strong>Input Manager</strong> 中，<code>Positive Button</code> 和 <code>Negative Button</code> 是用来处理轴输入（axis input）的。当你配置诸如 <code>&quot;Horizontal&quot;</code> 或 <code>&quot;Vertical&quot;</code> 这样代表方向或动作的输入轴时，这两个按钮起到了重要的作用。</p>
<h3 id="轴输入（Axis-Input）简介"><a href="#轴输入（Axis-Input）简介" class="headerlink" title="轴输入（Axis Input）简介"></a>轴输入（Axis Input）简介</h3><p>Unity 中的轴输入通常用来处理类似于左右、上下移动这样的操作。输入轴是一种 <strong>模拟输入</strong>，而不是简单的二元按键（开&#x2F;关）。例如：</p>
<ul>
<li><code>&quot;Horizontal&quot;</code> 轴可以映射到 <strong>A&#x2F;D</strong> 键或 <strong>左&#x2F;右</strong> 方向键，表示横向移动。</li>
<li><code>&quot;Vertical&quot;</code> 轴可以映射到 <strong>W&#x2F;S</strong> 键或 <strong>上&#x2F;下</strong> 方向键，表示纵向移动。</li>
</ul>
<p>这些轴输入返回的值在 <strong>-1 到 1</strong> 之间，用来表示不同的方向或强度。</p>
<h3 id="Positive-Button-和-Negative-Button-的作用"><a href="#Positive-Button-和-Negative-Button-的作用" class="headerlink" title="Positive Button 和 Negative Button 的作用"></a><code>Positive Button</code> 和 <code>Negative Button</code> 的作用</h3><ul>
<li><strong>Positive Button</strong> 是用来指定当你按下该按钮时，输入轴返回正向值（如 <code>1</code>）。例如，”D” 键或右方向键通常用作 <code>Positive Button</code>，它会让角色向右移动。</li>
<li><strong>Negative Button</strong> 是用来指定当你按下该按钮时，输入轴返回负向值（如 <code>-1</code>）。例如，”A” 键或左方向键通常用作 <code>Negative Button</code>，它会让角色向左移动。</li>
</ul>
<h3 id="示例：Horizontal-轴配置"><a href="#示例：Horizontal-轴配置" class="headerlink" title="示例：Horizontal 轴配置"></a>示例：<code>Horizontal</code> 轴配置</h3><p>假设我们在 <strong>Input Manager</strong> 中配置了一个名为 <code>&quot;Horizontal&quot;</code> 的输入轴。常见的设置可能是这样的：</p>
<ul>
<li><strong>Name</strong>: Horizontal</li>
<li><strong>Negative Button</strong>: A (或 Left Arrow)</li>
<li><strong>Positive Button</strong>: D (或 Right Arrow)</li>
<li><strong>Gravity</strong>: 3</li>
<li><strong>Dead</strong>: 0.001</li>
<li><strong>Sensitivity</strong>: 3</li>
<li><strong>Type</strong>: Key or Mouse Button</li>
<li><strong>Axis</strong>: X axis</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>当你按下 <code>Positive Button</code>（比如 <code>&quot;D&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个正值，接近 <code>1</code>。</li>
<li>当你按下 <code>Negative Button</code>（比如 <code>&quot;A&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个负值，接近 <code>-1</code>。</li>
<li>如果没有按下任何按钮，<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 将返回 <code>0</code>，表示没有水平输入。</li>
</ol>
<h3 id="为什么使用-Positive-和-Negative-按钮？"><a href="#为什么使用-Positive-和-Negative-按钮？" class="headerlink" title="为什么使用 Positive 和 Negative 按钮？"></a>为什么使用 Positive 和 Negative 按钮？</h3><p>它们的主要作用是提供一种简便的方式来处理方向性输入。例如，移动角色时，可以根据返回的轴值决定角色的移动方向：</p>
<ul>
<li>如果 <code>Input.GetAxis(&quot;Horizontal&quot;)</code> 返回正值（如 1），角色向右移动。</li>
<li>如果返回负值（如 -1），角色向左移动。</li>
</ul>
<h3 id="示例：检测水平轴输入并移动角色"><a href="#示例：检测水平轴输入并移动角色" class="headerlink" title="示例：检测水平轴输入并移动角色"></a>示例：检测水平轴输入并移动角色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float move = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">    transform.Translate(Vector3.right * move * Time.deltaTime * speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果玩家按下 <strong>“D”</strong> 或 <strong>右方向键</strong>（<code>Positive Button</code>），<code>move</code> 会变成正值，角色向右移动。</li>
<li>如果玩家按下 <strong>“A”</strong> 或 <strong>左方向键</strong>（<code>Negative Button</code>），<code>move</code> 会变成负值，角色向左移动。</li>
</ul>
<h3 id="配置解释"><a href="#配置解释" class="headerlink" title="配置解释"></a>配置解释</h3><ul>
<li><strong>Gravity</strong>: 控制按键松开后，轴值回到零的速度。数值越大，返回到 0 的速度越快。</li>
<li><strong>Sensitivity</strong>: 控制按键按下时，轴值从 0 加速到 1（或 -1）的速度。数值越大，响应越快。</li>
<li><strong>Dead</strong>: 一个小阈值，避免微小输入造成意外响应。小于该值的输入会被视为 0。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Positive Button</strong>：用于正方向的输入，通常映射为右&#x2F;上方向键或控制器的正向输入。</li>
<li><strong>Negative Button</strong>：用于负方向的输入，通常映射为左&#x2F;下方向键或控制器的反向输入。</li>
<li>它们是用于控制方向性输入的核心元素，特别是在控制角色移动时。</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>打卡</tag>
        <tag>闲得无聊所以发发</tag>
      </tags>
  </entry>
  <entry>
    <title>博客网站的创建教程</title>
    <url>/2024/09/16/%E7%BD%91%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="博客网站的创建"><a href="#博客网站的创建" class="headerlink" title="博客网站的创建"></a>博客网站的创建</h1><h2 id="1-前期准备工作"><a href="#1-前期准备工作" class="headerlink" title="1.前期准备工作"></a>1.前期准备工作</h2><h3 id="1-Git-Node-js-Hexo的安装"><a href="#1-Git-Node-js-Hexo的安装" class="headerlink" title="(1)Git Node.js Hexo的安装"></a>(1)Git Node.js Hexo的安装</h3><h5 id="这里就不讲git-node-js的安装了，网上直接下就完了"><a href="#这里就不讲git-node-js的安装了，网上直接下就完了" class="headerlink" title="这里就不讲git node.js的安装了，网上直接下就完了"></a>这里就不讲git node.js的安装了，网上直接下就完了</h5><h5 id="下面是hexo的安装，建议专门找一个文件夹，用GBH运行"><a href="#下面是hexo的安装，建议专门找一个文件夹，用GBH运行" class="headerlink" title="下面是hexo的安装，建议专门找一个文件夹，用GBH运行"></a>下面是hexo的安装，建议专门找一个文件夹，用GBH运行</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g  # 全局安装 Hexo CLI</span><br><span class="line">hexo init blog  # 初始化 Hexo 项目，创建 &#x27;blog&#x27; 目录</span><br><span class="line">cd blog  # 进入 &#x27;blog&#x27; 目录</span><br><span class="line">npm install  # 安装 Hexo 项目依赖</span><br><span class="line">hexo s  # 启动 Hexo </span><br></pre></td></tr></table></figure>

<h3 id="（2）主题拷贝"><a href="#（2）主题拷贝" class="headerlink" title="（2）主题拷贝"></a>（2）主题拷贝</h3><p>在hexo网页中（友链中有链接）最下面能看到409种主题（前人的智慧），然后在里面选择一个你感兴趣的主题就好了</p>
<p>这里个人推荐几个：Next,butterfly,ayer</p>
<p>然后找到GitHub，在你的文件夹下找到theme,git clone即可，不要忘记修改_config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: butterfly//最后几行</span><br></pre></td></tr></table></figure>

<p>然后尝试看看你的页面吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl//清空缓存</span><br><span class="line">hexo g//生成静态网页</span><br><span class="line">hexo s//生成本地网页</span><br></pre></td></tr></table></figure>

<h2 id="2-尝试发布，公开"><a href="#2-尝试发布，公开" class="headerlink" title="2.尝试发布，公开"></a>2.尝试发布，公开</h2><h3 id="（1）尝试发布第一篇博客"><a href="#（1）尝试发布第一篇博客" class="headerlink" title="（1）尝试发布第一篇博客"></a>（1）尝试发布第一篇博客</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;第一篇博客&quot;</span><br></pre></td></tr></table></figure>

<p>然后重新生成静态网页，本地网页，应该就能看见了</p>
<p>其原理是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &quot;title&quot;</span><br></pre></td></tr></table></figure>

<p>等以后可以在博客的md文件中加入标签和分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 博客网站的创建教程</span><br><span class="line">date: 2024-09-16</span><br><span class="line">categories: [教程]</span><br><span class="line">tags: [Hexo, 博客搭建, 前端]</span><br></pre></td></tr></table></figure>

<p>比如这篇文章的</p>
<h3 id="（2）发布在github-io上"><a href="#（2）发布在github-io上" class="headerlink" title="（2）发布在github.io上"></a>（2）发布在github.io上</h3><p>首先在你的github账号上新建一个名为cmzcc.github.io的仓库（这里cmzcc换成你的github名字即可）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: https:/github.com/cmzcc/cmzcc.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>在_config.yml进行以上修改，repo中用github.com&#x2F;cmzcc&#x2F;cmzcc.github.io.git即可，中间可以加通行证</p>
<p>在github主页中的&#x2F;setting&#x2F;developer setting&#x2F;personal access tokens&#x2F;tokens(classic)申请即可，在&#x2F;&#x2F;后加通行证然后加@</p>
<p>然后运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>运行完成后，你应该就能在https:&#x2F;cmzcc.github.io中见到它了</p>
<h2 id="3-个人DIY"><a href="#3-个人DIY" class="headerlink" title="3.个人DIY"></a>3.个人DIY</h2><h3 id="（1）修改主题配置"><a href="#（1）修改主题配置" class="headerlink" title="（1）修改主题配置"></a>（1）修改主题配置</h3><p>将&#x2F;theme&#x2F;“主题名称”&#x2F;_config.yml复制一份，到你的hexo根目录下，改名为_config.”主题名”.yml（备份，太重要了，血的教训）</p>
<p>所有比较善解人意的主题，都会有readme，可能github仓库里不全，那就在作者的个人博客中。</p>
<p>接下来就是个人发挥时间，大部分功能你只要选择true or flase即可</p>
<h3 id="2-子页"><a href="#2-子页" class="headerlink" title="(2) 子页"></a>(2) 子页</h3><p>初始情况下我们只有自己写的博客这一个子页，如果想新加几个子页，就需要用以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;子页名&quot;</span><br></pre></td></tr></table></figure>

<p>ps:你的主题中会给你配置好一些常见的子页的配置，直接就能得到帅气页面（eg:link,tag,category…）</p>
<p>然后在根目录下&#x2F;source&#x2F;中就能找到那个文件夹。</p>
<p>接下来对文件夹下的md文件进行编辑即可，这里推荐一个md文档编辑器：typora</p>
<h3 id="（3）其他功能"><a href="#（3）其他功能" class="headerlink" title="（3）其他功能"></a>（3）其他功能</h3><p>可以预见，个人网站花样极多，发挥你的想象力吧</p>
<h3 id="搜素系统："><a href="#搜素系统：" class="headerlink" title="搜素系统："></a>搜素系统：</h3><p>个人建议本地搜素就够了</p>
<h3 id="评论系统："><a href="#评论系统：" class="headerlink" title="评论系统："></a>评论系统：</h3><p>推荐一下<a href="https://www.bilibili.com/video/BV1Ft4y1A73f/?spm_id_from=333.1350.jump_directly&vd_source=1b08578fef86fba5aa90cd3727dff591">waline</a>,主要是免费。</p>
<p>打字机效果，看板娘等需要在github上找插件</p>
<h2 id="4-Q-A"><a href="#4-Q-A" class="headerlink" title="4.Q&amp;A"></a>4.Q&amp;A</h2><h4 id="Q-为什么网站部署到github没更新？"><a href="#Q-为什么网站部署到github没更新？" class="headerlink" title="Q:为什么网站部署到github没更新？"></a>Q:为什么网站部署到github没更新？</h4><h4 id="A-浏览器缓存问题，等三分钟，然后浏览器关闭，重新打开，不行就再摁几次F5。"><a href="#A-浏览器缓存问题，等三分钟，然后浏览器关闭，重新打开，不行就再摁几次F5。" class="headerlink" title="A:浏览器缓存问题，等三分钟，然后浏览器关闭，重新打开，不行就再摁几次F5。"></a>A:浏览器缓存问题，等三分钟，然后浏览器关闭，重新打开，不行就再摁几次F5。</h4><h4 id="Q-为什么本地网页和部署上的不一样？"><a href="#Q-为什么本地网页和部署上的不一样？" class="headerlink" title="Q:为什么本地网页和部署上的不一样？"></a>Q:为什么本地网页和部署上的不一样？</h4><h4 id="A-可能是浏览器缓存问题，先等等，也有不一样的概率，比如有些bug不影响本地静态网页，但影响托管的"><a href="#A-可能是浏览器缓存问题，先等等，也有不一样的概率，比如有些bug不影响本地静态网页，但影响托管的" class="headerlink" title="A:可能是浏览器缓存问题，先等等，也有不一样的概率，比如有些bug不影响本地静态网页，但影响托管的"></a>A:可能是浏览器缓存问题，先等等，也有不一样的概率，比如有些bug不影响本地静态网页，但影响托管的</h4><h4 id="网页，建议找找-config-yml里面是不是有bug"><a href="#网页，建议找找-config-yml里面是不是有bug" class="headerlink" title="网页，建议找找_config.yml里面是不是有bug"></a>网页，建议找找_config.yml里面是不是有bug</h4><p>————————————————————————————————————————————————————</p>
<p>完结撒花，希望多多评论</p>
<p>Ciallo～(∠・ω&lt; )⌒☆</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针与滑动窗口</title>
    <url>/2024/09/24/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="leetcode-题24"><a href="#leetcode-题24" class="headerlink" title="leetcode 题24"></a>leetcode 题24</h1><ul>
<li><pre><code>给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 方法一：双指针</span><br><span class="line"></span><br><span class="line">## 思路及算法：</span><br><span class="line"></span><br><span class="line">由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</span><br><span class="line"></span><br><span class="line">如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</span><br><span class="line"></span><br><span class="line">如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</span><br><span class="line"></span><br><span class="line">整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</span><br><span class="line"></span><br><span class="line">这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>class Solution {<br>public:<br>    int removeElement(vector<int>&amp; nums, int val) {<br>        int n &#x3D; nums.size();<br>        int left &#x3D; 0;<br>        for (int right &#x3D; 0; right &lt; n; right++) {<br>            if (nums[right] !&#x3D; val) {<br>                nums[left] &#x3D; nums[right];<br>                left++;<br>            }<br>        }<br>        return left;<br>    }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多两次。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</span><br><span class="line"></span><br><span class="line"># 方法二：双指针优化</span><br><span class="line"></span><br><span class="line">## 思路与算法：</span><br><span class="line"></span><br><span class="line">如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。</span><br><span class="line"></span><br><span class="line">实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。</span><br><span class="line"></span><br><span class="line">如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。</span><br><span class="line"></span><br><span class="line">当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。</span><br><span class="line"></span><br><span class="line">这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    int removeElement(vector<int>&amp; nums, int val) {<br>        int left &#x3D; 0, right &#x3D; nums.size();<br>        while (left &lt; right) {<br>            if (nums[left] &#x3D;&#x3D; val) {<br>                nums[left] &#x3D; nums[right - 1];<br>                right–;<br>            } else {<br>                left++;<br>            }<br>        }<br>        return left;<br>    }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 复杂度分析</span><br><span class="line"></span><br><span class="line">时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多一次。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(1)。我们只需要常数的空间保存若干变量。</span><br><span class="line"></span><br><span class="line"># leetcode 题24</span><br><span class="line"></span><br><span class="line">给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**</span><br><span class="line"></span><br><span class="line">找出该数组中满足其总和大于等于 `target` 的长度最小的 </span><br><span class="line"></span><br><span class="line">**子数组**</span><br><span class="line"></span><br><span class="line">`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。</span><br><span class="line"></span><br><span class="line">**示例 1：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 方法一：暴力解法（会超时）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    int minSubArrayLen(int s, vector<int>&amp; nums) {<br>        int n &#x3D; nums.size();<br>        if (n &#x3D;&#x3D; 0) {<br>            return 0;<br>        }<br>        int ans &#x3D; INT_MAX;<br>        for (int i &#x3D; 0; i &lt; n; i++) {<br>            int sum &#x3D; 0;<br>            for (int j &#x3D; i; j &lt; n; j++) {<br>                sum +&#x3D; nums[j];<br>                if (sum &gt;&#x3D; s) {<br>                    ans &#x3D; min(ans, j - i + 1);<br>                    break;<br>                }<br>            }<br>        }<br>        return ans &#x3D;&#x3D; INT_MAX ? 0 : ans;<br>    }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">时间复杂度：O(n的平方），其中 n 是数组的长度。需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组。</span><br><span class="line"></span><br><span class="line">空间复杂度：O(1)。</span><br><span class="line"></span><br><span class="line"># 方法二：前缀和 + 二分查找</span><br><span class="line"></span><br><span class="line">方法一的时间复杂度是 O(n的平方)，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要 O(n) 的时间。如果使用二分查找，则可以将时间优化到 O(logn)。</span><br><span class="line"></span><br><span class="line">为了使用二分查找，需要额外创建一个数组 sums 用于存储数组 nums 的前缀和，其中 sums[i] 表示从 nums[0] 到 nums[i−1] 的元素和。得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标 bound，使得 sums[bound]−sums[i−1]≥s，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）。</span><br><span class="line"></span><br><span class="line">因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。</span><br><span class="line"></span><br><span class="line">在很多语言中，都有现成的库和函数来为我们实现这里二分查找大于等于某个数的第一个位置的功能，比如 C++ 的 lower_bound。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    int minSubArrayLen(int s, vector<int>&amp; nums) {<br>        int n &#x3D; nums.size();<br>        if (n &#x3D;&#x3D; 0) {<br>            return 0;<br>        }<br>        int ans &#x3D; INT_MAX;<br>        vector<int> sums(n + 1, 0);<br>        &#x2F;&#x2F; 为了方便计算，令 size &#x3D; n + 1<br>        &#x2F;&#x2F; sums[0] &#x3D; 0 意味着前 0 个元素的前缀和为 0<br>        &#x2F;&#x2F; sums[1] &#x3D; A[0] 前 1 个元素的前缀和为 A[0]<br>        &#x2F;&#x2F; 以此类推<br>        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>            sums[i] &#x3D; sums[i - 1] + nums[i - 1];<br>        }<br>        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>            int target &#x3D; s + sums[i - 1];<br>            auto bound &#x3D; lower_bound(sums.begin(), sums.end(), target);<br>            if (bound !&#x3D; sums.end()) {<br>                ans &#x3D; min(ans, static_cast<int>((bound - sums.begin()) - (i - 1)));<br>            }<br>        }<br>        return ans &#x3D;&#x3D; INT_MAX ? 0 : ans;<br>    }<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 方法三：滑动窗口</span><br><span class="line"></span><br><span class="line">在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高。为了降低时间复杂度，可以使用滑动窗口的方法。</span><br><span class="line"></span><br><span class="line">定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）。</span><br><span class="line"></span><br><span class="line">初始状态下，start 和 end 都指向下标 0，sum 的值为 0。</span><br><span class="line"></span><br><span class="line">每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum&lt;s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    int minSubArrayLen(int target, vector<int>&amp; nums) {<br>        int result&#x3D;100001;<br>        int sum&#x3D;0;<br>        int i&#x3D;0;<br>        int subLength&#x3D;0;<br>        for(int j&#x3D;0;j&lt;nums.size();j++)<br>        {<br>            sum+&#x3D;nums[j];<br>            while(sum&gt;&#x3D;target)<br>            {<br>                subLength&#x3D;j-i+1;<br>                result&#x3D;result&lt;subLength?result:subLength;<br>                sum-&#x3D;nums[i++];<br>            }<br>        }<br>        return result&#x3D;&#x3D;100001?0:result;<br>    }<br>};</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
