<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Github拒绝push</title>
    <url>/2024/09/19/Github%E6%8B%92%E7%BB%9Dpush/</url>
    <content><![CDATA[<h2 id="Github-拒绝了你的push"><a href="#Github-拒绝了你的push" class="headerlink" title="Github 拒绝了你的push"></a>Github 拒绝了你的push</h2><p>你有没有出现以下问题？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ! [remote rejected] HEAD -&gt; main (push declined due to repository rule violations)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/cmzcc/cmzcc.github.io.git&#x27;</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教"><a href="#今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教" class="headerlink" title="今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教."></a>今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教.</h4><h3 id="1-出现问题的原因"><a href="#1-出现问题的原因" class="headerlink" title="1.出现问题的原因"></a>1.出现问题的原因</h3><h4 id="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用"><a href="#出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用" class="headerlink" title="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用."></a>出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用.</h4><h4 id="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用"><a href="#我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用" class="headerlink" title="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用."></a>我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用.</h4><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><h4 id="（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下"><a href="#（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下" class="headerlink" title="（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下."></a>（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下.</h4><h4 id="（2）找到你放网站的仓库，add-file看到没有"><a href="#（2）找到你放网站的仓库，add-file看到没有" class="headerlink" title="（2）找到你放网站的仓库，add file看到没有"></a>（2）找到你放网站的仓库，add file看到没有</h4><h4 id="然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去-（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"><a href="#然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去-（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）" class="headerlink" title="然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去.（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"></a>然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去.（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）</h4><h4 id="等上传完毕后，不要退出！！！"><a href="#等上传完毕后，不要退出！！！" class="headerlink" title="等上传完毕后，不要退出！！！"></a>等上传完毕后，不要退出！！！</h4><h4 id="点下面的提交即可，你的网站就水灵灵的更新啦"><a href="#点下面的提交即可，你的网站就水灵灵的更新啦" class="headerlink" title="点下面的提交即可，你的网站就水灵灵的更新啦."></a>点下面的提交即可，你的网站就水灵灵的更新啦.</h4>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>error</tag>
        <tag>hexo</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2025/01/12/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>Lambda 表达式</strong>是一种轻量级的函数对象（或匿名函数），可以在代码中定义并直接使用。它是从 C++11 引入的功能，常用于需要定义短小函数的场景，比如多线程、STL 算法或回调函数中。</p>
<hr>
<h2 id="1-Lambda-表达式的基本语法"><a href="#1-Lambda-表达式的基本语法" class="headerlink" title="1. Lambda 表达式的基本语法"></a><strong>1. Lambda 表达式的基本语法</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>捕获列表</code>**：定义 lambda 可以捕获哪些变量，以及如何捕获（按值或按引用）。</li>
<li>**<code>参数列表</code>**：和普通函数类似，定义函数的参数。</li>
<li>**<code>返回类型</code>**：可选，通常由编译器自动推断。</li>
<li>**<code>函数体</code>**：函数的逻辑部分。</li>
</ul>
<hr>
<h2 id="2-Lambda-表达式的基本示例"><a href="#2-Lambda-表达式的基本示例" class="headerlink" title="2. Lambda 表达式的基本示例"></a><strong>2. Lambda 表达式的基本示例</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最简单的 Lambda</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, Lambda!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda</span>(); <span class="comment">// 调用 lambda</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的 Lambda</span></span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, Lambda!</span><br><span class="line">Sum: 8</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-捕获列表"><a href="#3-捕获列表" class="headerlink" title="3. 捕获列表"></a><strong>3. 捕获列表</strong></h2><p>Lambda 可以通过 <strong>捕获列表</strong> 访问外部变量。捕获列表控制外部变量的作用域和捕获方式。</p>
<h3 id="1-按值捕获"><a href="#1-按值捕获" class="headerlink" title="(1) 按值捕获"></a><strong>(1) 按值捕获</strong></h3><ul>
<li>Lambda 会复制外部变量的值。</li>
<li>外部变量的值在 Lambda 定义时捕获，不受后续修改影响。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> byValue = [x] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Captured by value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">20</span>; <span class="comment">// 修改外部变量</span></span><br><span class="line">    <span class="built_in">byValue</span>(); <span class="comment">// 输出仍然是 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Captured by value: 10</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-按引用捕获"><a href="#2-按引用捕获" class="headerlink" title="(2) 按引用捕获"></a><strong>(2) 按引用捕获</strong></h3><ul>
<li>Lambda 捕获外部变量的引用，因此可以修改外部变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> byReference = [&amp;x] &#123;</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Captured by reference: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">byReference</span>(); <span class="comment">// 修改了 x</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Captured by reference: 20</span><br><span class="line">Modified x: 20</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-捕获所有变量"><a href="#3-捕获所有变量" class="headerlink" title="(3) 捕获所有变量"></a><strong>(3) 捕获所有变量</strong></h3><ul>
<li><strong>按值捕获所有变量</strong>：使用 <code>[=]</code>。</li>
<li><strong>按引用捕获所有变量</strong>：使用 <code>[&amp;]</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> captureAllByValue = [=] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> captureAllByReference = [&amp;] &#123;</span><br><span class="line">        x += <span class="number">5</span>;</span><br><span class="line">        y += <span class="number">5</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">captureAllByValue</span>(); <span class="comment">// 按值捕获，不影响外部变量</span></span><br><span class="line">    <span class="built_in">captureAllByReference</span>(); <span class="comment">// 按引用捕获，修改外部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x: 10, y: 20</span><br><span class="line">Modified x: 15, y: 25</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Lambda-的返回类型"><a href="#4-Lambda-的返回类型" class="headerlink" title="4. Lambda 的返回类型"></a><strong>4. Lambda 的返回类型</strong></h2><h3 id="1-自动推断返回类型"><a href="#1-自动推断返回类型" class="headerlink" title="(1) 自动推断返回类型"></a><strong>(1) 自动推断返回类型</strong></h3><ul>
<li>如果函数体只有一条 <code>return</code> 语句，返回类型会自动推断。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b; <span class="comment">// 自动推断为 int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-显式指定返回类型"><a href="#2-显式指定返回类型" class="headerlink" title="(2) 显式指定返回类型"></a><strong>(2) 显式指定返回类型</strong></h3><ul>
<li>如果返回类型不能自动推断，可以显式指定。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="type">double</span>)a / b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="5-Lambda-在-STL-中的使用"><a href="#5-Lambda-在-STL-中的使用" class="headerlink" title="5. Lambda 在 STL 中的使用"></a><strong>5. Lambda 在 STL 中的使用</strong></h2><p>Lambda 通常用作回调函数，尤其在 STL 算法中非常常见。</p>
<h3 id="1-用于-std-sort"><a href="#1-用于-std-sort" class="headerlink" title="(1) 用于 std::sort"></a><strong>(1) 用于 <code>std::sort</code></strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式自定义排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 按降序排序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5 3 2 1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-用于-std-for-each"><a href="#2-用于-std-for-each" class="headerlink" title="(2) 用于 std::for_each"></a><strong>(2) 用于 <code>std::for_each</code></strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并打印每个元素</span></span><br><span class="line">    std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-带状态的-Lambda"><a href="#6-带状态的-Lambda" class="headerlink" title="6. 带状态的 Lambda"></a><strong>6. 带状态的 Lambda</strong></h2><ul>
<li>Lambda 本质是一个函数对象，因此它可以存储状态。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [counter]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter; <span class="comment">// 由于捕获的是值，必须加 `mutable` 才能修改</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">increment</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">increment</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><strong>Lambda 表达式</strong>是一种简洁的方式定义匿名函数，非常适合短小的逻辑。</li>
<li><strong>捕获列表</strong>允许访问外部变量，通过值或引用捕获，甚至可以捕获所有变量。</li>
<li>在现代 C++ 中，Lambda 经常用于 STL 算法、多线程、回调等场景，是高效编写代码的重要工具。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity（一）</title>
    <url>/2024/09/19/Unity%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="平动和转动"><a href="#平动和转动" class="headerlink" title="平动和转动"></a>平动和转动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class instance : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public float moveSpeed = 10f;</span><br><span class="line">    public float turnSpeed = 50f;</span><br><span class="line">    private void Update()//update是每帧更新的函数</span><br><span class="line">    &#123;</span><br><span class="line">        if(Input.GetKey(KeyCode.UpArrow))</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Translate(Vector3.forward * moveSpeed*Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        //translate是平移，vector3是一个三维数组，forward代表（0，0，1)</span><br><span class="line">        //deltatime是两帧之间的时间间隔</span><br><span class="line">        //没有使用 Time.deltaTime 的问题</span><br><span class="line">        //如果你只是使用 moveSpeed 来移动物体，而不使用 Time.deltaTime，</span><br><span class="line">        //物体每帧的移动量将是恒定的.如果帧率提高，物体移动的频率就会增加</span><br><span class="line">        //移动速度就会变快；如果帧率降低，物体的移动频率减小，移动速度就会变慢.</span><br><span class="line">        //使用 Time.deltaTime</span><br><span class="line">        //通过乘以 Time.deltaTime，可以保证物体每秒的移动量保持一致，不受帧率影响.</span><br><span class="line">        if (Input.GetKey(KeyCode.LeftArrow)) </span><br><span class="line">        &#123;</span><br><span class="line">            transform.Rotate(Vector3.up,turnSpeed*Time.deltaTime); </span><br><span class="line">        &#125;</span><br><span class="line">        //rotate是旋转，vector3.up表示（0，1，0），这里是转动的轴</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="摄像机的平滑跟随和视角锁定"><a href="#摄像机的平滑跟随和视角锁定" class="headerlink" title="摄像机的平滑跟随和视角锁定"></a>摄像机的平滑跟随和视角锁定</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SerializeField] Transform target;</span><br><span class="line">[SerializeField] Vector3 offset;</span><br><span class="line">[SerializeField] float transitionSpeed = 2;</span><br><span class="line"></span><br><span class="line">private void LateUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    if (target != null)</span><br><span class="line">    &#123;</span><br><span class="line">       Vector3 targetPos = target.position + offset;</span><br><span class="line">        transform.position = Vector3.Lerp(transform.position, targetPos, transitionSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Transform target;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.LookAt(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两种对摄像头的设置<br>第一种是摄像机的平滑跟随，第二种是视角锁定（摄像机不动，只转动）</p>
<h1 id="GetAxis"><a href="#GetAxis" class="headerlink" title="GetAxis"></a>GetAxis</h1><p>在 <strong>Unity</strong> 的 <strong>Input Manager</strong> 中，<code>Positive Button</code> 和 <code>Negative Button</code> 是用来处理轴输入（axis input）的.当你配置诸如 <code>&quot;Horizontal&quot;</code> 或 <code>&quot;Vertical&quot;</code> 这样代表方向或动作的输入轴时，这两个按钮起到了重要的作用.</p>
<h3 id="轴输入（Axis-Input）简介"><a href="#轴输入（Axis-Input）简介" class="headerlink" title="轴输入（Axis Input）简介"></a>轴输入（Axis Input）简介</h3><p>Unity 中的轴输入通常用来处理类似于左右、上下移动这样的操作.输入轴是一种 <strong>模拟输入</strong>，而不是简单的二元按键（开&#x2F;关）.例如：</p>
<ul>
<li><code>&quot;Horizontal&quot;</code> 轴可以映射到 <strong>A&#x2F;D</strong> 键或 <strong>左&#x2F;右</strong> 方向键，表示横向移动.</li>
<li><code>&quot;Vertical&quot;</code> 轴可以映射到 <strong>W&#x2F;S</strong> 键或 <strong>上&#x2F;下</strong> 方向键，表示纵向移动.</li>
</ul>
<p>这些轴输入返回的值在 <strong>-1 到 1</strong> 之间，用来表示不同的方向或强度.</p>
<h3 id="Positive-Button-和-Negative-Button-的作用"><a href="#Positive-Button-和-Negative-Button-的作用" class="headerlink" title="Positive Button 和 Negative Button 的作用"></a><code>Positive Button</code> 和 <code>Negative Button</code> 的作用</h3><ul>
<li><strong>Positive Button</strong> 是用来指定当你按下该按钮时，输入轴返回正向值（如 <code>1</code>）.例如，”D” 键或右方向键通常用作 <code>Positive Button</code>，它会让角色向右移动.</li>
<li><strong>Negative Button</strong> 是用来指定当你按下该按钮时，输入轴返回负向值（如 <code>-1</code>）.例如，”A” 键或左方向键通常用作 <code>Negative Button</code>，它会让角色向左移动.</li>
</ul>
<h3 id="示例：Horizontal-轴配置"><a href="#示例：Horizontal-轴配置" class="headerlink" title="示例：Horizontal 轴配置"></a>示例：<code>Horizontal</code> 轴配置</h3><p>假设我们在 <strong>Input Manager</strong> 中配置了一个名为 <code>&quot;Horizontal&quot;</code> 的输入轴.常见的设置可能是这样的：</p>
<ul>
<li><strong>Name</strong>: Horizontal</li>
<li><strong>Negative Button</strong>: A (或 Left Arrow)</li>
<li><strong>Positive Button</strong>: D (或 Right Arrow)</li>
<li><strong>Gravity</strong>: 3</li>
<li><strong>Dead</strong>: 0.001</li>
<li><strong>Sensitivity</strong>: 3</li>
<li><strong>Type</strong>: Key or Mouse Button</li>
<li><strong>Axis</strong>: X axis</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>当你按下 <code>Positive Button</code>（比如 <code>&quot;D&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个正值，接近 <code>1</code>.</li>
<li>当你按下 <code>Negative Button</code>（比如 <code>&quot;A&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个负值，接近 <code>-1</code>.</li>
<li>如果没有按下任何按钮，<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 将返回 <code>0</code>，表示没有水平输入.</li>
</ol>
<h3 id="为什么使用-Positive-和-Negative-按钮？"><a href="#为什么使用-Positive-和-Negative-按钮？" class="headerlink" title="为什么使用 Positive 和 Negative 按钮？"></a>为什么使用 Positive 和 Negative 按钮？</h3><p>它们的主要作用是提供一种简便的方式来处理方向性输入.例如，移动角色时，可以根据返回的轴值决定角色的移动方向：</p>
<ul>
<li>如果 <code>Input.GetAxis(&quot;Horizontal&quot;)</code> 返回正值（如 1），角色向右移动.</li>
<li>如果返回负值（如 -1），角色向左移动.</li>
</ul>
<h3 id="示例：检测水平轴输入并移动角色"><a href="#示例：检测水平轴输入并移动角色" class="headerlink" title="示例：检测水平轴输入并移动角色"></a>示例：检测水平轴输入并移动角色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float move = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">    transform.Translate(Vector3.right * move * Time.deltaTime * speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果玩家按下 <strong>“D”</strong> 或 <strong>右方向键</strong>（<code>Positive Button</code>），<code>move</code> 会变成正值，角色向右移动.</li>
<li>如果玩家按下 <strong>“A”</strong> 或 <strong>左方向键</strong>（<code>Negative Button</code>），<code>move</code> 会变成负值，角色向左移动.</li>
</ul>
<h3 id="配置解释"><a href="#配置解释" class="headerlink" title="配置解释"></a>配置解释</h3><ul>
<li><strong>Gravity</strong>: 控制按键松开后，轴值回到零的速度.数值越大，返回到 0 的速度越快.</li>
<li><strong>Sensitivity</strong>: 控制按键按下时，轴值从 0 加速到 1（或 -1）的速度.数值越大，响应越快.</li>
<li><strong>Dead</strong>: 一个小阈值，避免微小输入造成意外响应.小于该值的输入会被视为 0.</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Positive Button</strong>：用于正方向的输入，通常映射为右&#x2F;上方向键或控制器的正向输入.</li>
<li><strong>Negative Button</strong>：用于负方向的输入，通常映射为左&#x2F;下方向键或控制器的反向输入.</li>
<li>它们是用于控制方向性输入的核心元素，特别是在控制角色移动时.</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>打卡</tag>
        <tag>闲得无聊所以发发</tag>
      </tags>
  </entry>
  <entry>
    <title>bind和回调函数的关系</title>
    <url>/2025/01/27/bind%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>在C++和其他编程语言中，**<code>bind</code>** 和 <strong>回调（Callback）</strong> 都是与函数调用有关的概念，但它们的作用和使用场景不同。接下来，我们来详细讲解它们的关系以及各自的功能。</p>
<h3 id="回调（Callback）函数"><a href="#回调（Callback）函数" class="headerlink" title="回调（Callback）函数"></a><strong>回调（Callback）函数</strong></h3><p>回调函数是一种设计模式，指的是将一个函数作为参数传递给另一个函数，并在某个事件发生时由后者调用这个函数。简单来说，回调函数是被“回调”执行的函数。</p>
<h4 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a><strong>回调函数的作用</strong></h4><ul>
<li>允许你在程序中实现灵活的控制流。</li>
<li>通过回调，你可以将具体的业务逻辑交给调用者来定义，而不是在框架或库中硬编码。</li>
</ul>
<h4 id="回调函数的典型示例"><a href="#回调函数的典型示例" class="headerlink" title="回调函数的典型示例"></a><strong>回调函数的典型示例</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Callback function called with value: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用回调的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">void</span> (*cb)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">cb</span>(data);  <span class="comment">// 调用回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">processData</span>(callback);  <span class="comment">// 传递回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>processData</code> 函数接受一个回调函数 <code>callback</code> 作为参数，并在适当时机调用它。<code>callback</code> 在 <code>processData</code> 中被回调。</p>
<h3 id="bind-的作用"><a href="#bind-的作用" class="headerlink" title="bind 的作用"></a><strong><code>bind</code> 的作用</strong></h3><p><code>bind</code> 是 C++11 中引入的标准库函数，用来创建一个新的可调用对象，将某些参数预先绑定到函数上，生成一个新的函数对象。<code>std::bind</code> 可以让你灵活地创建自定义回调函数，或者将部分函数参数预先填充。</p>
<h4 id="std-bind-的工作原理"><a href="#std-bind-的工作原理" class="headerlink" title="std::bind 的工作原理"></a><strong><code>std::bind</code> 的工作原理</strong></h4><ul>
<li><code>std::bind</code> 用于将某些参数“绑定”到函数上，创建一个新的函数对象，这个新的函数对象可以稍后被调用。</li>
<li>这与回调的关系在于，<code>bind</code> 可以帮助我们构造一个回调函数，而无需显式地定义一个回调函数。</li>
</ul>
<h4 id="std-bind-示例"><a href="#std-bind-示例" class="headerlink" title="std::bind 示例"></a><strong><code>std::bind</code> 示例</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  <span class="comment">// 包含 std::bind</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 来绑定参数</span></span><br><span class="line">    <span class="keyword">auto</span> bound_function = std::<span class="built_in">bind</span>(print_sum, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用绑定后的函数对象</span></span><br><span class="line">    <span class="built_in">bound_function</span>();  <span class="comment">// 输出：Sum: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::bind</code> 创建了一个新的函数对象 <code>bound_function</code>，它预先绑定了 <code>print_sum</code> 函数的两个参数。当调用 <code>bound_function()</code> 时，它会执行 <code>print_sum(10, 20)</code>。</p>
<h4 id="与回调的关系"><a href="#与回调的关系" class="headerlink" title="与回调的关系"></a><strong>与回调的关系</strong></h4><ul>
<li><code>std::bind</code> 是创建回调函数的一种方式。你可以将 <code>std::bind</code> 与事件驱动或异步处理机制结合起来，使用它来生成回调函数。</li>
<li>通过 <code>std::bind</code>，你可以将一些函数的参数预先填充，生成一个新的可调用对象，这个对象可以作为回调传递给其他函数。</li>
</ul>
<h3 id="回调与-bind-的关系"><a href="#回调与-bind-的关系" class="headerlink" title="回调与 bind 的关系"></a><strong>回调与 <code>bind</code> 的关系</strong></h3><ol>
<li><p><strong>回调函数</strong>是一个被传递并在未来某时被调用的函数。你可以通过回调让某个函数将控制权交给另一个函数。回调通常是在异步、事件驱动或接口设计中使用的。</p>
</li>
<li><p><strong><code>std::bind</code></strong> 是用于<strong>创建回调函数</strong>的一种方式，它将函数及其部分参数绑定在一起，生成一个新的可调用对象，方便将其作为回调传递给其他函数。</p>
</li>
</ol>
<hr>
<h3 id="示例：结合-bind-和回调"><a href="#示例：结合-bind-和回调" class="headerlink" title="示例：结合 bind 和回调"></a><strong>示例：结合 <code>bind</code> 和回调</strong></h3><p>假设我们有一个函数 <code>processData</code>，它接受一个回调函数。在这个例子中，我们使用 <code>std::bind</code> 来预先绑定参数，然后将生成的函数作为回调传递给 <code>processData</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  <span class="comment">// 包含 std::bind</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要回调的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; cb)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing data...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">cb</span>();  <span class="comment">// 调用回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定回调函数的参数</span></span><br><span class="line">    <span class="keyword">auto</span> bound_callback = std::<span class="built_in">bind</span>(print_sum, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将绑定后的函数作为回调传递</span></span><br><span class="line">    <span class="built_in">processData</span>(bound_callback);  <span class="comment">// 输出：Sum: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::bind</code> 创建了一个绑定了参数 10 和 20 的回调函数 <code>bound_callback</code>，然后它被传递到 <code>processData</code> 函数中执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>回调函数</strong>：允许将一个函数作为参数传递给另一个函数，稍后在适当的时机调用。</li>
<li>**<code>std::bind</code>**：是 C++11 引入的一个工具，用于绑定函数的部分参数，创建一个新的可调用对象。它常用于回调函数的生成，简化函数参数的传递和调用。</li>
</ul>
<p>两者的关系可以看作，**<code>bind</code> 是构建回调函数的一种方式**，尤其是当你希望提前指定回调函数的部分参数时。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中关于深拷贝与重载赋值运算符的思考</title>
    <url>/2024/09/17/c++%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class instance</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">	int* height;</span><br><span class="line">instance(int a,int h)</span><br><span class="line">&#123;</span><br><span class="line">	age = a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	height=new int(h);</span><br><span class="line">	cout &lt;&lt; *height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~instance()</span><br><span class="line">&#123;</span><br><span class="line">	if (height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete height;</span><br><span class="line">		height = NULL;</span><br><span class="line">		cout &lt;&lt; &quot;已清空&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">instance(const instance&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	age = p.age;</span><br><span class="line">	//height = p.height;编译器默认实现的就是这行代码</span><br><span class="line">	//深拷贝如下</span><br><span class="line">	height = new int(*p.height); </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//浅拷贝使两个height指向同一内存地址，会导致将已释放的内存再次释放，引发双重释放安全问题</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	instance p1(18,160);</span><br><span class="line">	instance p2(p1);</span><br><span class="line">	cout &lt;&lt; p2.age &lt;&lt;*p2.height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h1><p>众所周知，运算符重载后使运算符能实现原本无法完成的工作<br>赋值运算符，这里我们实现类对类的赋值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    char* data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数</span><br><span class="line">    MyClass(const char* str = &quot;&quot;) &#123;</span><br><span class="line">        data = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    MyClass(const MyClass&amp; other) &#123;</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重载赋值运算符</span><br><span class="line">    MyClass&amp; operator=(const MyClass&amp; other) &#123;</span><br><span class="line">        if (this == &amp;other) &#123;</span><br><span class="line">            return *this;  // 处理自赋值情况</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先释放原有资源</span><br><span class="line">        delete[] data;</span><br><span class="line"></span><br><span class="line">        // 分配新内存并拷贝数据</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line"></span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 析构函数</span><br><span class="line">    ~MyClass() &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印数据</span><br><span class="line">    void print() const &#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass a(&quot;Hello&quot;);</span><br><span class="line">    MyClass b(&quot;World&quot;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Before assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;Hello&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    a = b; // 使用重载的赋值运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;After assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;World&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="注意：一定要将被赋值对象中在堆中的数据释放掉"><a href="#注意：一定要将被赋值对象中在堆中的数据释放掉" class="headerlink" title="注意：一定要将被赋值对象中在堆中的数据释放掉."></a>注意：一定要将被赋值对象中在堆中的数据释放掉.</h3><h3 id="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"><a href="#否则会导致旧资源直接被新资源赋值后，内存覆盖掉" class="headerlink" title="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"></a>否则会导致旧资源直接被新资源赋值后，内存覆盖掉</h3><h2 id="有内存泄露，资源浪费的风险，以及未定义行为的风险"><a href="#有内存泄露，资源浪费的风险，以及未定义行为的风险" class="headerlink" title="有内存泄露，资源浪费的风险，以及未定义行为的风险"></a>有内存泄露，资源浪费的风险，以及未定义行为的风险</h2><h4 id="具体会不会发生所谓的双重释放，个人认为不会"><a href="#具体会不会发生所谓的双重释放，个人认为不会" class="headerlink" title="具体会不会发生所谓的双重释放，个人认为不会"></a>具体会不会发生所谓的双重释放，个人认为不会</h4>]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>重载</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的I/O流</title>
    <url>/2024/11/25/c++%E4%B8%AD%E7%9A%84IO%E6%B5%81/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>输入输出（I&#x2F;O）库</strong>提供了流（<code>stream</code>）的状态管理功能。每个流对象（如 <code>cin</code>, <code>cout</code>, <code>ifstream</code>, <code>ofstream</code> 等）都有一个与之相关的状态，标志着当前流的操作是否成功。流的状态主要通过流的<strong>条件标志</strong>（flags）来表示。这些标志通常用于检查流是否处于有效的状态，以便在进行输入输出操作时处理异常或错误。</p>
<h3 id="流的条件状态（Flags）"><a href="#流的条件状态（Flags）" class="headerlink" title="流的条件状态（Flags）"></a>流的条件状态（Flags）</h3><p>流的条件状态通过 <code>ios</code> 类中的几个成员标志进行管理，这些标志包括：</p>
<ol>
<li>**<code>good()</code>**：流是否处于正常状态，即没有发生任何错误。</li>
<li>**<code>eof()</code>**：流是否已经到达文件末尾。</li>
<li>**<code>fail()</code>**：流是否遇到输入&#x2F;输出错误。</li>
<li>**<code>bad()</code>**：流是否发生严重错误，导致无法继续读取或写入。</li>
</ol>
<p>这些状态标志可以通过流对象的方法访问，通常用于判断流的状态。</p>
<h3 id="流的状态检查"><a href="#流的状态检查" class="headerlink" title="流的状态检查"></a>流的状态检查</h3><h4 id="1-good"><a href="#1-good" class="headerlink" title="1. good()"></a>1. <code>good()</code></h4><ul>
<li><p><strong><code>good()</code></strong> 返回 <code>true</code> 如果流没有遇到任何错误，输入输出操作可以继续进行。它相当于检查流的状态是否为 <code>ios::goodbit</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入流状态正常。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-eof"><a href="#2-eof" class="headerlink" title="2. eof()"></a>2. <code>eof()</code></h4><ul>
<li><p><strong><code>eof()</code></strong> 检查流是否已经到达文件末尾或输入结束标志。对于从文件读取或从输入流读取数据时，可以使用该标志判断是否已读取完所有数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;已到达输入的末尾。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-fail"><a href="#3-fail" class="headerlink" title="3. fail()"></a>3. <code>fail()</code></h4><ul>
<li><p><strong><code>fail()</code></strong> 检查流是否发生了格式错误或输入输出错误。如果输入的数据类型不匹配或文件无法打开等操作失败时，会返回 <code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入数据失败，数据格式错误。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-bad"><a href="#4-bad" class="headerlink" title="4. bad()"></a>4. <code>bad()</code></h4><ul>
<li><p><strong><code>bad()</code></strong> 返回 <code>true</code>，如果流处于严重错误状态，通常在硬件故障或流被意外关闭时会发生。这是最严重的错误状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发生了严重错误，流无法继续使用。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见的流状态标志"><a href="#常见的流状态标志" class="headerlink" title="常见的流状态标志"></a>常见的流状态标志</h3><ul>
<li>**<code>ios::goodbit</code>**：正常状态，表示流没有错误。</li>
<li>**<code>ios::eofbit</code>**：表示流已到达文件末尾或输入结束。</li>
<li>**<code>ios::failbit</code>**：表示流遇到非致命错误，通常是格式错误或读取错误。</li>
<li>**<code>ios::badbit</code>**：表示流遇到致命错误，通常是硬件故障或无法继续操作。</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例 1: 标准输入流 (cin)</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个整数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入失败，格式错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你输入的整数是: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2: 文件输入流 (ifstream)</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否读取到末尾</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;已到达文件末尾。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3: 检查文件流是否出现严重错误</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件流出现严重错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>good()</code></strong> 用于检查流是否没有任何错误。</li>
<li><strong><code>eof()</code></strong> 用于检查是否已到达输入流的末尾。</li>
<li><strong><code>fail()</code></strong> 用于检查流是否发生了可恢复的错误（如输入数据不匹配）。</li>
<li><strong><code>bad()</code></strong> 用于检查流是否发生了致命错误。</li>
</ul>
<p>通过检查这些状态标志，你可以更加精确地控制和管理程序中的输入输出操作，及时捕获和处理异常。</p>
<h1 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h1><p>在 C++ 中，<code>string</code> 流（<code>stringstream</code>）是用于处理字符串输入和输出的流类，它包含在 <code>&lt;sstream&gt;</code> 头文件中。<code>stringstream</code> 可以被用来从字符串中提取数据，或者将数据格式化并输出到字符串中。它是 <code>iostream</code> 库的扩展，结合了输入流（<code>istringstream</code>）、输出流（<code>ostringstream</code>）和读写流（<code>stringstream</code>）。</p>
<h3 id="使用-stringstream（stringstream即可代替istringstream与ostringstream）"><a href="#使用-stringstream（stringstream即可代替istringstream与ostringstream）" class="headerlink" title="使用 stringstream（stringstream即可代替istringstream与ostringstream）"></a>使用 <code>stringstream</code>（stringstream即可代替istringstream与ostringstream）</h3><ol>
<li><p><strong>创建和初始化：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream ss; <span class="comment">// 创建一个空的 stringstream 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 &lt;&lt; 操作符向 stringstream 中写入数据</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot; world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 stringstream 中的内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stringstream content: &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们创建了一个空的 <code>stringstream</code> 对象 <code>ss</code>，并通过 <code>&lt;&lt;</code> 操作符向其中写入数据。通过 <code>ss.str()</code> 可以获取当前 <code>stringstream</code> 中的字符串。</p>
</li>
<li><p><strong>从字符串中提取数据：</strong><br>使用 <code>istringstream</code> 来从字符串中读取数据，类似于从文件或标准输入中读取数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;123 45.67 Hello&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>; <span class="comment">// 创建一个从字符串读取数据的 istringstream</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 stringstream 中提取数据</span></span><br><span class="line">    iss &gt;&gt; i &gt;&gt; d &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>iss &gt;&gt; i &gt;&gt; d &gt;&gt; s;</code>，我们从字符串 <code>str</code> 中依次提取数据，将其赋值给变量 <code>i</code>（整数）、<code>d</code>（浮动数）和 <code>s</code>（字符串）。</p>
</li>
<li><p><strong>向字符串写入数据：</strong><br>使用 <code>ostringstream</code> 可以将数据写入到一个字符串中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ostringstream oss; <span class="comment">// 创建一个输出流对象</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">    string name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 stringstream 写入数据</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取存储在 stringstream 中的字符串</span></span><br><span class="line">    string result = oss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们使用 <code>ostringstream</code> 将变量 <code>name</code> 和 <code>age</code> 写入字符串流 <code>oss</code> 中，然后通过 <code>oss.str()</code> 获取最终的字符串。</p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>**<code>istringstream</code>**：从字符串中读取数据。</li>
<li>**<code>ostringstream</code>**：将数据写入字符串。</li>
<li>**<code>stringstream</code>**：既能从字符串读取数据，也能将数据写入字符串。</li>
</ul>
<p>这种流的使用场景很多，常用于处理复杂的字符串格式转换、提取和拼接。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>I/O流</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性之emplace</title>
    <url>/2024/11/25/c++11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bemplace/</url>
    <content><![CDATA[<p><code>emplace</code> 是 C++ 中标准库（STL）提供的一种高效的元素插入方式，常用于容器（如 <code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code> 等）中。<code>emplace</code> 通过直接在容器内部构造元素，避免了不必要的拷贝或移动操作，从而提高了性能。</p>
<h3 id="emplace-和-insert-的区别"><a href="#emplace-和-insert-的区别" class="headerlink" title="emplace 和 insert 的区别"></a><code>emplace</code> 和 <code>insert</code> 的区别</h3><ul>
<li><p>**<code>insert</code>**：将一个已构造的对象插入到容器中。通常需要通过拷贝或移动构造将元素插入容器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">vec.<span class="built_in">insert</span>(vec.<span class="built_in">end</span>(), x);  <span class="comment">// 插入时会发生一次拷贝构造</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace</code>**：直接在容器内部构造元素，避免了额外的拷贝或移动操作。<code>emplace</code> 接受构造元素所需的参数，然后直接在容器中构造该元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">5</span>);  <span class="comment">// 在容器内部构造元素，避免拷贝</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么使用-emplace？"><a href="#为什么使用-emplace？" class="headerlink" title="为什么使用 emplace？"></a>为什么使用 <code>emplace</code>？</h3><ol>
<li><p><strong>避免不必要的拷贝或移动</strong>：</p>
<ul>
<li><code>insert</code> 必须先构造一个对象，然后将该对象插入容器，这可能涉及拷贝或移动构造。</li>
<li><code>emplace</code> 直接在容器中构造元素，省去了额外的拷贝或移动操作。</li>
</ul>
</li>
<li><p><strong>提高效率</strong>：</p>
<ul>
<li>特别是在容器中插入复杂对象时，使用 <code>emplace</code> 能显著提高性能，因为它直接传递构造参数，而不需要先创建一个对象。</li>
</ul>
</li>
</ol>
<h3 id="常见的-emplace-使用场景"><a href="#常见的-emplace-使用场景" class="headerlink" title="常见的 emplace 使用场景"></a>常见的 <code>emplace</code> 使用场景</h3><ul>
<li><p>**<code>emplace_back</code>**：用于 <code>std::vector</code> 等容器，在容器的末尾构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);  <span class="comment">// 直接构造元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace</code>**：对于 <code>std::map</code>、<code>std::unordered_map</code> 等关联容器，在指定位置构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">m.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);  <span class="comment">// 直接在 map 中构造一个键值对</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace_front</code>**：用于 <code>std::list</code> 等容器，在容器的前面构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line">lst.<span class="built_in">emplace_front</span>(<span class="number">10</span>);  <span class="comment">// 在容器前面直接构造一个元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="emplace-示例代码"><a href="#emplace-示例代码" class="headerlink" title="emplace 示例代码"></a><code>emplace</code> 示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 emplace_back 在 vector 中插入元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">10</span>);  <span class="comment">// 直接构造元素</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 10 20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace 在 map 中插入元素</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">    m.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    m.<span class="built_in">emplace</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : m) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// 1: apple</span></span><br><span class="line">    <span class="comment">// 2: banana</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>emplace</code> 提供了比 <code>insert</code> 更高效的方式来插入元素，因为它避免了不必要的对象构造、拷贝或移动操作。</li>
<li><code>emplace</code> 通过传递构造元素所需的参数，直接在容器内构造元素，而不是先创建元素再插入。</li>
<li>常见的 <code>emplace</code> 变种有 <code>emplace_back</code>（用于 <code>std::vector</code>）、<code>emplace</code>（用于 <code>std::map</code>, <code>std::unordered_map</code> 等）以及 <code>emplace_front</code>（用于 <code>std::list</code>）。</li>
</ul>
<p>使用 <code>emplace</code> 可以让你的程序更加高效，尤其是在需要频繁插入复杂对象时。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS，BFS遍历非联通图</title>
    <url>/2024/10/16/DFS%E9%81%8D%E5%8E%86%E9%9D%9E%E8%81%94%E9%80%9A%E5%9B%BE/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数 (DFS)</span><br><span class="line">// 从当前节点 `node` 开始访问，并递归访问其所有相邻的未访问节点</span><br><span class="line">void DFS(char node, unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph, unordered_set&lt;char&gt;&amp; visited) &#123;</span><br><span class="line">    // 标记当前节点为已访问</span><br><span class="line">    visited.insert(node);</span><br><span class="line">    // 输出当前节点（此处可以进行自定义的处理，像打印或其他操作）</span><br><span class="line">    cout &lt;&lt; node &lt;&lt; &quot; &quot;;  </span><br><span class="line"></span><br><span class="line">    // 遍历该节点的所有相邻节点</span><br><span class="line">    for (char neighbor : graph[node]) &#123;</span><br><span class="line">        // 如果相邻节点未访问过，则递归调用 DFS 访问该相邻节点</span><br><span class="line">        if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">            DFS(neighbor, graph, visited);  // 递归调用 DFS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历整个非联通图的DFS</span><br><span class="line">// 对于图中的每一个顶点，如果该顶点未访问过，执行 DFS 来遍历与其相连的部分</span><br><span class="line">void DFSForDisconnectedGraph(unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    // 创建一个集合，用于记录哪些节点已经访问过</span><br><span class="line">    unordered_set&lt;char&gt; visited;</span><br><span class="line">    </span><br><span class="line">    // 遍历图中的所有顶点（unordered_map 的每个键）</span><br><span class="line">    for (auto&amp; pair : graph) &#123;</span><br><span class="line">        char node = pair.first;  // 当前顶点</span><br><span class="line">        // 如果当前顶点未访问过，则从该顶点开始进行 DFS</span><br><span class="line">        if (visited.find(node) == visited.end()) &#123;</span><br><span class="line">            // 从一个新的连通分量的顶点开始新的 DFS</span><br><span class="line">            cout &lt;&lt; &quot;Starting new DFS from node: &quot; &lt;&lt; node &lt;&lt; endl;</span><br><span class="line">            DFS(node, graph, visited);  // 对该连通分量进行DFS遍历</span><br><span class="line">            cout &lt;&lt; endl;  // DFS 完成后换行，以区分不同的连通分量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用邻接表表示图：unordered_map&lt;char, vector&lt;char&gt;&gt;，表示图中每个顶点及其相邻顶点</span><br><span class="line">    unordered_map&lt;char, vector&lt;char&gt;&gt; graph;</span><br><span class="line">    </span><br><span class="line">    // 定义图的边</span><br><span class="line">    graph[&#x27;a&#x27;] = &#123;&#x27;b&#x27;&#125;;   // 顶点 a 和 b 相连</span><br><span class="line">    graph[&#x27;b&#x27;] = &#123;&#x27;a&#x27;, &#x27;d&#x27;&#125;;  // 顶点 b 与 a 和 d 相连</span><br><span class="line">    graph[&#x27;c&#x27;] = &#123;&#x27;e&#x27;&#125;;   // 顶点 c 与 e 相连</span><br><span class="line">    graph[&#x27;d&#x27;] = &#123;&#x27;b&#x27;&#125;;   // 顶点 d 与 b 相连</span><br><span class="line">    graph[&#x27;e&#x27;] = &#123;&#x27;c&#x27;&#125;;   // 顶点 e 与 c 相连</span><br><span class="line"></span><br><span class="line">    // 调用 DFSForDisconnectedGraph 对非联通图进行遍历</span><br><span class="line">    DFSForDisconnectedGraph(graph);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 广度优先搜索函数</span><br><span class="line">void bfs(const unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph, char start) &#123;</span><br><span class="line">    // 用于存储待访问节点的队列</span><br><span class="line">    queue&lt;char&gt; q;</span><br><span class="line">    // 用于标记已访问的节点</span><br><span class="line">    unordered_set&lt;char&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将起始节点标记为已访问并加入队列</span><br><span class="line">    visited.insert(start);</span><br><span class="line">    q.push(start);</span><br><span class="line"></span><br><span class="line">    // 开始遍历</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        // 取出队列中的当前节点</span><br><span class="line">        char node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        // 输出当前节点</span><br><span class="line">        cout &lt;&lt; &quot;Visited: &quot; &lt;&lt; node &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        // 遍历该节点的所有邻接节点</span><br><span class="line">        for (char neighbor : graph.at(node)) &#123;</span><br><span class="line">            // 如果该邻接节点尚未访问过，加入队列并标记为已访问</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                visited.insert(neighbor);</span><br><span class="line">                q.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 图的邻接表表示法</span><br><span class="line">    unordered_map&lt;char, vector&lt;char&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;&#x27;a&#x27;, &#123;&#x27;b&#x27;, &#x27;c&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;b&#x27;, &#123;&#x27;a&#x27;, &#x27;d&#x27;, &#x27;e&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;c&#x27;, &#123;&#x27;a&#x27;, &#x27;f&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;d&#x27;, &#123;&#x27;b&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;e&#x27;, &#123;&#x27;b&#x27;, &#x27;f&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;f&#x27;, &#123;&#x27;c&#x27;, &#x27;e&#x27;&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 从节点 &#x27;a&#x27; 开始执行 BFS</span><br><span class="line">    bfs(graph, &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问顺序的区别示例"><a href="#访问顺序的区别示例" class="headerlink" title="访问顺序的区别示例"></a><strong>访问顺序的区别示例</strong></h3><p>以一个简单的图为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    a</span><br><span class="line">   / \</span><br><span class="line">  b   c</span><br><span class="line"> / \   \</span><br><span class="line">d   e   f</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DFS 访问顺序</strong>（从节点 <code>a</code> 开始）：<code>a, b, d, e, c, f</code><ul>
<li>先从 <code>a</code> 开始，访问 <code>b</code>，然后继续到 <code>d</code>，没有其他未访问的邻接节点后回溯到 <code>b</code>，再访问 <code>e</code>，继续回溯到 <code>a</code>，然后访问 <code>c</code>，最后访问 <code>f</code>。</li>
</ul>
</li>
<li><strong>BFS 访问顺序</strong>（从节点 <code>a</code> 开始）：<code>a, b, c, d, e, f</code><ul>
<li>先从 <code>a</code> 开始，访问其所有邻接节点 <code>b</code> 和 <code>c</code>，然后继续访问 <code>b</code> 和 <code>c</code> 的所有邻接节点 <code>d, e, f</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的多线程写时复制</title>
    <url>/2025/02/27/c++%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;mutex&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;shared_mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//写时复制包装器模板类</span><br><span class="line">template&lt;typename	T&gt;</span><br><span class="line">class CowPtr</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	mutable shared_ptr&lt;T&gt; ptr; //mutable 关键字允许在 const 方法中修改这个成员变量</span><br><span class="line">	mutable shared_mutex mutex;//mutable 关键字允许在 const 方法中使用锁,shared_mutex为可读锁</span><br><span class="line">public:</span><br><span class="line">	CowPtr(T* p = nullptr):ptr(p) &#123;&#125;//构造函数</span><br><span class="line">	CowPtr(const shared_ptr&lt;T&gt;&amp; p):ptr(p)&#123;&#125;//通过shared_ptr构造</span><br><span class="line">	CowPtr(const CowPtr&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		lock_guard&lt;shared_mutex&gt;lock(other.mutex);</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	CowPtr(CowPtr&amp;&amp; other)noexcept//noexcept用来声明一个函数不会抛出任何异常</span><br><span class="line">	&#123;</span><br><span class="line">		/*</span><br><span class="line">		* 这里的 CowPtr(CowPtr&amp;&amp; other) 表示 接受一个右值引用 类型的 other 参数。它通常用于“移动”资源而不是“复制”资源。</span><br><span class="line">		  std::move(other.ptr) 将 other.ptr 从一个左值变为右值，并允许移动其内部资源，而不是复制它们</span><br><span class="line">		*/</span><br><span class="line">		lock_guard&lt;shared_mutex&gt;lock(other.mutex);//确保在移动资源时，不会发生数据竞争</span><br><span class="line">		ptr = move(other.ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	//赋值操作符</span><br><span class="line">	CowPtr&amp; operator=(const CowPtr&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;other)</span><br><span class="line">		&#123;</span><br><span class="line">			unique_lock&lt;shared_mutex&gt;lock_this(mutex, defer_lock);</span><br><span class="line">			unique_lock&lt;shared_mutex&gt;lock_other(other.mutex, defer_lock);</span><br><span class="line">			/*</span><br><span class="line">			* std::unique_lock 比 lock_guard 更灵活，允许延迟锁定（std::defer_lock） </span><br><span class="line">			  std::lock 函数可以同时锁定多个互斥锁，且能避免死锁</span><br><span class="line">			*/</span><br><span class="line">			lock(lock_this, lock_other);</span><br><span class="line">			ptr = other.ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	// 移动赋值操作符</span><br><span class="line">	CowPtr&amp; operator=(CowPtr&amp;&amp; other) noexcept &#123;</span><br><span class="line">		if (this != &amp;other) &#123;</span><br><span class="line">			std::unique_lock&lt;shared_mutex&gt; lock_this(mutex, std::defer_lock);</span><br><span class="line">			std::unique_lock&lt;shared_mutex&gt; lock_other(other.mutex, std::defer_lock);</span><br><span class="line"></span><br><span class="line">			std::lock(lock_this, lock_other);</span><br><span class="line"></span><br><span class="line">			ptr = std::move(other.ptr);</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 析构函数</span><br><span class="line">	~CowPtr() = default;</span><br><span class="line"></span><br><span class="line">	// 读取操作 - 返回常量引用</span><br><span class="line">	const T&amp; read() const &#123;</span><br><span class="line">		std::lock_guard&lt;std::shared_mutex&gt; lock(mutex);</span><br><span class="line">		return *ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 写入操作 - 返回可修改的引用，需要时执行写时复制</span><br><span class="line">	T&amp; write() &#123;</span><br><span class="line">		std::lock_guard&lt;shared_mutex&gt; lock(mutex);</span><br><span class="line"></span><br><span class="line">		// 检查引用计数，如果不是唯一拥有者，则复制一份</span><br><span class="line">		if (!ptr.unique()) &#123;</span><br><span class="line">			ptr = std::make_shared&lt;T&gt;(*ptr);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return *ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	* 写时复制策略，它的核心目的是 保证多个线程能够安全地共享资源，直到其中一个线程需要修改该资源时，才会复制该资源</span><br><span class="line">	* 实质上，当有需要写入的操作时，首先判断是否为唯一引用，如果是，那么直接修改不会影响</span><br><span class="line">	* 如果不是唯一引用，那么则复制一份数据的副本，原数据与副本各自独立，复制过程中用锁保证不会被其他线程修改</span><br><span class="line">	* 然后将副本修改，独自占用，其他读的操作，仍然读取原始数据</span><br><span class="line">	*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>智能指针</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的线程</title>
    <url>/2025/01/12/c++%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在 C++ 中，线程是用来实现并发编程的重要工具，它允许程序同时执行多个任务。C++11 标准引入了多线程支持，主要通过 <strong><code>&lt;thread&gt;</code></strong> 标头文件提供相关功能，包括线程创建、管理和同步等。</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h2><ul>
<li><strong>线程</strong>是程序执行的基本单位，一个程序可以包含多个线程。</li>
<li><strong>多线程</strong>可以提高程序效率，特别是在多核 CPU 上，每个线程可以在不同的核上运行。</li>
<li>C++ 提供的多线程功能包括：<ul>
<li>线程的创建与管理（<code>std::thread</code>）。</li>
<li>同步机制（如互斥锁 <code>std::mutex</code>、条件变量 <code>std::condition_variable</code> 等）。</li>
<li>数据保护（如线程安全的操作）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-创建和管理线程"><a href="#2-创建和管理线程" class="headerlink" title="2. 创建和管理线程"></a><strong>2. 创建和管理线程</strong></h2><h3 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1) 创建线程"></a><strong>1) 创建线程</strong></h3><p>线程可以通过 <strong><code>std::thread</code></strong> 创建，并且可以使用函数、lambda 表达式或可调用对象作为线程入口。</p>
<h4 id="a-使用普通函数"><a href="#a-使用普通函数" class="headerlink" title="(a) 使用普通函数"></a><strong>(a) 使用普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建线程</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>std::thread t(threadFunction)</code>**：创建线程并执行 <code>threadFunction</code>。</li>
<li>**<code>t.join()</code>**：主线程等待 <code>t</code> 线程执行完成。</li>
</ul>
<hr>
<h4 id="b-使用-lambda-表达式"><a href="#b-使用-lambda-表达式" class="headerlink" title="(b) 使用 lambda 表达式"></a><strong>(b) 使用 lambda 表达式</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread running with lambda!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="c-使用类的成员函数"><a href="#c-使用类的成员函数" class="headerlink" title="(c) 使用类的成员函数"></a><strong>(c) 使用类的成员函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread running with functor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker worker;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>; <span class="comment">// 创建线程并执行 Worker 的重载函数</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-分离线程（detach）"><a href="#2-分离线程（detach）" class="headerlink" title="2) 分离线程（detach）"></a><strong>2) 分离线程（<code>detach</code>）</strong></h3><p>分离线程允许主线程与新线程独立运行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Detached thread completed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 分离线程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：分离的线程在程序结束前需要完成，否则会出现未定义行为。</p>
<hr>
<h3 id="3-获取线程-ID"><a href="#3-获取线程-ID" class="headerlink" title="3) 获取线程 ID"></a><strong>3) 获取线程 ID</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::thread::id id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3. 线程同步"></a><strong>3. 线程同步</strong></h2><p>由于线程是并发执行的，因此多个线程访问共享资源时可能会导致数据竞争（Race Condition）。C++ 提供了多种同步工具来避免这种问题。</p>
<h3 id="1-互斥锁（std-mutex）"><a href="#1-互斥锁（std-mutex）" class="headerlink" title="1) 互斥锁（std::mutex）"></a><strong>1) 互斥锁（<code>std::mutex</code>）</strong></h3><p><strong>互斥锁</strong>用于保证只有一个线程可以访问共享资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁和解锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Thread 1: Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Thread 2: World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>std::lock_guard</code>**：管理锁的生命周期，防止忘记解锁。</li>
<li>**<code>mtx.lock()</code> 和 <code>mtx.unlock()</code>**：手动加锁和解锁，但可能导致死锁，不推荐使用。</li>
</ul>
<hr>
<h3 id="2-条件变量（std-condition-variable）"><a href="#2-条件变量（std-condition-variable）" class="headerlink" title="2) 条件变量（std::condition_variable）"></a><strong>2) 条件变量（<code>std::condition_variable</code>）</strong></h3><p>条件变量用于实现线程间的协调，例如一个线程等待某个条件成立时再执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件成立</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>; <span class="comment">// 修改条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个等待线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(notify)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-原子操作（std-atomic）"><a href="#3-原子操作（std-atomic）" class="headerlink" title="3) 原子操作（std::atomic）"></a><strong>3) 原子操作（<code>std::atomic</code>）</strong></h3><p><strong>原子操作</strong>用于多线程中对单个变量的操作，避免数据竞争。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter; <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a><strong>4. 注意事项</strong></h2><ol>
<li><strong>数据竞争</strong>：多个线程同时修改共享资源可能导致错误，需要使用同步机制。</li>
<li><strong>死锁</strong>：多个线程互相等待资源，导致程序无法继续。</li>
<li><strong>分离线程的风险</strong>：主线程结束时，分离的线程未完成可能会导致崩溃。</li>
<li><strong>性能开销</strong>：线程切换会带来一定的系统开销。</li>
</ol>
<hr>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h2><ul>
<li><strong>线程创建</strong>：<code>std::thread</code> 提供简单易用的接口。</li>
<li><strong>线程同步</strong>：使用 <code>std::mutex</code>、<code>std::condition_variable</code> 等工具保护共享数据。</li>
<li><strong>线程安全</strong>：推荐使用 <code>std::atomic</code> 或其他同步机制避免数据竞争。</li>
</ul>
<p>线程是 C++ 中实现并发的核心工具，但需要小心处理共享资源和线程生命周期，确保程序的正确性和性能。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的四种命名的强制类型转换</title>
    <url>/2024/11/19/c++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在 C++ 中，有四种强制类型转换操作符，分别是：</p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<p>这四种类型转换都属于强制类型转换,值得一提的是其实这四种强制转换都是较为危险的，很容易出现错误，尽量少用</p>
<h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><code>static_cast</code> 用于在类型之间进行转换时，进行编译时类型检查。</p>
<p>它适用于转换那些在语义上兼容的类型，例如基本数据类型、类之间的转换等。</p>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><ul>
<li><strong>类之间的转换</strong>（如父类和子类的转换）。</li>
<li><strong>基本数据类型之间的转换</strong>。</li>
<li><strong>指针类型之间的转换</strong>，当有继承关系时，可以转换指向基类的指针和指向派生类的指针。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//类之间的转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Base* 转换为 Derived*，这里是安全的</span></span><br><span class="line">    Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 上行是通过 static_cast</span></span><br><span class="line">    d-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);  <span class="comment">// 基本数据类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="comment">// 输出 10.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static_cast</code> 会进行类型检查，并且不允许不兼容的类型之间的转换。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//进行强制类型转换以便执行浮点数除法</span><br><span class="line">int i,j;</span><br><span class="line">double slope=static_cast&lt;double&gt;(j)/i;</span><br><span class="line">//进行指针的转换</span><br><span class="line">void *p=&amp;i;//任何非常量的对象的地址都能存入void*</span><br><span class="line">int *ij=static_cast&lt;int*&gt;(p);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 主要用于处理类层次结构中的指针或引用转换。它用于在类之间进行转换时，确保类型安全。<code>dynamic_cast</code> 在运行时进行类型检查，因此它适用于多态类型的转换（即包含虚函数的类）。</p>
<h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于处理继承体系中的转换，确保安全的类型转换。</li>
<li>可以用于将基类指针或引用转换为派生类指针或引用，前提是基类至少有一个虚函数（多态）。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 错误的转换，d会为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">        d-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 输出 Conversion failed!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dynamic_cast</code> 在运行时检查类型，如果转换失败，返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。它主要用于确保在继承关系中指针或引用的类型转换安全。</li>
</ul>
<h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><code>const_cast</code> 用于修改对象的常量性。</p>
<p>它允许去除或添加 <code>const</code> 限定符。注意，此处只能修改底层const</p>
<p>常见的用途包括将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型，或者反之。</p>
<h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>去除 <code>const</code> 限定符：可以将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型。</li>
<li>添加 <code>const</code> 限定符：可以将非 <code>const</code> 类型的指针或引用转换为 <code>const</code> 类型。</li>
</ul>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去除 const 限定符，允许修改对象</span></span><br><span class="line">    <span class="type">int</span>* modifiablePtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);</span><br><span class="line">    *modifiablePtr = <span class="number">20</span>;  <span class="comment">// 修改原对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除 const 限定符</span></span><br><span class="line">    <span class="built_in">modify</span>(ptr);  <span class="comment">// 此处会导致未定义行为</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 未定义行为，x值不可预测</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>警告</strong>：如果你去除 <code>const</code> 限定符并修改对象，该对象实际上可能是常量，修改它会导致未定义行为，因此这种转换应谨慎使用。</li>
</ul>
<h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 是最强大的类型转换操作符，它允许将一种类型的指针或引用转换为另一种完全不相关类型的指针或引用。它不进行任何类型检查，因此使用时必须非常小心。</p>
<h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于进行指针或引用之间的转换，即使它们在类型上没有任何继承关系。</li>
<li>可以将指针转换为整数类型，或将整数转换为指针类型。</li>
</ul>
<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> int_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pointer as integer: &quot;</span> &lt;&lt; int_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回指针</span></span><br><span class="line">    <span class="type">int</span>* new_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(int_ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dereferenced pointer: &quot;</span> &lt;&lt; *new_ptr &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reinterpret_cast</code> 可以将指针转换为整数，或将整数转换为指针，甚至可以在没有任何类型关系的类型之间进行转换。使用时需要非常小心，因为它可以绕过编译器的类型检查。</li>
</ul>
<h3 id="总结：四种类型转换的对比"><a href="#总结：四种类型转换的对比" class="headerlink" title="总结：四种类型转换的对比"></a>总结：四种类型转换的对比</h3><table>
<thead>
<tr>
<th>转换操作符</th>
<th>适用场景</th>
<th>编译时检查</th>
<th>运行时检查</th>
<th>类型安全</th>
</tr>
</thead>
<tbody><tr>
<td><code>static_cast</code></td>
<td>基本类型转换，类之间的转换，指针之间的转换</td>
<td>是</td>
<td>否</td>
<td>高</td>
</tr>
<tr>
<td><code>dynamic_cast</code></td>
<td>类之间的安全转换，主要用于多态（继承）</td>
<td>是</td>
<td>是</td>
<td>高</td>
</tr>
<tr>
<td><code>const_cast</code></td>
<td>修改对象的常量性（去除或添加 <code>const</code> 限定符）</td>
<td>是</td>
<td>否</td>
<td>中</td>
</tr>
<tr>
<td><code>reinterpret_cast</code></td>
<td>强制转换，指针与整数之间的转换，指针之间的任意转换</td>
<td>否</td>
<td>否</td>
<td>低（非常危险）</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>static_cast</code></strong> 用于编译时类型安全转换，适合大多数常规类型转换。</li>
<li><strong><code>dynamic_cast</code></strong> 用于多态类型的安全转换，尤其是指针和引用之间的转换，支持运行时类型检查。</li>
<li><strong><code>const_cast</code></strong> 用于修改 <code>const</code> 限定符（添加或去除 <code>const</code>）。</li>
<li><strong><code>reinterpret_cast</code></strong> 用于底层转换，指针和整数之间的转换，不进行类型检查，需要小心使用。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>强制类型转换操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu的乱序执行与内存顺序</title>
    <url>/2025/04/30/cpu%E7%9A%84%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>乱序执行是现代高性能处理器（CPU）中一种非常重要的<strong>性能优化技术</strong>。它的核心思想是：<strong>CPU 不严格按照程序代码中指令的顺序来执行它们，而是根据指令是否“准备好”来决定执行顺序，但最终要保证程序的结果与按顺序执行时一致。</strong></p>
<p><strong>为什么需要乱序执行？</strong></p>
<p>传统的 CPU 执行模式是**顺序执行 (In-Order Execution)**：CPU 严格按照程序代码的指令顺序一条接一条地执行。然而，这种方式效率不高，原因在于：</p>
<ol>
<li><p><strong>指令依赖 (Instruction Dependencies):</strong> 后一条指令可能需要等待前一条指令的结果才能执行。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD R1, R2, R3   ; R1 = R2 + R3</span><br><span class="line">SUB R4, R1, R5   ; R4 = R1 - R5  (需要等待 ADD 指令的结果 R1)</span><br></pre></td></tr></table></figure>
<p>在顺序执行中，SUB 指令必须等待 ADD 指令完成后才能开始。这会造成 CPU 的执行单元（如算术逻辑单元 ALU）在这段时间内处于空闲状态，浪费了计算资源。</p>
</li>
<li><p><strong>内存延迟 (Memory Latency):</strong> 从内存中读取数据通常比执行算术运算慢得多。如果一条指令需要从内存加载数据，CPU 可能需要等待几十甚至几百个时钟周期。在顺序执行中，CPU 会一直等待，直到数据加载完成才能继续执行下一条指令，导致整个流水线停顿。</p>
</li>
</ol>
<p>乱序执行就是为了解决这些问题，通过<strong>提高 CPU 执行单元的利用率</strong>和<strong>隐藏延迟</strong>来提升性能。</p>
<p><strong>乱序执行是如何工作的？</strong></p>
<p>现代支持乱序执行的 CPU 通常包含以下关键组件和流程（简化版）：</p>
<ol>
<li><strong>指令预取 (Instruction Fetch):</strong> CPU 仍然会按照程序顺序从内存中预取指令，并放入一个缓冲区。</li>
<li><strong>指令解码 (Instruction Decode):</strong> 预取的指令被解码，识别出它们的操作类型、操作数等。</li>
<li><strong>指令分发&#x2F;发射 (Instruction Dispatch&#x2F;Issue):</strong> 解码后的指令被放入一个<strong>指令窗口 (Instruction Window)</strong> 或<strong>重排序缓冲区 (Reorder Buffer - ROB)<strong>。CPU 会在这个窗口中扫描，寻找那些</strong>操作数已经准备好</strong>并且<strong>所需的执行单元空闲</strong>的指令。找到后，就将这些“准备好”的指令分发到相应的执行单元。<ul>
<li>注意：这里的关键是，分发出去的指令顺序可能与它们进入窗口的顺序不同，这就是“乱序执行”的体现。</li>
</ul>
</li>
<li><strong>指令执行 (Instruction Execution):</strong> 被分发到执行单元的指令开始执行。不同的执行单元可以并行工作（例如，一个 ALU 在做加法，一个浮点单元 FPU 在做乘法，一个加载&#x2F;存储单元 L&#x2F;S Unit 在从内存加载数据）。</li>
<li><strong>结果写回 (Result Write-back):</strong> 指令执行完成后，结果会被临时保存在一个地方（例如，重排序缓冲区或寄存器文件）。</li>
<li><strong>指令提交&#x2F;退休 (Instruction Commit&#x2F;Retirement):</strong> 这是乱序执行中最关键的一步，用于保证程序的正确性。CPU 会按照<strong>原始程序顺序</strong>来提交指令的结果。只有当一条指令在原始程序顺序中排在它前面的所有指令都已成功提交后，它才能提交其结果。提交意味着将最终结果写入到架构寄存器或主内存中，使其对后续指令和外部世界可见。<ul>
<li>这个“按序提交”的过程确保了即使执行是乱序的，程序的状态变化（如寄存器值、内存内容）看起来仍然像是按顺序发生的。这对于处理异常、中断以及保证多线程程序的正确性至关重要。</li>
</ul>
</li>
</ol>
<p><strong>核心思想总结：</strong></p>
<ul>
<li><strong>取指和提交是顺序的 (In-Order Fetch and Commit)。</strong></li>
<li><strong>执行是乱序的 (Out-of-Order Execution)。</strong></li>
</ul>
<p><strong>乱序执行带来的好处：</strong></p>
<ul>
<li><strong>提高指令级并行性 (Instruction-Level Parallelism - ILP):</strong> CPU 可以同时执行多个独立的指令。</li>
<li><strong>隐藏延迟:</strong> 当一条指令因为等待内存数据而停顿时，CPU 可以去执行窗口中其他不依赖该数据的指令，从而避免流水线停顿。</li>
<li><strong>提高执行单元利用率:</strong> 保持 CPU 的各个执行单元尽可能地忙碌。</li>
<li><strong>提升整体程序执行速度。</strong></li>
</ul>
<p><strong>乱序执行的挑战：</strong></p>
<ul>
<li><strong>硬件设计的复杂性:</strong> 需要复杂的逻辑来跟踪指令依赖、管理重排序缓冲区、实现寄存器重命名等。</li>
<li><strong>保持程序正确性:</strong> 必须精确地处理异常、中断，并确保内存操作的可见性（尤其在多处理器系统中，需要内存屏障等机制来保证内存一致性）。</li>
<li><strong>分支预测的依赖:</strong> 乱序执行通常与分支预测结合使用，预测错误会导致大量投机执行的工作被丢弃，影响效率。</li>
<li><strong>安全漏洞:</strong> 近年来发现的 Spectre 和 Meltdown 等安全漏洞就与乱序执行和投机执行（Speculative Execution，乱序执行的一个重要组成部分，CPU 预测未来可能执行的路径并提前执行指令）有关，可能导致敏感信息泄露。</li>
</ul>
<p><strong>简单类比：</strong></p>
<p>想象一个厨师要做几道菜。如果他严格按照每道菜的步骤一步一步做完一道再做下一道（顺序执行），效率会很低。而一个经验丰富的厨师会同时处理多道菜：先把需要炖的肉下锅（长时间操作），然后去切另一道菜的菜，同时看看烤箱里的蛋糕，再回来翻炒第一道菜的配料（乱序执行）。但他最终上菜（提交）时，仍然会按照客人点的顺序或菜单的顺序一道一道上。</p>
<p>总而言之，乱序执行是现代 CPU 为了榨取更多性能而采用的一种复杂但高效的技术，它通过打破指令的原始顺序来执行，但在结果上保持与顺序执行一致，从而显著提高了处理器的吞吐量。</p>
<h3 id="乱序执行的多线程挑战"><a href="#乱序执行的多线程挑战" class="headerlink" title="乱序执行的多线程挑战"></a>乱序执行的多线程挑战</h3><p>在多线程环境中，乱序执行可能来自：</p>
<ol>
<li><strong>编译器优化</strong>：编译器可能重排无关的内存操作以优化性能。</li>
<li><strong>CPU 乱序执行</strong>：处理器可能将指令重新排序以提高流水线效率。</li>
<li><strong>缓存一致性延迟</strong>：一个线程的写入可能停留在本地缓存中，延迟对其他线程可见。</li>
</ol>
<p>这些行为可能导致线程观察到的共享变量状态不符合程序员预期。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; x = <span class="number">1</span>; y = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (y == <span class="number">1</span>) <span class="built_in">assert</span>(x == <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>直觉上，线程 2 看到 <code>y == 1</code> 时，<code>x</code> 应为 1，但由于乱序，线程 2 可能看到 <code>y = 1</code> 而 <code>x</code> 仍为 0。</p>
<h3 id="C-内存模型应对乱序"><a href="#C-内存模型应对乱序" class="headerlink" title="C++ 内存模型应对乱序"></a>C++ 内存模型应对乱序</h3><p>C++11 引入的内存模型通过 <code>std::atomic</code> 和 <code>std::memory_order</code> 提供工具，控制内存操作的顺序和可见性：</p>
<ol>
<li><p>**<code>std::atomic</code>**：</p>
<ul>
<li>保证操作的原子性，防止线程间操作撕裂。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; x.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed); y.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (y.<span class="built_in">load</span>(std::memory_order_acquire) != <span class="number">1</span>); <span class="built_in">assert</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure></li>
<li>这里，<code>release</code> 和 <code>acquire</code> 确保线程 2 看到 <code>y = 1</code> 时，<code>x = 1</code> 已可见。</li>
</ul>
</li>
<li><p>**内存顺序 (<code>std::memory_order</code>)**：</p>
<ul>
<li><p><code>memory_order_seq_cst</code>：默认，提供全局一致的顺序，最严格但开销较高。</p>
</li>
<li><p><code>memory_order_acquire</code>：确保后续操作看到 <code>release</code> 前的写入。</p>
</li>
<li><p><code>memory_order_release</code>：确保前面的写入在 <code>release</code> 后对 <code>acquire</code> 线程可见。</p>
</li>
<li><p><code>memory_order_acp_rel</code>：acquire+release</p>
</li>
<li><p><code>memory_order_relaxed</code>：仅保证原子性，允许最大乱序，适用于无需同步的场景（如计数器）。</p>
</li>
<li><p><strong>配对形成同步</strong>：<code>release</code> 保证生产者线程在设置标志前，所有写入（比如数据）都完成并对其他线程“可见”；<code>acquire</code> 保证消费者线程在看到标志后，能看到生产者 <code>release</code> 前的所有写入。两者一起工作，就像主厨和服务员通过牌子协调，确保菜做好了才端上桌。</p>
</li>
<li><p><strong>内存顺序保证</strong>：<code>release</code> 防止生产者线程的写入被重排到标志设置之后；<code>acquire</code> 防止消费者线程的读取被重排到标志检查之前。这种“半场屏障”组合确保了正确的因果顺序。</p>
</li>
</ul>
</li>
<li><p><strong>同步原语</strong>：</p>
<ul>
<li>**互斥锁 (<code>std::mutex</code>)**：自动引入内存屏障，强制内存操作按锁的获取&#x2F;释放顺序。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; x = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="built_in">assert</span>(x == <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure></li>
<li>**条件变量 (<code>std::condition_variable</code>)**：与锁配合，确保信号传递和数据同步。</li>
<li>这些原语在底层使用内存屏障（如 <code>mfence</code> 或平台特定的指令），限制乱序。</li>
</ul>
</li>
</ol>
<h3 id="优化与权衡"><a href="#优化与权衡" class="headerlink" title="优化与权衡"></a>优化与权衡</h3><ul>
<li><strong>选择合适的内存顺序</strong>：<ul>
<li>使用 <code>seq_cst</code> 简单但可能牺牲性能。</li>
<li><code>acquire</code>&#x2F;<code>release</code> 适合生产者-消费者模式，效率更高。</li>
<li><code>relaxed</code> 用于无需严格同步的场景，如性能敏感的计数器。</li>
</ul>
</li>
<li><strong>避免过度同步</strong>：过多屏障会降低性能。例如，过多使用 <code>seq_cst</code> 或锁可能导致线程争用和性能瓶颈。</li>
<li><strong>调试复杂性</strong>：乱序问题难以复现，建议使用工具（如 ThreadSanitizer）检测数据竞争。</li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在高性能多线程程序（如服务器、游戏引擎）中，合理使用 <code>std::atomic</code> 和 <code>memory_order</code> 能显著提高效率。例如，无锁队列常使用 <code>acquire</code>&#x2F;<code>release</code> 语义实现高效同步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;Node*&gt; head&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    Node* old_head = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node-&gt;next = old_head;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, node, std::memory_order_release));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* node = head.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; !head.<span class="built_in">compare_exchange_weak</span>(node, node-&gt;next, std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++11</tag>
        <tag>多线程</tag>
        <tag>计算机架构</tag>
      </tags>
  </entry>
  <entry>
    <title>explicit关键字</title>
    <url>/2025/01/22/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a><strong><code>explicit</code> 关键字</strong></h3><p>在 C++ 中，<code>explicit</code> 是一个用于构造函数的修饰符，其主要作用是 <strong>防止隐式类型转换</strong>，从而避免某些情况下的代码歧义或意外错误。</p>
<hr>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><ol>
<li>修饰构造函数，防止隐式类型转换。</li>
<li>修饰带有单个参数的构造函数，避免单参数的构造函数被用作隐式类型转换运算符。</li>
</ol>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ClassName</span><span class="params">(Type param)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="为什么需要-explicit？"><a href="#为什么需要-explicit？" class="headerlink" title="为什么需要 explicit？"></a><strong>为什么需要 <code>explicit</code>？</strong></h3><ul>
<li>默认情况下，C++ 会允许单参数构造函数被隐式调用，用于进行类型转换。这种行为有时会导致意外的错误。</li>
<li>使用 <code>explicit</code> 可以禁止这样的隐式转换。</li>
</ul>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><h4 id="1-没有使用-explicit"><a href="#1-没有使用-explicit" class="headerlink" title="1. 没有使用 explicit"></a><strong>1. 没有使用 <code>explicit</code></strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单参数构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">42</span>; <span class="comment">// 隐式调用 MyClass(int) 构造函数</span></span><br><span class="line">    obj.<span class="built_in">display</span>();    <span class="comment">// 输出：Value: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h4><ul>
<li><code>MyClass obj = 42;</code> 中，整数 <code>42</code> 被隐式转换为 <code>MyClass</code> 类型的对象。</li>
<li>这种隐式转换可能导致意想不到的错误，尤其当构造函数的逻辑复杂或多义时。</li>
</ul>
<hr>
<h4 id="2-使用-explicit"><a href="#2-使用-explicit" class="headerlink" title="2. 使用 explicit"></a><strong>2. 使用 <code>explicit</code></strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> : m_value(value) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MyClass obj = 42; // 错误：因为 explicit 禁止隐式转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 必须显式调用构造函数</span></span><br><span class="line">    obj.<span class="built_in">display</span>();      <span class="comment">// 输出：Value: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a><strong>结果</strong></h4><ul>
<li>使用 <code>explicit</code> 后，<code>MyClass obj = 42;</code> 会编译报错。</li>
<li>必须显式调用构造函数：<code>MyClass obj(42);</code>。</li>
</ul>
<hr>
<h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a><strong>更多例子</strong></h3><h4 id="1-防止误用"><a href="#1-防止误用" class="headerlink" title="1. 防止误用"></a><strong>1. 防止误用</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> seconds)</span> : m_seconds(seconds) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer started for &quot;</span> &lt;&lt; m_seconds &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_seconds;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTimer</span><span class="params">(Timer t)</span> </span>&#123;</span><br><span class="line">    t.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// setTimer(10); // 错误：需要显式构造 Timer 对象</span></span><br><span class="line">    <span class="built_in">setTimer</span>(<span class="built_in">Timer</span>(<span class="number">10</span>)); <span class="comment">// 正确：显式构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>Timer</code> 构造函数未被 <code>explicit</code> 修饰，<code>setTimer(10)</code> 会隐式转换为 <code>Timer(10)</code>，可能导致意外行为。</li>
</ul>
<hr>
<h4 id="2-避免容器中意外类型转换"><a href="#2-避免容器中意外类型转换" class="headerlink" title="2. 避免容器中意外类型转换"></a><strong>2. 避免容器中意外类型转换</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyClass&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vec.push_back(10); // 错误：explicit 禁止隐式转换</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">MyClass</span>(<span class="number">10</span>)); <span class="comment">// 正确：显式构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="与非-explicit-的对比"><a href="#与非-explicit-的对比" class="headerlink" title="与非 explicit 的对比"></a><strong>与非 <code>explicit</code> 的对比</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>没有 <code>explicit</code></strong></th>
<th><strong>使用 <code>explicit</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>构造函数调用方式</strong></td>
<td>允许隐式和显式调用</td>
<td>仅允许显式调用</td>
</tr>
<tr>
<td><strong>隐式转换</strong></td>
<td>支持隐式类型转换，可能导致意外错误</td>
<td>禁止隐式类型转换，减少歧义和错误风险</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td>可省略显式构造调用（<code>Type obj = value;</code>）</td>
<td>必须显式调用构造函数（<code>Type obj(value);</code>）</td>
</tr>
</tbody></table>
<hr>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li><strong>单参数构造函数</strong>：当类有单参数构造函数时，避免隐式转换带来的歧义。</li>
<li><strong>限制类型转换</strong>：需要明确控制何时允许类型转换。</li>
<li><strong>模板类</strong>：显式控制模板参数的构造，避免意外的模板匹配。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li><p><strong><code>explicit</code> 的作用</strong>：</p>
<ul>
<li>防止隐式类型转换。</li>
<li>提高代码的安全性和可读性，避免意外错误。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>单参数构造函数。</li>
<li>需要限制隐式转换时。</li>
</ul>
</li>
<li><p><strong>编程建议</strong>：</p>
<ul>
<li>如果类的构造函数中有单参数，且你不希望它被隐式调用，**请使用 <code>explicit</code>**。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>inline内联函数的使用</title>
    <url>/2025/04/28/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>又是好久没有更新了，家人们，主播最近写完了c++的几个轮子项目，工程能力有了一内内的提高，现在在准备八股，希望暑假or大三能找到一个满意的实习吧（虽然就目前来看，c++全是劝退，我真服了，后悔没有选java了，后面主播慢慢转go吧）</p>
<p>在C++中，<code>inline</code> 关键字主要用于定义内联函数，具有以下两个主要作用：</p>
<ol>
<li><p><strong>优化性能</strong>：<br>使用 <code>inline</code> 修饰的函数，建议编译器在调用该函数时，将函数体的代码直接插入到调用点。</p>
<p>相比正常的函数调用过程：寄存器保存，参数压栈，跳转到函数地址，执行函数体，返回并恢复寄存器</p>
<p>这可以减少函数调用的开销，尤其适用于小型、频繁调用的函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>square(5)</code> 时，编译器可能将代码替换为 <code>5 * 5</code>，避免函数调用开销。<br><strong>注意</strong>：<code>inline</code> 只是建议，编译器可能忽略它，尤其在以下情况下：</p>
<ul>
<li>函数体过大</li>
<li>函数包含循环、递归、静态变量、switch 或 goto 语句</li>
<li>函数地址被取用（如通过函数指针）</li>
</ul>
</li>
<li><p><strong>允许多个定义</strong>：<br><code>inline</code> 函数可以在头文件中定义，并被多个编译单元（.cpp 文件）包含，而不会导致链接错误（违反“单一定义规则”）。这是因为 <code>inline</code> 函数允许多个相同的定义，链接器会选择一个定义并丢弃其他重复定义。<br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure>

<p>多个 .cpp 文件包含此头文件时，不会引发重定义错误。</p>
</li>
</ol>
<p>看到第二个作用，主播不禁想到了自己在项目开发的过程中，hpp文件那是嘎嘎重复被cpp文件使用啊（虽然有#program once）,而头文件中的类中难免有一些成员函数是直接定义在类里面的，那为什么没有事呢。</p>
<p>（正常情况下，函数只能在头文件中声明,而不能在头文件中定义）</p>
<h3 id="1-类内函数的内联特性"><a href="#1-类内函数的内联特性" class="headerlink" title="1. 类内函数的内联特性"></a>1. 类内函数的内联特性</h3><ul>
<li><p><strong>隐式内联</strong>：</p>
<ul>
<li><p>在类定义中<strong>直接定义</strong>的成员函数（包括普通成员函数、构造函数、析构函数等）<strong>默认是 <code>inline</code> 函数</strong>，无需显式使用 <code>inline</code> 关键字。</p>
</li>
<li><p>这是 C++ 标准规定的行为，原因是为了方便在头文件中定义类时，允许函数体直接嵌入类定义，而不会违反单一定义规则（ODR）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myclass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 隐式内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getValue</code> 的定义在类体内，自动视为 <code>inline</code>，可以在头文件中安全使用，多个 <code>.cpp</code> 文件包含时不会导致多重定义错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>**显式 <code>inline</code>**：</p>
<ul>
<li><p>如果成员函数在类内仅<strong>声明</strong>，在类外定义，则需要显式使用 <code>inline</code> 关键字来指定内联行为，否则它将是普通函数（非内联）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myclass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>; <span class="comment">// 仅声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MyClass::getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 显式内联</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在类外定义的 <code>getValue</code> 使用 <code>inline</code>，确保它可以在头文件中定义，且允许多个翻译单元使用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>效果</strong>：</p>
<ul>
<li>无论是隐式还是显式内联，编译器可能将函数体直接插入调用点，减少调用开销。</li>
<li>链接器会处理多份定义，确保符合 ODR。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-类内-inline-函数的实际作用"><a href="#2-类内-inline-函数的实际作用" class="headerlink" title="2. 类内 inline 函数的实际作用"></a>2. 类内 <code>inline</code> 函数的实际作用</h3><p>类内 <code>inline</code> 函数的作用与普通 <code>inline</code> 函数一致，主要包括：</p>
<ul>
<li><p>性能优化</p>
<p>：</p>
<ul>
<li><p>适合小型、频繁调用的成员函数（如 getter&#x2F;setter、状态检查）。</p>
</li>
<li><p>在嵌入式系统中，内联可以减少函数调用开销，优化实时性能。例如，在 FreeRTOS 中，检查任务状态的函数可以定义为内联：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaskRunning</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> taskState == RUNNING; &#125; <span class="comment">// 隐式内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskState taskState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>允许多定义</p>
<p>：</p>
<ul>
<li><p>类定义通常放在头文件中，隐式或显式内联的成员函数允许在多个 <code>.cpp</code> 文件中包含头文件，而不会导致链接错误。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">()</span> </span>&#123; counter++; &#125; <span class="comment">// 隐式内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123; Task t; t.<span class="built_in">incrementCounter</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123; Task t; t.<span class="built_in">incrementCounter</span>(); &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>incrementCounter</code> 是隐式内联，多个源文件包含 <code>task.h</code> 不会报错。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>接下来是inline函数的使用注意事项</p>
<ul>
<li>不能存在任何形式的循环语句</li>
<li>不能存在过多的条件判断语句</li>
<li>函数体不能过于庞大</li>
<li>内联函数声明必须存在于调用语句之前</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>inline</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>kahn算法实现拓扑排序</title>
    <url>/2024/10/21/kahn%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1-拓扑排序（Topological-Sorting）是什么？"><a href="#1-拓扑排序（Topological-Sorting）是什么？" class="headerlink" title="1. 拓扑排序（Topological Sorting）是什么？"></a>1. <strong>拓扑排序</strong>（Topological Sorting）是什么？</h3><p><strong>拓扑排序</strong>是一种用于 <strong>有向无环图</strong>（DAG, Directed Acyclic Graph） 的节点排序算法。它的目标是将图中的所有节点排成一个 <strong>线性序列</strong>，使得对于图中每一条从节点 <code>u</code> 到节点 <code>v</code> 的有向边 <code>u -&gt; v</code>，在排序中节点 <code>u</code> 都排在节点 <code>v</code> 的前面。</p>
<p><strong>简单来说</strong>，如果图中有一条边 <code>u -&gt; v</code>，那么在拓扑排序中，节点 <code>u</code> 必须排在节点 <code>v</code> 的前面。这个排序是图中所有节点的线性排列，并且保证了这种有向依赖关系。</p>
<h3 id="2-拓扑序列是什么？"><a href="#2-拓扑序列是什么？" class="headerlink" title="2. 拓扑序列是什么？"></a>2. <strong>拓扑序列</strong>是什么？</h3><p><strong>拓扑序列</strong>是拓扑排序的结果，即节点的一个线性排列，满足上述的依赖关系。对于给定的有向无环图，可能存在多个不同的拓扑序列，只要它们满足图中所有边的依赖关系。</p>
<h3 id="3-拓扑排序的应用场景"><a href="#3-拓扑排序的应用场景" class="headerlink" title="3. 拓扑排序的应用场景"></a>3. <strong>拓扑排序的应用场景</strong></h3><p>拓扑排序通常用于需要考虑依赖关系的场景，比如：</p>
<ul>
<li><strong>任务调度</strong>：例如，某些任务需要在其他任务完成后才能开始工作，可以将任务的依赖关系表示为有向无环图，通过拓扑排序确定任务的执行顺序。</li>
<li><strong>课程安排</strong>：如果某些课程有先修课要求，可以用拓扑排序来安排课程学习的顺序。</li>
<li><strong>构建系统</strong>：如果某些模块需要依赖其他模块编译，可以通过拓扑排序决定编译顺序。</li>
</ul>
<h3 id="4-如何进行拓扑排序？"><a href="#4-如何进行拓扑排序？" class="headerlink" title="4. 如何进行拓扑排序？"></a>4. <strong>如何进行拓扑排序？</strong></h3><p>有多种算法可以实现拓扑排序，最常用的有以下两种：</p>
<h4 id="（1）Kahn算法（基于入度的算法）"><a href="#（1）Kahn算法（基于入度的算法）" class="headerlink" title="（1）Kahn算法（基于入度的算法）"></a>（1）<strong>Kahn算法</strong>（基于入度的算法）</h4><ul>
<li><p><strong>思路</strong>：</p>
<ul>
<li>找到所有 <strong>入度为0</strong> 的节点（即没有任何节点指向它们的节点）。</li>
<li>将这些节点从图中移除，并将它们的邻接节点的入度减1。</li>
<li>如果某个邻接节点的入度减为0，将它也加入排序序列中。</li>
<li>重复该过程，直到所有节点都被处理。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>计算图中每个节点的 <strong>入度</strong>（指向该节点的边的数量）。</li>
<li>将所有 <strong>入度为0</strong> 的节点加入队列。</li>
<li>从队列中取出一个节点，加入拓扑序列，并将该节点的邻接节点入度减1。</li>
<li>如果某个邻接节点的入度变为0，将其加入队列。</li>
<li>重复步骤3和4，直到队列为空。如果此时拓扑序列包含了所有节点，则排序成功；否则，说明图中存在环，无法进行拓扑排序。</li>
</ol>
</li>
<li><p><strong>Kahn算法的时间复杂度</strong>：<code>O(V + E)</code>，其中 <code>V</code> 是节点数，<code>E</code> 是边数。</p>
</li>
</ul>
<h4 id="（2）深度优先搜索（DFS）法"><a href="#（2）深度优先搜索（DFS）法" class="headerlink" title="（2）深度优先搜索（DFS）法"></a>（2）<strong>深度优先搜索（DFS）法</strong></h4><ul>
<li><p><strong>思路</strong>：</p>
<ul>
<li>对图进行 <strong>DFS</strong> 遍历，在每次访问完成一个节点的所有邻接节点后，将该节点加入一个栈。</li>
<li>当所有节点都被访问完后，栈中的节点顺序即为拓扑排序的逆序。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>对图中的每个未访问的节点执行 DFS。</li>
<li>当遍历到某个节点时，先递归访问它的所有邻接节点（即访问所有依赖它的节点）。</li>
<li>在访问完所有邻接节点后，将该节点加入栈。</li>
<li>最后栈中节点的顺序就是拓扑序列。</li>
</ol>
</li>
<li><p><strong>DFS法的时间复杂度</strong>：<code>O(V + E)</code>，其中 <code>V</code> 是节点数，<code>E</code> 是边数。</p>
</li>
</ul>
<h3 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. <strong>举例说明</strong></h3><h4 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 → 0 ← 4</span><br><span class="line">↓       ↑</span><br><span class="line">2 → 3 → 1</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>有向图</strong> 表示：</p>
<ul>
<li>任务 <code>5</code> 和 <code>4</code> 是任务 <code>0</code> 的前置任务，任务 <code>5</code> 也是任务 <code>2</code> 的前置任务。</li>
<li>任务 <code>2</code> 是任务 <code>3</code> 的前置任务，任务 <code>3</code> 是任务 <code>1</code> 的前置任务。</li>
<li>任务 <code>4</code> 是任务 <code>0</code> 的前置任务。</li>
</ul>
</li>
<li><p><strong>拓扑排序结果</strong>：</p>
<ul>
<li>可能的 <strong>拓扑序列</strong> 为：<code>4, 5, 2, 3, 1, 0</code>。</li>
<li>也可能是：<code>5, 4, 2, 3, 1, 0</code>。</li>
</ul>
</li>
</ul>
<h4 id="Kahn算法实现（队列实现）："><a href="#Kahn算法实现（队列实现）：" class="headerlink" title="Kahn算法实现（队列实现）："></a><strong>Kahn算法实现（队列实现）</strong>：</h4><p>个人理解：将每个入度为0的顶点加入队列，然后依次处理，先加入拓扑序列，将其邻接结点入度减1后再判断是否为0，如果是就加入队列，然后将原节点推出队列，再获取队列第一个，直到队列为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">kahnTopologicalSort</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;  <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="comment">// 邻接表表示的图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList = &#123;</span><br><span class="line">        &#123;&#125;,       <span class="comment">// 节点 0</span></span><br><span class="line">        &#123;<span class="number">0</span>&#125;,      <span class="comment">// 节点 1 指向 0</span></span><br><span class="line">        &#123;<span class="number">3</span>&#125;,      <span class="comment">// 节点 2 指向 3</span></span><br><span class="line">        &#123;<span class="number">1</span>&#125;,      <span class="comment">// 节点 3 指向 1</span></span><br><span class="line">        &#123;<span class="number">0</span>&#125;,      <span class="comment">// 节点 4 指向 0</span></span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>&#125;    <span class="comment">// 节点 5 指向 0 和 2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topoOrder = <span class="built_in">kahnTopologicalSort</span>(n, adjList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查拓扑排序结果</span></span><br><span class="line">    <span class="keyword">if</span> (topoOrder.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拓扑排序结果: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : topoOrder) &#123;</span><br><span class="line">            cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;图中存在环，无法进行拓扑排序。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kahn算法实现</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">kahnTopologicalSort</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// 记录每个节点的入度</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topoOrder;       <span class="comment">// 存储拓扑排序的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[i]) &#123;</span><br><span class="line">            inDegree[neighbor]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">// 用于存放入度为0的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有入度为0的节点加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理队列中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        topoOrder.<span class="built_in">push_back</span>(node);  <span class="comment">// 将节点加入拓扑排序结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的所有邻接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[node]) &#123;</span><br><span class="line">            inDegree[neighbor]--;  <span class="comment">// 将邻接节点的入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (inDegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);  <span class="comment">// 如果邻接节点的入度为0，加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topoOrder;  <span class="comment">// 返回拓扑排序结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-如何判断是否存在拓扑排序？"><a href="#6-如何判断是否存在拓扑排序？" class="headerlink" title="6. 如何判断是否存在拓扑排序？"></a>6. <strong>如何判断是否存在拓扑排序？</strong></h3><p>拓扑排序仅适用于 <strong>有向无环图</strong>（DAG），也就是说图中不能有环。如果图中存在环，则无法进行拓扑排序，因为环中的节点之间存在相互依赖，无法线性排序。因此，在进行拓扑排序的过程中，如果图中存在环，算法将无法处理完所有节点。对于 Kahn 算法而言，如果最终没有处理完所有节点（即队列中还有节点入度不为 0），则说明图中存在环。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>拓扑排序</strong> 是将 <strong>有向无环图（DAG）</strong> 的所有节点按照依赖关系排序的过程。</li>
<li><strong>拓扑序列</strong> 是拓扑排序的结果，满足在图中每条边 <code>u -&gt; v</code> 中，节点 <code>u</code> 必须在节点 <code>v</code> 之前。</li>
<li>常见的拓扑排序算法有 <strong>Kahn算法</strong>（基于入度）和 <strong>DFS算法</strong>。</li>
<li>拓扑排序广泛应用于任务调度、编译依赖等需要考虑顺序依赖的场景。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode心得</title>
    <url>/2024/11/02/leetcode%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>1.对于复杂条件的题，看能不能将条件简化，比如通过排序让题目简单，比如去掉多余空格，让后序算法简化操作</p>
<p>2.双指针对于局部的变化有奇效</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>仿函数</title>
    <url>/2025/01/12/%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>仿函数（Function Object 或 Functor）</strong> 是一种行为类似于函数的对象。仿函数是通过重载 <code>operator()</code> 运算符来实现的，这样一个对象就可以像函数一样调用。</p>
<p>仿函数的核心思想是：<strong>对象可以具有类似函数的行为，并且可以携带状态</strong>。这为设计灵活的函数调用方式提供了可能性，尤其是在 STL（标准模板库）中，仿函数被广泛应用于算法、容器操作等场景。</p>
<hr>
<h2 id="1-仿函数的基本概念"><a href="#1-仿函数的基本概念" class="headerlink" title="1. 仿函数的基本概念"></a><strong>1. 仿函数的基本概念</strong></h2><p>仿函数是通过在一个类中重载 <code>operator()</code> 运算符来实现的。这样，类的对象就可以被调用（表现得像一个函数）。</p>
<h3 id="仿函数的基本语法"><a href="#仿函数的基本语法" class="headerlink" title="仿函数的基本语法"></a><strong>仿函数的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载 operator()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Called with: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyFunctor functor; <span class="comment">// 创建仿函数对象</span></span><br><span class="line">    <span class="built_in">functor</span>(<span class="number">10</span>);       <span class="comment">// 像函数一样调用对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called with: 10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>functor(10)</code> 的调用会自动调用 <code>MyFunctor</code> 类的 <code>operator()</code> 函数。这样，<code>functor</code> 对象就表现得像一个函数。</p>
<hr>
<h2 id="2-仿函数的优点"><a href="#2-仿函数的优点" class="headerlink" title="2. 仿函数的优点"></a><strong>2. 仿函数的优点</strong></h2><ol>
<li><p><strong>携带状态：</strong><br>仿函数可以包含成员变量，用于保存状态，而普通函数无法做到这一点。</p>
</li>
<li><p><strong>灵活性和可扩展性：</strong><br>仿函数是一个类，可以拥有额外的功能，如构造函数、成员函数等，提供比普通函数更多的功能和灵活性。</p>
</li>
<li><p><strong>STL 算法支持：</strong><br>仿函数与 STL 算法（如 <code>std::sort</code>、<code>std::for_each</code>）配合得非常好，用于定义自定义的行为。</p>
</li>
</ol>
<hr>
<h2 id="3-仿函数的应用"><a href="#3-仿函数的应用" class="headerlink" title="3. 仿函数的应用"></a><strong>3. 仿函数的应用</strong></h2><h3 id="3-1-仿函数与-STL-算法结合"><a href="#3-1-仿函数与-STL-算法结合" class="headerlink" title="3.1 仿函数与 STL 算法结合"></a><strong>3.1 仿函数与 STL 算法结合</strong></h3><p>仿函数可以作为参数传递给 STL 算法，例如 <code>std::sort</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数作为自定义排序规则</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vec) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5 3 2 1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>仿函数 <code>Compare</code> 定义了一个自定义排序规则：返回 <code>true</code> 时表示 <code>a</code> 应该排在 <code>b</code> 的前面。</li>
<li><code>std::sort</code> 接受仿函数作为第三个参数，用于对容器中的元素进行排序。</li>
</ul>
<hr>
<h3 id="3-2-状态保存的仿函数"><a href="#3-2-状态保存的仿函数" class="headerlink" title="3.2 状态保存的仿函数"></a><strong>3.2 状态保存的仿函数</strong></h3><p>仿函数可以保存状态，普通函数无法做到这一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 保存状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + value; <span class="comment">// 返回加上状态值后的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">add5</span><span class="params">(<span class="number">5</span>)</span></span>;   <span class="comment">// 创建一个仿函数对象，保存状态值 5</span></span><br><span class="line">    <span class="function">Adder <span class="title">add10</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建另一个仿函数对象，保存状态值 10</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add5</span>(<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 输出 8（3 + 5）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add10</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 输出 13（3 + 10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>仿函数 <code>Adder</code> 内部保存了一个状态 <code>value</code>，通过构造函数进行初始化。</li>
<li>调用仿函数时，可以使用该状态进行计算，类似于闭包（closure）的效果。</li>
</ul>
<hr>
<h3 id="3-3-使用-STL-的-std-for-each"><a href="#3-3-使用-STL-的-std-for-each" class="headerlink" title="3.3 使用 STL 的 std::for_each"></a><strong>3.3 使用 STL 的 <code>std::for_each</code></strong></h3><p>仿函数可以用于 STL 算法 <code>std::for_each</code>，实现对容器中每个元素的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数，用于打印元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数与 for_each</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>Print</code> 仿函数定义了如何处理每个元素。</li>
<li><code>std::for_each</code> 将容器中的每个元素依次传递给仿函数。</li>
</ul>
<hr>
<h3 id="3-4-Lambda-表达式的替代"><a href="#3-4-Lambda-表达式的替代" class="headerlink" title="3.4 Lambda 表达式的替代"></a><strong>3.4 Lambda 表达式的替代</strong></h3><p>在现代 C++（C++11 及以上）中，仿函数可以被 <strong>Lambda 表达式</strong> 替代。Lambda 表达式更简洁，但仿函数在某些复杂场景下依然有优势。</p>
<p>等价于上面的 <code>std::for_each</code> 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式替代仿函数</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-STL-中常见的仿函数"><a href="#4-STL-中常见的仿函数" class="headerlink" title="4. STL 中常见的仿函数"></a><strong>4. STL 中常见的仿函数</strong></h2><p>C++ STL 提供了一些常用的内置仿函数，主要定义在头文件 <code>&lt;functional&gt;</code> 中：</p>
<h3 id="4-1-算术仿函数"><a href="#4-1-算术仿函数" class="headerlink" title="4.1 算术仿函数"></a><strong>4.1 算术仿函数</strong></h3><ul>
<li><code>std::plus</code>：加法。</li>
<li><code>std::minus</code>：减法。</li>
<li><code>std::multiplies</code>：乘法。</li>
<li><code>std::divides</code>：除法。</li>
<li><code>std::modulus</code>：取模。</li>
<li><code>std::negate</code>：取负。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="type">int</span>&gt; add;           <span class="comment">// 加法仿函数</span></span><br><span class="line">    multiplies&lt;<span class="type">int</span>&gt; multiply; <span class="comment">// 乘法仿函数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;        <span class="comment">// 输出 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;  <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-逻辑仿函数"><a href="#4-2-逻辑仿函数" class="headerlink" title="4.2 逻辑仿函数"></a><strong>4.2 逻辑仿函数</strong></h3><ul>
<li><code>std::equal_to</code>：等于。</li>
<li><code>std::not_equal_to</code>：不等于。</li>
<li><code>std::greater</code>：大于。</li>
<li><code>std::less</code>：小于。</li>
<li><code>std::greater_equal</code>：大于等于。</li>
<li><code>std::less_equal</code>：小于等于。</li>
</ul>
<h3 id="4-3-逻辑操作仿函数"><a href="#4-3-逻辑操作仿函数" class="headerlink" title="4.3 逻辑操作仿函数"></a><strong>4.3 逻辑操作仿函数</strong></h3><ul>
<li><code>std::logical_and</code>：逻辑与。</li>
<li><code>std::logical_or</code>：逻辑或。</li>
<li><code>std::logical_not</code>：逻辑非。</li>
</ul>
<hr>
<h2 id="5-仿函数与-Lambda-的对比"><a href="#5-仿函数与-Lambda-的对比" class="headerlink" title="5. 仿函数与 Lambda 的对比"></a><strong>5. 仿函数与 Lambda 的对比</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>仿函数</strong></th>
<th><strong>Lambda 表达式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态管理</strong></td>
<td>通过类的成员变量保存状态</td>
<td>捕获变量（自动或手动捕获）</td>
</tr>
<tr>
<td><strong>代码长度</strong></td>
<td>需要定义一个类，代码较长</td>
<td>简洁（C++11 及以上）</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>灵活，可定义复杂行为</td>
<td>简单场景更适用</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>C++98 开始支持</td>
<td>C++11 及以上支持</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li>仿函数是通过重载 <code>operator()</code> 实现的对象，可以像函数一样调用。</li>
<li>仿函数能够保存状态，并灵活应用于 STL 算法。</li>
<li>在现代 C++ 中，仿函数仍然有其独特的作用，尤其是在复杂的场景中，而简单场景更推荐使用 Lambda 表达式。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>thread_local的作用</title>
    <url>/2025/01/27/thread-local%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>thread_local修饰的变量，可以理解为每个线程独有的静态变量</p>
<h3 id="thread-local-的作用"><a href="#thread-local-的作用" class="headerlink" title="thread_local 的作用"></a><strong><code>thread_local</code> 的作用</strong></h3><p><code>thread_local</code> 是 C++11 引入的一个关键字，它用于声明线程局部存储（TLS）。<strong>线程局部存储</strong>指的是每个线程都有自己的变量副本，而这些副本在不同线程之间互不干扰。每个线程访问 <code>thread_local</code> 变量时，都会得到该变量的独立副本。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p><code>thread_local</code> 的主要作用是确保每个线程都有该变量的独立副本，避免不同线程之间对该变量的竞争和冲突。这在多线程程序中非常重要，特别是当不同线程需要独立的状态或数据时。</p>
<hr>
<h3 id="如何使用-thread-local"><a href="#如何使用-thread-local" class="headerlink" title="如何使用 thread_local"></a><strong>如何使用 <code>thread_local</code></strong></h3><p><code>thread_local</code> 可以修饰普通的变量、静态变量、类成员变量等。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法</strong>：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> type variable_name;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;  <span class="comment">// 每个线程都有自己的独立 counter 变量</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a><strong>1. 基本用法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_counter = <span class="number">0</span>;  <span class="comment">// 每个线程都有自己的 thread_counter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++thread_counter;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Counter: &quot;</span> &lt;&lt; thread_counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程也可以访问</span></span><br><span class="line">    <span class="built_in">increment_counter</span>();  <span class="comment">// 主线程也有自己的 thread_counter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出（可能的）："><a href="#输出（可能的）：" class="headerlink" title="输出（可能的）："></a><strong>输出（可能的）</strong>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread ID: 140306947039680, Counter: 1</span><br><span class="line">Thread ID: 140306938646976, Counter: 1</span><br><span class="line">Thread ID: 140306941834368, Counter: 1</span><br></pre></td></tr></table></figure>

<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a><strong>说明</strong>：</h4><ul>
<li>这个例子展示了 <code>thread_local</code> 变量 <code>thread_counter</code> 的用法。每个线程都拥有 <code>thread_counter</code> 的独立副本，所以主线程和两个子线程中的 <code>thread_counter</code> 是不同的。</li>
<li><code>thread_counter</code> 是线程局部变量，每个线程的修改不会影响其他线程的副本。</li>
</ul>
<hr>
<h3 id="thread-local-的重要特点"><a href="#thread-local-的重要特点" class="headerlink" title="thread_local 的重要特点"></a><strong><code>thread_local</code> 的重要特点</strong></h3><ol>
<li><p><strong>每个线程拥有独立副本</strong>：</p>
<ul>
<li>每个线程都有变量的独立副本，线程之间互不影响。</li>
<li>即使是静态或全局变量，加上 <code>thread_local</code> 修饰后，也会变成每个线程的局部变量。</li>
</ul>
</li>
<li><p><strong>线程生命周期管理</strong>：</p>
<ul>
<li>当线程启动时，<code>thread_local</code> 变量会被初始化。</li>
<li>当线程结束时，<code>thread_local</code> 变量的析构函数会被调用，执行必要的清理操作。</li>
</ul>
</li>
<li><p><strong>不适用于所有类型的变量</strong>：</p>
<ul>
<li><code>thread_local</code> 变量不能是动态分配的（比如通过 <code>new</code> 创建的对象）和指向虚拟基类的指针等。</li>
<li>对象的构造和析构是自动处理的，且 <code>thread_local</code> 变量必须具有静态或线程存储期。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="thread-local-的适用场景"><a href="#thread-local-的适用场景" class="headerlink" title="thread_local 的适用场景"></a><strong><code>thread_local</code> 的适用场景</strong></h3><ol>
<li><p><strong>每个线程都有独立状态</strong>：</p>
<ul>
<li>例如，记录每个线程的执行状态、计数器、缓存等。</li>
</ul>
</li>
<li><p><strong>避免锁竞争</strong>：</p>
<ul>
<li>在多线程环境中，通过将数据声明为 <code>thread_local</code>，每个线程有独立的数据副本，避免了锁的竞争，提高并发效率。</li>
</ul>
</li>
<li><p><strong>优化线程性能</strong>：</p>
<ul>
<li>当线程需要维护一些状态信息时，使用 <code>thread_local</code> 可以减少不必要的同步开销。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="与静态局部变量的对比"><a href="#与静态局部变量的对比" class="headerlink" title="与静态局部变量的对比"></a><strong>与静态局部变量的对比</strong></h3><p><strong>普通静态局部变量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ++count;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static</code> 变量在多个函数调用之间保持其值，但它在所有线程之间是共享的，不适合多线程环境。</li>
</ul>
<p><strong><code>thread_local</code> 变量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 每个线程有自己的独立副本</span></span><br><span class="line">    ++count;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>thread_local</code> 变量会确保每个线程有自己的副本，避免多线程共享问题。</li>
</ul>
<hr>
<h3 id="限制与注意事项"><a href="#限制与注意事项" class="headerlink" title="限制与注意事项"></a><strong>限制与注意事项</strong></h3><ol>
<li><p><strong>线程销毁时的清理</strong>：</p>
<ul>
<li><code>thread_local</code> 变量的生命周期是与线程绑定的，线程结束时，这些变量会自动销毁，但它们的析构函数只会在对应线程结束时执行。</li>
</ul>
</li>
<li><p><strong>初始化顺序</strong>：</p>
<ul>
<li><code>thread_local</code> 变量的初始化顺序不如常规静态变量的初始化顺序明确，因此在使用时需要确保其线程安全初始化。</li>
</ul>
</li>
<li><p><strong>性能影响</strong>：</p>
<ul>
<li>由于每个线程都有自己的副本，可能会带来内存的开销。特别是在多线程数目较大的情况下，可能需要管理的副本会变得比较多。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>thread_local</code> 关键字允许每个线程都有变量的独立副本，这对于多线程程序中的线程独立数据存储非常有用。</li>
<li>使用 <code>thread_local</code> 可以避免多线程之间的竞争，提高程序性能和线程安全。</li>
<li><code>thread_local</code> 变量的生命周期与线程绑定，在该线程结束时，自动析构。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线程</tag>
        <tag>多线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>再探智能指针</title>
    <url>/2025/02/27/%E5%86%8D%E6%8E%A2%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>又是许久未见的一期非人机博客，哈哈哈，感觉事好多（才不是寒假偷懒）</p>
<p>写完cc_muduo网络库之后，深感c++基础有待加深学习，于是重新看了一遍智能指针</p>
<p>众所周知，智能指针包括三种shared_ptr,weak_ptr,unique_ptr,我们一个个来</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>智能指针，作为c++独有的方式，相比malloc,free,以及new delete这两对需要手动释放的情侣，智能指针总算学会了自动释放内存</p>
<p>但是很不幸的是，他学艺不精，依然容易存在双重释放等问题，但依然是巨大的进步</p>
<p>智能指针的自动释放依赖于RAII机制，即在栈上，依赖析构函数实现的自动释放方法</p>
<p>毕竟栈上的内存，在离开作用域之后，会自动释放，便借用这个机制，在析构函数中加入delete，从而实现</p>
<p>shared_ptr，强调的是共享所有权，可以通过裸指针构造，也可以通过另一个智能指针构造</p>
<p>每个shared_ptr的引用计数都会指向该对象的数量，当引用计数为0（最后一个shared_ptr析构时，会自动删除对象和引用计数）</p>
<p>这里强调两点构造时要注意的：</p>
<p><strong>（1）不要用同一个裸指针创建多个shared_ptr</strong></p>
<p><strong>（2）避免用this指针创建shared_ptr</strong></p>
<p>原因都类似，在用裸指针创建shared_ptr时，会创建一个计数对象，如果用同一个裸指针创建两个shared_ptr,那么一个计数对象是2，新的那个却是1.而用一个shared_ptr初始化（赋值）另一个shared_ptr就没问题，只会在已有的计数对象上++</p>
<p>在必须用this指针创建shared_ptr时，我们一般使用shared_from_this()函数，可以安全的获得指针，但是要求this指针指向的该类已被shared_ptr指向</p>
<p>shared_ptr实际上包括两个指针，一个是指向管理对象的指针，另一个是指向控制块的指针</p>
<p>控制块中有引用计数，弱计数，和其他一些东西</p>
<p>而引用计数的内存是动态分配的，递增和递减是原子操作</p>
<p>一般来说，我们创建一个shared_ptr有两种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过一个裸指针构造</span><br><span class="line">test* p = new test(1);</span><br><span class="line">std::shared_ptr&lt;test&gt; sp(p);</span><br><span class="line">//使用make_shared实现</span><br><span class="line">std::shared_ptr&lt;test&gt; sp = std::make_shared&lt;test&gt;(1);</span><br></pre></td></tr></table></figure>

<p>相比先创建对象，然后再创建shared_ptr,make_shared不但更安全，而且只会产生一次内存分配，将对象和计数对象共用一块区域，效率更高</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr表示临时所有权，是弱引用，不会增加引用计数，需要配合shared_ptr使用，追踪判断shared_ptr的对象是否有效，当需要临时所有权时，也可以将weak_ptr转换成shared_ptr，使引用计数++</p>
<p>weak_ptr的构造可以用一个weak_ptr也可以用shared_ptr</p>
<p>在多线程操作中，管理共享对象是一个令人头疼的事情，最大的困难就是保证共享对象的有效性和共享对象的有效性检测</p>
<p>在这里我们一般使用weak_ptr和shared_ptr的结合使用来完成</p>
<p>正常情况下，在将弱引用转换为强引用的过程中我们很容易出现以下状况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;int&gt; wp1(sp1);//弱引用不增加引用计数  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//在多线程环境下，可能在初始化sp2和wp1.expired()之间，sp1的引用计数减为0，从而导致未定义操作（并非原子操作）</span><br><span class="line">if (!wp1.expired())//检测shared_ptr对象是否已经释放</span><br><span class="line">&#123;</span><br><span class="line">//sp1,wp1指向的被释放</span><br><span class="line">	shared_ptr&lt;int&gt;sp2(wp1);</span><br><span class="line">	cout &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们选择原子操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp3 = wp1.lock();//通过weak_ptr对象获取shared_ptr对象(原子操作，将弱引用转换为强引用)</span><br></pre></td></tr></table></figure>

<p>这样的话，如果wp1指向的对象仍存在，就一定能成功初始化sp3，如果不存在，就返回0，不会出现未定义操作</p>
<p>如此，我们便可以根据sp3的状况，判断是否对象有效</p>
<h3 id="这里插播一条提醒：不要出现循环引用"><a href="#这里插播一条提醒：不要出现循环引用" class="headerlink" title="这里插播一条提醒：不要出现循环引用"></a>这里插播一条提醒：不要出现循环引用</h3><p>比如，分别创建类A，B的shared_ptr，然后再用该指针，在类内创建shared_ptr分别指向另一个，这样的话，就表示两者互有所有权。这种是不正确的，应该在其中一方使用weak_ptr</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr代表的是独占所有权，没有拷贝语义，只能通过移动操作来转移所有权，有三个核心接口：release()，reset()，swap()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;test&gt;up1(new test(1));</span><br><span class="line">std::unique_ptr&lt;test&gt;up2(new test(2));</span><br><span class="line">up1=std::move(up2);//test(2)会销毁，up1指向test(2),up2为空</span><br><span class="line"></span><br><span class="line">up1.reset(up2.release());//up2不再指向test(2),up1指向test(2)，同时将test(1)销毁，up2变为空</span><br></pre></td></tr></table></figure>

<p>reset的参数是一个裸指针（或者为空），将原unique_ptr指向的对象销毁后指向参数的指针指向的对象</p>
<p>release的返回值是裸指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;test&gt;&gt;v1;</span><br><span class="line">v1.emplace_back(move(up1));//在容器中要使用move转移所有权</span><br></pre></td></tr></table></figure>



<h2 id="智能指针在多线程中的强大作用"><a href="#智能指针在多线程中的强大作用" class="headerlink" title="智能指针在多线程中的强大作用"></a>智能指针在多线程中的强大作用</h2><h3 id="1-一个-shared-ptr-对象可以被多个线程同时读"><a href="#1-一个-shared-ptr-对象可以被多个线程同时读" class="headerlink" title="1. 一个 shared_ptr 对象可以被多个线程同时读"></a>1. <strong>一个 <code>shared_ptr</code> 对象可以被多个线程同时读</strong></h3><p><strong>✓ 正确</strong><br>多个线程可以同时读取同一个 <code>shared_ptr</code> 对象而不会产生问题。<code>std::shared_ptr</code> 的读操作是线程安全的，包括：</p>
<ul>
<li>获取原始指针 (get())</li>
<li>检查引用计数 (use_count())</li>
<li>检查指针是否为空 (operator bool)</li>
</ul>
<h3 id="2-两个-shared-ptr-对象实体可以被两个线程同时读写，即使他们管理的是同一个对象"><a href="#2-两个-shared-ptr-对象实体可以被两个线程同时读写，即使他们管理的是同一个对象" class="headerlink" title="2. 两个 shared_ptr 对象实体可以被两个线程同时读写，即使他们管理的是同一个对象"></a>2. <strong>两个 <code>shared_ptr</code> 对象实体可以被两个线程同时读写，即使他们管理的是同一个对象</strong></h3><p><strong>✓ 正确，但有重要注意事项</strong><br>从 <code>shared_ptr</code> 本身的角度看，两个不同的 <code>shared_ptr</code> 实例可以分别被不同线程安全地修改（比如赋值、重置等），即使它们指向同一个底层对象。这是因为你在修改的是两个不同的智能指针实例。</p>
<p><strong>然而，重要注意事项</strong>：虽然修改两个不同的 <code>shared_ptr</code> 实例是安全的，但如果通过这两个智能指针同时修改它们指向的同一个对象，则会产生数据竞争，这是不安全的，需要额外的同步机制。</p>
<h3 id="3-多个线程读写同一个-shared-ptr-对象实体，需要加锁"><a href="#3-多个线程读写同一个-shared-ptr-对象实体，需要加锁" class="headerlink" title="3. 多个线程读写同一个 shared_ptr 对象实体，需要加锁"></a>3. <strong>多个线程读写同一个 <code>shared_ptr</code> 对象实体，需要加锁</strong></h3><p><strong>✓ 正确</strong><br>如果多个线程需要修改同一个 <code>shared_ptr</code> 实例（例如对同一个 <code>shared_ptr</code> 变量进行赋值或重置操作），则需要同步机制（如互斥锁）来保护这些操作。<code>shared_ptr</code> 的引用计数机制是线程安全的，但智能指针实例本身的修改操作不是线程安全的。</p>
<h3 id="总结与补充说明"><a href="#总结与补充说明" class="headerlink" title="总结与补充说明"></a>总结与补充说明</h3><ul>
<li><strong><code>shared_ptr</code> 的引用计数</strong>：内部引用计数的增减是原子的、线程安全的</li>
<li><strong><code>shared_ptr</code> 实例的修改</strong>：对同一个 <code>shared_ptr</code> 变量的修改需要同步</li>
<li><strong><code>shared_ptr</code> 指向的对象</strong>：对指向对象的并发访问需要用户自行提供同步机制</li>
</ul>
<h4 id="第二点需要明确区分”修改-shared-ptr-实例本身”和”修改-shared-ptr-所指向的对象”这两种不同的操作。"><a href="#第二点需要明确区分”修改-shared-ptr-实例本身”和”修改-shared-ptr-所指向的对象”这两种不同的操作。" class="headerlink" title="第二点需要明确区分”修改 shared_ptr 实例本身”和”修改 shared_ptr 所指向的对象”这两种不同的操作。"></a>第二点需要明确区分”修改 <code>shared_ptr</code> 实例本身”和”修改 <code>shared_ptr</code> 所指向的对象”这两种不同的操作。</h4><p>在下一节中，我们将详细介绍写时复制</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历访问的实现</title>
    <url>/2024/09/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我们从小学二年级开始，就学过二叉树了（bushi）</p>
<p>那么，如何用编程实现二叉树的遍历呢？</p>
<p>（这里使用c艹）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二叉树的每个结点都是如此定义的</p>
<h1 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h1><h5 id="分为前序，中序，后序三种遍历方法。"><a href="#分为前序，中序，后序三种遍历方法。" class="headerlink" title="分为前序，中序，后序三种遍历方法。"></a>分为前序，中序，后序三种遍历方法。</h5><p>前序是从根结点开始，访问到最左侧第一个叶子结点后，访问右侧叶子，然后返回上一级（不访问），访问同级右侧结点，然后往下按照先左后右的顺序访问，等左子树访问完毕后，访问右子树。</p>
<p>中序是从左侧第一个叶子结点开始，返回上一级（访问），下一级右侧，返回上上级，右侧最下方左侧结点，然后返回上一级（访问），以此类推。</p>
<p>后序是按从左到右的顺序，左侧第一个叶子结点开始，访问完上一级结点左侧后，去右侧，然后返回上一级。</p>
<h5 id="每种遍历方法又分为递归和非递归两种"><a href="#每种遍历方法又分为递归和非递归两种" class="headerlink" title="每种遍历方法又分为递归和非递归两种"></a>每种遍历方法又分为递归和非递归两种</h5><h2 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h2><h3 id="1-前序遍历（非递归）"><a href="#1-前序遍历（非递归）" class="headerlink" title="1. 前序遍历（非递归）"></a>1. 前序遍历（非递归）</h3><p>前序遍历的顺序是：根节点 -&gt; 左子树 -&gt; 右子树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; result; // 存储遍历结果</span><br><span class="line">    if (!root) return result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk; // 辅助栈</span><br><span class="line">    stk.push(root);       // 首先将根节点入栈</span><br><span class="line"></span><br><span class="line">    while (!stk.empty()) &#123;</span><br><span class="line">        TreeNode* node = stk.top();  // 获取栈顶元素</span><br><span class="line">        stk.pop();                   // 弹出栈顶元素</span><br><span class="line">        result.push_back(node-&gt;val); // 访问节点（加入结果）</span><br><span class="line"></span><br><span class="line">        // 先压右子节点，再压左子节点，保证左子节点先处理</span><br><span class="line">        if (node-&gt;right) stk.push(node-&gt;right);</span><br><span class="line">        if (node-&gt;left) stk.push(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历（非递归）"><a href="#2-中序遍历（非递归）" class="headerlink" title="2. 中序遍历（非递归）"></a>2. 中序遍历（非递归）</h3><p>中序遍历的顺序是：左子树 -&gt; 根节点 -&gt; 右子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 遍历到最左节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        current = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">// 转向右子树</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong>：创建一个栈来存储节点，并将当前节点指向根节点。</p>
<p><strong>遍历左子树</strong>：使用一个 <code>while</code> 循环，持续将当前节点的左子节点压入栈中，直到当前节点为 <code>NULL</code>。这一步实际上是在找到最左侧的节点。</p>
<p><strong>处理节点</strong>：当当前节点为 <code>NULL</code> 且栈不为空时，弹出栈顶节点，输出该节点的值。这就是中序遍历的核心步骤。</p>
<p><strong>转向右子树</strong>：将当前节点更新为弹出的节点的右子节点，继续上述过程。</p>
<p><strong>结束条件</strong>：当当前节点为 <code>NULL</code> 且栈为空时，遍历结束。</p>
<h3 id="3-后序遍历（非递归）"><a href="#3-后序遍历（非递归）" class="headerlink" title="3. 后序遍历（非递归）"></a>3. 后序遍历（非递归）</h3><p>后序遍历的顺序是：左子树 -&gt; 右子树 -&gt; 根节点。</p>
<p>后序遍历的非递归实现较复杂，可以使用两个栈来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">    stk<span class="number">1.</span><span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个栈，stk1用于遍历，stk2用于存储结果</span></span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = stk<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">        stk<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        stk<span class="number">2.</span><span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子节点和右子节点按顺序压入stk1</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) stk<span class="number">1.</span><span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) stk<span class="number">1.</span><span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将stk2中的节点依次弹出到结果中</span></span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(stk<span class="number">2.</span><span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        stk<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三种非递归遍历方法使用栈来模拟递归调用的过程，顺序不同是由于每种遍历访问节点的顺序不同。</p>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>递归算法是一种非常常见且简单的二叉树遍历实现方式，它依赖函数调用栈的隐式机制来完成节点的访问。在二叉树的递归遍历中，递归函数会按照特定的顺序调用自身来遍历树的各个节点。</p>
<h3 id="1-前序遍历（递归）"><a href="#1-前序遍历（递归）" class="headerlink" title="1. 前序遍历（递归）"></a>1. 前序遍历（递归）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>前序遍历的顺序是：<strong>先访问根节点</strong>，再访问左子树，最后访问右子树。</p>
<p>前序遍历顺序：</p>
<ul>
<li>根节点 -&gt; 左子树 -&gt; 右子树。</li>
</ul>
<h4 id="递归算法步骤"><a href="#递归算法步骤" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>先访问当前节点（根节点）。</li>
<li>递归访问左子树。</li>
<li>递归访问右子树。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                  <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);         <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">preorderTraversal</span>(root-&gt;left, result); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">preorderTraversal</span>(root-&gt;right, result); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明"><a href="#过程说明" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先访问根节点 <code>1</code>，然后递归访问它的右子节点 <code>2</code>。</li>
<li>访问 <code>2</code> 后，递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问 <code>3</code> 后，没有更多节点，递归结束。</li>
</ul>
<p>最终前序遍历的结果为 <code>[1, 2, 3]</code>。</p>
<hr>
<h3 id="2-中序遍历（递归）"><a href="#2-中序遍历（递归）" class="headerlink" title="2. 中序遍历（递归）"></a>2. 中序遍历（递归）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>中序遍历的顺序是：<strong>先访问左子树</strong>，然后访问根节点，最后访问右子树。</p>
<p>中序遍历顺序：</p>
<ul>
<li>左子树 -&gt; 根节点 -&gt; 右子树。</li>
</ul>
<h4 id="递归算法步骤-1"><a href="#递归算法步骤-1" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>递归访问左子树。</li>
<li>访问当前节点（根节点）。</li>
<li>递归访问右子树。</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                    <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;left, result);   <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);            <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;right, result);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明-1"><a href="#过程说明-1" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先递归访问 <code>1</code> 的左子树，但为空，直接访问根节点 <code>1</code>。</li>
<li>然后递归访问右子树，从 <code>2</code> 开始，递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问完 <code>3</code>，回到 <code>2</code>，访问 <code>2</code>。</li>
</ul>
<p>最终中序遍历的结果为 <code>[1, 3, 2]</code>。</p>
<hr>
<h3 id="3-后序遍历（递归）"><a href="#3-后序遍历（递归）" class="headerlink" title="3. 后序遍历（递归）"></a>3. 后序遍历（递归）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>后序遍历的顺序是：<strong>先访问左子树</strong>，再访问右子树，最后访问根节点。</p>
<p>后序遍历顺序：</p>
<ul>
<li>左子树 -&gt; 右子树 -&gt; 根节点。</li>
</ul>
<h4 id="递归算法步骤-2"><a href="#递归算法步骤-2" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>递归访问左子树。</li>
<li>递归访问右子树。</li>
<li>访问当前节点（根节点）。</li>
</ol>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                    <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left, result);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;right, result); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);             <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明-2"><a href="#过程说明-2" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先递归访问 <code>1</code> 的左子树，空节点返回。</li>
<li>然后递归访问 <code>1</code> 的右子节点 <code>2</code>，继续递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问 <code>3</code> 后返回，访问 <code>2</code> 后返回，最后访问根节点 <code>1</code>。</li>
</ul>
<p>最终后序遍历的结果为 <code>[3, 2, 1]</code>。</p>
<hr>
<h3 id="递归遍历的工作原理"><a href="#递归遍历的工作原理" class="headerlink" title="递归遍历的工作原理"></a>递归遍历的工作原理</h3><p>递归遍历的核心思想是利用系统调用栈隐式地保存当前节点的状态，并通过函数的自我调用完成对二叉树各个节点的遍历。在每一次递归调用时，栈帧会记录当前函数的上下文（包括参数和本地变量），当递归返回时，栈帧会恢复之前的状态。因此，递归算法中不需要显式地使用栈结构来保存节点状态，递归的函数调用本身就是栈的模拟。</p>
<h1 id="通过遍历确定二叉树"><a href="#通过遍历确定二叉树" class="headerlink" title="通过遍历确定二叉树"></a>通过遍历确定二叉树</h1><p>首先，一种遍历是肯定不能的</p>
<p>前序遍历＋后序也不能</p>
<p>但中序＋任意就可以</p>
<p>下面是后序和中序的一个例子</p>
<p>给定二叉树的<strong>后序遍历</strong>和<strong>中序遍历</strong>，可以确定这棵二叉树的结构。</p>
<ul>
<li><strong>后序遍历</strong>：<code>dabec</code></li>
<li><strong>中序遍历</strong>：<code>debac</code></li>
</ul>
<h3 id="重建二叉树的步骤"><a href="#重建二叉树的步骤" class="headerlink" title="重建二叉树的步骤"></a>重建二叉树的步骤</h3><ol>
<li><p><strong>后序遍历的特点</strong>：后序遍历的最后一个节点是根节点。因此，通过后序遍历可以找到二叉树的根节点。</p>
<ul>
<li>在后序遍历 <code>dabec</code> 中，最后一个元素 <code>c</code> 是二叉树的根节点。</li>
</ul>
</li>
<li><p><strong>在中序遍历中找到根节点</strong>：通过中序遍历，可以将二叉树分为左子树和右子树。</p>
<ul>
<li>中序遍历是 <code>debac</code>，根节点 <code>c</code> 在中序遍历中的位置是最后一位，因此 <code>deba</code> 是左子树，右子树为空。</li>
</ul>
</li>
<li><p><strong>递归构建左子树</strong>：</p>
<ul>
<li>左子树的中序遍历是 <code>deba</code>，左子树的后序遍历是 <code>dabe</code>（从后序遍历中取去掉根节点的部分）。</li>
<li>继续对 <code>dabe</code> 和 <code>deba</code> 递归构建。</li>
</ul>
</li>
<li><p><strong>对左子树进行递归构建</strong>：</p>
<ul>
<li>在后序遍历 <code>dabe</code> 中，最后一个元素 <code>e</code> 是左子树的根节点。</li>
<li>在中序遍历 <code>deba</code> 中，根节点 <code>e</code> 的位置将 <code>d</code> 和 <code>ba</code> 分为左右子树，左子树为 <code>d</code>，右子树为 <code>ba</code>。</li>
</ul>
</li>
<li><p><strong>递归构建左子树和右子树</strong>：</p>
<ul>
<li>对左子树 <code>d</code>，中序遍历和后序遍历均为 <code>d</code>，因此它是叶子节点。</li>
<li>对右子树 <code>ba</code>：<ul>
<li>在后序遍历 <code>ba</code> 中，根节点是 <code>a</code>，剩下的 <code>b</code> 是它的左子树。</li>
<li>对左子树 <code>b</code>，中序遍历和后序遍历均为 <code>b</code>，因此它是叶子节点。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="最终二叉树的结构"><a href="#最终二叉树的结构" class="headerlink" title="最终二叉树的结构"></a>最终二叉树的结构</h3><p>将上述步骤的结果组合在一起，二叉树的形状如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    c</span><br><span class="line">   /</span><br><span class="line">  e</span><br><span class="line"> / \</span><br><span class="line">d   a</span><br><span class="line">   /</span><br><span class="line">  b</span><br></pre></td></tr></table></figure>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul>
<li>根节点是 <code>c</code>，它的左子树是 <code>e</code>。</li>
<li>节点 <code>e</code> 的左子树是 <code>d</code>，右子树是 <code>a</code>。</li>
<li>节点 <code>a</code> 有一个左子树 <code>b</code>，而 <code>b</code> 和 <code>d</code> 都是叶子节点。</li>
</ul>
<p>通过后序遍历和中序遍历，我们成功地重建了这棵二叉树。</p>
<hr>
<h1 id="递归-vs-非递归"><a href="#递归-vs-非递归" class="headerlink" title="递归 vs. 非递归"></a>递归 vs. 非递归</h1><ol>
<li><p><strong>递归遍历</strong>：</p>
<ul>
<li>简洁且符合思维逻辑。</li>
<li>利用系统调用栈来管理递归状态，不需要手动维护栈。</li>
<li>如果树的深度较深，递归深度过大会导致栈溢出。</li>
</ul>
</li>
<li><p><strong>非递归遍历</strong>：</p>
<ul>
<li>使用显式栈来模拟递归，避免了函数调用的开销。</li>
<li>更加适合处理非常深的树，避免了递归栈溢出的问题。</li>
<li>实现较为复杂，尤其是后序遍历，需要用到两个栈。</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>递归遍历是通过系统调用栈隐式地实现节点状态的保存与恢复，而非递归遍历则通过显式的栈来模拟递归过程。选择递归或非递归方法通常取决于具体应用场景以及对性能和栈深度的要求。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>几种排序</title>
    <url>/2024/11/12/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>冒泡排序</strong>（Bubble Sort）是一种简单直观的排序算法，其基本思想是通过多次遍历待排序的序列，比较相邻元素并交换它们的位置，使较大的元素逐渐“冒泡”到序列的末尾。尽管效率较低，但它是介绍排序算法时常用的例子之一，适合对小规模数据的排序。</p>
<h3 id="冒泡排序的原理"><a href="#冒泡排序的原理" class="headerlink" title="冒泡排序的原理"></a>冒泡排序的原理</h3><ol>
<li>从序列的第一个元素开始，依次比较相邻的两个元素。如果前面的元素大于后面的元素，就交换它们的位置。</li>
<li>每次遍历后，最大的元素会被交换到当前未排序部分的末尾。</li>
<li>对未排序部分重复上述过程，直到没有元素需要交换为止。</li>
</ol>
<h3 id="冒泡排序的特点"><a href="#冒泡排序的特点" class="headerlink" title="冒泡排序的特点"></a>冒泡排序的特点</h3><ul>
<li><strong>时间复杂度</strong>：<ul>
<li>最坏情况： $O(n^2)$（数组逆序）</li>
<li>最好情况： $O(n)$（数组已经有序，只需一次遍历）</li>
<li>平均情况： $O(n^2)$</li>
</ul>
</li>
<li><strong>空间复杂度</strong>： $O(1)$（只需常数级的额外空间）</li>
<li><strong>稳定性</strong>：起泡排序是稳定的排序算法，即相同的元素在排序后不会改变相对顺序。</li>
</ul>
<h3 id="冒泡排序的实现"><a href="#冒泡排序的实现" class="headerlink" title="冒泡排序的实现"></a>冒泡排序的实现</h3><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环控制需要进行的轮数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 标志变量用于检测数组是否已经有序</span></span><br><span class="line">        <span class="type">bool</span> swapped = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内层循环用于比较和交换相邻元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换相邻元素</span></span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;  <span class="comment">// 记录交换发生</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果本轮没有发生交换，数组已排序，提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>快速排序</strong>（Quick Sort）是一种高效的基于分治法的排序算法，它通过递归地将数组分成两个子数组来排序。快速排序通常是实际应用中最快的排序算法之一，适用于大规模数据排序。</p>
<h3 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h3><ol>
<li><strong>选取基准（pivot）</strong>：从数组中选择一个元素作为基准，可以是第一个元素、最后一个元素、中间元素或随机选择。</li>
<li><strong>分区（Partition）</strong>：将数组分成两部分，使得左侧子数组的所有元素都小于基准，而右侧子数组的所有元素都大于或等于基准。</li>
<li><strong>递归排序</strong>：对左右两个子数组分别递归地应用快速排序。</li>
<li><strong>合并</strong>：由于在分区的过程中数组已经部分有序，所以不需要额外的合并操作。</li>
</ol>
<h3 id="快速排序的特点"><a href="#快速排序的特点" class="headerlink" title="快速排序的特点"></a>快速排序的特点</h3><ul>
<li><strong>时间复杂度</strong>：<ul>
<li>最坏情况： $O(n^2)$（当数组基本有序或基准选择不当时）</li>
<li>最好情况： $O(n \log n)$（理想情况下，基准能将数组均匀分割）</li>
<li>平均情况： $O(n \log n)$</li>
</ul>
</li>
<li><strong>空间复杂度</strong>： $O(\log n)$，用于递归栈空间。</li>
<li><strong>不稳定性</strong>：快速排序是不稳定的排序算法，即相同的元素在排序后可能会改变相对顺序。</li>
</ul>
<h3 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h3><p>下面是快速排序的经典实现，其中基准选取最后一个元素。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，将基准放到正确位置，并返回基准的最终位置索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最后一个元素为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;        <span class="comment">// i 为较小元素的边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素小于等于基准</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;  <span class="comment">// 增加边界索引</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);  <span class="comment">// 交换当前元素与边界元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);  <span class="comment">// 将基准放到正确位置</span></span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);  <span class="comment">// 返回基准的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 分区，并获取基准位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序左右子数组</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h3><ol>
<li><strong>三数取中</strong>：选择基准时，可以取头、中、尾三个元素的中间值，避免数组本身有序时出现最坏情况。</li>
<li><strong>随机选择基准</strong>：通过随机选择基准位置，打乱输入数组，减少最坏情况发生的概率。</li>
<li><strong>小数组插入排序</strong>：当子数组长度较小时（如10以下），可以使用插入排序代替快速排序，以提高效率。</li>
</ol>
<h3 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="headerlink" title="快速排序的性能分析"></a>快速排序的性能分析</h3><p>$$<br>快速排序的性能在很大程度上取决于分区是否平衡。<br>$$</p>
<p>$$<br>平衡的分区能保证时间复杂度接近 O(n \log n)，而极端不平衡的分区会导致最坏的 O(n^2)复杂度。因此，优化基准的选择非常重要。<br>$$</p>
<p>简单选择排序（Selection Sort）是一种排序算法，通过反复找到未排序部分中的最小元素，将其放到数组的起始位置，逐步构建有序序列。这个算法适合数据量较小的情况，时间复杂度为 $O(n^2)$。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>从数组的第一个元素开始，假设它是最小元素。</li>
<li>遍历数组的剩余部分，找到比当前最小元素更小的值并更新最小元素。</li>
<li>遍历完成后，将找到的最小值和当前未排序部分的第一个元素交换。</li>
<li>移动到下一个位置，重复上述步骤，直到整个数组排序完毕。</li>
</ol>
<h3 id="实现代码（C-）"><a href="#实现代码（C-）" class="headerlink" title="实现代码（C++）"></a>实现代码（C++）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逐一确定数组中每一个位置的最终元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i; <span class="comment">// 假设当前索引 i 是最小元素的位置</span></span><br><span class="line">        <span class="comment">// 查找从 i+1 到 n-1 中比 arr[minIndex] 更小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123; <span class="comment">// 更新最小元素的位置</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换最小元素到当前的 i 位置</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123; <span class="comment">// 避免自身交换</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[minIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">selectionSort</span>(arr, n); <span class="comment">// 对数组进行选择排序</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n); <span class="comment">// 输出排序结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>堆排序（Heap Sort）是一种基于二叉堆的数据结构实现的排序算法，具有时间复杂度为 $O(n \log n)$，可以被认为是一种改进的选择排序。堆排序的特点是无论数据情况如何，其时间复杂度都能保持稳定，是一种不稳定的原地排序算法。</p>
<h3 id="二叉堆简介"><a href="#二叉堆简介" class="headerlink" title="二叉堆简介"></a>二叉堆简介</h3><p>堆排序使用<strong>最大堆</strong>或<strong>最小堆</strong>来辅助排序：</p>
<ul>
<li><strong>最大堆</strong>：父节点的值总是大于或等于子节点的值。</li>
<li><strong>最小堆</strong>：父节点的值总是小于或等于子节点的值。</li>
</ul>
<p>在堆排序中，通常使用<strong>最大堆</strong>来实现升序排序。</p>
<h3 id="堆排序算法步骤"><a href="#堆排序算法步骤" class="headerlink" title="堆排序算法步骤"></a>堆排序算法步骤</h3><ol>
<li><strong>构建最大堆</strong>：将数组视为一个完全二叉树，从最后一个非叶子节点开始，对每个节点进行<strong>堆调整</strong>，使整个数组满足最大堆的性质。</li>
<li><strong>排序</strong>：<ul>
<li>将堆顶元素（最大值）与数组末尾元素交换，这样最大值就处于正确的最终位置。</li>
<li>将堆的大小减一，对新的堆顶元素进行<strong>堆调整</strong>，以重新保持最大堆的性质。</li>
<li>重复上述过程，直到堆的大小减为 1，排序完成。</li>
</ul>
</li>
</ol>
<h3 id="堆排序代码实现（C-）"><a href="#堆排序代码实现（C-）" class="headerlink" title="堆排序代码实现（C++）"></a>堆排序代码实现（C++）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将以 root 为根的子树调整为最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = root;         <span class="comment">// 将根节点设为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * root + <span class="number">1</span>;    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * root + <span class="number">2</span>;   <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是根节点，则交换并递归调整</span></span><br><span class="line">    <span class="keyword">if</span> (largest != root) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[root], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);  <span class="comment">// 递归调整受影响的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 逐一取出元素并调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);    <span class="comment">// 将最大元素移动到末尾</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);      <span class="comment">// 调整剩下的元素形成最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例执行过程"><a href="#示例执行过程" class="headerlink" title="示例执行过程"></a>示例执行过程</h3><p>假设我们对数组 <code>&#123;12, 11, 13, 5, 6, 7&#125;</code> 进行堆排序：</p>
<ol>
<li><p><strong>构建最大堆</strong>：  </p>
<ul>
<li>选择非叶子节点 <code>5</code> 和 <code>6</code>，调整以 <code>5</code> 和 <code>6</code> 为根的子树。</li>
<li>继续调整上层节点，最后整个数组满足最大堆的结构：<code>&#123;13, 11, 12, 5, 6, 7&#125;</code>。</li>
</ul>
</li>
<li><p><strong>排序过程</strong>：</p>
<ul>
<li>将堆顶元素 <code>13</code> 与最后一个元素交换：<code>&#123;7, 11, 12, 5, 6, 13&#125;</code>，缩小堆的范围到 <code>[0, n-2]</code>，再对堆顶进行堆调整。</li>
<li>重复此过程直到排序完成，最终结果为：<code>&#123;5, 6, 7, 11, 12, 13&#125;</code>。</li>
</ul>
</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>堆排序的时间复杂度为 $O(n \log n)$，因为：</p>
<ul>
<li>建堆操作的时间复杂度为 $O(n)$。</li>
<li>排序过程中需要 $O(\log n)$ 的时间进行堆调整，总体复杂度为 $O(n \log n)$。</li>
</ul>
<p>归并排序（Merge Sort）是一种基于<strong>分治法（Divide and Conquer）</strong>的排序算法。它将数组分成较小的子数组，分别排序后再合并，最终完成排序。</p>
<h3 id="1-算法原理"><a href="#1-算法原理" class="headerlink" title="1. 算法原理"></a>1. 算法原理</h3><p>归并排序的核心思想是：</p>
<ol>
<li><strong>分</strong>：将待排序数组分成两个子数组，分别对这两个子数组进行排序。</li>
<li><strong>治</strong>：通过递归将子数组继续分割，直到每个子数组的长度为 1。</li>
<li><strong>合</strong>：将两个有序子数组合并成一个有序数组。</li>
</ol>
<h3 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h3><ol>
<li><strong>递归分割数组</strong>：<ul>
<li>将数组从中间分成两部分，直到每部分只剩一个元素。</li>
</ul>
</li>
<li><strong>合并子数组</strong>：<ul>
<li>合并两个已排序的子数组为一个有序数组。</li>
</ul>
</li>
</ol>
<h3 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3. 时间复杂度"></a>3. 时间复杂度</h3><ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$<ul>
<li>每次分割数组的时间复杂度为 $O(\log n)$，合并数组的时间复杂度为 $O(n)$。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：$O(n)$<ul>
<li>归并排序需要额外的数组空间来存储合并后的结果。</li>
</ul>
</li>
</ul>
<h3 id="4-C-实现"><a href="#4-C-实现" class="headerlink" title="4. C++ 实现"></a>4. C++ 实现</h3><p>以下是归并排序的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>; <span class="comment">// 左子数组大小</span></span><br><span class="line">    <span class="type">int</span> n2 = right - mid;    <span class="comment">// 右子数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">        R[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left; <span class="comment">// 初始索引</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始数组: 12 11 13 5 6 7 </span><br><span class="line">排序后的数组: 5 6 7 11 12 13 </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><p><strong>merge 函数</strong>：</p>
<ul>
<li>将两个有序数组（<code>L</code> 和 <code>R</code>）合并为一个有序数组。</li>
<li>使用两个指针遍历子数组，同时更新原数组中的值。</li>
</ul>
</li>
<li><p><strong>mergeSort 函数</strong>：</p>
<ul>
<li>递归分割数组为两部分，直到每部分只剩一个元素。</li>
<li>调用 <code>merge</code> 函数将子数组合并。</li>
</ul>
</li>
<li><p><strong>递归基线条件</strong>：</p>
<ul>
<li>当 <code>left &gt;= right</code> 时，数组无法再分割，递归结束。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>稳定性</strong>：归并排序是一种稳定的排序算法。</li>
<li><strong>性能稳定</strong>：时间复杂度始终为 $O(n \log n)$，无论最佳、最差或平均情况。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>空间复杂度较高</strong>：需要额外的数组空间来辅助合并操作。</li>
<li><strong>递归开销</strong>：递归调用会增加时间和空间的开销。</li>
</ol>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>归并排序适用于需要稳定排序的场景，特别是在处理大规模数据集或链表时（链表中归并排序的空间复杂度为 $O(1)$）。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>堆排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>单源最短路径问题与Dijkstra算法</title>
    <url>/2024/10/23/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%B8%8EDijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="单源最短路径问题（Single-Source-Shortest-Path-SSSP）"><a href="#单源最短路径问题（Single-Source-Shortest-Path-SSSP）" class="headerlink" title="单源最短路径问题（Single Source Shortest Path, SSSP）"></a><strong>单源最短路径问题</strong>（Single Source Shortest Path, SSSP）</h2><h5 id="是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。"><a href="#是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。" class="headerlink" title="是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。"></a>是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的<strong>起点</strong>（源点）到图中<strong>所有其他节点</strong>的最短路径。</h5><h3 id="问题定义："><a href="#问题定义：" class="headerlink" title="问题定义："></a>问题定义：</h3><ul>
<li><strong>图</strong>：图可以是有向图或无向图，通常包含若干个节点和边，每条边都有一个非负权重（即从一个节点到另一个节点的代价或距离）。</li>
<li><strong>起点（源点）</strong>：单源最短路径问题会指定一个起始节点，称为源节点，问题要求从这个源节点出发，计算它到图中其他所有节点的最短路径。</li>
<li><strong>最短路径</strong>：最短路径是指从源节点到目标节点经过的路径中，总边权重之和最小的路径。</li>
</ul>
<h3 id="具体目标："><a href="#具体目标：" class="headerlink" title="具体目标："></a>具体目标：</h3><p>对于给定的源节点s，你需要找到从s到每个其他节点v的最短路径长度，并且路径上的权重和最小。</p>
<h3 id="常见的算法："><a href="#常见的算法：" class="headerlink" title="常见的算法："></a>常见的算法：</h3><ol>
<li><strong>Dijkstra算法</strong>：<ul>
<li>解决<strong>边权非负</strong>的单源最短路径问题，时间复杂度为$O((V + E) \log V)$，适合稀疏图。</li>
</ul>
</li>
<li><strong>Bellman-Ford算法</strong>：<ul>
<li>可以处理<strong>负权边</strong>的情况，且能够检测负权环，时间复杂度为$O(V \times E)$。</li>
</ul>
</li>
<li><strong>Floyd-Warshall算法</strong>：<ul>
<li>这是一个<strong>多源最短路径</strong>算法，可以计算图中任意两个节点之间的最短路径，时间复杂度为O(V^3)。</li>
</ul>
</li>
<li><strong>SPFA算法</strong>（Shortest Path Faster Algorithm）：<ul>
<li>Bellman-Ford的优化版本，通常在图较稀疏时运行更快。</li>
</ul>
</li>
</ol>
<h2 id="Dijkstra算法："><a href="#Dijkstra算法：" class="headerlink" title="Dijkstra算法："></a><strong>Dijkstra算法</strong>：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个结构体来表示边</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to;     // 边的目标节点</span><br><span class="line">    int weight; // 边的权重</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个pair来表示优先队列中的元素，first为当前距离，second为当前节点</span><br><span class="line">using pii = pair&lt;int, int&gt;;</span><br><span class="line"></span><br><span class="line">// Dijkstra算法函数，参数为起点和图的邻接表</span><br><span class="line">vector&lt;int&gt; dijkstra(int start, const vector&lt;vector&lt;Edge&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    int n = graph.size();  // 获取图中节点的数量</span><br><span class="line">    vector&lt;int&gt; dist(n, INT_MAX);  // 初始化每个节点的距离为无穷大</span><br><span class="line">    dist[start] = 0;  // 起点到自身的距离为0</span><br><span class="line"></span><br><span class="line">    // 定义优先队列，按照距离升序排列，pair的格式是&#123;距离, 节点&#125;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123;0, start&#125;);  // 将起点放入优先队列</span><br><span class="line"></span><br><span class="line">    // 当优先队列不为空时，执行以下操作</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        int curr_dist = pq.top().first;  // 获取当前节点的距离</span><br><span class="line">        int curr_node = pq.top().second;  // 获取当前节点</span><br><span class="line">        pq.pop();  // 弹出队首元素</span><br><span class="line"></span><br><span class="line">        // 如果当前距离已经大于记录的最短距离，跳过（优化）</span><br><span class="line">        if (curr_dist &gt; dist[curr_node]) continue;</span><br><span class="line"></span><br><span class="line">        // 遍历当前节点的邻居</span><br><span class="line">        for (const Edge&amp; edge : graph[curr_node]) &#123;</span><br><span class="line">            int next_node = edge.to;        // 邻居节点</span><br><span class="line">            int weight = edge.weight;       // 边的权重</span><br><span class="line"></span><br><span class="line">            // 计算从当前节点到邻居节点的距离</span><br><span class="line">            if (dist[curr_node] + weight &lt; dist[next_node]) &#123;</span><br><span class="line">                dist[next_node] = dist[curr_node] + weight;  // 更新邻居节点的最短距离</span><br><span class="line">                pq.push(&#123;dist[next_node], next_node&#125;);  // 将邻居节点加入优先队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dist;  // 返回从起点到其他所有节点的最短距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;  // n为节点数，m为边数</span><br><span class="line">    cout &lt;&lt; &quot;输入图的节点数和边数：&quot;;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    // 定义图的邻接表</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; graph(n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;输入每条边（格式：起点 终点 权重）：\n&quot;;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int u, v, w;  // u为起点，v为终点，w为权重</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        graph[u].push_back(&#123;v, w&#125;);  // 添加从u到v的边，权重为w</span><br><span class="line">        // 如果是无向图，需要加上这行代码：</span><br><span class="line">        // graph[v].push_back(&#123;u, w&#125;);  // 添加从v到u的边</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int start;  // 起点</span><br><span class="line">    cout &lt;&lt; &quot;输入起点：&quot;;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line"></span><br><span class="line">    // 执行Dijkstra算法</span><br><span class="line">    vector&lt;int&gt; dist = dijkstra(start, graph);</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    cout &lt;&lt; &quot;从起点到其他节点的最短距离：&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (dist[i] == INT_MAX)</span><br><span class="line">            cout &lt;&lt; &quot;节点 &quot; &lt;&lt; i &lt;&lt; &quot; 不可达&quot; &lt;&lt; endl;  // 如果距离为无穷大，说明不可达</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;到节点 &quot; &lt;&lt; i &lt;&lt; &quot; 的最短距离为： &quot; &lt;&lt; dist[i] &lt;&lt; endl;  // 输出最短距离</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="图的描述"><a href="#图的描述" class="headerlink" title="图的描述"></a>图的描述</h3><ul>
<li>节点: 0, 1, 2, 3, 4</li>
<li>边及其权重：<ul>
<li>0 → 1 (权重 1)</li>
<li>0 → 2 (权重 4)</li>
<li>1 → 2 (权重 2)</li>
<li>1 → 3 (权重 5)</li>
<li>2 → 3 (权重 3)</li>
<li>3 → 4 (权重 1)</li>
</ul>
</li>
</ul>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们将从节点 <code>0</code> 开始，使用Dijkstra算法计算到其他节点的最短路径。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p><strong>距离数组</strong> <code>dist[]</code>：初始化为无穷大，源节点的距离为0。</p>
<ul>
<li><code>dist[0] = 0</code></li>
<li><code>dist[1] = ∞</code></li>
<li><code>dist[2] = ∞</code></li>
<li><code>dist[3] = ∞</code></li>
<li><code>dist[4] = ∞</code></li>
</ul>
</li>
<li><p><strong>优先队列</strong>：将源节点加入优先队列。</p>
<ul>
<li><code>pq = [(0, 0)]</code>（表示距离为0，节点为0）</li>
</ul>
</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol>
<li><p><strong>处理节点 0</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(0, 0)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>1</code>，更新距离：<ul>
<li><code>dist[1] = min(∞, 0 + 1) = 1</code></li>
<li>加入优先队列：<code>pq = [(1, 1)]</code></li>
</ul>
</li>
<li>对于 <code>2</code>，更新距离：<ul>
<li><code>dist[2] = min(∞, 0 + 4) = 4</code></li>
<li>加入优先队列：<code>pq = [(1, 1), (4, 2)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 1</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(1, 1)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>2</code>，更新距离：<ul>
<li><code>dist[2] = min(4, 1 + 2) = 3</code></li>
<li>更新优先队列：<code>pq = [(3, 2), (4, 2)]</code>（会自动调整优先队列顺序）</li>
</ul>
</li>
<li>对于 <code>3</code>，更新距离：<ul>
<li><code>dist[3] = min(∞, 1 + 5) = 6</code></li>
<li>加入优先队列：<code>pq = [(3, 2), (4, 2), (6, 3)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 2</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(3, 2)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>3</code>，更新距离：<ul>
<li><code>dist[3] = min(6, 3 + 3) = 6</code>（不变）</li>
</ul>
</li>
<li>这个节点不更新，不加入队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 3</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(6, 3)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>4</code>，更新距离：<ul>
<li><code>dist[4] = min(∞, 6 + 1) = 7</code></li>
<li>加入优先队列：<code>pq = [(7, 4)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 4</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(7, 4)</code>。</li>
<li>节点 <code>4</code> 没有邻居节点，不再更新。</li>
</ul>
</li>
</ol>
<h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><ul>
<li><code>dist[0] = 0</code> (到自身)</li>
<li><code>dist[1] = 1</code> (通过边 <code>0 → 1</code>)</li>
<li><code>dist[2] = 3</code> (通过边 <code>0 → 1 → 2</code>)</li>
<li><code>dist[3] = 6</code> (通过边 <code>0 → 1 → 2 → 3</code>)</li>
<li><code>dist[4] = 7</code> (通过边 <code>0 → 1 → 2 → 3 → 4</code>)</li>
</ul>
<h2 id="对于一次性获得所有路径间的最小路径（包括负权）-可以用floyd算法"><a href="#对于一次性获得所有路径间的最小路径（包括负权）-可以用floyd算法" class="headerlink" title="对于一次性获得所有路径间的最小路径（包括负权）,可以用floyd算法"></a>对于一次性获得所有路径间的最小路径（包括负权）,可以用floyd算法</h2><p>下面是Floyd-Warshall算法的C++实现。该实现使用一个二维数组来表示图的邻接矩阵，并通过三重循环来更新所有节点对之间的最短路径。</p>
<h3 id="Floyd-Warshall-C-实现"><a href="#Floyd-Warshall-C-实现" class="headerlink" title="Floyd-Warshall C++ 实现"></a>Floyd-Warshall C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义无穷大，表示节点之间不可达</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Floyd-Warshall算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floydWarshall</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化距离矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist = graph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三重循环，逐个更新通过每个中间节点的路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">// 更新dist[i][j]，如果通过k节点可以缩短路径</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] &lt; INF &amp;&amp; dist[k][j] &lt; INF) &#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终的最短路径矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The following matrix shows the shortest distances between every pair of vertices:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == INF)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;INF&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">        &#123;INF, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, INF&#125;,</span><br><span class="line">        &#123;INF, INF, <span class="number">0</span>, <span class="number">3</span>, INF&#125;,</span><br><span class="line">        &#123;INF, INF, INF, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;INF, INF, INF, INF, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Floyd-Warshall算法</span></span><br><span class="line">    <span class="built_in">floydWarshall</span>(graph, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>INF</code> 定义为一个非常大的数，用于表示节点之间不可达。这里用 <code>1e9</code> (即 $10^9$) 来表示。</li>
<li><code>graph</code> 是一个二维数组，表示图的邻接矩阵。</li>
</ul>
</li>
<li><p><strong>核心算法</strong>：</p>
<ul>
<li>三重循环遍历所有节点 <code>k</code>，<code>i</code> 和 <code>j</code>，其中 <code>k</code> 是中间节点。检查是否通过 <code>k</code> 作为中间节点可以使 <code>i</code> 到 <code>j</code> 的路径更短。</li>
<li>如果通过节点 <code>k</code> 可以使 <code>dist[i][j]</code> 更短，那么就更新 <code>dist[i][j]</code>。</li>
<li><code>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);</code> 这就是动态规划的更新公式。</li>
</ul>
</li>
<li><p><strong>输出结果</strong>：</p>
<ul>
<li>最终 <code>dist</code> 数组中保存了所有节点对之间的最短距离。</li>
<li>如果节点对不可达，显示 <code>INF</code>。</li>
</ul>
</li>
</ol>
<h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h3><p>对于上面的代码，输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following matrix shows the shortest distances between every pair of vertices:</span><br><span class="line">0   1   3   6   7   </span><br><span class="line">INF 0   2   5   6   </span><br><span class="line">INF INF 0   3   4   </span><br><span class="line">INF INF INF 0   1   </span><br><span class="line">INF INF INF INF 0   </span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>时间复杂度：$O(n^3)$，其中 $n$ 是图的节点数。</li>
<li>空间复杂度：$O(n^2)$，因为使用了二维数组存储距离矩阵。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>单源最短路径问题</tag>
      </tags>
  </entry>
  <entry>
    <title>友元与友元函数</title>
    <url>/2025/05/02/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="友元与友元函数"><a href="#友元与友元函数" class="headerlink" title="友元与友元函数"></a>友元与友元函数</h3><p>在 C++ 中，<strong>友元</strong>（friend）是一种机制，允许特定的非成员函数或类访问某个类的私有（private）和保护（protected）成员，从而在一定程度上绕过封装限制。友元函数和友元类是友元机制的两种主要形式。以下是详细说明。</p>
<hr>
<h3 id="1-友元函数"><a href="#1-友元函数" class="headerlink" title="1. 友元函数"></a>1. 友元函数</h3><p><strong>友元函数</strong>是一个非成员函数，但通过在类中用 <code>friend</code> 关键字声明，获得访问该类私有和保护成员的权限。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>非成员函数</strong>：友元函数不属于类的成员，不能通过类的对象直接调用（如 <code>obj.func()</code>），而是像普通全局函数一样调用。</li>
<li><strong>访问权限</strong>：可以直接访问类的私有和保护成员，通常需要通过对象参数传递。</li>
<li><strong>声明位置</strong>：在类中用 <code>friend</code> 关键字声明，可位于 <code>public</code>、<code>private</code> 或 <code>protected</code> 区域（位置不影响功能）。</li>
<li><strong>调用方式</strong>：通过函数名直接调用，通常传递类对象作为参数。</li>
</ul>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>; <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(obj); <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="典型用途"><a href="#典型用途" class="headerlink" title="典型用途"></a>典型用途</h4><ol>
<li><strong>运算符重载</strong>：如前文讨论的，流运算符（<code>&lt;&lt;</code>、<code>&gt;&gt;</code>）通常定义为友元函数，因为左侧操作数（如 <code>std::ostream</code>）不是类对象。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    os &lt;&lt; obj.value;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>多类交互</strong>：当一个函数需要访问多个类的私有成员时，可声明为所有相关类的友元。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numA;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">int</span> n) : <span class="built_in">numA</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> ClassA&amp;, <span class="type">const</span> ClassB&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numB;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>(<span class="type">int</span> n) : <span class="built_in">numB</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> ClassA&amp;, <span class="type">const</span> ClassB&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> ClassA&amp; a, <span class="type">const</span> ClassB&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.numA + b.numB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-友元类"><a href="#2-友元类" class="headerlink" title="2. 友元类"></a>2. 友元类</h3><p><strong>友元类</strong>是指一个类被声明为另一个类的友元，从而该类的所有成员函数都可以访问另一个类的私有和保护成员。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>全类访问</strong>：友元类的所有成员函数自动成为友元函数，拥有对目标类的私有和保护成员的访问权限。</li>
<li><strong>单向关系</strong>：如果类 A 声明类 B 为友元，B 可以访问 A 的私有成员，但 A 不能访问 B 的私有成员，除非 B 也声明 A 为友元。</li>
<li><strong>非继承</strong>：友元关系不会被继承，派生类无法自动获得友元权限。</li>
</ul>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>; <span class="comment">// 声明友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    FriendClass f;</span><br><span class="line">    f.<span class="built_in">show</span>(obj); <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="典型用途-1"><a href="#典型用途-1" class="headerlink" title="典型用途"></a>典型用途</h4><ul>
<li><strong>紧密耦合的类</strong>：如数据库表和索引类，索引类需要直接访问表类的私有数据。</li>
<li><strong>模块化设计</strong>：在硬件接口开发（如 OpenBMC 风扇管理）中，一个控制器类可能需要访问硬件设备类的内部状态。</li>
</ul>
<hr>
<h3 id="3-友元的使用场景与你的项目相关性"><a href="#3-友元的使用场景与你的项目相关性" class="headerlink" title="3. 友元的使用场景与你的项目相关性"></a>3. 友元的使用场景与你的项目相关性</h3><p>结合你提到的 C++ 项目（如 OpenBMC 风扇管理、硬件接口或数据分析工具）：</p>
<ul>
<li><strong>运算符重载</strong>：如前文所述，友元函数常用于流运算符或对称运算符（如 <code>+</code>），在硬件接口中可用于格式化输出设备状态（如 <code>std::cout &lt;&lt; fanController</code>）。</li>
<li><strong>硬件模块交互</strong>：友元类可用于模块化设计。例如，一个 <code>FanController</code> 类可能声明 <code>SystemMonitor</code> 为友元，以便后者直接访问风扇的私有状态（如转速、温度），无需暴露公共接口。</li>
<li><strong>调试与 Valgrind</strong>：友元函数可用于调试工具，访问类的私有成员以打印详细状态，结合 Valgrind 确保无内存泄漏。</li>
<li><strong>多态性</strong>：在多态设计中，友元函数可以通过基类接口访问派生类的私有数据，但需谨慎使用以避免破坏封装。</li>
</ul>
<hr>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><strong>封装性</strong>：友元会部分打破封装，过多使用可能导致代码维护困难。优先考虑通过公共接口（如 getter）访问数据，除非友元显著简化设计。</li>
<li><strong>耦合性</strong>：友元函数或类增加类之间的耦合，需谨慎设计，避免过度依赖。</li>
<li><strong>声明顺序</strong>：友元类或函数涉及多类交互时，需使用前向声明（如 <code>class ClassB;</code>）以解决编译器依赖问题。</li>
<li><strong>非对称性</strong>：友元关系是单向的，A 是 B 的友元不意味着 B 是 A 的友元。</li>
<li><strong>性能</strong>：友元函数通常内联（<code>inline</code>），性能开销低，但复杂逻辑可能导致临时对象开销，需注意资源管理。</li>
</ul>
<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li><strong>友元函数</strong>：通过 <code>friend</code> 关键字声明的非成员函数，可访问类的私有和保护成员，常用于运算符重载或多类交互。</li>
<li><strong>友元类</strong>：一个类被声明为另一个类的友元，其所有成员函数可访问目标类的私有和保护成员，适合紧密耦合的模块。</li>
<li><strong>适用场景</strong>：运算符重载、调试、硬件接口交互、紧密耦合的类设计。</li>
<li><strong>注意事项</strong>：谨慎使用友元以保护封装，优先考虑公共接口，注意耦合性和声明顺序。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>友元</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀表与KMP算法</title>
    <url>/2024/11/02/%E5%89%8D%E7%BC%80%E8%A1%A8%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p> KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配的高效算法，它能够在文本串中查找模式串出现的位置。KMP算法的核心在于避免重复比较字符，从而提高匹配效率。</p>
<h3 id="KMP算法的基本思路"><a href="#KMP算法的基本思路" class="headerlink" title="KMP算法的基本思路"></a>KMP算法的基本思路</h3><ol>
<li><strong>预处理模式串</strong>：通过构建一个“部分匹配表”（或称为“失配表”），在模式串中记录每个位置的最长可匹配前缀长度。</li>
<li><strong>匹配过程</strong>：利用部分匹配表，在匹配失败时，根据前缀信息跳过不必要的比较，从而加速匹配过程。</li>
</ol>
<h3 id="部分匹配表（LPS数组）"><a href="#部分匹配表（LPS数组）" class="headerlink" title="部分匹配表（LPS数组）"></a>部分匹配表（LPS数组）</h3><p>LPS（Longest Prefix Suffix）数组用于存储模式串的每个前缀的最长相等前后缀的长度。具体构建方式如下：</p>
<ul>
<li>**LPS[i]**：表示模式串的前缀（<code>pattern[0]</code> 到 <code>pattern[i]</code>）的最长相等前后缀的长度。</li>
</ul>
<h3 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h3><p>下面是KMP算法的完整实现，包括LPS数组的构建和匹配过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于构建LPS数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">computeLPS</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lps</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// 上一个最长前缀后缀的长度</span></span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;     <span class="comment">// LPS[0]始终为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (length &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[length]) &#123;</span><br><span class="line">            length = lps[length - <span class="number">1</span>]; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[length]) &#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        lps[i] = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP搜索算法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">KMPSearch</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; lps = <span class="built_in">computeLPS</span>(pattern);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; positions; <span class="comment">// 存储匹配的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 文本指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == text[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配</span></span><br><span class="line">            positions.<span class="built_in">push_back</span>(i - j);</span><br><span class="line">            j = lps[j - <span class="number">1</span>]; <span class="comment">// 继续查找下一个匹配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; pattern[j] != text[i]) &#123; <span class="comment">// 匹配失败</span></span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = lps[j - <span class="number">1</span>]; <span class="comment">// 根据LPS表跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++; <span class="comment">// 否则向前移动文本指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">KMPSearch</span>(text, pattern);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pos : result) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pattern found at index: &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol>
<li><strong>computeLPS函数</strong>：构建LPS数组，遍历模式串并填充LPS数组，使用回溯逻辑。</li>
<li><strong>KMPSearch函数</strong>：使用LPS数组进行模式匹配：<ul>
<li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向文本和模式串。</li>
<li>如果字符匹配，两个指针同时移动。</li>
<li>如果模式串匹配完成，将起始位置保存。</li>
<li>如果不匹配，根据LPS数组调整模式指针。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n + m)，其中 n 是文本串的长度，m 是模式串的长度。</li>
<li><strong>空间复杂度</strong>：O(m)，用于存储LPS数组。</li>
</ul>
<p>KMP算法是一个非常高效的字符串匹配算法，适用于大规模文本搜索。希望这个解释和示例代码对你理解KMP算法有帮助！如果你有任何问题或需要进一步的解释，请告诉我！</p>
<p> 当然可以！让我们通过一个具体的实例来演示KMP算法的工作过程。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有以下文本串和模式串：</p>
<ul>
<li><strong>文本串</strong>：<code>text = &quot;ABABDABACDABABCABAB&quot;</code></li>
<li><strong>模式串</strong>：<code>pattern = &quot;ABABCABAB&quot;</code></li>
</ul>
<p>我们要找到模式串在文本串中的所有出现位置。</p>
<h3 id="步骤-1：构建LPS数组"><a href="#步骤-1：构建LPS数组" class="headerlink" title="步骤 1：构建LPS数组"></a>步骤 1：构建LPS数组</h3><p>首先，我们需要构建模式串的LPS数组。</p>
<h4 id="模式串：ABABCABAB"><a href="#模式串：ABABCABAB" class="headerlink" title="模式串：ABABCABAB"></a>模式串：<code>ABABCABAB</code></h4><ul>
<li>计算LPS数组：<ul>
<li><code>lps[0] = 0</code>（第一个字符没有前缀和后缀）</li>
<li><code>lps[1] = 0</code>（<code>A</code>没有相等的前后缀）</li>
<li><code>lps[2] = 1</code>（<code>AB</code>的前缀<code>A</code>和后缀<code>A</code>相等）</li>
<li><code>lps[3] = 2</code>（<code>ABA</code>的前缀<code>AB</code>和后缀<code>AB</code>相等）</li>
<li><code>lps[4] = 0</code>（<code>ABAB</code>没有相等的前后缀）</li>
<li><code>lps[5] = 1</code>（<code>ABABC</code>的前缀<code>A</code>和后缀<code>A</code>相等）</li>
<li><code>lps[6] = 2</code>（<code>ABABCA</code>的前缀<code>AB</code>和后缀<code>AB</code>相等）</li>
<li><code>lps[7] = 3</code>（<code>ABABCAB</code>的前缀<code>ABA</code>和后缀<code>ABA</code>相等）</li>
<li><code>lps[8] = 4</code>（<code>ABABCABA</code>的前缀<code>ABAB</code>和后缀<code>ABAB</code>相等）</li>
</ul>
</li>
</ul>
<p>最终的LPS数组为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lps = [0, 0, 1, 2, 0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="步骤-2：进行KMP搜索"><a href="#步骤-2：进行KMP搜索" class="headerlink" title="步骤 2：进行KMP搜索"></a>步骤 2：进行KMP搜索</h3><p>接下来我们使用KMP算法进行匹配。</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>i = 0</code>（文本指针）</li>
<li><code>j = 0</code>（模式指针）</li>
<li><code>positions = []</code>（存储匹配位置）</li>
</ul>
</li>
<li><p><strong>开始匹配</strong>：</p>
<ul>
<li><strong>第 1 次比较</strong>：<code>text[0] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 1</code>, <code>j = 1</code></li>
<li><strong>第 2 次比较</strong>：<code>text[1] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 2</code>, <code>j = 2</code></li>
<li><strong>第 3 次比较</strong>：<code>text[2] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 3</code>, <code>j = 3</code></li>
<li><strong>第 4 次比较</strong>：<code>text[3] = &#39;B&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 4</code>, <code>j = 4</code></li>
<li><strong>第 5 次比较</strong>：<code>text[4] = &#39;D&#39;</code>, <code>pattern[4] = &#39;C&#39;</code> → 不匹配。根据LPS数组，<code>j = lps[3] = 2</code>，回溯到<code>pattern[2]</code>。</li>
<li><strong>继续比较</strong>：<code>text[4] = &#39;D&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 不匹配，<code>j = lps[1] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 5</code>。</li>
</ul>
</li>
<li><p><strong>继续匹配</strong>：</p>
<ul>
<li><strong>第 6 次比较</strong>：<code>text[5] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 6</code>, <code>j = 1</code></li>
<li><strong>第 7 次比较</strong>：<code>text[6] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 7</code>, <code>j = 2</code></li>
<li><strong>第 8 次比较</strong>：<code>text[7] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 8</code>, <code>j = 3</code></li>
<li><strong>第 9 次比较</strong>：<code>text[8] = &#39;C&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 不匹配。根据LPS，<code>j = lps[2] = 1</code>，回溯到<code>pattern[1]</code>。</li>
<li><strong>继续比较</strong>：<code>text[8] = &#39;C&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 不匹配，<code>j = lps[0] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 9</code>。</li>
</ul>
</li>
<li><p><strong>再次匹配</strong>：</p>
<ul>
<li><strong>第 10 次比较</strong>：<code>text[9] = &#39;D&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 不匹配，<code>i++</code> → <code>i = 10</code>。</li>
<li><strong>第 11 次比较</strong>：<code>text[10] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 11</code>, <code>j = 1</code></li>
<li><strong>第 12 次比较</strong>：<code>text[11] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 12</code>, <code>j = 2</code></li>
<li><strong>第 13 次比较</strong>：<code>text[12] = &#39;C&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 不匹配，<code>j = lps[1] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 13</code>。</li>
<li><strong>第 14 次比较</strong>：<code>text[13] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 14</code>, <code>j = 1</code></li>
<li><strong>第 15 次比较</strong>：<code>text[14] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 15</code>, <code>j = 2</code></li>
<li><strong>第 16 次比较</strong>：<code>text[15] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 16</code>, <code>j = 3</code></li>
<li><strong>第 17 次比较</strong>：<code>text[16] = &#39;B&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 17</code>, <code>j = 4</code></li>
<li><strong>第 18 次比较</strong>：<code>text[17] = &#39;C&#39;</code>, <code>pattern[4] = &#39;C&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 18</code>, <code>j = 5</code></li>
<li><strong>第 19 次比较</strong>：<code>text[18] = &#39;A&#39;</code>, <code>pattern[5] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 19</code>, <code>j = 6</code></li>
<li><strong>第 20 次比较</strong>：<code>text[19] = &#39;B&#39;</code>, <code>pattern[6] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 20</code>, <code>j = 7</code></li>
<li><strong>第 21 次比较</strong>：<code>i = 20</code>，超出文本长度，停止匹配。</li>
</ul>
</li>
</ol>
<h3 id="匹配结果"><a href="#匹配结果" class="headerlink" title="匹配结果"></a>匹配结果</h3><p>在整个过程中，我们找到了模式串在文本串中的匹配起始位置：</p>
<ul>
<li><strong>匹配位置</strong>：<code>positions = [10]</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>模式串 <code>&quot;ABABCABAB&quot;</code> 在文本串 <code>&quot;ABABDABACDABABCABAB&quot;</code> 中的匹配位置是 <code>10</code>。</li>
</ul>
<p>这种通过LPS数组的预处理，使得算法能够避免重复比较，提高了效率，特别是在文本较长和模式较短的情况下尤为明显。如果你有其他问题或需要更深入的解释，请随时问我！</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>kmp</tag>
        <tag>前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针与滑动窗口</title>
    <url>/2024/09/24/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h1><p>题目：给定一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要<strong>原地</strong>移除所有数值等于 <code>val</code> 的元素.元素的顺序可以改变.然后返回数组中与 <code>val</code> 不同的元素的数量.</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，你需要执行以下操作：</p>
<ul>
<li>修改 <code>nums</code> 数组，使得 <code>nums</code> 的前 <code>k</code> 个元素包含所有不等于 <code>val</code> 的元素.</li>
<li>返回 <code>k</code> 的值.<code>nums</code> 中的其他元素和数组大小不重要.</li>
</ul>
<h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="思路及算法："><a href="#思路及算法：" class="headerlink" title="思路及算法："></a>思路及算法：</h2><p>由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上.可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置.</p>
<p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>
<p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位.</p>
<p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val.当左右指针遍历完输入数组以后，left 的值就是输出数组的长度.</p>
<p>这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        for (int right = 0; right &lt; n; right++) &#123;</span><br><span class="line">            if (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 为序列的长度.我们只需要遍历该序列至多两次.</p>
<p>空间复杂度：O(1).我们只需要常数的空间保存若干变量.</p>
<h1 id="方法二：双指针优化"><a href="#方法二：双指针优化" class="headerlink" title="方法二：双指针优化"></a>方法二：双指针优化</h1><h2 id="思路与算法："><a href="#思路与算法：" class="headerlink" title="思路与算法："></a>思路与算法：</h2><p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位.注意到题目中说：「元素的顺序可以改变」.实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求.这个优化在序列中 val 元素的数量较少时非常有效.</p>
<p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列.</p>
<p>如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位.如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止.</p>
<p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素.</p>
<p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次.与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int left = 0, right = nums.size();</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right - 1];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n)，其中 n 为序列的长度.我们只需要遍历该序列至多一次.</p>
<p>空间复杂度：O(1).我们只需要常数的空间保存若干变量.</p>
<h1 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h1><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>.</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**.**如果不存在符合条件的子数组，返回 <code>0</code> .</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组.</span><br></pre></td></tr></table></figure>

<h1 id="方法一：暴力解法（会超时）"><a href="#方法一：暴力解法（会超时）" class="headerlink" title="方法一：暴力解法（会超时）"></a>方法一：暴力解法（会超时）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                if (sum &gt;= s) &#123;</span><br><span class="line">                    ans = min(ans, j - i + 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n的平方），其中 n 是数组的长度.需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组.</p>
<p>空间复杂度：O(1).</p>
<h1 id="方法二：前缀和-二分查找"><a href="#方法二：前缀和-二分查找" class="headerlink" title="方法二：前缀和 + 二分查找"></a>方法二：前缀和 + 二分查找</h1><p>方法一的时间复杂度是 O(n的平方)，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要 O(n) 的时间.如果使用二分查找，则可以将时间优化到 O(logn).</p>
<p>为了使用二分查找，需要额外创建一个数组 sums 用于存储数组 nums 的前缀和，其中 sums[i] 表示从 nums[0] 到 nums[i−1] 的元素和.得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标 bound，使得 sums[bound]−sums[i−1]≥s，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）.</p>
<p>因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性.如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了.</p>
<p>在很多语言中，都有现成的库和函数来为我们实现这里二分查找大于等于某个数的第一个位置的功能，比如 C++ 的 lower_bound.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        vector&lt;int&gt; sums(n + 1, 0); </span><br><span class="line">        // 为了方便计算，令 size = n + 1 </span><br><span class="line">        // sums[0] = 0 意味着前 0 个元素的前缀和为 0</span><br><span class="line">        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span><br><span class="line">        // 以此类推</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - 1] + nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int target = s + sums[i - 1];</span><br><span class="line">            auto bound = lower_bound(sums.begin(), sums.end(), target);</span><br><span class="line">            if (bound != sums.end()) &#123;</span><br><span class="line">                ans = min(ans, static_cast&lt;int&gt;((bound - sums.begin()) - (i - 1)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="方法三：滑动窗口"><a href="#方法三：滑动窗口" class="headerlink" title="方法三：滑动窗口"></a>方法三：滑动窗口</h1><p>在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高.为了降低时间复杂度，可以使用滑动窗口的方法.</p>
<p>定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）.</p>
<p>初始状态下，start 和 end 都指向下标 0，sum 的值为 0.</p>
<p>每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum&lt;s，在此过程中同样更新子数组的最小长度.在每一轮迭代的最后，将 end 右移.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int result=100001;</span><br><span class="line">        int sum=0;</span><br><span class="line">        int i=0;</span><br><span class="line">        int subLength=0;</span><br><span class="line">        for(int j=0;j&lt;nums.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            while(sum&gt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">                subLength=j-i+1;</span><br><span class="line">                result=result&lt;subLength?result:subLength;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result==100001?0:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>数据结构与算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>可调用对象的绑定器和包装器</title>
    <url>/2025/01/12/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%E5%8C%85%E8%A3%85%E5%99%A8/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>可调用对象的绑定器和包装器</strong>是用来简化或增强对函数（包括普通函数、成员函数、函数对象、Lambda 表达式等）的调用操作的工具。它们广泛用于泛型编程和 STL 算法中，以便将函数灵活地传递给算法或动态控制其行为。</p>
<hr>
<h2 id="1-可调用对象的绑定器"><a href="#1-可调用对象的绑定器" class="headerlink" title="1. 可调用对象的绑定器"></a><strong>1. 可调用对象的绑定器</strong></h2><p>绑定器的作用是<strong>将一个可调用对象的一部分参数提前绑定</strong>，从而生成一个新的可调用对象。</p>
<p>C++11 起引入了 <code>std::bind</code>，用于创建一个可调用对象并绑定部分参数；在现代 C++（C++20）中，更推荐使用 <strong>Lambda 表达式</strong> 替代 <code>std::bind</code>。</p>
<h3 id="1-1-std-bind"><a href="#1-1-std-bind" class="headerlink" title="1.1 std::bind"></a><strong>1.1 std::bind</strong></h3><p><code>std::bind</code> 是一个函数模板，它可以接受一个可调用对象（如普通函数、成员函数、函数对象等）及部分参数，并返回一个新的可调用对象，该对象可以像函数一样调用。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind 所在的头文件</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">bind</span>(callable, arg1, arg2, ..., argN);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>callable</code>：要绑定的可调用对象。</li>
<li><code>arg1, arg2, ..., argN</code>：可调用对象的参数，其中可以使用占位符 <code>_1</code>, <code>_2</code>, … 来延迟绑定。</li>
</ul>
<p>占位符 <code>_1</code>, <code>_2</code>, … 来自头文件 <code>&lt;functional&gt;</code>，表示绑定时保留的参数位置。</p>
<hr>
<h4 id="例子-1：绑定普通函数"><a href="#例子-1：绑定普通函数" class="headerlink" title="例子 1：绑定普通函数"></a><strong>例子 1：绑定普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind, std::placeholders</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; <span class="comment">// 使用占位符 _1, _2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add_five = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, _1); <span class="comment">// 绑定第一个参数为 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_five</span>(<span class="number">10</span>) &lt;&lt; endl;          <span class="comment">// 输出 15（5 + 10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::bind(add, 5, _1)</code> 创建了一个新函数对象 <code>add_five</code>，它将 <code>add</code> 的第一个参数固定为 <code>5</code>，第二个参数保留动态输入。</li>
<li>调用 <code>add_five(10)</code> 等价于调用 <code>add(5, 10)</code>。</li>
</ul>
<hr>
<h4 id="例子-2：绑定成员函数"><a href="#例子-2：绑定成员函数" class="headerlink" title="例子 2：绑定成员函数"></a><strong>例子 2：绑定成员函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> bound_fn = std::<span class="built_in">bind</span>(&amp;MyClass::display, &amp;obj, _1); <span class="comment">// 绑定成员函数</span></span><br><span class="line">    <span class="built_in">bound_fn</span>(<span class="number">42</span>); <span class="comment">// 输出 Value: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>成员函数绑定时，需要提供对象指针（如 <code>&amp;obj</code>）作为隐式的 <code>this</code> 参数。</li>
<li><code>std::bind(&amp;MyClass::display, &amp;obj, _1)</code> 将成员函数的调用与对象绑定。</li>
</ul>
<hr>
<h3 id="1-2-替代-std-bind-的-Lambda-表达式"><a href="#1-2-替代-std-bind-的-Lambda-表达式" class="headerlink" title="1.2 替代 std::bind 的 Lambda 表达式"></a><strong>1.2 替代 std::bind 的 Lambda 表达式</strong></h3><p>在现代 C++ 中，Lambda 表达式更简洁，功能更强，因此可以用 Lambda 替代 <code>std::bind</code>。</p>
<p>以上绑定普通函数的例子，用 Lambda 表达式可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_five = [](<span class="type">int</span> b) &#123; <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">5</span>, b); &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add_five</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>

<p>绑定成员函数的例子，用 Lambda 表达式可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_fn = [&amp;obj](<span class="type">int</span> x) &#123; obj.<span class="built_in">display</span>(x); &#125;;</span><br><span class="line"><span class="built_in">bound_fn</span>(<span class="number">42</span>); <span class="comment">// 输出 Value: 42</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-可调用对象的包装器"><a href="#2-可调用对象的包装器" class="headerlink" title="2. 可调用对象的包装器"></a><strong>2. 可调用对象的包装器</strong></h2><p>包装器的作用是<strong>将一个可调用对象封装起来，允许在运行时管理其调用行为</strong>。</p>
<h3 id="2-1-std-function"><a href="#2-1-std-function" class="headerlink" title="2.1 std::function"></a><strong>2.1 std::function</strong></h3><p><code>std::function</code> 是一个通用的函数包装器，用来存储和调用任何符合特定签名的可调用对象。<br>它可以存储：</p>
<ul>
<li>普通函数</li>
<li>函数指针</li>
<li>成员函数指针</li>
<li>Lambda 表达式</li>
<li>仿函数</li>
</ul>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::function 所在的头文件</span></span></span><br><span class="line"></span><br><span class="line">std::function&lt;R(Args...)&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>R</code>：函数的返回类型。</li>
<li><code>Args...</code>：函数的参数类型列表。</li>
</ul>
<hr>
<h4 id="例子-1：包装普通函数"><a href="#例子-1：包装普通函数" class="headerlink" title="例子 1：包装普通函数"></a><strong>例子 1：包装普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::function</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add; <span class="comment">// 包装普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;              <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="例子-2：包装-Lambda-表达式"><a href="#例子-2：包装-Lambda-表达式" class="headerlink" title="例子 2：包装 Lambda 表达式"></a><strong>例子 2：包装 Lambda 表达式</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;; <span class="comment">// 包装 Lambda</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;                                            <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="例子-3：包装仿函数"><a href="#例子-3：包装仿函数" class="headerlink" title="例子 3：包装仿函数"></a><strong>例子 3：包装仿函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = <span class="built_in">Multiply</span>(); <span class="comment">// 包装仿函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">6</span>, <span class="number">7</span>) &lt;&lt; endl;                    <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-std-function-与-std-bind-配合使用"><a href="#2-2-std-function-与-std-bind-配合使用" class="headerlink" title="2.2 std::function 与 std::bind 配合使用"></a><strong>2.2 std::function 与 std::bind 配合使用</strong></h3><p><code>std::function</code> 可以与 <code>std::bind</code> 结合使用，将部分参数绑定后存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, _1); <span class="comment">// 绑定第一个参数为 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; endl;                             <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-std-function-的灵活性"><a href="#2-3-std-function-的灵活性" class="headerlink" title="2.3 std::function 的灵活性"></a><strong>2.3 std::function 的灵活性</strong></h3><p><code>std::function</code> 允许运行时动态更改存储的可调用对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func;</span><br><span class="line"></span><br><span class="line">    func = add; <span class="comment">// 动态存储 add</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    func = subtract; <span class="comment">// 动态存储 subtract</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-区别与应用场景"><a href="#3-区别与应用场景" class="headerlink" title="3. 区别与应用场景"></a><strong>3. 区别与应用场景</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>std::bind</strong></th>
<th><strong>std::function</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>用于绑定函数的部分参数，生成新的可调用对象</td>
<td>用于包装函数，统一管理所有可调用对象</td>
</tr>
<tr>
<td><strong>参数绑定</strong></td>
<td>支持占位符 <code>_1</code>, <code>_2</code> 等</td>
<td>不支持参数绑定</td>
</tr>
<tr>
<td><strong>运行时动态性</strong></td>
<td>固定绑定时传入的函数和参数</td>
<td>可以运行时动态更改存储的可调用对象</td>
</tr>
<tr>
<td><strong>替代方案</strong></td>
<td>Lambda 表达式可以完全替代</td>
<td>无明显替代方案（功能独特）</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li>**<code>std::bind</code>**：用于将函数的部分参数提前绑定生成一个新的可调用对象，但在现代 C++ 中，通常使用更直观的 <strong>Lambda 表达式</strong> 代替。</li>
<li>**<code>std::function</code>**：是一个灵活的函数包装器，可以统一存储和调用各种可调用对象（普通函数、Lambda、仿函数等），适用于需要动态改变函数行为的场景。</li>
</ul>
<p>结合 <code>std::bind</code> 和 <code>std::function</code>（如 <code>ThreadFunc</code>），我们可以更灵活地创建回调函数或者线程入口函数。<code>std::bind</code> 允许你将某些函数的参数预先绑定，生成一个新的可调用对象。这个新的可调用对象可以通过 <code>std::function</code> 传递，作为回调或者线程的入口函数。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h3 id="结合-std-bind-和-ThreadFunc-的用法"><a href="#结合-std-bind-和-ThreadFunc-的用法" class="headerlink" title="结合 std::bind 和 ThreadFunc 的用法"></a><strong>结合 <code>std::bind</code> 和 <code>ThreadFunc</code> 的用法</strong></h3><p>假设你需要通过 <code>std::bind</code> 绑定函数的某些参数，然后将其传递给一个线程或其他需要可调用对象的地方。使用 <code>std::function</code> 和 <code>std::bind</code> 可以非常方便地处理这种情况。</p>
<h3 id="示例：使用-std-bind-和-ThreadFunc-传递绑定参数"><a href="#示例：使用-std-bind-和-ThreadFunc-传递绑定参数" class="headerlink" title="示例：使用 std::bind 和 ThreadFunc 传递绑定参数"></a><strong>示例：使用 <code>std::bind</code> 和 <code>ThreadFunc</code> 传递绑定参数</strong></h3><p>在这个例子中，我们将创建一个 <code>ThreadFunc</code> 类型的对象，使用 <code>std::bind</code> 绑定一个函数的部分参数，然后将绑定后的函数作为线程的入口函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程函数类型别名</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例线程函数，接受两个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定 print_sum 的两个参数</span></span><br><span class="line">    <span class="comment">// 绑定参数 a = 10，b = 20</span></span><br><span class="line">    ThreadFunc func = std::<span class="built_in">bind</span>(print_sum, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程并传递绑定后的函数作为入口函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a><strong>解释：</strong></h3><ol>
<li><strong><code>ThreadFunc</code> 类型别名</strong>：<code>using ThreadFunc = std::function&lt;void()&gt;;</code> 定义了一个新的类型 <code>ThreadFunc</code>，表示一个无参数且返回 <code>void</code> 的可调用对象。</li>
<li><strong><code>std::bind</code> 的使用</strong>：<code>std::bind(print_sum, 10, 20)</code> 创建了一个新的函数对象，它绑定了 <code>print_sum</code> 函数的两个参数 <code>a</code> 和 <code>b</code>，分别为 10 和 20。返回的是一个新的可调用对象，它没有参数，可以通过 <code>ThreadFunc</code> 来表示。</li>
<li><strong>传递给线程</strong>：<code>std::thread t(func);</code> 创建了一个新的线程 <code>t</code>，并将 <code>func</code>（一个经过 <code>std::bind</code> 绑定的函数对象）作为线程的入口函数。</li>
<li><strong>等待线程执行</strong>：<code>t.join();</code> 等待线程执行完毕。</li>
</ol>
<h3 id="示例：结合-std-bind-和-lambda"><a href="#示例：结合-std-bind-和-lambda" class="headerlink" title="示例：结合 std::bind 和 lambda"></a><strong>示例：结合 <code>std::bind</code> 和 lambda</strong></h3><p>你也可以将 <code>std::bind</code> 与 lambda 表达式结合，动态地传递参数。在这种情况下，lambda 表达式可以充当回调函数的一部分，<code>std::bind</code> 则允许你预先绑定一些参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程函数类型别名</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例线程函数，接受两个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定一个函数，并结合 lambda 来处理参数</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    ThreadFunc func = std::<span class="built_in">bind</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">print_sum</span>(a, b);  <span class="comment">// 使用 lambda 来调用 print_sum</span></span><br><span class="line">    &#125;, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程并传递绑定后的函数作为入口函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li><strong><code>std::bind</code> 和 <code>ThreadFunc</code></strong> 结合使用时，<code>std::bind</code> 可以为函数创建一个新的可调用对象，绑定部分参数，生成一个无参数的函数对象。这个对象可以通过 <code>ThreadFunc</code> 类型来表示。</li>
<li><strong>灵活性</strong>：<code>std::bind</code> 使得我们可以预先绑定一些参数，创建更灵活的回调函数或线程入口函数。结合 <code>std::function</code> 类型别名后，代码会更加简洁和清晰。</li>
<li><strong>代码简化</strong>：在多线程和回调编程中，使用 <code>std::bind</code> 和 <code>ThreadFunc</code> 可以极大地简化参数传递和回调逻辑，尤其是当你需要传递复杂的函数或绑定多个参数时。</li>
</ul>
<p>这种方式常用于多线程编程和事件驱动编程中，使得代码更加模块化、灵活。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四种强制类型转换操作符</title>
    <url>/2024/11/25/%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p>在 C++ 中，有四种强制类型转换操作符，分别是：</p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<p>这四种类型转换都属于强制类型转换，它们的应用场景和功能有所不同。下面详细介绍每一种。</p>
<h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><code>static_cast</code> 用于在类型之间进行转换时，进行编译时类型检查。它适用于转换那些在语义上兼容的类型，例如基本数据类型、类之间的转换等。</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><ul>
<li><strong>类之间的转换</strong>（如父类和子类的转换）。</li>
<li><strong>基本数据类型之间的转换</strong>。</li>
<li><strong>指针类型之间的转换</strong>，当有继承关系时，可以转换指向基类的指针和指向派生类的指针。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Base* 转换为 Derived*，这里是安全的</span></span><br><span class="line">    Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 上行是通过 static_cast</span></span><br><span class="line">    d-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);  <span class="comment">// 基本数据类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="comment">// 输出 10.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static_cast</code> 会进行类型检查，并且不允许不兼容的类型之间的转换。</li>
</ul>
<h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 主要用于处理类层次结构中的指针或引用转换。它用于在类之间进行转换时，确保类型安全。<code>dynamic_cast</code> 在运行时进行类型检查，因此它适用于多态类型的转换（即包含虚函数的类）。</p>
<h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于处理继承体系中的转换，确保安全的类型转换。</li>
<li>可以用于将基类指针或引用转换为派生类指针或引用，前提是基类至少有一个虚函数（多态）。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 错误的转换，d会为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">        d-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 输出 Conversion failed!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dynamic_cast</code> 在运行时检查类型，如果转换失败，返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。它主要用于确保在继承关系中指针或引用的类型转换安全。</li>
</ul>
<h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><code>const_cast</code> 用于修改对象的常量性。它允许去除或添加 <code>const</code> 限定符。常见的用途包括将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型，或者反之。</p>
<h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>去除 <code>const</code> 限定符：可以将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型。</li>
<li>添加 <code>const</code> 限定符：可以将非 <code>const</code> 类型的指针或引用转换为 <code>const</code> 类型。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去除 const 限定符，允许修改对象</span></span><br><span class="line">    <span class="type">int</span>* modifiablePtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);</span><br><span class="line">    *modifiablePtr = <span class="number">20</span>;  <span class="comment">// 修改原对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除 const 限定符</span></span><br><span class="line">    <span class="built_in">modify</span>(ptr);  <span class="comment">// 此处会导致未定义行为</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 未定义行为，x值不可预测</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>警告</strong>：如果你去除 <code>const</code> 限定符并修改对象，该对象实际上可能是常量，修改它会导致未定义行为，因此这种转换应谨慎使用。</li>
</ul>
<h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 是最强大的类型转换操作符，它允许将一种类型的指针或引用转换为另一种完全不相关类型的指针或引用。它不进行任何类型检查，因此使用时必须非常小心。</p>
<h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于进行指针或引用之间的转换，即使它们在类型上没有任何继承关系。</li>
<li>可以将指针转换为整数类型，或将整数转换为指针类型。</li>
</ul>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> int_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pointer as integer: &quot;</span> &lt;&lt; int_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回指针</span></span><br><span class="line">    <span class="type">int</span>* new_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(int_ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dereferenced pointer: &quot;</span> &lt;&lt; *new_ptr &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reinterpret_cast</code> 可以将指针转换为整数，或将整数转换为指针，甚至可以在没有任何类型关系的类型之间进行转换。使用时需要非常小心，因为它可以绕过编译器的类型检查。</li>
</ul>
<h3 id="总结：四种类型转换的对比"><a href="#总结：四种类型转换的对比" class="headerlink" title="总结：四种类型转换的对比"></a>总结：四种类型转换的对比</h3><table>
<thead>
<tr>
<th>转换操作符</th>
<th>适用场景</th>
<th>编译时检查</th>
<th>运行时检查</th>
<th>类型安全</th>
</tr>
</thead>
<tbody><tr>
<td><code>static_cast</code></td>
<td>基本类型转换，类之间的转换，指针之间的转换</td>
<td>是</td>
<td>否</td>
<td>高</td>
</tr>
<tr>
<td><code>dynamic_cast</code></td>
<td>类之间的安全转换，主要用于多态（继承）</td>
<td>是</td>
<td>是</td>
<td>高</td>
</tr>
<tr>
<td><code>const_cast</code></td>
<td>修改对象的常量性（去除或添加 <code>const</code> 限定符）</td>
<td>是</td>
<td>否</td>
<td>中</td>
</tr>
<tr>
<td><code>reinterpret_cast</code></td>
<td>强制转换，指针与整数之间的转换，指针之间的任意转换</td>
<td>否</td>
<td>否</td>
<td>低（非常危险）</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>static_cast</code></strong> 用于编译时类型安全转换，适合大多数常规类型转换。</li>
<li><strong><code>dynamic_cast</code></strong> 用于多态类型的安全转换，尤其是指针和引用之间的转换，支持运行时类型检查。</li>
<li><strong><code>const_cast</code></strong> 用于修改 <code>const</code> 限定符（添加或去除 <code>const</code>）。</li>
<li><strong><code>reinterpret_cast</code></strong> 用于底层转换，指针和整数之间的转换，不进行类型检查，需要小心使用。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>完美转发</title>
    <url>/2025/05/11/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h2 id="C-中的“完美转发”（Perfect-Forwarding）。"><a href="#C-中的“完美转发”（Perfect-Forwarding）。" class="headerlink" title="C++ 中的“完美转发”（Perfect Forwarding）。"></a>C++ 中的“完美转发”（Perfect Forwarding）。</h2><p><strong>核心含义：</strong></p>
<p>完美转发是指在函数模板中，将接收到的参数<strong>以其原本的值类别（左值或右值）和 <code>const</code>&#x2F;<code>volatile</code> 属性</strong>转发给另一个函数。</p>
<p>简单来说，就是让一个“中间”函数（通常是模板函数）能够透明地将参数传递给它调用的“目标”函数，就好像参数是直接传递给目标函数一样，不会因为经过中间函数而改变参数的左值&#x2F;右值属性或 <code>const</code>&#x2F;<code>volatile</code> 属性。</p>
<p><strong>为什么需要完美转发？</strong></p>
<p>考虑一个常见的场景：你有一个泛型函数（比如一个包装器、一个工厂函数、一个日志记录函数），它接收任意类型的参数，然后将这些参数传递给另一个实际执行操作的函数。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with lvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with const lvalue/rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的包装器函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T arg)</span> </span>&#123; <span class="comment">// 按值传递</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside wrapper (by value)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">target_function</span>(arg); <span class="comment">// 问题在这里！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper_ref</span><span class="params">(T&amp; arg)</span> </span>&#123; <span class="comment">// 按左值引用传递</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside wrapper (by lvalue ref)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">target_function</span>(arg); <span class="comment">// 问题在这里！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper_const_ref</span><span class="params">(<span class="type">const</span> T&amp; arg)</span> </span>&#123; <span class="comment">// 按 const 左值引用传递</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside wrapper (by const lvalue ref)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">target_function</span>(arg); <span class="comment">// 问题在这里！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x); <span class="comment">// 传入左值 x</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">20</span>); <span class="comment">// 传入右值 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">wrapper_ref</span>(x); <span class="comment">// 传入左值 x</span></span><br><span class="line">    <span class="comment">// wrapper_ref(20); // 错误：不能将右值绑定到左值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">wrapper_const_ref</span>(x); <span class="comment">// 传入左值 x</span></span><br><span class="line">    <span class="built_in">wrapper_const_ref</span>(<span class="number">20</span>); <span class="comment">// 传入右值 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中：</p>
<ol>
<li><code>wrapper(T arg)</code>：参数 <code>arg</code> 是按值传递的，这意味着传入的实参会被复制一份。无论你传入左值还是右值，<code>arg</code> 在 <code>wrapper</code> 函数内部都是一个独立的局部变量（一个左值）。当你将 <code>arg</code> 传递给 <code>target_function</code> 时，它会匹配 <code>target_function(int&amp;)</code> 或 <code>target_function(const int&amp;)</code>（取决于 <code>T</code> 是否被推导为 const），而永远不会匹配 <code>target_function(int&amp;&amp;)</code>。原始实参的右值属性丢失了。</li>
<li><code>wrapper_ref(T&amp; arg)</code>：这个包装器只能接收左值。如果你传入右值，会编译错误。即使传入左值，<code>arg</code> 在内部是左值引用，传递给 <code>target_function</code> 时也是作为左值引用传递。</li>
<li><code>wrapper_const_ref(const T&amp; arg)</code>：这个包装器可以接收左值和右值（因为 <code>const T&amp;</code> 可以绑定到右值）。但无论传入什么，<code>arg</code> 在内部都是一个 <code>const</code> 左值引用。传递给 <code>target_function</code> 时，它会匹配 <code>target_function(const int&amp;)</code>。原始实参的右值属性丢失了，并且增加了 <code>const</code> 属性。</li>
</ol>
<p>这些传统的传递方式都无法实现“完美转发”，即无法让 <code>target_function</code> 像直接接收原始实参那样，根据实参是左值还是右值来选择对应的重载版本。这在需要利用移动语义（当传入右值时）的场景下尤其成问题。</p>
<p><strong>如何实现完美转发？</strong></p>
<p>完美转发依赖于两个关键的 C++11 特性：</p>
<ol>
<li><strong>万能引用 (Universal Reference &#x2F; Forwarding Reference)：</strong> 在函数模板参数中使用 <code>T&amp;&amp;</code>（其中 <code>T</code> 是模板参数）或 <code>auto&amp;&amp;</code>。这使得参数可以绑定到左值或右值，并通过引用折叠规则保留了原始实参的值类别信息。</li>
<li><strong><code>std::forward&lt;T&gt;()</code>：</strong> 这是一个标准库工具，用于在转发参数时<strong>有条件地</strong>将其转换为右值引用。如果原始实参是左值，<code>std::forward</code> 会将其转发为左值引用；如果原始实参是右值，<code>std::forward</code> 会将其转发为右值引用。</li>
</ol>
<p><strong>使用完美转发的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// 需要包含 &lt;utility&gt; 来使用 std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with lvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with const lvalue/rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完美转发的包装器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perfect_forwarding_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; <span class="comment">// T&amp;&amp; 是万能引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside perfect_forwarding_wrapper&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 使用 std::forward&lt;T&gt; 转发参数</span></span><br><span class="line">    <span class="built_in">target_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cx = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(x);     <span class="comment">// 传入左值 x -&gt; T 被推导为 int&amp; -&gt; std::forward&lt;int&amp;&gt;(arg) 返回 int&amp; -&gt; 匹配 target_function(int&amp;)</span></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(<span class="number">20</span>);    <span class="comment">// 传入右值 20 -&gt; T 被推导为 int -&gt; std::forward&lt;int&gt;(arg) 返回 int&amp;&amp; -&gt; 匹配 target_function(int&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(cx);    <span class="comment">// 传入 const 左值 cx -&gt; T 被推导为 const int&amp; -&gt; std::forward&lt;const int&amp;&gt;(arg) 返回 const int&amp; -&gt; 匹配 target_function(const int&amp;)</span></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// 传入右值 std::move(x) -&gt; T 被推导为 int -&gt; std::forward&lt;int&gt;(arg) 返回 int&amp;&amp; -&gt; 匹配 target_function(int&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with lvalue: 10</span><br><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with rvalue: 20</span><br><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with const lvalue/rvalue: 30</span><br><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with rvalue: 10</span><br></pre></td></tr></table></figure>

<p>可以看到，通过使用 <code>T&amp;&amp;</code> 万能引用和 <code>std::forward&lt;T&gt;(arg)</code>，<code>perfect_forwarding_wrapper</code> 成功地将实参的原始值类别和 <code>const</code> 属性传递给了 <code>target_function</code>，使得 <code>target_function</code> 能够根据传入的实参类型选择正确的重载版本。</p>
<p><strong>总结：</strong></p>
<p>完美转发是一种技术，用于在泛型编程（特别是模板函数）中，将参数以其原始的左值&#x2F;右值属性和 <code>const</code>&#x2F;<code>volatile</code> 属性转发给另一个函数。它通过结合<strong>万能引用（或称转发引用）</strong>和 <strong><code>std::forward</code></strong> 工具来实现，解决了传统参数传递方式在转发过程中丢失参数原始属性的问题，这对于实现通用的、高效的包装器函数和利用移动语义至关重要。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++11</tag>
        <tag>完美转发</tag>
        <tag>万能引用</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树的调整(左旋与右旋)</title>
    <url>/2024/10/30/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4-%E5%B7%A6%E6%97%8B%E4%B8%8E%E5%8F%B3%E6%97%8B/</url>
    <content><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，它在结构上保持一定的平衡，以确保在最坏情况下依然具有较好的查找、插入和删除性能。</p>
<h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><p><strong>平衡</strong>的具体定义可以根据不同类型的平衡树略有不同。一般来说，一个二叉树是平衡的，当其任意节点的左右子树高度差的绝对值不超过某个特定值（通常是1）时。</p>
<h3 id="常见类型的平衡二叉树"><a href="#常见类型的平衡二叉树" class="headerlink" title="常见类型的平衡二叉树"></a>常见类型的平衡二叉树</h3><ol>
<li><p><strong>AVL树</strong>：</p>
<ul>
<li><p>每个节点的左右子树高度差（平衡因子）只允许为 -1、0 或 1。</p>
</li>
<li><p>在插入或删除节点后，如果导致不平衡，会通过旋转操作来恢复平衡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt; // 用于 std::max</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 节点结构</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;       // 节点值</span><br><span class="line">    Node* left;    // 左子节点</span><br><span class="line">    Node* right;   // 右子节点</span><br><span class="line">    int height;    // 节点高度</span><br><span class="line"></span><br><span class="line">    Node(int k) : key(k), left(nullptr), right(nullptr), height(1) &#123;&#125; // 初始化节点</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 获取节点的高度</span><br><span class="line">int getHeight(Node* node) &#123;</span><br><span class="line">    return node ? node-&gt;height : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取平衡因子</span><br><span class="line">int getBalanceFactor(Node* node) &#123;</span><br><span class="line">    return node ? getHeight(node-&gt;left) - getHeight(node-&gt;right) : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新节点的高度</span><br><span class="line">void updateHeight(Node* node) &#123;</span><br><span class="line">    node-&gt;height = max(getHeight(node-&gt;left), getHeight(node-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 右旋操作</span><br><span class="line">Node* rightRotate(Node* y) &#123;</span><br><span class="line">    Node* x = y-&gt;left;</span><br><span class="line">    Node* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">    // 右旋转</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    // 更新高度</span><br><span class="line">    updateHeight(y);</span><br><span class="line">    updateHeight(x);</span><br><span class="line"></span><br><span class="line">    // 返回新的根节点</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 左旋操作</span><br><span class="line">Node* leftRotate(Node* x) &#123;</span><br><span class="line">    Node* y = x-&gt;right;</span><br><span class="line">    Node* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    // 左旋转</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    // 更新高度</span><br><span class="line">    updateHeight(x);</span><br><span class="line">    updateHeight(y);</span><br><span class="line"></span><br><span class="line">    // 返回新的根节点</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点并保持平衡</span><br><span class="line">Node* insert(Node* node, int key) &#123;</span><br><span class="line">    // 1. 标准的二叉搜索树插入</span><br><span class="line">    if (!node) return new Node(key);</span><br><span class="line"></span><br><span class="line">    if (key &lt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    &#125; else if (key &gt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 不允许插入重复值</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 更新当前节点的高度</span><br><span class="line">    updateHeight(node);</span><br><span class="line"></span><br><span class="line">    // 3. 计算平衡因子</span><br><span class="line">    int balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">    // 4. 根据平衡因子进行相应的旋转操作</span><br><span class="line">    // 左左情况</span><br><span class="line">    if (balanceFactor &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        return rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右右情况</span><br><span class="line">    if (balanceFactor &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        return leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 左右情况</span><br><span class="line">    if (balanceFactor &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">        return rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右左情况</span><br><span class="line">    if (balanceFactor &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">        return leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回不变的节点指针</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中序遍历树以显示结果</span><br><span class="line">void inOrder(Node* root) &#123;</span><br><span class="line">    if (root) &#123;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; root-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数测试AVL树</span><br><span class="line">int main() &#123;</span><br><span class="line">    Node* root = nullptr;</span><br><span class="line"></span><br><span class="line">    // 插入一些节点</span><br><span class="line">    root = insert(root, 10);</span><br><span class="line">    root = insert(root, 20);</span><br><span class="line">    root = insert(root, 30);</span><br><span class="line">    root = insert(root, 40);</span><br><span class="line">    root = insert(root, 50);</span><br><span class="line">    root = insert(root, 25);</span><br><span class="line"></span><br><span class="line">    // 中序遍历 AVL 树</span><br><span class="line">    cout &lt;&lt; &quot;中序遍历 AVL 树: &quot;;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>红黑树</strong>：</p>
<ul>
<li>是一种自平衡的二叉搜索树，每个节点都有一个颜色属性（红色或黑色），并遵循特定的颜色规则。</li>
<li>保证从根到叶的路径上的黑色节点数量相同，从而保持树的平衡性。</li>
</ul>
</li>
</ol>
<h3 id="平衡二叉树的特点"><a href="#平衡二叉树的特点" class="headerlink" title="平衡二叉树的特点"></a>平衡二叉树的特点</h3><ul>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li>查找、插入和删除操作的时间复杂度通常为 O(\log n)，这使得平衡二叉树非常高效，特别是在大量数据的情况下。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>平衡二叉树的空间复杂度为 O(n)，与普通的二叉树相同。</li>
</ul>
</li>
<li><p><strong>自我平衡</strong>：</p>
<ul>
<li>在插入或删除节点时，通过旋转和调整树的结构，保持树的平衡，从而避免退化成链表。</li>
</ul>
</li>
</ul>
<p> 旋转操作是平衡二叉树（如 AVL 树和红黑树）中的重要技术，用于在插入或删除节点后恢复树的平衡。旋转操作可以分为两种类型：左旋（Left Rotation）和右旋（Right Rotation）。以下是这两种旋转的详细介绍及其实现。</p>
<h1 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h1><p>首先注意，右旋（L）实际上是将树向左旋转，左旋则是将树向右旋转</p>
<h3 id="1-右旋（Right-Rotation）"><a href="#1-右旋（Right-Rotation）" class="headerlink" title="1. 右旋（Right Rotation）"></a>1. 右旋（Right Rotation）</h3><p>右旋操作是将某个节点（称为“失衡节点”）的左子节点提升为新的根节点，同时将失衡节点降为新根节点的右子节点。</p>
<h4 id="右旋的步骤"><a href="#右旋的步骤" class="headerlink" title="右旋的步骤"></a>右旋的步骤</h4><ol>
<li>设失衡节点为 <code>y</code>，其左子节点为 <code>x</code>。</li>
<li>将 <code>x</code> 的右子节点（如果存在）连接到 <code>y</code> 的左子节点。</li>
<li>将 <code>x</code> 提升为新的根节点。</li>
<li>将 <code>y</code> 设为 <code>x</code> 的右子节点。</li>
</ol>
<h4 id="右旋的伪代码"><a href="#右旋的伪代码" class="headerlink" title="右旋的伪代码"></a>右旋的伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="type">int</span> height; <span class="comment">// 用于 AVL 树的高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* y)</span> </span>&#123;</span><br><span class="line">    TreeNode* x = y-&gt;left;           <span class="comment">// 让 x 指向 y 的左子节点</span></span><br><span class="line">    TreeNode* T2 = x-&gt;right;         <span class="comment">// 保存 x 的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    x-&gt;right = y;                    <span class="comment">// 将 y 设置为 x 的右子节点</span></span><br><span class="line">    y-&gt;left = T2;                    <span class="comment">// 将 T2 设置为 y 的左子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度（如果需要）</span></span><br><span class="line">    y-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-左旋（Left-Rotation）"><a href="#2-左旋（Left-Rotation）" class="headerlink" title="2. 左旋（Left Rotation）"></a>2. 左旋（Left Rotation）</h3><p>左旋操作是将某个节点的右子节点提升为新的根节点，同时将失衡节点降为新根节点的左子节点。</p>
<h4 id="左旋的步骤"><a href="#左旋的步骤" class="headerlink" title="左旋的步骤"></a>左旋的步骤</h4><ol>
<li>设失衡节点为 <code>x</code>，其右子节点为 <code>y</code>。</li>
<li>将 <code>y</code> 的左子节点（如果存在）连接到 <code>x</code> 的右子节点。</li>
<li>将 <code>y</code> 提升为新的根节点。</li>
<li>将 <code>x</code> 设为 <code>y</code> 的左子节点。</li>
</ol>
<h4 id="左旋的伪代码"><a href="#左旋的伪代码" class="headerlink" title="左旋的伪代码"></a>左旋的伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* x)</span> </span>&#123;</span><br><span class="line">    TreeNode* y = x-&gt;right;         <span class="comment">// 让 y 指向 x 的右子节点</span></span><br><span class="line">    TreeNode* T2 = y-&gt;left;         <span class="comment">// 保存 y 的左子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    y-&gt;left = x;                    <span class="comment">// 将 x 设置为 y 的左子节点</span></span><br><span class="line">    x-&gt;right = T2;                  <span class="comment">// 将 T2 设置为 x 的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度（如果需要）</span></span><br><span class="line">    x-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    y-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-组合旋转"><a href="#3-组合旋转" class="headerlink" title="3. 组合旋转"></a>3. 组合旋转</h3><h4 id="AVL有且只有的四种情况（LL-LR-RL-RR）"><a href="#AVL有且只有的四种情况（LL-LR-RL-RR）" class="headerlink" title="AVL有且只有的四种情况（LL,LR,RL,RR）"></a>AVL有且只有的四种情况（LL,LR,RL,RR）</h4><p>图片来自<a href="https://blog.csdn.net/a6892255/article/details/117001282?ops_request_misc=%7B%22request_id%22:%22EBCFF1FE-F5C1-4776-B879-A508C09E98D5%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=EBCFF1FE-F5C1-4776-B879-A508C09E98D5&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117001282-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B&spm=1018.2226.3001.4187">数据结构之AVL树(平衡二叉树)的理解_avl左右旋-CSDN博客</a></p>
<h4 id="1-LL"><a href="#1-LL" class="headerlink" title="1.LL"></a>1.LL</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/edea4edc378247e01a490437e164a51f.png" alt="LL"></p>
<h4 id="2-LR"><a href="#2-LR" class="headerlink" title="2.LR"></a>2.LR</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dc372fd873d281a3bb0b8a92eaae54fa.png" alt="LR(1)"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/30204ce4046bd0a9c2316159496d1886.png" alt="LR(2)"></p>
<h4 id="3-RL"><a href="#3-RL" class="headerlink" title="3.RL"></a>3.RL</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d60980e235068364f15691ef822690de.png" alt="RL(1)"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/084bc177d55d0797ab75c3caf6963405.png" alt="RL(2)"></p>
<h4 id="4-RR"><a href="#4-RR" class="headerlink" title="4.RR"></a>4.RR</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/60bb25e94471951b5602f0507a5b232c.png" alt="RR2"></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>懒加载</title>
    <url>/2025/01/22/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p><strong>懒加载</strong>（Lazy Initialization 或 Lazy Loading）是一种设计模式或编程技巧，它的核心思想是：<strong>延迟初始化资源，只有在真正需要的时候才创建或加载这些资源</strong>。</p>
<hr>
<h3 id="懒加载的特点"><a href="#懒加载的特点" class="headerlink" title="懒加载的特点"></a><strong>懒加载的特点</strong></h3><ol>
<li><strong>避免不必要的开销</strong><ul>
<li>如果资源加载非常耗时或占用大量内存，懒加载可以减少程序启动时的资源占用。</li>
</ul>
</li>
<li><strong>提升性能</strong><ul>
<li>只有在资源被真正需要时才加载，减少了程序的启动时间。</li>
</ul>
</li>
<li><strong>按需加载</strong><ul>
<li>资源是否加载取决于程序运行时的实际需求，可能避免加载某些资源。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="懒加载的使用场景"><a href="#懒加载的使用场景" class="headerlink" title="懒加载的使用场景"></a><strong>懒加载的使用场景</strong></h3><ol>
<li><p><strong>单例模式</strong></p>
<ul>
<li>在单例模式中，实例对象通常会在第一次访问时才创建。</li>
<li>例如，你的 <code>Logger</code> 类的实现：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Logger &amp;<span class="title">Logger::instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger; <span class="comment">// 静态变量只在第一次调用时初始化</span></span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Logger</code> 对象只有在调用 <code>Logger::instance()</code> 时才会被创建，而不是程序启动时。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件或资源加载</strong></p>
<ul>
<li>某些大文件、图像、数据库连接等，只有当它们真正被使用时才加载：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    std::string filePath;</span><br><span class="line">    <span class="type">bool</span> loaded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!loaded) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Loading image from: &quot;</span> &lt;&lt; filePath &lt;&lt; std::endl;</span><br><span class="line">            loaded = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这里，<code>load()</code> 方法只会在需要时加载图像。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Web开发</strong></p>
<ul>
<li>某些页面的资源（如图片、视频等）可能只有当用户滚动到相关区域时才加载，减少初始页面加载时间。</li>
</ul>
</li>
<li><p><strong>数据库连接或远程服务</strong></p>
<ul>
<li>某些昂贵的资源，比如数据库连接或远程 API 的初始化，可以延迟到第一次调用时：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;Connection&gt; conn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Connection* <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">            conn = std::<span class="built_in">make_unique</span>&lt;Connection&gt;(<span class="string">&quot;database_url&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="懒加载的优缺点"><a href="#懒加载的优缺点" class="headerlink" title="懒加载的优缺点"></a><strong>懒加载的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><strong>节约资源</strong><ul>
<li>如果某些资源没有被使用，那么它们就不会被初始化，节省内存和 CPU 开销。</li>
</ul>
</li>
<li><strong>提升性能</strong><ul>
<li>程序启动时不需要一次性加载所有资源，减少启动时间。</li>
</ul>
</li>
<li><strong>动态性</strong><ul>
<li>根据实际需要按需加载，增加程序的灵活性。</li>
</ul>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><strong>可能导致延迟</strong><ul>
<li>当资源在运行时第一次被访问时，懒加载会增加一定的初始化开销，可能导致短暂的延迟。</li>
</ul>
</li>
<li><strong>线程安全问题</strong><ul>
<li>在多线程环境中，如果多个线程同时访问未初始化的资源，可能会导致竞争条件或重复初始化。需要通过加锁或使用线程安全的机制（如 C++11 的静态局部变量）解决。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="懒加载与饿加载对比"><a href="#懒加载与饿加载对比" class="headerlink" title="懒加载与饿加载对比"></a><strong>懒加载与饿加载对比</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>懒加载</strong></th>
<th><strong>饿加载（Eager Loading）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>加载时机</strong></td>
<td>只有在需要时才加载资源</td>
<td>程序启动时立即加载资源</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>程序启动时较快，首次使用时可能有延迟</td>
<td>程序启动时较慢，但运行时无需等待</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>只有用到的资源才会加载，节约内存</td>
<td>所有资源都被加载，可能造成浪费</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>需要确保初始化过程的线程安全</td>
<td>初始化时线程安全问题相对较少</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>资源加载成本高，且不一定被全部使用</td>
<td>资源较少，或所有资源都会被使用</td>
</tr>
</tbody></table>
<hr>
<h3 id="懒加载的实现方式"><a href="#懒加载的实现方式" class="headerlink" title="懒加载的实现方式"></a><strong>懒加载的实现方式</strong></h3><h4 id="1-静态局部变量"><a href="#1-静态局部变量" class="headerlink" title="1. 静态局部变量"></a><strong>1. 静态局部变量</strong></h4><ul>
<li>C++ 中常用懒加载方式，利用静态局部变量的特性：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Logger &amp;<span class="title">Logger::instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;  <span class="comment">// 只有第一次调用时，logger 才会被初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-延迟初始化变量"><a href="#2-延迟初始化变量" class="headerlink" title="2. 延迟初始化变量"></a><strong>2. 延迟初始化变量</strong></h4><ul>
<li>用一个标志位来判断是否已加载资源：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyObject</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;Resource&gt; resource;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Resource* <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!resource) &#123;</span><br><span class="line">            resource = std::<span class="built_in">make_unique</span>&lt;Resource&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-双重检查锁（用于多线程）"><a href="#3-双重检查锁（用于多线程）" class="headerlink" title="3. 双重检查锁（用于多线程）"></a><strong>3. 双重检查锁（用于多线程）</strong></h4><ul>
<li>多线程情况下的懒加载，可以用双重检查锁：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>懒加载是一种高效的设计模式，适合那些<strong>资源初始化开销大但并非总是需要</strong>的场景。在你的 <code>Logger</code> 单例模式中，懒加载的使用保证了资源的按需加载和全局唯一性，同时避免了程序启动时不必要的性能消耗。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>指向常量的指针与常量指针</title>
    <url>/2024/11/17/%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p>好久没有更新博客了，与最近考试多有关，也与个人怠惰有关</p>
<p>今天的内容是指向常量的指针（pointer to const）与指针常量（const pointer），这是昨天在阅读《c++ primer》中重新理解的内容，有了些许新的感悟，趁热打铁，发在博客上</p>
<h3 id="在讲那两个之前，先说一下const与对常量的引用（reference-to-const）"><a href="#在讲那两个之前，先说一下const与对常量的引用（reference-to-const）" class="headerlink" title="在讲那两个之前，先说一下const与对常量的引用（reference to const）"></a>在讲那两个之前，先说一下const与对常量的引用（reference to const）</h3><h4 id="const修饰词"><a href="#const修饰词" class="headerlink" title="const修饰词"></a>const修饰词</h4><p>使用const修饰词修饰的变量，即常量，是必须初始化的，且初始化后不能修改其值</p>
<p>初始化时除了用如下方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a=1;</span><br></pre></td></tr></table></figure>

<p>同样可以用非常量但同类型的值进行赋值（拷贝）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">const int b=a;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>const修饰的对象在编译时直接替换，类似define，即提前将所有出现其的位置替换成对应的数值，不申请额外空间</p>
<p>以下场景除外(都要等具体的值才能初始化)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a =fun();</span><br><span class="line">const int &amp;b=c;</span><br></pre></td></tr></table></figure>

<p>同时const对象仅在文件内部有效，要实现在一个文件中定义，在多个文件中声明并使用，要用extern 关键字修饰所有const对象</p>
<h4 id="对const的引用（常量引用）"><a href="#对const的引用（常量引用）" class="headerlink" title="对const的引用（常量引用）"></a>对const的引用（常量引用）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常量引用本身是常量，无法修改引用的对象</span><br><span class="line">const int a=1;</span><br><span class="line">const int b=2;</span><br><span class="line">const int &amp;r =a;</span><br><span class="line">r=b;//错误，不可修改</span><br><span class="line">r=2;//错误，不可修改</span><br></pre></td></tr></table></figure>

<p>常量引用不能改变引用的值（毕竟常量的值无法改变）</p>
<p>要对常量使用引用，也只能使用常量引用</p>
<h2 id="但是，常量引用可以引用非常量的同类型变量"><a href="#但是，常量引用可以引用非常量的同类型变量" class="headerlink" title="但是，常量引用可以引用非常量的同类型变量"></a>但是，常量引用可以引用非常量的同类型变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">const int &amp;r =i;//正确</span><br><span class="line"></span><br><span class="line">const int &amp;r2=r1*2;//正确</span><br><span class="line"></span><br><span class="line">i=4;//i不是常量，可以修改，同样会导致r的值变动</span><br></pre></td></tr></table></figure>

<p>这种场景经常出现，甚至比引用常量更多，主要应用场景在函数参数传递时，传递参数的常量引用，可以确保参数不被修改，同时避免拷贝的花销。</p>
<p>在接口等地方非常常见，可以参考《effective c++》中的建议</p>
<p>可以理解为常量引用引用的是一个临时常量，变量的值赋给了临时变量。</p>
<p>ok.到此为止，下面是指向常量的指针与常量指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line"></span><br><span class="line">指针常量</span><br><span class="line">int* const p1 = &amp;a;</span><br><span class="line">*p1 = 6;</span><br><span class="line">// const pointer,本身是个常量，不能改变指向的对象</span><br><span class="line">//只能指向变量，无法指向常量</span><br><span class="line">//如果指向的对象并非是常量，指向对象的值还是可以修改的</span><br><span class="line"></span><br><span class="line">指向常量的指针（常量指针）</span><br><span class="line">const int* p2 = &amp;a;</span><br><span class="line">p2 = &amp;b;//正确，pointer to const,本身不是常量，可以改变指向的对象</span><br><span class="line">*p2=3;//错误，无法通过这种方式修改指向的变量的值</span><br><span class="line">//类似常量引用，可以指向常量，也可以指向变量</span><br><span class="line"></span><br><span class="line">const int* const p3 = &amp;a;//指向常量的常量指针</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h3><p>顶层const表示其本身是常量，即常量和常量指针，无法修改其值（常量指针无法修改指向的对象，即地址，也就是其值）</p>
<p>底层const表示指向（引用）的对象是一个“常量”（常量或变量），无法修改指向（引用）对象的值，即常量引用和指向常量的指针等</p>
<p>拷贝时，两者区别非常明显</p>
<p>顶层const，可以随意赋给变量做值</p>
<p>底层const,不可以赋给变量做值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">const int *r1=a;</span><br><span class="line">int *const r2=a;</span><br><span class="line"></span><br><span class="line">int *p=r1;//错误，底层const无法赋值</span><br><span class="line">int *p=r2;//正确</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>指针</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2025/01/12/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><strong>智能指针</strong>是一种在编程中管理动态内存资源的对象。它封装了原始指针（raw pointer），并提供额外的功能，例如自动释放资源、避免内存泄漏和管理对象的生命周期。智能指针广泛用于需要动态分配内存的语言（如 C++），通过 RAII（Resource Acquisition Is Initialization）原则实现内存管理。</p>
<p>在 C++ 中，智能指针主要在 <strong><code>&lt;memory&gt;</code></strong> 头文件中定义，包括以下几种类型：</p>
<hr>
<h3 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a><strong>1. <code>std::unique_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>独占所有权（一个对象只能有一个 <code>unique_ptr</code> 拥有它）。</li>
<li>不可复制，但可以通过 <code>std::move</code> 转移所有权。</li>
<li>适合需要明确单一所有权的场景。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 创建智能指针</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;                      <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 离开作用域时，自动释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2. std::shared_ptr"></a><strong>2. <code>std::shared_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>共享所有权（多个智能指针可以共享同一个资源）。</li>
<li>通过引用计数管理资源生命周期，计数归零时释放资源。</li>
<li>使用场景：多个对象需要共享同一资源。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享同一资源</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl; <span class="comment">// 输出 42, 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 所有 `shared_ptr` 离开作用域时释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a><strong>3. <code>std::weak_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>与 <code>shared_ptr</code> 配合使用，弱引用（不增加引用计数）。</li>
<li>用于解决循环引用问题（两个对象通过 <code>shared_ptr</code> 相互引用，导致资源无法释放）。</li>
<li>在访问资源前需要检查是否有效。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// 创建弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = weak.<span class="built_in">lock</span>()) &#123; <span class="comment">// 检查资源是否有效</span></span><br><span class="line">        std::cout &lt;&lt; *locked &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 资源离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ol>
<li><strong>避免内存泄漏</strong>：智能指针会自动释放资源，无需手动调用 <code>delete</code>。</li>
<li><strong>安全性</strong>：通过封装原始指针，减少指针操作中的错误（如悬空指针、重复释放）。</li>
<li><strong>易于使用</strong>：支持语义清晰的接口和自动管理生命周期。</li>
</ol>
<hr>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ol>
<li>引入了额外的内存开销（如 <code>shared_ptr</code> 的引用计数）。</li>
<li>需要注意循环引用问题（可通过 <code>weak_ptr</code> 避免）。</li>
<li>不适用于所有场景，例如实时性能要求特别高的代码。</li>
</ol>
<hr>
<h3 id="智能指针-vs-原始指针"><a href="#智能指针-vs-原始指针" class="headerlink" title="智能指针 vs 原始指针"></a><strong>智能指针 vs 原始指针</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>智能指针</strong></th>
<th><strong>原始指针</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存管理</strong></td>
<td>自动释放</td>
<td>手动释放</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>更安全（防止悬空指针等问题）</td>
<td>容易出错</td>
</tr>
<tr>
<td><strong>使用复杂度</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>略有开销（如引用计数）</td>
<td>无开销</td>
</tr>
</tbody></table>
<p>智能指针在现代 C++ 中被广泛使用，是 C++11 引入的重要功能之一，极大地提高了代码的安全性和可维护性。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树:Prim 算法和Kruskal 算法</title>
    <url>/2024/10/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim-%E7%AE%97%E6%B3%95%E5%92%8CKruskal-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在 C++ 中，实现最小生成树（MST）的常用算法有两种：<strong>Prim 算法</strong>和<strong>Kruskal 算法</strong>。这两种算法适用于加权无向图，用于寻找包含所有顶点的边的集合，使得边的总权重最小，且没有环路。</p>
<h3 id="1-Prim-算法"><a href="#1-Prim-算法" class="headerlink" title="1. Prim 算法"></a>1. Prim 算法</h3><p>Prim 算法通过贪心策略来构建 MST，从任意起始顶点开始，每次选择权重最小的边扩展 MST。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>初始化一个集合 <code>MST</code>，包含图中的任意一个顶点。</li>
<li>找到从集合 <code>MST</code> 到剩余顶点中权重最小的边，并将该边加入 <code>MST</code>。</li>
<li>重复步骤 2，直到所有顶点都包含在 <code>MST</code> 中。</li>
</ol>
<h4 id="C-实现示例（使用优先队列）"><a href="#C-实现示例（使用优先队列）" class="headerlink" title="C++ 实现示例（使用优先队列）"></a>C++ 实现示例（使用优先队列）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来表示边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Prim 算法计算最小生成树的总权重</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">primMST</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();  <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inMST</span><span class="params">(n, <span class="literal">false</span>)</span></span>;  <span class="comment">// 标记顶点是否在 MST 中</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;  <span class="comment">// 最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);  <span class="comment">// 起始顶点的权重为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [weight, u] = pq.<span class="built_in">top</span>();  <span class="comment">// 获取权重最小的边</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inMST[u]) <span class="keyword">continue</span>;  <span class="comment">// 如果已经在 MST 中，跳过</span></span><br><span class="line"></span><br><span class="line">        inMST[u] = <span class="literal">true</span>;  <span class="comment">// 标记顶点 u 在 MST 中</span></span><br><span class="line">        totalWeight += weight;  <span class="comment">// 累加边的权重</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 u 的所有邻接边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.to;</span><br><span class="line">            <span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!inMST[v]) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;w, v&#125;);  <span class="comment">// 将未加入 MST 的顶点及其权重放入优先队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个无向加权图</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;  <span class="comment">// 图中顶点数</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点 0 开始计算最小生成树的总权重</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="built_in">primMST</span>(graph, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><ul>
<li><code>graph</code> 是一个邻接表，每个顶点的邻接边存储在一个 <code>vector</code> 中。</li>
<li><code>priority_queue</code> 用于选择当前权重最小的边。</li>
<li><code>inMST</code> 数组用于标记哪些顶点已经在 MST 中。</li>
<li>算法的时间复杂度为 (O(E \log V))，其中 (E) 是边数，(V) 是顶点数。</li>
</ul>
<h3 id="2-Kruskal-算法"><a href="#2-Kruskal-算法" class="headerlink" title="2. Kruskal 算法"></a>2. Kruskal 算法</h3><p>Kruskal 算法通过贪心策略来构建 MST，每次选择权重最小的边，添加到 MST 中，前提是不会形成环。</p>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>将图中的所有边按权重从小到大排序。</li>
<li>初始化一个并查集，用于判断是否会形成环。</li>
<li>依次选择权重最小的边，如果该边连接的两个顶点属于不同的集合，则将其加入 MST。</li>
<li>重复步骤 3，直到 MST 包含 (V-1) 条边。</li>
</ol>
<h4 id="C-实现示例（使用并查集）"><a href="#C-实现示例（使用并查集）" class="headerlink" title="C++ 实现示例（使用并查集）"></a>C++ 实现示例（使用并查集）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来表示边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">from</span>(f), <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) : <span class="built_in">parent</span>(n), <span class="built_in">rank</span>(n, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u != parent[u]) &#123;</span><br><span class="line">            parent[u] = <span class="built_in">find</span>(parent[u]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootU = <span class="built_in">find</span>(u);</span><br><span class="line">        <span class="type">int</span> rootV = <span class="built_in">find</span>(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootU == rootV) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// u 和 v 在同一个集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 联合集合，按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootU] &gt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootU] &lt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootU] = rootV;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">            ++rank[rootU];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Kruskal 算法计算最小生成树的总权重</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> n, vector&lt;Edge&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将边按权重从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;  <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> edgesUsed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">unionSets</span>(edge.from, edge.to)) &#123;</span><br><span class="line">            totalWeight += edge.weight;</span><br><span class="line">            edgesUsed++;</span><br><span class="line">            <span class="keyword">if</span> (edgesUsed == n - <span class="number">1</span>) <span class="keyword">break</span>;  <span class="comment">// 当使用的边数达到 n-1 时，停止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;  <span class="comment">// 图中顶点数</span></span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最小生成树的总权重</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="built_in">kruskalMST</span>(n, edges);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h4><ul>
<li>使用 <code>Edge</code> 结构体来表示边，包括起点、终点和权重。</li>
<li>使用 <code>UnionFind</code> 类来实现并查集，用于检测是否形成环。</li>
<li>将所有边按权重排序，然后使用贪心算法构建 MST。</li>
<li>算法的时间复杂度为 (O(E \log E))，因为排序耗时 (O(E \log E))，而并查集的操作近似为 (O(\log V))。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Prim 算法</strong>适用于稠密图（边多），通常使用邻接表和优先队列实现。</li>
<li><strong>Kruskal 算法</strong>适用于稀疏图（边少），通过边排序和并查集来实现。</li>
</ul>
<p>这两种算法都能高效地找到图的最小生成树，但适用的场景略有不同。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>最小生成树</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕vector</title>
    <url>/2025/05/02/%E6%89%8B%E6%92%95vector/</url>
    <content><![CDATA[<p>手撕不了一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;new&gt;</span><br><span class="line"></span><br><span class="line">// 简单的内存池分配器，用于高效内存管理</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class PoolAllocator &#123;</span><br><span class="line">private:</span><br><span class="line">    struct Block &#123;</span><br><span class="line">        Block* next; // 指向下一个空闲块的指针</span><br><span class="line">    &#125;;</span><br><span class="line">    static constexpr size_t POOL_SIZE = 1024 * sizeof(T); // 内存池总大小</span><br><span class="line">    static constexpr size_t BLOCK_SIZE = sizeof(T) &gt; sizeof(Block) ? sizeof(T) : sizeof(Block); // 每个块的大小</span><br><span class="line">    unsigned char* pool_;  // 原始内存池</span><br><span class="line">    Block* free_list_;     // 空闲块链表头</span><br><span class="line">    size_t pool_size_;     // 内存池总大小</span><br><span class="line"></span><br><span class="line">// 初始化空闲块链表，将内存池分割为链接的块</span><br><span class="line">void init_pool() &#123;</span><br><span class="line">    free_list_ = reinterpret_cast&lt;Block*&gt;(pool_);</span><br><span class="line">    Block* current = free_list_;</span><br><span class="line">    size_t block_count = pool_size_ / BLOCK_SIZE;</span><br><span class="line">    for (size_t i = 0; i &lt; block_count - 1; ++i) &#123;</span><br><span class="line">        current-&gt;next = reinterpret_cast&lt;Block*&gt;(reinterpret_cast&lt;unsigned char*&gt;(current) + BLOCK_SIZE);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    using value_type = T;</span><br><span class="line"></span><br><span class="line">// 构造函数：分配内存池并初始化空闲链表</span><br><span class="line">PoolAllocator() : pool_(new unsigned char[POOL_SIZE]), free_list_(nullptr), pool_size_(POOL_SIZE) &#123;</span><br><span class="line">    init_pool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 析构函数：释放内存池</span><br><span class="line">~PoolAllocator() &#123; delete[] pool_; &#125;</span><br><span class="line"></span><br><span class="line">// 从内存池分配单个块</span><br><span class="line">T* allocate(size_t n) &#123;</span><br><span class="line">    if (n != 1) throw std::bad_alloc(); // 仅支持单对象分配</span><br><span class="line">    if (!free_list_) throw std::bad_alloc(); // 内存池已耗尽</span><br><span class="line">    Block* block = free_list_;</span><br><span class="line">    free_list_ = free_list_-&gt;next;</span><br><span class="line">    return reinterpret_cast&lt;T*&gt;(block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将块归还到内存池</span><br><span class="line">void deallocate(T* p, size_t n) noexcept &#123;</span><br><span class="line">    if (n != 1) return;</span><br><span class="line">    Block* block = reinterpret_cast&lt;Block*&gt;(p);</span><br><span class="line">    block-&gt;next = free_list_;</span><br><span class="line">    free_list_ = block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 支持不同类型的重绑定</span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line">struct rebind &#123;</span><br><span class="line">    using other = PoolAllocator&lt;U&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 向量实现，支持自定义分配器</span><br><span class="line">template &lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;</span><br><span class="line">class MyVector &#123;</span><br><span class="line">private:</span><br><span class="line">    using AllocTraits = std::allocator_traits&lt;Alloc&gt;;</span><br><span class="line">    T* data_;         // 动态数组指针</span><br><span class="line">    size_t size_;     // 元素数量</span><br><span class="line">    size_t capacity_; // 当前容量</span><br><span class="line">    Alloc alloc_;     // 分配器实例</span><br><span class="line"></span><br><span class="line">// 重新分配到新容量，移动现有元素</span><br><span class="line">void reallocate(size_t new_capacity) &#123;</span><br><span class="line">    T* new_data = AllocTraits::allocate(alloc_, new_capacity);</span><br><span class="line">    for (size_t i = 0; i &lt; size_; ++i) &#123;</span><br><span class="line">        AllocTraits::construct(alloc_, new_data + i, std::move(data_[i]));</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + i);</span><br><span class="line">    &#125;</span><br><span class="line">    if (data_) AllocTraits::deallocate(alloc_, data_, capacity_);</span><br><span class="line">    data_ = new_data;</span><br><span class="line">    capacity_ = new_capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁指定范围内的元素</span><br><span class="line">void destroy_range(T* first, T* last) &#123;</span><br><span class="line">    while (first != last) &#123;</span><br><span class="line">        AllocTraits::destroy(alloc_, first);</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数：空向量</span><br><span class="line">    MyVector() : data_(nullptr), size_(0), capacity_(0), alloc_() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 初始化列表构造函数</span><br><span class="line">MyVector(std::initializer_list&lt;T&gt; init, const Alloc&amp; alloc = Alloc())</span><br><span class="line">    : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) &#123;</span><br><span class="line">    reserve(init.size());</span><br><span class="line">    for (const T&amp; value : init) &#123;</span><br><span class="line">        push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝构造函数</span><br><span class="line">MyVector(const MyVector&amp; other)</span><br><span class="line">    : data_(nullptr), size_(0), capacity_(0), alloc_(AllocTraits::select_on_container_copy_construction(other.alloc_)) &#123;</span><br><span class="line">    reserve(other.size_);</span><br><span class="line">    for (size_t i = 0; i &lt; other.size_; ++i) &#123;</span><br><span class="line">        push_back(other.data_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动构造函数</span><br><span class="line">MyVector(MyVector&amp;&amp; other) noexcept</span><br><span class="line">    : data_(other.data_), size_(other.size_), capacity_(other.capacity_), alloc_(std::move(other.alloc_)) &#123;</span><br><span class="line">    other.data_ = nullptr;</span><br><span class="line">    other.size_ = 0;</span><br><span class="line">    other.capacity_ = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 析构函数：清理元素和内存</span><br><span class="line">~MyVector() &#123;</span><br><span class="line">    destroy_range(data_, data_ + size_);</span><br><span class="line">    if (data_) AllocTraits::deallocate(alloc_, data_, capacity_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝赋值运算符</span><br><span class="line">MyVector&amp; operator=(const MyVector&amp; other) &#123;</span><br><span class="line">    if (this != &amp;other) &#123;</span><br><span class="line">        MyVector temp(other);</span><br><span class="line">        std::swap(data_, temp.data_);</span><br><span class="line">        std::swap(size_, temp.size_);</span><br><span class="line">        std::swap(capacity_, temp.capacity_);</span><br><span class="line">        std::swap(alloc_, temp.alloc_);</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动赋值运算符</span><br><span class="line">MyVector&amp; operator=(MyVector&amp;&amp; other) noexcept &#123;</span><br><span class="line">    if (this != &amp;other) &#123;</span><br><span class="line">        destroy_range(data_, data_ + size_);</span><br><span class="line">        if (data_) AllocTraits::deallocate(alloc_, data_, capacity_);</span><br><span class="line">        data_ = other.data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">        alloc_ = std::move(other.alloc_);</span><br><span class="line">        other.data_ = nullptr;</span><br><span class="line">        other.size_ = 0;</span><br><span class="line">        other.capacity_ = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素访问</span><br><span class="line">T&amp; operator[](size_t index) &#123; return data_[index]; &#125;</span><br><span class="line">const T&amp; operator[](size_t index) const &#123; return data_[index]; &#125;</span><br><span class="line"></span><br><span class="line">// 安全元素访问，带边界检查</span><br><span class="line">T&amp; at(size_t index) &#123;</span><br><span class="line">    if (index &gt;= size_) throw std::out_of_range(&quot;索引越界&quot;);</span><br><span class="line">    return data_[index];</span><br><span class="line">&#125;</span><br><span class="line">const T&amp; at(size_t index) const &#123;</span><br><span class="line">    if (index &gt;= size_) throw std::out_of_range(&quot;索引越界&quot;);</span><br><span class="line">    return data_[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 容量操作</span><br><span class="line">size_t size() const &#123; return size_; &#125;</span><br><span class="line">size_t capacity() const &#123; return capacity_; &#125;</span><br><span class="line">bool empty() const &#123; return size_ == 0; &#125;</span><br><span class="line"></span><br><span class="line">// 预留容量，必要时重新分配</span><br><span class="line">void reserve(size_t new_capacity) &#123;</span><br><span class="line">    if (new_capacity &gt; capacity_) &#123;</span><br><span class="line">        reallocate(new_capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整大小，添加默认元素或裁剪</span><br><span class="line">void resize(size_t new_size) &#123;</span><br><span class="line">    if (new_size &gt; size_) &#123;</span><br><span class="line">        reserve(new_size);</span><br><span class="line">        while (size_ &lt; new_size) &#123;</span><br><span class="line">            AllocTraits::construct(alloc_, data_ + size_, T());</span><br><span class="line">            ++size_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        destroy_range(data_ + new_size, data_ + size_);</span><br><span class="line">        size_ = new_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素操作</span><br><span class="line">// 在末尾追加元素</span><br><span class="line">void push_back(const T&amp; value) &#123;</span><br><span class="line">    if (size_ == capacity_) &#123;</span><br><span class="line">        reserve(capacity_ == 0 ? 1 : capacity_ * 2);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::construct(alloc_, data_ + size_, value);</span><br><span class="line">    ++size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾原地构造元素</span><br><span class="line">template &lt;typename... Args&gt;</span><br><span class="line">void emplace_back(Args&amp;&amp;... args) &#123;</span><br><span class="line">    if (size_ == capacity_) &#123;</span><br><span class="line">        reserve(capacity_ == 0 ? 1 : capacity_ * 2);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::construct(alloc_, data_ + size_, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    ++size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除最后一个元素</span><br><span class="line">void pop_back() &#123;</span><br><span class="line">    if (size_ &gt; 0) &#123;</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + size_ - 1);</span><br><span class="line">        --size_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入元素</span><br><span class="line">void insert(T* pos, const T&amp; value) &#123;</span><br><span class="line">    size_t index = pos - data_;</span><br><span class="line">    if (index &gt; size_) throw std::out_of_range(&quot;无效插入位置&quot;);</span><br><span class="line">    if (size_ == capacity_) &#123;</span><br><span class="line">        reserve(capacity_ == 0 ? 1 : capacity_ * 2);</span><br><span class="line">    &#125;</span><br><span class="line">    for (size_t i = size_; i &gt; index; --i) &#123;</span><br><span class="line">        AllocTraits::construct(alloc_, data_ + i, std::move(data_[i - 1]));</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::construct(alloc_, data_ + index, value);</span><br><span class="line">    ++size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素</span><br><span class="line">void erase(T* pos) &#123;</span><br><span class="line">    size_t index = pos - data_;</span><br><span class="line">    if (index &gt;= size_) throw std::out_of_range(&quot;无效删除位置&quot;);</span><br><span class="line">    for (size_t i = index; i &lt; size_ - 1; ++i) &#123;</span><br><span class="line">        AllocTraits::construct(alloc_, data_ + i, std::move(data_[i + 1]));</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::destroy(alloc_, data_ + size_ - 1);</span><br><span class="line">    --size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 迭代器</span><br><span class="line">T* begin() &#123; return data_; &#125;</span><br><span class="line">T* end() &#123; return data_ + size_; &#125;</span><br><span class="line">const T* begin() const &#123; return data_; &#125;</span><br><span class="line">const T* end() const &#123; return data_ + size_; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>以下是对上述 <code>my_vector.h</code> 实现的详细讲解，涵盖主要功能、设计思路和关键特性：</p>
<ol>
<li><p><strong>内存池分配器（<code>PoolAllocator</code>）</strong>：</p>
<ul>
<li><strong>目的</strong>：提供高效的内存分配，减少动态分配（如 <code>malloc</code>）的开销，适合资源受限环境。</li>
<li><strong>实现</strong>：<ul>
<li>使用固定大小的内存池（<code>POOL_SIZE</code>），通过空闲链表（<code>free_list_</code>）管理块。</li>
<li>每个块的大小为 <code>BLOCK_SIZE</code>，确保足够存储 <code>T</code> 或 <code>Block</code>（取较大者）。</li>
<li><code>allocate</code> 从空闲链表获取块，时间复杂度 ( O(1) )。</li>
<li><code>deallocate</code> 将块归还空闲链表，同样 ( O(1) )。</li>
</ul>
</li>
<li><strong>特性</strong>：<ul>
<li>仅支持单对象分配（<code>n == 1</code>），适合 <code>MyVector</code> 的连续内存需求。</li>
<li>通过 <code>rebind</code> 支持不同类型的分配，符合 C++ 分配器标准。</li>
<li>抛出 <code>std::bad_alloc</code> 处理内存耗尽，增强健壮性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>vector实现（<code>MyVector</code>）</strong>：</p>
<ul>
<li><strong>目的</strong>：模拟 <code>std::vector</code>，支持动态数组功能，同时兼容自定义分配器。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>构造与销毁</strong>：支持默认、初始化列表、拷贝、移动构造函数，以及析构函数，确保资源正确管理。</li>
<li><strong>元素访问</strong>：通过 <code>operator[]</code>（无边界检查）和 <code>at</code>（带边界检查）访问元素，<code>at</code> 抛出 <code>std::out_of_range</code>。</li>
<li><strong>容量管理</strong>：<ul>
<li><code>reserve</code> 预分配容量，<code>resize</code> 调整大小，必要时构造或销毁元素。</li>
<li>容量翻倍策略（<code>capacity_ * 2</code>）均摊 ( O(1) ) 插入复杂度。</li>
</ul>
</li>
<li><strong>元素操作</strong>：<ul>
<li><code>push_back</code>：追加元素，必要时扩展容量。</li>
<li><code>emplace_back</code>：原地构造元素，减少拷贝&#x2F;移动开销。</li>
<li><code>pop_back</code>：删除末尾元素。</li>
<li><code>insert</code>：在指定位置插入元素，移动后续元素，时间复杂度 ( O(n) )。</li>
<li><code>erase</code>：删除指定位置元素，移动后续元素，时间复杂度 ( O(n) )。</li>
</ul>
</li>
<li><strong>迭代器</strong>：提供简单的指针迭代器（<code>begin</code>、<code>end</code>），支持范围遍历。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异常安全</strong>：</p>
<ul>
<li><strong>强异常保证</strong>：<code>insert</code>、<code>erase</code>、<code>emplace_back</code> 在异常时保持对象一致性，通过移动操作和临时对象实现。</li>
<li><strong>基本异常保证</strong>：内存分配失败不破坏对象，析构函数正确清理。</li>
<li><code>at</code> 和 <code>insert</code>&#x2F;<code>erase</code> 的边界检查抛出 <code>std::out_of_range</code>，便于调试。</li>
</ul>
</li>
<li><p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>分配器抽象</strong>：通过 <code>AllocTraits</code> 支持 <code>std::allocator</code> 或 <code>PoolAllocator</code>，增强灵活性。</li>
<li><strong>移动语义</strong>：拷贝&#x2F;移动构造函数和赋值运算符优化性能，移动操作标记为 <code>noexcept</code>。</li>
<li><strong>内存效率</strong>：<code>PoolAllocator</code> 减少碎片，连续内存布局（<code>data_</code>）保持缓存友好性。</li>
<li><strong>简洁性</strong>：代码结构清晰，注释详细，易于维护和扩展。</li>
</ul>
</li>
<li><p><strong>局限性</strong>：</p>
<ul>
<li><code>PoolAllocator</code> 仅支持单对象分配，内存池大小固定（耗尽时抛异常）。</li>
<li><code>insert</code> 和 <code>erase</code> 时间复杂度为 ( O(n) )，不适合频繁中间操作。</li>
<li>迭代器仅为简单指针，未实现完整随机访问迭代器类。</li>
</ul>
</li>
<li><p><strong>扩展方向</strong>：</p>
<ul>
<li><strong>动态内存池</strong>：支持池扩展，适应更大内存需求。</li>
<li><strong>完整迭代器</strong>：实现 STL 兼容的随机访问迭代器，支持复杂算法。</li>
<li><strong>多对象分配</strong>：扩展 <code>PoolAllocator</code> 支持 <code>n</code> 个对象分配。</li>
<li><strong>性能优化</strong>：调整容量增长策略（如 <code>1.5</code> 倍）以减少内存浪费，或添加 <code>shrink_to_fit</code>。</li>
</ul>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyVector&lt;std::string, PoolAllocator&lt;std::string&gt;&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 原地构造</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 构造 &quot;aaaaa&quot;</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="string">&quot;World&quot;</span>); <span class="comment">// 插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: Hello World aaaaa</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 删除 World</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: Hello aaaaa</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        vec.<span class="built_in">at</span>(<span class="number">10</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/2024/10/09/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>米娜桑好久不见，国庆期间没有更新博客，属实有点摆烂</p>
<p>今天我们的主题是树与二叉树的转换，以及树的储存方法，遍历方法与二叉树的区别等</p>
<p>首先，我们要明白的是，树可以有多个子节点，而二叉树最多只有两个，所以二叉树是特殊的树</p>
<h1 id="一-树的存储与转换"><a href="#一-树的存储与转换" class="headerlink" title="一.树的存储与转换"></a>一.树的存储与转换</h1><h3 id="1-父亲表示法（双亲表示法）"><a href="#1-父亲表示法（双亲表示法）" class="headerlink" title="1.父亲表示法（双亲表示法）"></a>1.<strong>父亲表示法</strong>（双亲表示法）</h3><ul>
<li><p>使用一个数组来存储每个节点，其中每个节点只包含一个指针（或索引），指向其父节点。这种表示法的缺点是无法快速找到子节点，但优点是节省了存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    int parentIndex; // 指向父节点在数组中的索引</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-孩子链表表示法"><a href="#2-孩子链表表示法" class="headerlink" title="2.孩子链表表示法"></a>2.<strong>孩子链表表示法</strong></h3><ul>
<li><p>使用一个数组来存储每个节点，每个节点包含一个链表，链表中的每个节点指向该节点的子节点。这样，查找子节点的时间较快，但会增加空间开销。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 孩子链表中的节点</span><br><span class="line">struct ChildNode &#123;</span><br><span class="line">    int childIndex;        // 子节点的索引（或指针）</span><br><span class="line">    ChildNode* next;       // 指向下一个子节点的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 树的节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;              // 数据域，存储该节点的值</span><br><span class="line">    ChildNode* childList;  // 指向孩子链表的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（1）孩子链表表示法的特点"><a href="#（1）孩子链表表示法的特点" class="headerlink" title="（1）孩子链表表示法的特点"></a>（1）<strong>孩子链表表示法的特点</strong></h5><ol>
<li><strong>灵活性</strong>：<ul>
<li>每个节点的子节点数量不受限制，子节点数量可以动态扩展，因此这种表示法适合<strong>多叉树</strong>（即节点可以有多个子节点的树）。</li>
</ul>
</li>
<li><strong>存储空间</strong>：<ul>
<li>每个节点只存储一个指向其孩子链表的指针，而不是为所有可能的子节点预留空间，因此相比顺序存储更加节省空间，特别适合子节点数量较不确定的树结构。</li>
</ul>
</li>
<li><strong>节点操作</strong>：<ul>
<li><strong>插入节点</strong>：插入新子节点只需要在孩子链表的末尾添加一个节点，操作比较简单。</li>
<li><strong>删除节点</strong>：删除某个子节点时，只需要从孩子链表中移除相应的节点，但需要额外处理该子节点的所有子节点。</li>
<li><strong>查找子节点</strong>：查找某个节点的子节点时，需要遍历该节点的孩子链表，这可能导致查找子节点的效率较低。</li>
</ul>
</li>
</ol>
<h5 id="（2）孩子链表表示法的示例"><a href="#（2）孩子链表表示法的示例" class="headerlink" title="（2）孩子链表表示法的示例"></a>（2）<strong>孩子链表表示法的示例</strong></h5><p>假设有如下树结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line"> / | \</span><br><span class="line">2  3  4</span><br><span class="line">  / \</span><br><span class="line"> 5   6</span><br></pre></td></tr></table></figure>

<p>对应的孩子链表表示法如下：</p>
<ul>
<li>节点 1 的孩子链表指向节点 2、3 和 4。</li>
<li>节点 3 的孩子链表指向节点 5 和 6。</li>
</ul>
<p>图解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode(1) -&gt; ChildList -&gt; [TreeNode(2)] -&gt; [TreeNode(3)] -&gt; [TreeNode(4)] -&gt; NULL</span><br><span class="line">TreeNode(3) -&gt; ChildList -&gt; [TreeNode(5)] -&gt; [TreeNode(6)] -&gt; NULL</span><br></pre></td></tr></table></figure>

<p>对应的代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义孩子链表中的节点</span><br><span class="line">struct ChildNode &#123;</span><br><span class="line">    int childIndex;         // 孩子的索引或指针</span><br><span class="line">    ChildNode* next;        // 下一个孩子的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义树的节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;               // 节点的值</span><br><span class="line">    ChildNode* childList;   // 孩子链表的头指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 示例：创建节点和孩子链表</span><br><span class="line">TreeNode node1, node2, node3, node4, node5, node6;</span><br><span class="line">node1.data = 1;</span><br><span class="line">node2.data = 2;</span><br><span class="line">node3.data = 3;</span><br><span class="line">node4.data = 4;</span><br><span class="line">node5.data = 5;</span><br><span class="line">node6.data = 6;</span><br><span class="line"></span><br><span class="line">// 为节点1创建孩子链表</span><br><span class="line">ChildNode* child1 = new ChildNode&#123;2, NULL&#125;;  // 指向节点2</span><br><span class="line">ChildNode* child2 = new ChildNode&#123;3, NULL&#125;;  // 指向节点3</span><br><span class="line">ChildNode* child3 = new ChildNode&#123;4, NULL&#125;;  // 指向节点4</span><br><span class="line"></span><br><span class="line">child1-&gt;next = child2;</span><br><span class="line">child2-&gt;next = child3;</span><br><span class="line">node1.childList = child1;  // 节点1的孩子链表</span><br><span class="line"></span><br><span class="line">// 为节点3创建孩子链表</span><br><span class="line">ChildNode* child5 = new ChildNode&#123;5, NULL&#125;;  // 指向节点5</span><br><span class="line">ChildNode* child6 = new ChildNode&#123;6, NULL&#125;;  // 指向节点6</span><br><span class="line">child5-&gt;next = child6;</span><br><span class="line">node3.childList = child5;  // 节点3的孩子链表</span><br></pre></td></tr></table></figure>

<h3 id="3-孩子兄弟表示法"><a href="#3-孩子兄弟表示法" class="headerlink" title="3.孩子兄弟表示法"></a>3.孩子兄弟表示法</h3><p>在树结构中，<strong>孩子</strong>和<strong>兄弟</strong>是指节点之间的一种关系：</p>
<h5 id="孩子（Child）："><a href="#孩子（Child）：" class="headerlink" title="孩子（Child）："></a><strong>孩子（Child）</strong>：</h5><ul>
<li><strong>孩子节点</strong>是指某个节点的直接下级节点。</li>
<li>如果一个节点有若干子节点，这些子节点就是它的孩子。</li>
<li>每个树节点可以有0个、1个或多个孩子。</li>
</ul>
<h5 id="兄弟（Sibling）："><a href="#兄弟（Sibling）：" class="headerlink" title="兄弟（Sibling）："></a><strong>兄弟（Sibling）</strong>：</h5><ul>
<li><strong>兄弟节点</strong>是指同一个父节点的多个子节点之间的关系。</li>
<li>如果两个或多个节点有相同的父节点，这些节点互为兄弟。</li>
</ul>
<h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>孩子兄弟表示法，是以左孩子的形式存储最左边的孩子，以右孩子的形式存储第一个右兄弟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义多叉树节点结构</span><br><span class="line">struct MultiTreeNode &#123;</span><br><span class="line">    int data;                    // 数据域</span><br><span class="line">    vector&lt;MultiTreeNode*&gt; children; // 子节点列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义二叉树节点结构</span><br><span class="line">struct BinaryTreeNode &#123;</span><br><span class="line">    int data;                    // 数据域</span><br><span class="line">    BinaryTreeNode* left;        // 左子节点，表示第一个子节点</span><br><span class="line">    BinaryTreeNode* right;       // 右子节点，表示兄弟节点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这样的形式将树以二叉树的形式存储了起来，进而实现了树向二叉树的转换</p>
<h4 id="转换步骤："><a href="#转换步骤：" class="headerlink" title="转换步骤："></a><strong>转换步骤</strong>：</h4><ol>
<li><strong>保持第一个子节点为左孩子</strong>：<ul>
<li>在多叉树中，某个节点的第一个子节点转换为二叉树中的左孩子。</li>
</ul>
</li>
<li><strong>其他子节点变为右兄弟</strong>：<ul>
<li>在多叉树中，该节点的第二个及以后的子节点依次作为第一个子节点的右兄弟节点。</li>
</ul>
</li>
<li><strong>兄弟之间的关系通过右子节点表示</strong>：<ul>
<li>在二叉树中，右子节点用来表示多叉树中的兄弟节点。</li>
</ul>
</li>
</ol>
<h4 id="转换示意图"><a href="#转换示意图" class="headerlink" title="转换示意图"></a><strong>转换示意图</strong></h4><p>假设有如下的多叉树结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     A</span><br><span class="line">   / | \</span><br><span class="line">  B  C  D</span><br><span class="line"> / \</span><br><span class="line">E   F</span><br></pre></td></tr></table></figure>

<p>转换成二叉树的步骤如下：</p>
<ol>
<li>节点 <code>A</code> 的第一个子节点 <code>B</code> 作为 <code>A</code> 的左孩子，<code>C</code> 和 <code>D</code> 作为 <code>B</code> 的右兄弟。</li>
<li>节点 <code>B</code> 的第一个子节点 <code>E</code> 作为 <code>B</code> 的左孩子，<code>F</code> 作为 <code>E</code> 的右兄弟。</li>
</ol>
<p>转换成二叉树后的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    A</span><br><span class="line">   /</span><br><span class="line">  B</span><br><span class="line"> / \</span><br><span class="line">E   C</span><br><span class="line"> \   \</span><br><span class="line">  F   D</span><br></pre></td></tr></table></figure>

<p>可以看到，在转换后的二叉树中：</p>
<ul>
<li><p>原来多叉树中节点 <code>A</code> 的子节点 <code>B、C、D</code> 被通过左孩子和右兄弟关系串联在一起。</p>
</li>
<li><p>原来节点 <code>B</code> 的子节点 <code>E、F</code> 也通过相同的方式连接。</p>
<p>  &#x2F;&#x2F; 多叉树转二叉树的递归转换函数<br>  BinaryTreeNode* convertToBinaryTree(MultiTreeNode* root)<br>  {<br>  if (root &#x3D;&#x3D; nullptr) return nullptr;<br>  &#x2F;&#x2F; 创建对应的二叉树节点<br>  BinaryTreeNode* newNode &#x3D; new BinaryTreeNode();<br>  newNode-&gt;data &#x3D; root-&gt;data;<br>  newNode-&gt;left &#x3D; nullptr;<br>  newNode-&gt;right &#x3D; nullptr;</p>
<p>  if (!root-&gt;children.empty())<br>  {<br>  &#x2F;&#x2F; 将第一个孩子作为左子树<br>  newNode-&gt;left &#x3D; convertToBinaryTree(root-&gt;children[0]);<br><br>  &#x2F;&#x2F; 将其他孩子作为兄弟通过右子树连接<br>  BinaryTreeNode* current &#x3D; newNode-&gt;left;<br>  for (size_t i &#x3D; 1; i &lt; root-&gt;children.size(); ++i)<br>  {<br>      current-&gt;right &#x3D; convertToBinaryTree(root-&gt;children[i]);<br>      current &#x3D; current-&gt;right;<br>  }<br>  }</p>
<p>  return newNode;<br>  }</p>
</li>
</ul>
<h3 id="4-森林与二叉树的转换"><a href="#4-森林与二叉树的转换" class="headerlink" title="4.森林与二叉树的转换"></a>4.森林与二叉树的转换</h3><p>将森林中的每棵树都转换成二叉树</p>
<p>然后从第二棵树开始，每棵树的根节点都是前一棵树的根节点的兄弟</p>
<h1 id="二-树和森林的遍历"><a href="#二-树和森林的遍历" class="headerlink" title="二.树和森林的遍历"></a>二.树和森林的遍历</h1><h3 id="1-树的遍历"><a href="#1-树的遍历" class="headerlink" title="1.树的遍历"></a>1.树的遍历</h3><p>树的前序遍历和其转换成的二叉树的前序遍历相同</p>
<p>树的后序遍历与其转换成的二叉树的中序遍历相同</p>
<h5 id="树的中序遍历"><a href="#树的中序遍历" class="headerlink" title="树的中序遍历"></a>树的中序遍历</h5><p>中序遍历树最左边的孩子，访问根节点，再依次访问中序遍历其他孩子</p>
<h3 id="2-森林的遍历：依次遍历每棵树"><a href="#2-森林的遍历：依次遍历每棵树" class="headerlink" title="2.森林的遍历：依次遍历每棵树"></a>2.森林的遍历：依次遍历每棵树</h3>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>树</tag>
        <tag>链表</tag>
        <tag>森林</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2025/01/12/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="模板（Template）概述"><a href="#模板（Template）概述" class="headerlink" title="模板（Template）概述"></a><strong>模板（Template）概述</strong></h3><p>模板是 C++ 中的一种<strong>泛型编程机制</strong>，允许编写通用的代码，可以在不指定具体数据类型的情况下定义函数、类或结构体。模板的主要目的是提供代码的复用性和灵活性，从而支持处理多种数据类型的能力。</p>
<p>C++ 中的模板主要分为两种：</p>
<ol>
<li><strong>函数模板</strong>（Function Template）</li>
<li><strong>类模板</strong>（Class Template）</li>
</ol>
<hr>
<h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a><strong>1. 函数模板</strong></h2><p>函数模板是定义一个可以操作多种数据类型的函数。通过模板，函数可以在调用时根据传递的参数类型自动生成具体的函数。</p>
<h3 id="1-1-函数模板的基本语法"><a href="#1-1-函数模板的基本语法" class="headerlink" title="1.1 函数模板的基本语法"></a><strong>1.1 函数模板的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;    <span class="comment">// 显式指定类型为 int</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">4.2</span>) &lt;&lt; endl;    <span class="comment">// 隐式推导类型为 double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">7.7</span><br></pre></td></tr></table></figure>

<h3 id="1-2-关键点"><a href="#1-2-关键点" class="headerlink" title="1.2 关键点"></a><strong>1.2 关键点</strong></h3><ul>
<li><code>template &lt;typename T&gt;</code>：定义模板，其中 <code>T</code> 是占位符，表示数据类型。<ul>
<li>也可以使用 <code>class</code> 代替 <code>typename</code>（两者在模板声明中等价）。</li>
</ul>
</li>
<li>模板函数的具体类型可以<strong>显式指定</strong>（如 <code>add&lt;int&gt;(3, 4)</code>），也可以通过参数<strong>隐式推导</strong>（如 <code>add(3.5, 4.2)</code>）。</li>
</ul>
<hr>
<h3 id="1-3-函数模板的特例化"><a href="#1-3-函数模板的特例化" class="headerlink" title="1.3 函数模板的特例化"></a><strong>1.3 函数模板的特例化</strong></h3><p>有时我们希望对某些特定类型提供专门的实现，可以通过模板特例化实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例化版本（针对 const char* 类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="built_in">max</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>) ? a : b; <span class="comment">// 字符串比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;             <span class="comment">// 输出 7</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>) &lt;&lt; endl; <span class="comment">// 输出 banana</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>特例化版本定义了针对 <code>const char*</code> 类型的专门实现。</li>
<li>当模板匹配到 <code>const char*</code> 类型时，会优先使用特例化版本。</li>
</ul>
<hr>
<h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2. 类模板"></a><strong>2. 类模板</strong></h2><p>类模板是为实现通用的类而设计的，允许类操作不同类型的数据而不需要重复编写代码。</p>
<h3 id="2-1-类模板的基本语法"><a href="#2-1-类模板的基本语法" class="headerlink" title="2.1 类模板的基本语法"></a><strong>2.1 类模板的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;      <span class="comment">// int 类型</span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Value: 10</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Value: 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>template &lt;typename T&gt;</code> 定义了一个类模板。</li>
<li>模板类实例化时，需要为模板参数 <code>T</code> 提供具体类型，如 <code>MyClass&lt;int&gt;</code>。</li>
</ul>
<hr>
<h3 id="2-2-类模板的特例化"><a href="#2-2-类模板的特例化" class="headerlink" title="2.2 类模板的特例化"></a><strong>2.2 类模板的特例化</strong></h3><p>和函数模板一样，类模板也可以为某些特定类型提供特例化实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Generic template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例化版本（针对 int 类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Specialized template for int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj1; <span class="comment">// 使用通用模板</span></span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj2;    <span class="comment">// 使用特例化模板</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Generic template</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Specialized template for int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>通用模板适用于所有类型，但当实例化类型为 <code>int</code> 时，会使用特例化版本。</li>
</ul>
<hr>
<h3 id="2-3-类模板的部分特例化"><a href="#2-3-类模板的部分特例化" class="headerlink" title="2.3 类模板的部分特例化"></a><strong>2.3 类模板的部分特例化</strong></h3><p>类模板还支持<strong>部分特例化</strong>，即只对部分模板参数进行特例化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Generic template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化（当第二个类型参数是 int 时）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Partial specialization for second type int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">double</span>&gt; obj1; <span class="comment">// 通用模板</span></span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">int</span>&gt; obj2;   <span class="comment">// 部分特例化模板</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Generic template</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Partial specialization for second type int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>部分特例化可以只针对某些类型参数组合，提供更灵活的设计。</li>
</ul>
<hr>
<h2 id="3-模板的其他用法"><a href="#3-模板的其他用法" class="headerlink" title="3. 模板的其他用法"></a><strong>3. 模板的其他用法</strong></h2><h3 id="3-1-模板默认参数"><a href="#3-1-模板默认参数" class="headerlink" title="3.1 模板默认参数"></a><strong>3.1 模板默认参数</strong></h3><p>模板参数可以提供默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">display</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;&gt; obj;       <span class="comment">// 使用默认类型 int</span></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2; <span class="comment">// 显式指定类型为 double</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">display</span>();  <span class="comment">// 输出 Type: int</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Type: double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-模板模板参数"><a href="#3-2-模板模板参数" class="headerlink" title="3.2 模板模板参数"></a><strong>3.2 模板模板参数</strong></h3><p>模板参数本身可以是模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : c) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;vector&gt; obj; <span class="comment">// 使用 vector 作为模板模板参数</span></span><br><span class="line">    obj.<span class="built_in">display</span>();       <span class="comment">// 输出 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>template &lt;template &lt;typename, typename&gt; class Container&gt;</code> 定义了模板模板参数。</li>
<li>实例化时，<code>vector</code> 作为模板模板参数被传递。</li>
</ul>
<hr>
<h2 id="4-编译期计算与模板"><a href="#4-编译期计算与模板" class="headerlink" title="4. 编译期计算与模板"></a><strong>4. 编译期计算与模板</strong></h2><p>模板可以用于<strong>编译期计算</strong>，例如实现递归的斐波那契数列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; endl; <span class="comment">// 输出 55</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>模板通过递归定义实现了编译期的斐波那契数列计算。</li>
<li><code>Fibonacci&lt;10&gt;</code> 会在编译时计算出结果。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>模板是 C++ 强大的泛型编程工具，其主要特点包括：</p>
<ol>
<li><strong>函数模板</strong> 和 <strong>类模板</strong>。</li>
<li>支持特例化（全特例化和部分特例化）。</li>
<li>提供了编译期计算能力。</li>
<li>与 STL 紧密结合，广泛用于算法和容器中。</li>
</ol>
<p>模板大大提高了代码的复用性和通用性，但模板的编译错误通常比较复杂，因此需要小心使用。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>移动语义的方方面面</title>
    <url>/2025/05/11/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</url>
    <content><![CDATA[<p>主播刚刚考完计算机组成原理哈，然后浅浅荒废了几天的时间，leetcode也没刷，八股也没看，不过计算机组成原理终究是过了，姑且算对计算机有了更深入的一点点了解，过几天的信号与系统和电动力学才是折磨。</p>
<p>碎碎念结束。</p>
<p>————————————————————————————————————————————————————————————</p>
<p>c++11中引入了一个经常见到的函数，std::move，初次见面是在unique_ptr那一节中，后来在移动构造函数中也有见面，它的作用可以简单的理解为实现将左值转换为右值。</p>
<p>那么我们首先介绍一下什么是左值和右值。</p>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>左值，可以理解为有内存地址的值，与之相对，右值就是没有内存地址的值。</p>
<p>从硬件上说，左值由内存存储，右值由寄存器存储，所以右值就是马上就要消亡的值，生命周期一般只有所在的那一行代码</p>
<p>常见的右值形式包括：</p>
<p>1.int x &#x3D; 5;里面的5等常量</p>
<p>2.调用函数的返回值</p>
<p>3.算术表达式或者逻辑表达式</p>
<p>而左值就是我们常说的变量及所有可以被左赋值的值</p>
<p>从而我们得到了左值引用和右值引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">int &amp;x=a;//左值引用</span><br><span class="line">int &amp;&amp;b=2;//右值引用</span><br></pre></td></tr></table></figure>

<p>而左值引用和右值引用又可以用同一种方式表示，即万能引用</p>
<p>有两种形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void fun(T &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">//这里就是万能引用</span><br><span class="line">&#125;</span><br><span class="line">auto &amp;&amp;ref=x;</span><br><span class="line">auto &amp;&amp;ref1=5;//这是另一种万能引用的表现方式，这里ref被自动推导为左值引用，ref1被自动引用为右值引用</span><br><span class="line">fun(x);</span><br><span class="line">fun(5);</span><br><span class="line">fun(ref);</span><br><span class="line">fun(ref1);//四种情况中万能引用被推导为左值，右值，左值，右值引用</span><br></pre></td></tr></table></figure>

<p>这里左值和右值的引用相遇，具体的结果有一个规则，即折叠引用，可以理解为两者都右值才右值，否则有一个左值，就被推导为左值</p>
<h4 id="右值引用！-万能引用"><a href="#右值引用！-万能引用" class="headerlink" title="右值引用！&#x3D;万能引用"></a>右值引用！&#x3D;万能引用</h4><p>右值引用是已经确定的，只能传入右值的，而万能引用由模板和auto实现，本质是不确定的</p>
<h1 id="为什么要移动语义"><a href="#为什么要移动语义" class="headerlink" title="为什么要移动语义"></a>为什么要移动语义</h1><p>前菜讲完，接下来是移动语义</p>
<p>在常见的类的赋值中，我们常常调用拷贝构造函数，而其底层是深拷贝，是需要在堆上申请空间new的，这样的空间开销是非常大的，特别是在占用空间特别大的类当中，除了这个还有两个原因</p>
<ol>
<li><strong>性能开销大：</strong> 深拷贝涉及到内存分配（可能很慢）和大量数据的复制。对于包含大量数据的对象（如 <code>std::vector</code>, <code>std::string</code>），这会非常耗时。</li>
<li><strong>资源浪费：</strong> 在很多情况下，我们复制一个对象仅仅是为了临时使用，或者原对象在复制后很快就会被销毁。例如，函数返回一个大对象时，会创建一个临时对象，然后将这个临时对象拷贝到接收变量中。这个临时对象马上就没用了，但我们却花费了昂贵的代价去复制它的内容。</li>
<li><strong>无法处理独占资源：</strong> 有些资源是不能被复制的，比如文件句柄、互斥锁（mutex）、智能指针 <code>std::unique_ptr</code> 等。这些资源通常是独占的。如果一个类管理着这样的独占资源，那么它的拷贝构造函数和拷贝赋值运算符就无法实现（或者被显式删除），导致这类对象无法进行正常的复制操作，限制了它们的使用场景（比如不能作为函数返回值，不能放入需要复制的标准容器）。</li>
</ol>
<p>于是为了提高效率，处理独占资源，避免不必要的拷贝，我们采用了移动语义</p>
<p>举一个移动语义的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class S</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	char[5] student;</span><br><span class="line">	S(const S&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">    	size=new char[5];</span><br><span class="line">    	for(int i=0;i&lt;5;++i)</span><br><span class="line">    	&#123;</span><br><span class="line">    		student[i]=other.student[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;//拷贝构造函数</span><br><span class="line">    S(S&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">    	student=other.student;</span><br><span class="line">    	other.student=nullptr;</span><br><span class="line">    &#125;//移动构造函数</span><br><span class="line">    </span><br><span class="line">    ~S()</span><br><span class="line">    &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的移动构造函数类似浅拷贝，参数要是右值，可以是真正的右值，也可以是move实现的左值转换成的右值</p>
<p><strong>需要移动语义的典型场景：</strong></p>
<ul>
<li><p>函数返回大对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">createLargeVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">1000000</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    <span class="keyword">return</span> vec; <span class="comment">// C++11 后，这里通常会发生移动而不是拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVec = <span class="built_in">createLargeVector</span>(); <span class="comment">// 接收返回值时，使用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>在没有移动语义之前，返回 vec会创建一个临时std::vector对象，并将vec的所有元素拷贝到这个临时对象中，然后将这个临时对象拷贝到myVec中（如果 RVO&#x2F;NRVO 不起作用的话）。有了移动语义，vec的资源可以直接转移给临时对象，再从临时对象转移给myVec</p>
<p>，避免了两次昂贵的拷贝。</p>
</li>
<li><p>将对象放入容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names;</span><br><span class="line">std::string s = <span class="string">&quot;very long string...&quot;</span>;</span><br><span class="line">names.<span class="built_in">push_back</span>(s); <span class="comment">// 拷贝</span></span><br><span class="line">names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// 移动，s 的内容被转移，s 变为空或有效但未指定状态</span></span><br><span class="line">names.<span class="built_in">push_back</span>(<span class="string">&quot;another long string...&quot;</span>); <span class="comment">// 临时右值，移动</span></span><br></pre></td></tr></table></figure>

<p>当std::vector需要扩容时，它会分配新的内存并将现有元素转移到新位置。有了移动语义，这个转移过程是移动操作，而不是拷贝操作，大大提高了性能。</p>
</li>
<li><p>对象交换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">std::<span class="built_in">swap</span>(v1, v2); <span class="comment">// std::swap 的高效实现依赖于移动语义</span></span><br></pre></td></tr></table></figure>

<p>std::swap 的标准实现通常是：通过三次移动操作实现高效交换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp = std::move(a); a = std::move(b); b = std::move(temp);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>移动语义</tag>
        <tag>右值引用</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树及其遍历</title>
    <url>/2024/09/25/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h1><h3 id="以下是实现该结构并进行中序遍历的代码："><a href="#以下是实现该结构并进行中序遍历的代码：" class="headerlink" title="以下是实现该结构并进行中序遍历的代码："></a>以下是实现该结构并进行中序遍历的代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线索二叉树节点的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;                      <span class="comment">// 节点的值</span></span><br><span class="line">    ThreadedNode* left;             <span class="comment">// 指向左子节点</span></span><br><span class="line">    ThreadedNode* right;            <span class="comment">// 指向右子节点</span></span><br><span class="line">    <span class="type">bool</span> lThread;                   <span class="comment">// 左指针是否为线索</span></span><br><span class="line">    <span class="type">bool</span> rThread;                   <span class="comment">// 右指针是否为线索</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化节点值，并将左右指针初始化为空，线索标志初始化为 false</span></span><br><span class="line">    <span class="built_in">ThreadedNode</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">lThread</span>(<span class="literal">false</span>), <span class="built_in">rThread</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点并构建线索二叉树的函数</span></span><br><span class="line"><span class="function">ThreadedNode* <span class="title">insert</span><span class="params">(ThreadedNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新节点</span></span><br><span class="line">    ThreadedNode* newNode = <span class="keyword">new</span> <span class="built_in">ThreadedNode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树为空，直接返回新节点作为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `current` 用于跟踪当前节点，`parent` 用于跟踪当前节点的父节点</span></span><br><span class="line">    ThreadedNode* current = root;</span><br><span class="line">    ThreadedNode* parent = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要插入的位置</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        parent = current;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入左子树</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; current-&gt;value) &#123;</span><br><span class="line">            <span class="comment">// 如果左指针不是线索，继续向左子树移动</span></span><br><span class="line">            <span class="keyword">if</span> (!current-&gt;lThread)</span><br><span class="line">                current = current-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 遇到线索停止</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 插入右子树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果右指针不是线索，继续向右子树移动</span></span><br><span class="line">            <span class="keyword">if</span> (!current-&gt;rThread)</span><br><span class="line">                current = current-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 遇到线索停止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据值的大小决定插入到左子树还是右子树</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; parent-&gt;value) &#123;</span><br><span class="line">        <span class="comment">// 左子树插入</span></span><br><span class="line">        newNode-&gt;left = parent-&gt;left;  <span class="comment">// 新节点的左指针指向父节点的左指针</span></span><br><span class="line">        newNode-&gt;right = parent;       <span class="comment">// 新节点的右指针指向父节点</span></span><br><span class="line">        parent-&gt;lThread = <span class="literal">false</span>;       <span class="comment">// 插入后，父节点的左指针不再是线索</span></span><br><span class="line">        parent-&gt;left = newNode;        <span class="comment">// 父节点的左子树变为新节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 右子树插入</span></span><br><span class="line">        newNode-&gt;right = parent-&gt;right; <span class="comment">// 新节点的右指针指向父节点的右指针</span></span><br><span class="line">        newNode-&gt;left = parent;         <span class="comment">// 新节点的左指针指向父节点</span></span><br><span class="line">        parent-&gt;rThread = <span class="literal">false</span>;        <span class="comment">// 插入后，父节点的右指针不再是线索</span></span><br><span class="line">        parent-&gt;right = newNode;        <span class="comment">// 父节点的右子树变为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到中序遍历的起点（即最左边的节点）</span></span><br><span class="line"><span class="function">ThreadedNode* <span class="title">leftmost</span><span class="params">(ThreadedNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 一直移动到没有左子节点的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!node-&gt;lThread) </span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线索化二叉树的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraversal</span><span class="params">(ThreadedNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最左边的节点开始</span></span><br><span class="line">    ThreadedNode* current = <span class="built_in">leftmost</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个树</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出当前节点的值</span></span><br><span class="line">        cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点的右指针是线索，直接跳到下一个中序节点</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;rThread)</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则找到当前节点右子树中的最左节点</span></span><br><span class="line">            current = <span class="built_in">leftmost</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadedNode* root = <span class="literal">nullptr</span>;  <span class="comment">// 创建一个空的线索二叉树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点，构建线索二叉树</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">5</span>);  <span class="comment">// 插入根节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">3</span>);  <span class="comment">// 插入左子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">8</span>);  <span class="comment">// 插入右子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">2</span>);  <span class="comment">// 插入左子树中的左子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">4</span>);  <span class="comment">// 插入左子树中的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化后的中序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrderTraversal</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a>代码说明：</h3><ol>
<li><p><strong>树的结构</strong>：</p>
<ul>
<li>我们插入节点顺序为 <code>5, 3, 8, 2, 4</code>，构造如下的树：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>中序遍历顺序</strong>：</p>
<ul>
<li>中序遍历的顺序是：<strong>先访问左子树，再访问根节点，最后访问右子树</strong>.</li>
<li>对于这棵树的中序遍历顺序是：<code>2 3 4 5 8</code>.</li>
</ul>
</li>
<li><p><strong>关键函数</strong>：</p>
<ul>
<li><code>insert</code>：在二叉树中插入节点，同时维护线索化指针.</li>
<li><code>leftmost</code>：寻找中序遍历中最左边的节点，作为遍历起点.</li>
<li><code>inOrderTraversal</code>：通过线索化指针进行中序遍历.</li>
</ul>
</li>
</ol>
<h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><p>运行此代码，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中序遍历: 2 3 4 5 8</span><br></pre></td></tr></table></figure>

<h1 id="线索化二叉树解释："><a href="#线索化二叉树解释：" class="headerlink" title="线索化二叉树解释："></a>线索化二叉树解释：</h1><h3 id="1-初始状态："><a href="#1-初始状态：" class="headerlink" title="1. 初始状态："></a>1. <strong>初始状态</strong>：</h3><p>我们创建了一个空的线索二叉树 <code>root</code>，即 <code>root = nullptr</code>.</p>
<h3 id="2-插入节点-5："><a href="#2-插入节点-5：" class="headerlink" title="2. 插入节点 5："></a>2. <strong>插入节点 5</strong>：</h3><ul>
<li>调用 <code>insert(root, 5)</code>.</li>
<li>因为 <code>root</code> 是 <code>nullptr</code>，直接返回新节点 <code>5</code> 作为根节点.此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></li>
<li><code>5</code> 没有子节点，也没有线索.</li>
</ul>
<h3 id="3-插入节点-3："><a href="#3-插入节点-3：" class="headerlink" title="3. 插入节点 3："></a>3. <strong>插入节点 3</strong>：</h3><ul>
<li>调用 <code>insert(root, 3)</code>，即在节点 <code>5</code> 的基础上插入.</li>
<li><code>3 &lt; 5</code>，因此我们将其插入到 <code>5</code> 的左子树中.</li>
<li>节点 <code>3</code> 的右指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  5 (线索)</span><br></pre></td></tr></table></figure></li>
<li><code>5</code> 的左指针不再是线索，它现在有一个真正的左子树（节点 <code>3</code>）.</li>
</ul>
<h3 id="4-插入节点-8："><a href="#4-插入节点-8：" class="headerlink" title="4. 插入节点 8："></a>4. <strong>插入节点 8</strong>：</h3><ul>
<li>调用 <code>insert(root, 8)</code>，即在当前树结构上插入.</li>
<li><code>8 &gt; 5</code>，因此我们将其插入到节点 <code>5</code> 的右子树中.</li>
<li>节点 <code>8</code> 的左指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">3   8</span><br><span class="line"> \</span><br><span class="line">  5 (线索)</span><br><span class="line">  8 (线索)</span><br></pre></td></tr></table></figure></li>
<li>节点 <code>5</code> 的右指针现在指向真正的右子树（节点 <code>8</code>）.</li>
</ul>
<h3 id="5-插入节点-2："><a href="#5-插入节点-2：" class="headerlink" title="5. 插入节点 2："></a>5. <strong>插入节点 2</strong>：</h3><ul>
<li>调用 <code>insert(root, 2)</code>，即在当前树结构上插入.</li>
<li><code>2 &lt; 5</code>，继续向左走，<code>2 &lt; 3</code>，因此我们将其插入到节点 <code>3</code> 的左子树中.</li>
<li>节点 <code>2</code> 的右指针作为线索指向节点 <code>3</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   5 (线索)</span><br><span class="line"> \</span><br><span class="line">  3 (线索)</span><br></pre></td></tr></table></figure></li>
<li>节点 <code>3</code> 的左指针不再是线索，它现在有一个真正的左子树（节点 <code>2</code>）.</li>
</ul>
<h3 id="6-插入节点-4："><a href="#6-插入节点-4：" class="headerlink" title="6. 插入节点 4："></a>6. <strong>插入节点 4</strong>：</h3><ul>
<li>调用 <code>insert(root, 4)</code>，即在当前树结构上插入.</li>
<li><code>4 &lt; 5</code>，继续向左走，<code>4 &gt; 3</code>，因此我们将其插入到节点 <code>3</code> 的右子树中.</li>
<li>节点 <code>4</code> 的右指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br><span class="line">\	 \</span><br><span class="line">3(线) 5 (线索)</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-树的最终结构："><a href="#7-树的最终结构：" class="headerlink" title="7. 树的最终结构："></a>7. <strong>树的最终结构</strong>：</h3><p>经过上述插入操作，最终树的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br></pre></td></tr></table></figure>

<ul>
<li>左子树是：<code>3 -&gt; 2, 3 -&gt; 4</code>，并且线索指向相应的节点.</li>
</ul>
<h3 id="8-中序遍历过程："><a href="#8-中序遍历过程：" class="headerlink" title="8. 中序遍历过程："></a>8. <strong>中序遍历过程</strong>：</h3><h4 id="步骤-1：找到最左边的节点"><a href="#步骤-1：找到最左边的节点" class="headerlink" title="步骤 1：找到最左边的节点"></a>步骤 1：找到最左边的节点</h4><ul>
<li>调用 <code>leftmost(root)</code>，找到树中最左边的节点，即 <code>2</code>.</li>
</ul>
<h4 id="步骤-2：遍历中序节点"><a href="#步骤-2：遍历中序节点" class="headerlink" title="步骤 2：遍历中序节点"></a>步骤 2：遍历中序节点</h4><ul>
<li>当前节点是 <code>2</code>，输出 <code>2</code>，然后查看 <code>2</code> 的右指针，发现它是线索指向节点 <code>3</code>，因此移动到节点 <code>3</code>.</li>
<li>当前节点是 <code>3</code>，输出 <code>3</code>，然后查看 <code>3</code> 的右指针，发现它指向节点 <code>4</code>，移动到节点 <code>4</code>.</li>
<li>当前节点是 <code>4</code>，输出 <code>4</code>，然后查看 <code>4</code> 的右指针，发现它是线索，指向节点 <code>5</code>，移动到节点 <code>5</code>.</li>
<li>当前节点是 <code>5</code>，输出 <code>5</code>，然后查看 <code>5</code> 的右指针，指向真正的右子树，找到最左边的节点 <code>8</code>.</li>
<li>当前节点是 <code>8</code>，输出 <code>8</code>，然后它没有右子树或线索，遍历结束.</li>
</ul>
<h3 id="9-中序遍历输出："><a href="#9-中序遍历输出：" class="headerlink" title="9. 中序遍历输出："></a>9. <strong>中序遍历输出</strong>：</h3><p>最终中序遍历输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 5 8</span><br></pre></td></tr></table></figure>

<p>这就是整个代码的运行过程和中序遍历结果.</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>赫夫曼树与赫夫曼编码</title>
    <url>/2024/10/09/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h3 id="1-哈夫曼树（Huffman-Tree）："><a href="#1-哈夫曼树（Huffman-Tree）：" class="headerlink" title="1. 哈夫曼树（Huffman Tree）："></a>1. <strong>哈夫曼树（Huffman Tree）</strong>：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>哈夫曼树是一种带权路径长度最短的二叉树，通常用于<strong>数据压缩</strong>。</p>
<h3 id="它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。"><a href="#它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。" class="headerlink" title="它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。"></a>它的“最优”体现在<strong>权重大的节点离根节点更近</strong>，从而使加权路径长度最小。</h3><h4 id="构造过程："><a href="#构造过程：" class="headerlink" title="构造过程："></a>构造过程：</h4><p>哈夫曼树的构建基于贪心算法，步骤如下：</p>
<ol>
<li>将给定的所有权值看作是森林中的单节点树。</li>
<li>每次选择两个权值最小的节点进行合并，构成一个新的父节点，其权值为两个子节点的权值之和。</li>
<li>重复上述过程，直到所有节点合并成一棵二叉树。</li>
</ol>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul>
<li><strong>数据压缩</strong>：哈夫曼树用于<strong>哈夫曼编码</strong>，它通过为高频率字符分配较短的编码，低频率字符分配较长的编码，达到压缩数据的目的。</li>
</ul>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>假设我们有字符集和对应的权值（频率）如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>频率</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>5</td>
</tr>
<tr>
<td>B</td>
<td>9</td>
</tr>
<tr>
<td>C</td>
<td>12</td>
</tr>
<tr>
<td>D</td>
<td>13</td>
</tr>
<tr>
<td>E</td>
<td>16</td>
</tr>
<tr>
<td>F</td>
<td>45</td>
</tr>
</tbody></table>
<p>构建哈夫曼树的过程如下：</p>
<ol>
<li>选择频率最小的 <code>A(5)</code> 和 <code>B(9)</code>，合并为一个新节点，权值为 14。</li>
<li>再选择 <code>C(12)</code> 和 <code>D(13)</code> 合并，权值为 25。</li>
<li>合并 <code>14</code> 和 <code>E(16)</code>，权值为 30。</li>
<li>合并 <code>25</code> 和 <code>F(45)</code>，权值为 70。</li>
<li>最后合并 <code>30</code> 和 <code>70</code>，得到哈夫曼树的根节点。</li>
</ol>
<p>这棵树是<strong>最优的</strong>，因为它最小化了每个字符的加权路径长度。</p>
<h5 id="最终生成的最优二叉树如下："><a href="#最终生成的最优二叉树如下：" class="headerlink" title="最终生成的最优二叉树如下："></a>最终生成的最优二叉树如下：</h5><pre><code>        R(100)
       /     \
   N3(30)   N4(70)
    /   \      /   \
 A(5)  E(16) N2(25) F(45)
            /   \
         C(12) D(13)
</code></pre>
<h1 id="2-赫夫曼编码"><a href="#2-赫夫曼编码" class="headerlink" title="2.赫夫曼编码"></a>2.赫夫曼编码</h1><p>为了实现高效率，我们要采取不等长编码原则，以及前缀编码原则</p>
<h3 id="赫夫曼编码过程："><a href="#赫夫曼编码过程：" class="headerlink" title="赫夫曼编码过程："></a>赫夫曼编码过程：</h3><p>向左用0表示，向右用1表示</p>
<p>根据树的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         R(100)</span><br><span class="line">        /     \</span><br><span class="line">    N3(30)   N4(70)</span><br><span class="line">   /   \      /   \</span><br><span class="line">A(5)  E(16) N2(25) F(45)</span><br><span class="line">           /   \</span><br><span class="line">        C(12) D(13)</span><br></pre></td></tr></table></figure>

<p>生成的赫夫曼编码应该是：</p>
<ul>
<li><strong>A</strong>: 00</li>
<li><strong>E</strong>: 01</li>
<li><strong>C</strong>: 100</li>
<li><strong>D</strong>: 101</li>
<li><strong>F</strong>: 11</li>
</ul>
<h3 id="对应的编码表："><a href="#对应的编码表：" class="headerlink" title="对应的编码表："></a>对应的编码表：</h3><table>
<thead>
<tr>
<th>字符</th>
<th>赫夫曼编码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>00</td>
</tr>
<tr>
<td>E</td>
<td>01</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>101</td>
</tr>
<tr>
<td>F</td>
<td>11</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>贪心算法</tag>
        <tag>树</tag>
        <tag>最优二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/2025/05/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>昨天忽然想到，emplace_back和push_back，emplace_back本质就是移动语义吗，然后在容器后边直接构造，只有一次构造，我就想，那push_back一个右值的时候，是不是和emplace_back一模一样的啊，然后翻了翻以前自己的博客（请神上身了属于是）,然后直接绷不住了，写的什么玩意，一点不深刻。有一种看自己五年前QQ动态的美（人果然不能共情曾经的自己）。</p>
<p>实际上哈，push_back左值右值是不一样的，会调用重载的不同版本的push_back函数，都要调用构造函数创建对象，区别只在于传入左值调用拷贝构造函数，传入右值调用移动构造函数，而emplace_back是完美转发参数给内部，调用的构造函数。</p>
<p>到此为止。</p>
<p>———————————————————不知道华不华丽的分割线—————————————————</p>
<p>迭代器，用b站宇文新粥的说法，就是给指针穿上了华丽的衣服，是指针的钢铁侠战甲</p>
<p>迭代器，实际上是类or结构体，里面封装了一个对应容器的指针，以及所有相关的操作符重载，目的就是让迭代器有指针的所有功能</p>
<h3 id="为什么要迭代器而不是指针"><a href="#为什么要迭代器而不是指针" class="headerlink" title="为什么要迭代器而不是指针"></a>为什么要迭代器而不是指针</h3><p>因为容器是多种多样的，比如vector是内存分布在相邻地址，而list就是链表，每个节点相隔甚远，map什么的用红黑树实现就更别说了，而容器算法很多又是通用的，比如sort（list不能用），find等，为了让list也能用类似原生指针的东西访问，我们采用了迭代器。</p>
<p>不同容器的迭代器是不一样的，比如vector就很类似原生指针，而其他的只是重载函数实现了类似效果</p>
<p><strong>容器与迭代器的关系</strong></p>
<ul>
<li>每个容器类（如 <code>std::vector</code>, <code>std::list</code>, <code>std::map</code> 等）都在其内部定义了至少一种或多种迭代器类型（例如 <code>iterator</code> 和 <code>const_iterator</code>）。这些迭代器类型是该容器的<strong>友元类</strong>，或者直接定义在容器类内部，以便访问容器的私有成员（如 <code>vector</code> 的底层数组指针，<code>list</code> 的节点指针）。</li>
<li>容器的 <code>begin()</code> 和 <code>end()</code> 成员函数负责创建并返回该容器特定类型的迭代器对象。</li>
</ul>
<p><strong>迭代器特性 (Iterator Traits)</strong></p>
<p>标准库算法（如 <code>std::sort</code>, <code>std::find</code>）是泛型的，它们通过模板参数接收迭代器。为了知道传入的迭代器具备哪些能力（属于哪个类别），以及它指向的元素类型是什么，标准库使用了一个叫做 <code>std::iterator_traits</code> 的模板元编程技术。</p>
<p><code>std::iterator_traits&lt;Iterator&gt;</code> 可以提取出迭代器的以下信息：</p>
<ul>
<li><code>iterator_category</code>: 迭代器类别（如 <code>std::random_access_iterator_tag</code>）</li>
<li><code>value_type</code>: 迭代器指向的元素类型</li>
<li><code>difference_type</code>: 两个迭代器之间的距离类型</li>
<li><code>pointer</code>: 指向元素类型的指针类型</li>
<li><code>reference</code>: 元素类型的引用类型</li>
</ul>
<p>自定义的迭代器需要通过继承 <code>std::iterator</code> 或在迭代器类中定义这些 <code>typedef</code> 来配合 <code>std::iterator_traits</code>。</p>
<h3 id="type-traits-类型萃取"><a href="#type-traits-类型萃取" class="headerlink" title="type traits(类型萃取)"></a>type traits(类型萃取)</h3><p>主要体现在<strong>算法如何根据迭代器的特性来选择最优化的实现路径</strong>。</p>
<p>核心机制是通过 <code>std::iterator_traits</code> 这个类型萃取模板来实现的。</p>
<p><strong>1. <code>std::iterator_traits</code> 的作用</strong></p>
<p><code>std::iterator_traits</code> 是一个特殊的类型萃取模板，它的作用是从任何迭代器类型 <code>Iterator</code> 中提取出关于该迭代器的标准信息。这些信息通常是通过迭代器类内部定义的 <code>typedef</code> 来提供的。<code>std::iterator_traits</code> 会查找并暴露这些嵌套类型，使得算法可以通过统一的方式访问它们。</p>
<p><code>std::iterator_traits&lt;Iterator&gt;</code> 通常会提供以下几个重要的嵌套类型（即萃取出的特性）：</p>
<ul>
<li><code>value_type</code>: 迭代器所指向元素的类型。</li>
<li><code>difference_type</code>: 用于表示两个迭代器之间距离的类型（通常是 <code>ptrdiff_t</code>）。</li>
<li><code>pointer</code>: 迭代器指向元素的指针类型。</li>
<li><code>reference</code>: 迭代器指向元素的引用类型。</li>
<li><code>iterator_category</code>: 这是一个非常重要的特性，它指示了迭代器的能力（例如，输入迭代器、前向迭代器、随机访问迭代器等）。</li>
</ul>
<p><code>std::iterator_traits</code> 还为原始指针类型（如 <code>T*</code>）提供了偏特化，使得原始指针也能像 STL 迭代器一样工作，并被识别为随机访问迭代器。</p>
<p><strong>2. 迭代器分类与标签 (Iterator Categories and Tags)</strong></p>
<p><code>iterator_category</code> 是连接 Type Traits 和迭代器能力的关键。C++ 定义了一系列的标签类型来表示不同的迭代器类别，它们之间存在继承关系：</p>
<ul>
<li><code>std::input_iterator_tag</code> (输入迭代器)</li>
<li><code>std::output_iterator_tag</code> (输出迭代器)</li>
<li><code>std::forward_iterator_tag</code> (前向迭代器) - 继承自 <code>input_iterator_tag</code> 和 <code>output_iterator_tag</code></li>
<li><code>std::bidirectional_iterator_tag</code> (双向迭代器) - 继承自 <code>forward_iterator_tag</code></li>
<li><code>std::random_access_iterator_tag</code> (随机访问迭代器) - 继承自 <code>bidirectional_iterator_tag</code></li>
</ul>
<p>一个迭代器类型通过在其内部定义 <code>iterator_category</code> 为这些标签类型之一，来声明自己的能力。例如，<code>std::vector</code> 的迭代器内部会定义 <code>typedef std::random_access_iterator_tag iterator_category;</code>。</p>
<p><strong>3. 算法如何利用 <code>std::iterator_traits</code> 和分类标签</strong></p>
<p>STL 算法（如 <code>std::advance</code>, <code>std::distance</code>, <code>std::copy</code>, <code>std::sort</code> 等）是模板函数，它们接受迭代器作为参数。在算法的内部实现中，它们会使用 <code>std::iterator_traits</code> 来获取迭代器的特性，尤其是 <code>iterator_category</code>。</p>
<p>基于 <code>iterator_category</code> 的不同，算法会采用不同的实现策略。这通常通过<strong>标签分派 (Tag Dispatching)</strong> 或 C++17 后的 <code>if constexpr</code> 来实现，这是一种编译时多态。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接表，邻接矩阵和十字链表</title>
    <url>/2024/10/16/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="1-邻接表的实现"><a href="#1-邻接表的实现" class="headerlink" title="1. 邻接表的实现"></a>1. 邻接表的实现</h3><p>邻接表使用一个数组或 <code>vector</code> 来存储每个顶点的边列表。每个顶点的边列表存储在一个链表或 <code>vector</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// 顶点数量</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adj.<span class="built_in">resize</span>(V);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj[i]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; v;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-邻接矩阵的实现"><a href="#2-邻接矩阵的实现" class="headerlink" title="2. 邻接矩阵的实现"></a>2. 邻接矩阵的实现</h3><p>邻接矩阵使用一个二维数组来存储顶点之间的边。每个元素表示顶点之间是否存在边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// 顶点数量</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMatrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adjMatrix.<span class="built_in">resize</span>(V, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjMatrix[u][v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是无向图，也要添加下面这一行</span></span><br><span class="line">        <span class="comment">// adjMatrix[v][u] = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                cout &lt;&lt; adjMatrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-十字链表的实现"><a href="#3-十字链表的实现" class="headerlink" title="3. 十字链表的实现"></a>3. 十字链表的实现</h3><p>十字链表是一种复杂的数据结构，特别适用于有向图。它包含每个顶点的出边和入边链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> tail;  <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> head;  <span class="comment">// 边的终点</span></span><br><span class="line">    EdgeNode *nextOut; <span class="comment">// 下一条出边</span></span><br><span class="line">    EdgeNode *nextIn;  <span class="comment">// 下一条入边</span></span><br><span class="line">    <span class="built_in">EdgeNode</span>(<span class="type">int</span> t, <span class="type">int</span> h) : <span class="built_in">tail</span>(t), <span class="built_in">head</span>(h), <span class="built_in">nextOut</span>(<span class="literal">nullptr</span>), <span class="built_in">nextIn</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 顶点的数据</span></span><br><span class="line">    EdgeNode *firstOut; <span class="comment">// 出边链表头节点</span></span><br><span class="line">    EdgeNode *firstIn;  <span class="comment">// 入边链表头节点</span></span><br><span class="line">    <span class="built_in">VertexNode</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(d), <span class="built_in">firstOut</span>(<span class="literal">nullptr</span>), <span class="built_in">firstIn</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrthogonalList</span> &#123;</span><br><span class="line">    vector&lt;VertexNode*&gt; vertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrthogonalList</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">            vertices.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">VertexNode</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        EdgeNode* edge = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(u, v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到出边链表</span></span><br><span class="line">        edge-&gt;nextOut = vertices[u]-&gt;firstOut;</span><br><span class="line">        vertices[u]-&gt;firstOut = edge;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到入边链表</span></span><br><span class="line">        edge-&gt;nextIn = vertices[v]-&gt;firstIn;</span><br><span class="line">        vertices[v]-&gt;firstIn = edge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打印出边链表</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;  Out-edges:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode* e = vertices[i]-&gt;firstOut; e != <span class="literal">nullptr</span>; e = e-&gt;nextOut) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; e-&gt;head;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印入边链表</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;  In-edges:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode* e = vertices[i]-&gt;firstIn; e != <span class="literal">nullptr</span>; e = e-&gt;nextIn) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &lt;- &quot;</span> &lt;&lt; e-&gt;tail;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">OrthogonalList <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>十字链表</strong>（Orthogonal List）是一种用于表示<strong>有向图</strong>的链式存储结构，它同时包含了每个顶点的<strong>入边</strong>和<strong>出边</strong>信息。十字链表是一种扩展的邻接表，能够方便地访问有向图中的边和顶点的入度、出度关系。该结构特别适合处理复杂的有向图问题。</p>
<h3 id="十字链表的定义"><a href="#十字链表的定义" class="headerlink" title="十字链表的定义"></a>十字链表的定义</h3><p>在十字链表中，每个顶点既有一个<strong>出边链表</strong>，也有一个<strong>入边链表</strong>，分别存储从该顶点出发和指向该顶点的边。具体来说：</p>
<ul>
<li>每条边由两个链表节点表示：<strong>出边节点</strong>（表示从某顶点出发的边）和<strong>入边节点</strong>（表示指向某顶点的边）。</li>
<li>顶点包含两个指针：一个指向该顶点的出边链表的头节点，另一个指向该顶点的入边链表的头节点。</li>
</ul>
<h3 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h3><ul>
<li><strong>顶点结构（Vertex Node）</strong>：每个顶点有两个指针，一个指向该顶点的出边链表（out-edge list），另一个指向该顶点的入边链表（in-edge list）。</li>
<li><strong>边结构（Edge Node）</strong>：每条边有两个指针，一个指向下一个出边（out-edge），另一个指向下一个入边（in-edge）。此外，边节点会记录边的起点和终点信息（通常是用来标识的起点和终点索引）。</li>
</ul>
<h3 id="十字链表的节点结构"><a href="#十字链表的节点结构" class="headerlink" title="十字链表的节点结构"></a>十字链表的节点结构</h3><p>假设有向图有 ( V ) 个顶点， ( E ) 条边，十字链表的基本节点可以定义为以下形式：</p>
<ol>
<li><p><strong>顶点节点（Vertex Node）</strong>：</p>
<ul>
<li><strong>data</strong>：顶点的值或标识。</li>
<li><strong>firstOut</strong>：指向该顶点的<strong>出边链表</strong>的头节点。</li>
<li><strong>firstIn</strong>：指向该顶点的<strong>入边链表</strong>的头节点。</li>
</ul>
</li>
<li><p><strong>边节点（Edge Node）</strong>：</p>
<ul>
<li><strong>tail</strong>：起点（边的出发顶点）。</li>
<li><strong>head</strong>：终点（边的目标顶点）。</li>
<li><strong>nextOut</strong>：指向<strong>出边链表</strong>中的下一条边（从相同顶点出发的下一条边）。</li>
<li><strong>nextIn</strong>：指向<strong>入边链表</strong>中的下一条边（指向相同顶点的下一条边）。</li>
<li><strong>weight</strong>（可选）：如果是加权图，则可以包含边的权重信息。</li>
</ul>
</li>
</ol>
<h3 id="十字链表的示例"><a href="#十字链表的示例" class="headerlink" title="十字链表的示例"></a>十字链表的示例</h3><p>我们通过一个简单的有向图来说明十字链表的结构。假设有如下有向图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">顶点：A, B, C, D</span><br><span class="line">边：A → B, A → C, B → C, C → D</span><br></pre></td></tr></table></figure>

<h4 id="1-顶点的出边链表和入边链表"><a href="#1-顶点的出边链表和入边链表" class="headerlink" title="1. 顶点的出边链表和入边链表"></a>1. 顶点的出边链表和入边链表</h4><ul>
<li>顶点 A 的<strong>出边链表</strong>：A → B, A → C</li>
<li>顶点 A 的<strong>入边链表</strong>：无</li>
<li>顶点 B 的<strong>出边链表</strong>：B → C</li>
<li>顶点 B 的<strong>入边链表</strong>：A → B</li>
<li>顶点 C 的<strong>出边链表</strong>：C → D</li>
<li>顶点 C 的<strong>入边链表</strong>：A → C, B → C</li>
<li>顶点 D 的<strong>入边链表</strong>：C → D</li>
</ul>
<h4 id="2-十字链表表示"><a href="#2-十字链表表示" class="headerlink" title="2. 十字链表表示"></a>2. 十字链表表示</h4><p>顶点节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A: firstOut -&gt; (A → B), firstIn -&gt; null</span><br><span class="line">B: firstOut -&gt; (B → C), firstIn -&gt; (A → B)</span><br><span class="line">C: firstOut -&gt; (C → D), firstIn -&gt; (A → C)</span><br><span class="line">D: firstOut -&gt; null,      firstIn -&gt; (C → D)</span><br></pre></td></tr></table></figure>

<p>边节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(A → B): nextOut -&gt; (A → C), nextIn -&gt; null</span><br><span class="line">(A → C): nextOut -&gt; null,      nextIn -&gt; null</span><br><span class="line">(B → C): nextOut -&gt; null,      nextIn -&gt; (A → C)</span><br><span class="line">(C → D): nextOut -&gt; null,      nextIn -&gt; null</span><br></pre></td></tr></table></figure>

<p>在这个结构中，顶点 A 通过 <code>firstOut</code> 链接了出边 <code>(A → B)</code>，并通过 <code>nextOut</code> 指向下一条出边 <code>(A → C)</code>，而 <code>firstIn</code> 为 <code>null</code>，因为没有指向 A 的边。同样，边 <code>(A → B)</code> 的 <code>nextIn</code> 为空，因为没有指向 B 的其他边。</p>
<h3 id="十字链表的优缺点"><a href="#十字链表的优缺点" class="headerlink" title="十字链表的优缺点"></a>十字链表的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>方便处理有向图</strong>：十字链表同时存储了<strong>出边</strong>和<strong>入边</strong>信息，因此可以方便地遍历从顶点出发的边以及指向该顶点的边。这使得在处理有向图的算法中（如拓扑排序、求解强连通分量等）非常高效。</li>
<li><strong>高效的边操作</strong>：可以快速获取某个顶点的所有出边和入边，适合需要频繁查询边信息的场景。</li>
<li><strong>适合稀疏图</strong>：十字链表只存储实际存在的边，因此在边数较少的稀疏图中节省空间。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>复杂性高</strong>：相比于普通的邻接表或邻接矩阵，十字链表的数据结构较为复杂，构建和维护成本较高。每条边需要维护两个链表，代码实现上较为复杂。</li>
<li><strong>空间占用较大</strong>：由于每条边需要存储两个链表指针（<code>nextOut</code> 和 <code>nextIn</code>），十字链表比简单的邻接表占用更多的空间。</li>
</ol>
<h3 id="十字链表的时间复杂度"><a href="#十字链表的时间复杂度" class="headerlink" title="十字链表的时间复杂度"></a>十字链表的时间复杂度</h3><ul>
<li><strong>空间复杂度</strong>：由于每条边都需要额外维护两个指针，十字链表的空间复杂度为 ( O(V + 2E) )，即每个顶点存储两个指针，每条边也存储两个指针。</li>
<li><strong>遍历所有出边&#x2F;入边</strong>：从某个顶点出发，遍历所有出边或入边的时间复杂度是 ( O(d) )，其中 ( d ) 是该顶点的度数。</li>
<li><strong>查找特定边</strong>：查找某个顶点的所有出边或入边仍然需要遍历整个链表，时间复杂度为 ( O(d) )。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>有向图的遍历</strong>：十字链表适合处理需要同时遍历出边和入边的有向图算法，例如：</p>
<ul>
<li><strong>拓扑排序</strong>：需要同时考虑入度和出度，十字链表方便在 O(1) 时间内访问这些信息。</li>
<li><strong>强连通分量</strong>算法：在求解强连通分量时，需要遍历有向图的逆图，十字链表能够高效支持这种操作。</li>
</ul>
</li>
<li><p><strong>网络流</strong>：在最大流或最小费用流等问题中，十字链表能够高效表示网络中的有向边及其流量信息。</p>
</li>
</ul>
<p><strong>十字链表</strong>是一种用于表示<strong>有向图</strong>的链式结构，通过同时维护顶点的出边和入边链表，能够高效处理有向图的遍历和操作，尤其适用于那些需要频繁查询边信息和入度、出度关系的应用场景。虽然其空间开销较大，结构复杂，但在有向图的高级算法中，十字链表提供了很高的效率。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>邻接表</strong>适用于稀疏图，空间效率高，但查询特定边的时间复杂度较高。</li>
<li><strong>邻接矩阵</strong>适用于稠密图，查询特定边的时间复杂度为 $O(1)$，但空间效率较低。</li>
<li><strong>十字链表</strong>适用于有向图，能够高效地处理出边和入边的操作，适合复杂的有向图算法。</li>
</ul>
<p>通过这些实现，我们可以根据具体问题的需求选择合适的数据结构来表示图。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载与友元函数</title>
    <url>/2025/05/02/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>众所周知，运算符重载作为多态的一种实现，使用是较为普遍的</p>
<p>但是重载运算符，本身是几元就有几个参数，对于二元运算符，第一个参数对应左侧运算对象，第二个参数对应右侧运算对象</p>
<p>而重载运算符作为类的成员函数的时候，第一个参数就隐式绑定了this指针，即左侧运算对象固定为this指针</p>
<p>举个最常见的拷贝赋值重载函数例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DeepCopy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int *data;</span><br><span class="line">	//省略构造函数</span><br><span class="line">	DeepCopy&amp; operator=(const DeepCopy &amp;other)</span><br><span class="line">	&#123;</span><br><span class="line">		if(this!=other)</span><br><span class="line">		&#123;</span><br><span class="line">			delete data;</span><br><span class="line">			data=new int (*(other.data));</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">DeepCopy a，b;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>但是，我们难免会遇到非成员函数重载的情况，此时我们就要借助友元函数或者全局函数，但友元函数相对更为常规，比如以下例子</p>
<h3 id="1-需要对称性或隐式转换支持"><a href="#1-需要对称性或隐式转换支持" class="headerlink" title="1. 需要对称性或隐式转换支持"></a>1. <strong>需要对称性或隐式转换支持</strong></h3><ul>
<li><strong>场景</strong>：当运算符的两个操作数需要平等对待（如 <code>+</code>、<code>*</code>、<code>==</code> 等双目运算符），且可能涉及不同类型的隐式转换。</li>
<li><strong>原因</strong>：成员函数将左侧操作数（<code>this</code>）固定为类类型，限制了左侧操作数的隐式转换。而非成员函数允许左右操作数都进行隐式转换，提供更自然的语义。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MyClass</span>(lhs.value + rhs.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">5</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">MyClass c = a + b; <span class="comment">// OK</span></span><br><span class="line">MyClass d = <span class="number">5</span> + a; <span class="comment">// 非成员函数支持 int 到 MyClass 的隐式转换</span></span><br></pre></td></tr></table></figure>
如果 <code>operator+</code> 是成员函数，<code>5 + a</code> 会失败，因为左侧的 <code>int</code> 无法调用成员函数。</li>
</ul>
<h3 id="2-涉及非类类型或标准库类型"><a href="#2-涉及非类类型或标准库类型" class="headerlink" title="2. 涉及非类类型或标准库类型"></a>2. <strong>涉及非类类型或标准库类型</strong></h3><ul>
<li><strong>场景</strong>：运算符涉及自定义类与内置类型（如 <code>int</code>、<code>double</code>）或标准库类型（如 <code>std::string</code>）的交互。</li>
<li><strong>原因</strong>：你无法修改内置类型或标准库类型的定义来添加成员函数，因此只能使用非成员函数。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::string data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> std::string&amp; d) : <span class="built_in">data</span>(d) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::string <span class="keyword">operator</span>+(<span class="type">const</span> std::string&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs + rhs.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::string s = <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">MyClass</span>(<span class="string">&quot;World&quot;</span>); <span class="comment">// 非成员函数支持</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-提高封装性或避免侵入式修改"><a href="#3-提高封装性或避免侵入式修改" class="headerlink" title="3. 提高封装性或避免侵入式修改"></a>3. <strong>提高封装性或避免侵入式修改</strong></h3><ul>
<li><strong>场景</strong>：当你不希望修改类的定义（例如第三方库的类）或想保持类接口简洁。</li>
<li><strong>原因</strong>：非成员函数（通常声明为 <code>friend</code> 或通过公共接口访问）可以在类外部定义，减少对类内部实现的依赖。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(lhs.<span class="built_in">getValue</span>() + rhs.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里无需修改 <code>MyClass</code> 的定义，保持了封装性。</li>
</ul>
<h3 id="4-流运算符（）"><a href="#4-流运算符（）" class="headerlink" title="4. 流运算符（&lt;&lt; 和 &gt;&gt;）"></a>4. <strong>流运算符（<code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>）</strong></h3><ul>
<li><strong>场景</strong>：重载输入输出流运算符（如 <code>std::ostream</code> 的 <code>&lt;&lt;</code> 或 <code>std::istream</code> 的 <code>&gt;&gt;</code>）。</li>
<li><strong>原因</strong>：这些运算符的左侧操作数是 <code>std::ostream</code> 或 <code>std::istream</code>，无法修改其类定义，因此必须使用非成员函数。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        os &lt;&lt; obj.value;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">x</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; x; <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>友元 vs. 公共接口</strong>：非成员函数可以通过 <code>friend</code> 访问私有成员，或通过公共 getter 方法操作。前者更简洁但可能降低封装性，后者更符合封装但代码稍冗长。</li>
<li><strong>隐式转换的副作用</strong>：非成员函数支持双边隐式转换，可能导致意外的类型转换，需谨慎设计构造函数（考虑 <code>explicit</code>）。</li>
<li><strong>性能</strong>：非成员函数通常是内联的（<code>inline</code>），性能与成员函数相当，但复杂运算需注意临时对象的创建和销毁开销。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>建议将运算符重载定义为非成员函数的场景包括：</p>
<ol>
<li>需要左右操作数的对称性或隐式转换（如 <code>+</code>、<code>*</code>）。</li>
<li>涉及非类类型或标准库类型（如 <code>std::string</code>、<code>std::ostream</code>）。</li>
<li>提高封装性或避免修改类定义。</li>
<li>流运算符（<code>&lt;&lt;</code>、<code>&gt;&gt;</code>）。</li>
</ol>
<p>关于友元的相关介绍，可以查看另一篇帖子。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>友元</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
</search>
