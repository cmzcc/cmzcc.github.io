<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS，BFS遍历非联通图</title>
    <url>/2024/10/16/DFS%E9%81%8D%E5%8E%86%E9%9D%9E%E8%81%94%E9%80%9A%E5%9B%BE/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数 (DFS)</span><br><span class="line">// 从当前节点 `node` 开始访问，并递归访问其所有相邻的未访问节点</span><br><span class="line">void DFS(char node, unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph, unordered_set&lt;char&gt;&amp; visited) &#123;</span><br><span class="line">    // 标记当前节点为已访问</span><br><span class="line">    visited.insert(node);</span><br><span class="line">    // 输出当前节点（此处可以进行自定义的处理，像打印或其他操作）</span><br><span class="line">    cout &lt;&lt; node &lt;&lt; &quot; &quot;;  </span><br><span class="line"></span><br><span class="line">    // 遍历该节点的所有相邻节点</span><br><span class="line">    for (char neighbor : graph[node]) &#123;</span><br><span class="line">        // 如果相邻节点未访问过，则递归调用 DFS 访问该相邻节点</span><br><span class="line">        if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">            DFS(neighbor, graph, visited);  // 递归调用 DFS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历整个非联通图的DFS</span><br><span class="line">// 对于图中的每一个顶点，如果该顶点未访问过，执行 DFS 来遍历与其相连的部分</span><br><span class="line">void DFSForDisconnectedGraph(unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    // 创建一个集合，用于记录哪些节点已经访问过</span><br><span class="line">    unordered_set&lt;char&gt; visited;</span><br><span class="line">    </span><br><span class="line">    // 遍历图中的所有顶点（unordered_map 的每个键）</span><br><span class="line">    for (auto&amp; pair : graph) &#123;</span><br><span class="line">        char node = pair.first;  // 当前顶点</span><br><span class="line">        // 如果当前顶点未访问过，则从该顶点开始进行 DFS</span><br><span class="line">        if (visited.find(node) == visited.end()) &#123;</span><br><span class="line">            // 从一个新的连通分量的顶点开始新的 DFS</span><br><span class="line">            cout &lt;&lt; &quot;Starting new DFS from node: &quot; &lt;&lt; node &lt;&lt; endl;</span><br><span class="line">            DFS(node, graph, visited);  // 对该连通分量进行DFS遍历</span><br><span class="line">            cout &lt;&lt; endl;  // DFS 完成后换行，以区分不同的连通分量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用邻接表表示图：unordered_map&lt;char, vector&lt;char&gt;&gt;，表示图中每个顶点及其相邻顶点</span><br><span class="line">    unordered_map&lt;char, vector&lt;char&gt;&gt; graph;</span><br><span class="line">    </span><br><span class="line">    // 定义图的边</span><br><span class="line">    graph[&#x27;a&#x27;] = &#123;&#x27;b&#x27;&#125;;   // 顶点 a 和 b 相连</span><br><span class="line">    graph[&#x27;b&#x27;] = &#123;&#x27;a&#x27;, &#x27;d&#x27;&#125;;  // 顶点 b 与 a 和 d 相连</span><br><span class="line">    graph[&#x27;c&#x27;] = &#123;&#x27;e&#x27;&#125;;   // 顶点 c 与 e 相连</span><br><span class="line">    graph[&#x27;d&#x27;] = &#123;&#x27;b&#x27;&#125;;   // 顶点 d 与 b 相连</span><br><span class="line">    graph[&#x27;e&#x27;] = &#123;&#x27;c&#x27;&#125;;   // 顶点 e 与 c 相连</span><br><span class="line"></span><br><span class="line">    // 调用 DFSForDisconnectedGraph 对非联通图进行遍历</span><br><span class="line">    DFSForDisconnectedGraph(graph);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 广度优先搜索函数</span><br><span class="line">void bfs(const unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph, char start) &#123;</span><br><span class="line">    // 用于存储待访问节点的队列</span><br><span class="line">    queue&lt;char&gt; q;</span><br><span class="line">    // 用于标记已访问的节点</span><br><span class="line">    unordered_set&lt;char&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将起始节点标记为已访问并加入队列</span><br><span class="line">    visited.insert(start);</span><br><span class="line">    q.push(start);</span><br><span class="line"></span><br><span class="line">    // 开始遍历</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        // 取出队列中的当前节点</span><br><span class="line">        char node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        // 输出当前节点</span><br><span class="line">        cout &lt;&lt; &quot;Visited: &quot; &lt;&lt; node &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        // 遍历该节点的所有邻接节点</span><br><span class="line">        for (char neighbor : graph.at(node)) &#123;</span><br><span class="line">            // 如果该邻接节点尚未访问过，加入队列并标记为已访问</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                visited.insert(neighbor);</span><br><span class="line">                q.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 图的邻接表表示法</span><br><span class="line">    unordered_map&lt;char, vector&lt;char&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;&#x27;a&#x27;, &#123;&#x27;b&#x27;, &#x27;c&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;b&#x27;, &#123;&#x27;a&#x27;, &#x27;d&#x27;, &#x27;e&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;c&#x27;, &#123;&#x27;a&#x27;, &#x27;f&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;d&#x27;, &#123;&#x27;b&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;e&#x27;, &#123;&#x27;b&#x27;, &#x27;f&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;f&#x27;, &#123;&#x27;c&#x27;, &#x27;e&#x27;&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 从节点 &#x27;a&#x27; 开始执行 BFS</span><br><span class="line">    bfs(graph, &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问顺序的区别示例"><a href="#访问顺序的区别示例" class="headerlink" title="访问顺序的区别示例"></a><strong>访问顺序的区别示例</strong></h3><p>以一个简单的图为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    a</span><br><span class="line">   / \</span><br><span class="line">  b   c</span><br><span class="line"> / \   \</span><br><span class="line">d   e   f</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DFS 访问顺序</strong>（从节点 <code>a</code> 开始）：<code>a, b, d, e, c, f</code><ul>
<li>先从 <code>a</code> 开始，访问 <code>b</code>，然后继续到 <code>d</code>，没有其他未访问的邻接节点后回溯到 <code>b</code>，再访问 <code>e</code>，继续回溯到 <code>a</code>，然后访问 <code>c</code>，最后访问 <code>f</code>。</li>
</ul>
</li>
<li><strong>BFS 访问顺序</strong>（从节点 <code>a</code> 开始）：<code>a, b, c, d, e, f</code><ul>
<li>先从 <code>a</code> 开始，访问其所有邻接节点 <code>b</code> 和 <code>c</code>，然后继续访问 <code>b</code> 和 <code>c</code> 的所有邻接节点 <code>d, e, f</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI模型</title>
    <url>/2025/06/30/OSI%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>我们一般说网络有七层，是指OSI模型，从下到上依次为：</p>
<ol>
<li>物理层 (Physical Layer)</li>
<li>数据链路层 (Data Link Layer)</li>
<li>网络层 (Network Layer)</li>
<li>传输层 (Transport Layer)</li>
<li>会话层 (Session Layer)</li>
<li>表示层 (Presentation Layer)</li>
<li>应用层 (Application Layer)</li>
</ol>
<h1 id="OSI模型的缺点"><a href="#OSI模型的缺点" class="headerlink" title="OSI模型的缺点"></a>OSI模型的缺点</h1><p>OSI（开放系统互连）模型是一种用于网络协议设计的理论框架，尽管它在标准化和教学中有重要作用，但也存在一些缺点：</p>
<ol>
<li><p><strong>过于理论化</strong>：</p>
<ul>
<li>OSI模型是抽象的参考模型，未直接应用于实际网络实现（如TCP&#x2F;IP模型）。许多协议不严格遵循其七层划分，导致实际应用中难以完全映射。</li>
</ul>
</li>
<li><p><strong>复杂性高</strong>：</p>
<ul>
<li>七层结构过于细化，增加了设计和实现的复杂性。例如，会话层和表示层的功能在实际协议（如TCP&#x2F;IP）中常被合并或忽略。</li>
</ul>
</li>
<li><p><strong>效率问题</strong>：</p>
<ul>
<li>每层严格的模块化设计可能导致数据处理和传输的额外开销，影响性能。实际网络协议（如TCP&#x2F;IP）更注重效率，层数更少。</li>
</ul>
</li>
<li><p><strong>缺乏实际实现</strong>：</p>
<ul>
<li>OSI模型本身不是一个可运行的协议栈，仅作为参考框架。实际网络（如互联网）更多基于TCP&#x2F;IP模型，OSI的协议（如X.25）使用较少。</li>
</ul>
</li>
<li><p><strong>标准化进程缓慢</strong>：</p>
<ul>
<li>OSI模型及其相关协议的开发和标准化过程耗时长，导致在快速发展的网络技术领域中落后于TCP&#x2F;IP等更实用的模型。</li>
</ul>
</li>
<li><p><strong>功能重叠</strong>：</p>
<ul>
<li>某些层的功能（如传输层和会话层）存在部分重叠，边界模糊，可能导致设计冗余或实现困难。</li>
</ul>
</li>
<li><p><strong>不适应现代网络需求</strong>：</p>
<ul>
<li>OSI模型设计时未充分考虑现代网络的复杂性（如云计算、虚拟化、SDN），使其在某些新兴技术场景中显得过时。</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>尽管OSI模型在理论上提供了清晰的网络分层思路，但在实际应用中因复杂性、效率问题和缺乏广泛实现而受到限制。TCP&#x2F;IP模型因其简洁性和实用性成为主流，但OSI模型仍作为学习和协议设计的参考标准。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LSM-Tree</title>
    <url>/2025/06/29/LSM-Tree/</url>
    <content><![CDATA[<p>云之重器。。。这个仇，我记下了。27届怎么你了</p>
<h3 id="LSM-Tree-Log-Structured-Merge-Tree"><a href="#LSM-Tree-Log-Structured-Merge-Tree" class="headerlink" title="LSM Tree (Log-Structured Merge-Tree)"></a>LSM Tree (Log-Structured Merge-Tree)</h3><p>LSM Tree（日志结构合并树）是一种数据结构，广泛应用于高性能、高吞吐的存储系统，特别是在写密集型场景中。它通过将写操作转化为顺序追加日志，并定期合并数据来优化性能。以下从定义、原理、实现、优缺点及应用场景详细介绍LSM Tree，并结合Linux环境和分布式系统（如分布式锁）的上下文。</p>
<hr>
<h3 id="1-LSM-Tree-定义"><a href="#1-LSM-Tree-定义" class="headerlink" title="1. LSM Tree 定义"></a><strong>1. LSM Tree 定义</strong></h3><p>LSM Tree 是一种面向写优化的持久化数据结构，结合了内存和磁盘存储，通过<strong>日志结构</strong>和<strong>多级合并</strong>实现高效的写操作和合理的读性能。它最初由 Patrick O’Neil 等人在1996年提出，适用于需要高吞吐量写入的数据库系统。</p>
<hr>
<h3 id="2-LSM-Tree-工作原理"><a href="#2-LSM-Tree-工作原理" class="headerlink" title="2. LSM Tree 工作原理"></a><strong>2. LSM Tree 工作原理</strong></h3><p>LSM Tree 的核心思想是将随机写转化为顺序写，并通过后台合并操作维护数据的有序性。其结构和操作流程如下：</p>
<h4 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a><strong>结构组成</strong></h4><ol>
<li><p><strong>内存组件（MemTable）</strong>：</p>
<ul>
<li>内存中的数据结构（如跳表、红黑树），用于存储最近写入的数据。</li>
<li>MemTable 提供快速的读写操作，数据按键排序。</li>
<li>当 MemTable 达到一定大小，转换为不可变的 Immutable MemTable。</li>
</ul>
</li>
<li><p><strong>磁盘组件（SSTable，Sorted String Table）</strong>：</p>
<ul>
<li>磁盘上的有序、不可变文件，包含键值对（Key-Value Pair）。</li>
<li>每个 SSTable 包含数据块、索引块（用于快速查找）和布隆过滤器（减少无效读）。</li>
<li>SSTable 分多个层级（Level 0, Level 1, …），层级越高数据越老、越大。</li>
</ul>
</li>
<li><p><strong>预写日志（WAL，Write-Ahead Log）</strong>：</p>
<ul>
<li>每次写操作先追加到磁盘上的 WAL，确保数据持久化，防止内存数据丢失。</li>
<li>WAL 是顺序写入，性能高，故障恢复时通过重放 WAL 恢复 MemTable。</li>
</ul>
</li>
</ol>
<h4 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a><strong>操作流程</strong></h4><ol>
<li><p><strong>写操作</strong>：</p>
<ul>
<li>数据写入 WAL（顺序追加，保证持久性）。</li>
<li>数据插入 MemTable（内存操作，快速）。</li>
<li>当 MemTable 满时，转换为 Immutable MemTable，后台将其刷盘为 Level 0 的 SSTable。</li>
</ul>
</li>
<li><p><strong>读操作</strong>：</p>
<ul>
<li>优先查询 MemTable 和 Immutable MemTable。</li>
<li>如果未找到，查询磁盘上的 SSTable，从 Level 0 到更高层级。</li>
<li>使用布隆过滤器快速排除不存在的键，减少磁盘 I&#x2F;O。</li>
<li>可能需要合并多个 SSTable 的结果（若键存在于多层）。</li>
</ul>
</li>
<li><p><strong>合并操作（Compaction）</strong>：</p>
<ul>
<li>后台定期合并 SSTable，消除重复键，减少层级中的文件数。</li>
<li>常见合并策略：<ul>
<li><strong>Level-based Compaction</strong>：将低层级的 SSTable 与高一层级合并，保持层级有序。</li>
<li><strong>Size-tiered Compaction</strong>：将同一层级中大小相近的 SSTable 合并。</li>
</ul>
</li>
<li>合并过程类似归并排序，生成新的 SSTable。</li>
</ul>
</li>
</ol>
<h4 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a><strong>层级结构</strong></h4><ul>
<li><strong>Level 0</strong>：直接从 MemTable 刷盘，文件小但可能有键重叠。</li>
<li>**Level 1+**：更高层级的 SSTable 通过合并生成，文件更大，键范围不重叠（或重叠少）。</li>
<li>层级越高，数据量越大，访问频率越低（冷数据）。</li>
</ul>
<hr>
<h3 id="3-LSM-Tree-在-Linux-中的实现"><a href="#3-LSM-Tree-在-Linux-中的实现" class="headerlink" title="3. LSM Tree 在 Linux 中的实现"></a><strong>3. LSM Tree 在 Linux 中的实现</strong></h3><p>在 Linux 系统中，LSM Tree 通常由数据库或存储引擎实现，运行在用户态进程中。以下是 Linux 环境中的关键点：</p>
<ol>
<li><p><strong>文件系统交互</strong>：</p>
<ul>
<li>WAL 和 SSTable 存储在 Linux 文件系统（如 ext4、XFS）上，依赖顺序写优化（如追加写）。</li>
<li>Linux 的 <code>fsync</code> 或 <code>O_DIRECT</code> 系统调用确保数据持久化。</li>
<li>文件系统缓存（Page Cache）加速 SSTable 读操作，但可能增加写放大（Write Amplification）。</li>
</ul>
</li>
<li><p><strong>进程与线程</strong>：</p>
<ul>
<li>LSM Tree 的操作（如写、读、合并）由数据库进程管理，多个线程并行处理：<ul>
<li><strong>写线程</strong>：处理客户端请求，写入 WAL 和 MemTable。</li>
<li><strong>合并线程</strong>：后台运行 Compaction，合并 SSTable。</li>
<li><strong>读线程</strong>：查询 MemTable 和 SSTable。</li>
</ul>
</li>
<li>线程同步（如互斥锁）用于保护 MemTable 和 WAL 的并发访问。</li>
</ul>
</li>
<li><p><strong>分布式锁集成</strong>（结合上下文）：</p>
<ul>
<li>在分布式系统中，LSM Tree 数据库（如 RocksDB、LevelDB）可能与分布式锁结合使用，确保多节点数据一致性。</li>
<li>示例：多节点写入共享键值对时，使用 Redis 或 ZooKeeper 分布式锁防止并发冲突。</li>
<li>Linux 进程通过客户端库（如 Redisson、Curator）访问分布式锁服务，结合 LSM Tree 的本地存储。</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>Linux 的 <code>epoll</code> 或 <code>io_uring</code> 支持高效 I&#x2F;O，加速 WAL 和 SSTable 的读写。</li>
<li>内核的 <code>futex</code> 优化用户态线程同步，减少锁竞争开销。</li>
<li>使用 <code>mmap</code> 映射 SSTable 文件到内存，加速随机读。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-LSM-Tree-优缺点"><a href="#4-LSM-Tree-优缺点" class="headerlink" title="4. LSM Tree 优缺点"></a><strong>4. LSM Tree 优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><p><strong>写性能高</strong>：</p>
<ul>
<li>写操作是顺序追加（WAL 和 MemTable），避免随机写，适合高吞吐场景。</li>
<li>相比 B+树（如 InnoDB），LSM Tree 写放大较低（尽管 Compaction 引入一定放大）。</li>
</ul>
</li>
<li><p><strong>可扩展性</strong>：</p>
<ul>
<li>层级结构支持大规模数据存储，SSTable 文件可分布在多个磁盘。</li>
<li>适合分布式系统，通过分区（Sharding）扩展。</li>
</ul>
</li>
<li><p><strong>故障恢复</strong>：</p>
<ul>
<li>WAL 提供持久化支持，系统崩溃后可通过重放 WAL 恢复 MemTable。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li>支持范围查询（因 SSTable 有序）和点查询（通过索引和布隆过滤器）。</li>
</ul>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><p><strong>读性能较低</strong>：</p>
<ul>
<li>读操作可能需要查询多个 SSTable（尤其 Level 0 键重叠较多），延迟较高。</li>
<li>布隆过滤器虽减少无效读，但仍需多次磁盘 I&#x2F;O。</li>
</ul>
</li>
<li><p><strong>写放大</strong>：</p>
<ul>
<li>Compaction 合并过程会重写数据，增加磁盘 I&#x2F;O 和存储空间使用。</li>
<li>写放大因层级数和合并策略而异。</li>
</ul>
</li>
<li><p><strong>空间开销</strong>：</p>
<ul>
<li>重复键可能存在于多层 SSTable，需 Compaction 清理，临时增加存储需求。</li>
<li>WAL 和 MemTable 占用额外内存。</li>
</ul>
</li>
<li><p><strong>复杂性</strong>：</p>
<ul>
<li>实现和管理复杂，需调优 Compaction 策略、层级大小等参数。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-LSM-Tree-应用场景"><a href="#5-LSM-Tree-应用场景" class="headerlink" title="5. LSM Tree 应用场景"></a><strong>5. LSM Tree 应用场景</strong></h3><p>LSM Tree 广泛应用于 NoSQL 数据库和存储引擎，适合写密集、高吞吐的场景：</p>
<ol>
<li><p><strong>NoSQL 数据库</strong>：</p>
<ul>
<li><strong>RocksDB</strong>：Facebook 开发的嵌入式存储引擎，广泛用于分布式系统（如 MyRocks）。</li>
<li><strong>LevelDB</strong>：Google 开发的轻量级键值存储。</li>
<li><strong>Cassandra</strong>：分布式数据库，使用 LSM Tree 存储数据。</li>
<li><strong>HBase</strong>：分布式大数据存储，基于 LSM Tree 实现。</li>
</ul>
</li>
<li><p><strong>日志系统</strong>：</p>
<ul>
<li>如 Kafka 的存储层，使用 LSM Tree 类似结构存储日志数据。</li>
</ul>
</li>
<li><p><strong>时间序列数据库</strong>：</p>
<ul>
<li>如 InfluxDB、Prometheus，适合高频写入的时间序列数据。</li>
</ul>
</li>
<li><p><strong>分布式系统</strong>（结合分布式锁）：</p>
<ul>
<li>LSM Tree 数据库与分布式锁结合，确保多节点一致性。</li>
<li>示例：分布式事务中，节点通过 ZooKeeper 锁协调对 RocksDB 的写入。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-LSM-Tree-与分布式锁的结合"><a href="#6-LSM-Tree-与分布式锁的结合" class="headerlink" title="6. LSM Tree 与分布式锁的结合"></a><strong>6. LSM Tree 与分布式锁的结合</strong></h3><p>结合上下文（分布式锁），LSM Tree 在分布式系统中常与分布式锁一起使用，以解决并发写问题：</p>
<ol>
<li><p><strong>场景</strong>：</p>
<ul>
<li>多个节点同时写入同一键（如库存更新），需分布式锁保证互斥。</li>
<li>示例：电商系统使用 Redis 分布式锁保护 RocksDB 的库存键更新。</li>
</ul>
</li>
<li><p><strong>实现</strong>：</p>
<ul>
<li>节点通过 Redis（<code>SETNX</code>）或 ZooKeeper（临时顺序节点）获取锁。</li>
<li>获取锁后，写入 LSM Tree 的 MemTable 和 WAL。</li>
<li>释放锁后，其他节点可继续写入。</li>
<li>Compaction 过程在后台运行，不受锁影响。</li>
</ul>
</li>
<li><p><strong>Linux 环境支持</strong>：</p>
<ul>
<li>分布式锁客户端运行在 Linux 进程中，线程处理锁请求和 LSM Tree 写入。</li>
<li>使用 <code>epoll</code> 优化锁服务网络通信，<code>futex</code> 优化本地线程同步。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><p>LSM Tree 是一种写优化的数据结构，通过顺序追加（WAL 和 MemTable）和后台合并（Compaction）实现高效写入，广泛用于 NoSQL 数据库（如 RocksDB、Cassandra）。其优点是高吞吐、低写延迟，缺点是读性能较低和写放大。在 Linux 环境中，LSM Tree 依赖文件系统和线程管理，与分布式锁结合可解决分布式系统中的并发问题。</p>
<p><strong>与分布式锁的关系</strong>：</p>
<ul>
<li>LSM Tree 提供本地存储，分布式锁保证多节点一致性。</li>
<li>典型场景：分布式事务、库存更新等。</li>
</ul>
<p>如果需要具体实现代码（如 RocksDB 的 LSM Tree 配置）或性能调优细节，请告诉我！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>LSM-Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC通信</title>
    <url>/2025/09/29/IPC%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>上班要用，临时抱佛脚学一下，引用<a href="https://cloud.tencent.com/developer/article/2439262?policyId=1004">进程间通信 IPC 完全指南：各种机制的原理与实战-腾讯云开发者社区-腾讯云</a></p>
<p>在现代计算系统中，多进程环境已经成为标准配置。随着计算需求的增长和应用复杂性的提升，单一进程往往无法独立完成所有任务。为了提高系统的灵活性、性能和可靠性，多个进程之间的协作成为了必然的选择。这就引出了一个关键问题：如何高效、安全地实现进程间的数据交换与通信？这就是进程间通信（Inter-Process Communication，IPC）的核心问题。</p>
<p><strong>进程间通信的重要性：</strong></p>
<p>进程间通信是指在不同进程之间传递信息的机制。在多进程系统中，各个进程可能需要共享数据、协调工作或交换状态信息。例如，在一个Web服务器中，工作进程可能需要与管理进程通信，以获取配置或报告状态；在数据处理系统中，生产者进程与消费者进程需要交换数据以完成任务。这些通信需求促使了IPC机制的设计与实现。</p>
<p>有效的IPC机制不仅能够提升系统的性能和响应速度，还能确保数据的一致性和系统的稳定性。在某些情况下，IPC机制甚至可以成为系统架构的核心组成部分，例如在分布式系统或<a href="https://cloud.tencent.com/product/tse?from_column=20065&from=20065">微服务架构</a>中，进程间通信的效率直接影响到整个系统的性能。</p>
<p>本指南旨在深入探讨进程间通信的各种机制，从基础知识到实战应用，帮助读者全面理解IPC的工作原理，并掌握如何在不同场景下选择和应用最合适的IPC方法。本文将涵盖以下几个方面：</p>
<ol>
<li><strong>进程间通信的基本概念</strong>：介绍IPC的定义、应用场景及主要挑战，为后续深入理解奠定基础。</li>
<li><strong>经典的IPC机制</strong>：详细解读管道、消息队列、共享内存、信号、套接字和内存映射文件等传统IPC机制的原理、优缺点及实际应用。</li>
</ol>
<p><img src="https://developer.qcloudimg.com/http-save/yehe-11218869/12f8b873613cc3ff948620f2dd1e31fa.png" alt="img"></p>
<h2 id="二、进程间通信的基本概念"><a href="#二、进程间通信的基本概念" class="headerlink" title="二、进程间通信的基本概念"></a>二、进程间通信的基本概念</h2><p>进程间通信是一种通常由操作系统（或操作系统）提供的机制。该机制的主要目的或目标是在多个进程之间提供通信。简而言之，互通允许一个进程让另一个进程知道某些事件已经发生。</p>
<h3 id="2-1、进程间通信（IPC）的定义"><a href="#2-1、进程间通信（IPC）的定义" class="headerlink" title="2.1、进程间通信（IPC）的定义"></a>2.1、进程间通信（IPC）的定义</h3><p>定义：<strong>进程间通信用于在一个或多个进程（或程序）中的众多线程之间交换有用的信息</strong>。由于进程之间拥有独立的地址空间和资源，直接访问对方的数据是不可能的。因此，IPC机制提供了一种通过操作系统提供的接口来进行数据交换的方法。IPC机制不仅涉及数据传输，还包括进程间的同步与协调。</p>
<h3 id="2-2、IPC-的应用场景"><a href="#2-2、IPC-的应用场景" class="headerlink" title="2.2、IPC 的应用场景"></a>2.2、IPC 的应用场景</h3><ul>
<li><strong>数据共享</strong>：多个进程需要访问或修改同一数据集合。例如，数据库系统中的多个进程可能需要访问共享的缓存或数据库表。</li>
<li><strong>任务协调</strong>：进程之间需要协同工作以完成复杂任务。例如，在网络服务器中，工作进程需要与主进程协调处理请求。</li>
<li><strong>状态更新</strong>：进程需要互相传递状态信息以便于系统的整体协调。例如，监控系统中的主进程需要获取各个子进程的运行状态。</li>
</ul>
<h3 id="2-3、IPC-的主要挑战"><a href="#2-3、IPC-的主要挑战" class="headerlink" title="2.3、IPC 的主要挑战"></a>2.3、IPC 的主要挑战</h3><ul>
<li><strong>同步与互斥</strong>：多个进程可能同时访问共享资源，需要确保数据的一致性和避免冲突。同步机制（如锁和信号量）帮助控制对共享资源的访问。</li>
<li><strong>数据一致性</strong>：确保在进程间传递的数据在接收方能够准确还原。数据一致性问题通常需要设计合理的数据格式和验证机制。</li>
<li><strong>性能</strong>：IPC机制的效率对系统性能有直接影响。选择合适的IPC机制可以在满足通信需求的同时，尽可能降低通信的开销。</li>
<li><strong>安全性</strong>：确保IPC过程中数据的安全性和隐私，防止未经授权的访问或数据篡改。</li>
</ul>
<h3 id="2-4、IPC-机制的分类和选择"><a href="#2-4、IPC-机制的分类和选择" class="headerlink" title="2.4、IPC 机制的分类和选择"></a>2.4、IPC 机制的分类和选择</h3><ul>
<li><strong>基于消息的通信</strong>：如消息队列、套接字等，通过消息传递实现进程间的数据交换。</li>
<li><strong>基于共享内存的通信</strong>：如共享内存和内存映射文件，通过共享内存区域实现进程间的数据共享。</li>
<li><strong>基于信号的通信</strong>：如信号机制，通过发送和接收信号实现进程间的事件通知和同步。</li>
</ul>
<p>IPC 机制的选择：</p>
<ul>
<li><strong>数据量和通信频率</strong>：对于大量数据和频繁通信，需要高效的机制，如共享内存。</li>
<li><strong>数据一致性要求</strong>：高一致性要求需要可靠的机制，如消息队列。</li>
<li><strong>实时性</strong>：实时系统对通信延迟有严格要求，需要优先考虑低延迟的IPC机制，如信号。</li>
<li><strong>复杂性和维护性</strong>：有些IPC机制实现和维护较为复杂，需要考虑系统的开发和维护成本。</li>
</ul>
<h2 id="三、经典的-IPC-机制"><a href="#三、经典的-IPC-机制" class="headerlink" title="三、经典的 IPC 机制"></a>三、经典的 IPC 机制</h2><ul>
<li>管道（Pipe）。</li>
<li>消息队列（Message Queues）。</li>
<li>共享内存（Shared Memory）。</li>
<li>信号（Signals）。</li>
<li>套接字（Sockets）。</li>
<li>内存映射文件（Memory-Mapped Files）</li>
</ul>
<h3 id="3-1、管道（Pipe）"><a href="#3-1、管道（Pipe）" class="headerlink" title="3.1、管道（Pipe）"></a>3.1、管道（Pipe）</h3><p><strong>管道是一种单向的数据通道，即数据通道中的数据一次只能向一个方向移动</strong>。这是一种半双工方法，为了实现全双工，需要另一根管道，形成一组双通道，以便能够在两个进程中发送和接收数据。通常，它使用标准方法进行输入和输出。这些管道用于所有类型的 POSIX 系统以及不同版本的Windows操作系统。</p>
<p>在Unix和类Unix系统中，管道通常用于父子进程之间或者通过<code>fork</code>创建的进程之间进行通信，因为<strong>在一个进程中使用管道是没有意义的</strong>。管道有两种类型：匿名管道和命名管道（FIFO）。</p>
<p>管道（Pipe）可能是本地使用最广泛的 IPC 方法之一。管道（Pipe）实际上是使用一段内核内存实现的。系统调用始终创建一个管道和两个关联的文件说明，用于从管道读取和写入管道。</p>
<p>优点：</p>
<ul>
<li>实现简单，适合简单的父子进程通信。</li>
<li>管道使用管道缓冲区，可以控制读写进程之间的数据流。</li>
</ul>
<p>缺点：</p>
<ul>
<li>单向传输限制了其应用场景，不适合双向通信。</li>
<li>由于是基于内存的，对于大数据量的传输效率可能较低。</li>
<li>匿名管道通常只能用于具有亲缘关系的进程之间，而无法在任意两个进程之间进行通信。</li>
</ul>
<p><strong>管道的工作原理：</strong></p>
<ol>
<li><strong>管道的创建</strong>：在Unix系统中，可以使用<code>pipe()</code>系统调用来创建一个管道。这个调用会返回两个文件描述符，一个用于读操作，一个用于写操作。例如： int pipefd[2]; if (pipe(pipefd) &#x3D;&#x3D; -1) {     perror(“pipe”);     exit(EXIT_FAILURE); } <code>pipefd[0]</code>用于读取数据，而<code>pipefd[1]</code>用于写入数据。两个文件描述符形成了一个单向的数据流通道。</li>
<li>数据传输：<ul>
<li>写操作：进程可以通过写文件描述符将数据写入管道。数据会被存储在管道的缓冲区中，直到被读取。const char *message &#x3D; “Hello, World!”; write(pipefd[1], message, strlen(message));</li>
<li>读操作：另一个进程可以通过读取文件描述符从管道中读取数据。读取操作会从缓冲区中提取数据，并将其返回给调用进程。char buffer[128]; ssize_t bytesRead &#x3D; read(pipefd[0], buffer, sizeof(buffer));</li>
</ul>
</li>
<li>管道的使用：<ul>
<li>在进程间通信中，通常有两个进程使用管道进行数据交换。例如，父进程创建管道，并在<code>fork()</code>之后将管道的读写文件描述符分别传递给子进程和父进程。</li>
<li>子进程可以将数据写入管道，父进程则从管道中读取数据。此时，数据在两个进程之间流动，通过管道实现了进程间的数据传递。</li>
</ul>
</li>
</ol>
<p><strong>区分匿名管道与命名管道：</strong></p>
<ul>
<li><strong>匿名管道</strong>：匿名管道最基本的管道类型，它是一个临时的、单向的数据通道，通常用于具有亲缘关系的进程（如父子进程）之间的通信。匿名管道没有名称，它们在管道创建时只在进程内有效，无法在系统中被其他进程访问。</li>
<li><strong>命名管道（FIFO）</strong>：命名管道是一种具有名称的特殊文件，它在文件系统中存在，允许不相关的进程之间进行通信。因此可以在不相关的进程之间实现双向或单向的通信，而不需要进程间有直接的亲缘关系。使用<code>mkfifo()</code>函数创建命名管道，并通过文件路径进行读写操作：mkfifo(“&#x2F;tmp&#x2F;myfifo”, 0666);</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名管道</span></span><br><span class="line">#include &lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;stdlib.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;unistd.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;string.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    int pipefd[<span class="number">2</span>];</span><br><span class="line">    pid_t pid;</span><br><span class="line">    char buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">pipe</span>(pipefd) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = <span class="title function_">fork</span>()) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="title function_">close</span>(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="keyword">const</span> char *message = <span class="string">&quot;Hello from child&quot;</span>;</span><br><span class="line">        <span class="title function_">write</span>(pipefd[<span class="number">1</span>], message, <span class="title function_">strlen</span>(message) + <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_SUCCESS</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="title function_">close</span>(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="title function_">read</span>(pipefd[<span class="number">0</span>], buffer, <span class="title function_">sizeof</span>(buffer));</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="title function_">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名管道（FIFO）</span></span><br><span class="line">#include &lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;stdlib.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;fcntl.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;unistd.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;string.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> char *fifo = <span class="string">&quot;/tmp/myfifo&quot;</span>;</span><br><span class="line">    char buffer[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建命名管道</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">mkfifo</span>(fifo, <span class="number">0666</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = <span class="title function_">fork</span>()) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        int fd = <span class="title function_">open</span>(fifo, <span class="variable constant_">O_WRONLY</span>);</span><br><span class="line">        <span class="keyword">const</span> char *message = <span class="string">&quot;Hello from FIFO&quot;</span>;</span><br><span class="line">        <span class="title function_">write</span>(fd, message, <span class="title function_">strlen</span>(message) + <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">close</span>(fd);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_SUCCESS</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        int fd = <span class="title function_">open</span>(fifo, <span class="variable constant_">O_RDONLY</span>);</span><br><span class="line">        <span class="title function_">read</span>(fd, buffer, <span class="title function_">sizeof</span>(buffer));</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="title function_">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除命名管道</span></span><br><span class="line">    <span class="title function_">unlink</span>(fifo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong></p>
<p>管道常用于实现简单的父子进程间的数据传递，或在管道的另一端读取进程的标准输出。在Shell脚本中，管道被广泛用于将一个命令的输出传递给另一个命令作为输入。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ls | grep <span class="string">&quot;txt&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个命令将<code>ls</code>命令的输出传递给<code>grep</code>命令进行过滤，使用管道实现了两个命令之间的数据传递。</p>
<h3 id="3-2、消息队列（Message-Queues）"><a href="#3-2、消息队列（Message-Queues）" class="headerlink" title="3.2、消息队列（Message Queues）"></a>3.2、消息队列（Message Queues）</h3><p>消息队列 (Message Queue) 允许进程在两个进程之间以消息的形式交换数据。它允许进程通过相互发送消息来异步通信，其中消息存储在队列中，等待处理，并在处理后删除。</p>
<p>消息队列是在非共享内存环境中使用的缓冲区，其中任务通过相互传递消息而不是通过访问共享变量进行通信。任务共享一个公共缓冲池。消息队列是一个无界 FIFO 队列，可防止不同线程的并发访问。</p>
<p><strong>定义：消息队列提供异步通信协议，消息的发送方和接收方不需要同时与消息队列进行交互。</strong></p>
<p>简单的说，消息队列的工作原理类似于邮箱：多个进程可以向消息队列发送邮件，接受者可以从队列中取回邮件。</p>
<p>事件是异步的。当一个类将事件发送到另一个类时，它不会将其直接发送到目标反应类，而是将事件传递到操作系统消息队列。当目标类准备好处理事件时，它从消息队列的头部检索该事件。可以改用触发的操作来传递同步事件。</p>
<p>许多任务可以将消息写入队列，但一次只能有一个任务从队列中读取消息。读取器在消息队列上等待，直到有消息要处理。消息可以是任意大小的。</p>
<p>消息队列是一种软件组件，可在微服务和无服务器基础架构中实现应用程序到应用程序的通信。消息使用异步通信协议进行传输和接收，该协议对消息进行排队，不需要收件人的立即响应。</p>
<p><strong>优点:</strong></p>
<ul>
<li><strong>异步通信:</strong> 发送进程无需等待接收进程立即处理消息，可以高效地继续执行其他任务，提高了系统吞吐量和响应速度。</li>
<li><strong>解耦:</strong> 不同进程之间可以相互通信，而不需要了解对方的内部结构或运行机制，降低了系统复杂度和维护难度。</li>
<li><strong>灵活的消息处理:</strong> 可以根据消息内容采取不同的处理策略，实现不同的功能，灵活地处理不同类型的数据。</li>
<li><strong>安全性:</strong> 可以使用权限控制机制保护消息队列的访问权限，确保数据安全。</li>
<li><strong>排队机制:</strong> 由于消息存放在队列中，消息的顺序会被保留，确保消息按指定的顺序被接收并处理。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>资源开销:</strong> 创建和管理消息队列需要消耗系统资源，包括内存和系统调用时间。</li>
<li><strong>复杂性:</strong> 与其他简单IPC机制相比，消息队列的使用需要了解消息结构、权限设置和同步机制等概念。</li>
<li><strong>性能:</strong> 在并发场景下，如果消息队列长度过长，可能会因为消息处理速度跟不上发送速度而导致积压，影响系统性能。</li>
<li><strong>限于特定处理消息类型:</strong> 消息队列更适合用于处理自包含信息的完整消息，而在处理有限数据类型，例如同步信号更推荐使用其他机制，例如信号量。</li>
</ul>
<p>在程序中使用四个重要功能来实现使用消息队列的 IPC：</p>
<ul>
<li><strong><code>msgget(key_t key, int msgflg)</code></strong>: 用来创建或打开一个消息队列。第一个参数是命名系统中消息队列的键，使用<code>ftok</code>创建；第二个参数用于为消息队列分配权限。</li>
<li><strong><code>msgsnd(int msqid, const void \*msg_ptr, size_t msg_sz, int msgflg)</code></strong>: 用于发送消息到消息队列。最后一个参数控制在消息队列已满或达到排队消息的系统限制时会发生什么情况。</li>
<li><strong><code>msgrcv(int msqid, void \*msg_ptr, size_t msg_sz, long int msgtype, int msgflg)</code></strong>: 用于从消息队列接收消息。</li>
<li><strong><code>msgctl(int msqid, int command, struct msqid_ds \*buf)</code></strong>: 用于控制消息队列，例如修改权限、获取消息队列信息等等。第二个参数可以具有<code>IPC_STAT</code>、<code>IPC_SET</code>、<code>IPC_RMID</code>中的一个。</li>
</ul>
<p>使用消息队列执行 IPC 的步骤：</p>
<ol>
<li>创建一个新队列或由 <code>msgget()</code> 打开一个现有队列。</li>
<li>新消息由 <code>msgsnd()</code> 添加到队列末尾。每条消息都有一个正的长整型字段、一个非负长度和实际的数据字节（对应于长度），所有这些都在将消息添加到队列时指定给 <code>msgsnd()</code>。</li>
<li>消息由 <code>msgrcv()</code> 从队列中获取。我们不必按先进先出的顺序获取消息。相反，可以根据消息的类型字段获取消息。</li>
<li>对消息队列 <code>msgctl()</code>执行控制操作。</li>
</ol>
<p>示例，写消息队列：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdlib.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;stdio.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;string.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;unistd.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/types.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/ipc.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/msg.<span class="property">h</span>&gt;  </span><br><span class="line">#define <span class="variable constant_">MAX_TEXT</span> <span class="number">512</span>   <span class="comment">//maximum length of the message that can be sent allowed  </span></span><br><span class="line">struct my_msg&#123;  </span><br><span class="line">    long int msg_type;  </span><br><span class="line">    char some_text[<span class="variable constant_">MAX_TEXT</span>];  </span><br><span class="line">&#125;;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    int running=<span class="number">1</span>;  </span><br><span class="line">    int msgid;  </span><br><span class="line">    struct my_msg some_data;  </span><br><span class="line">    char buffer[<span class="number">50</span>]; <span class="comment">//array to store user input  </span></span><br><span class="line">    msgid=<span class="title function_">msgget</span>((key_t)<span class="number">14534</span>,<span class="number">0666</span>|<span class="variable constant_">IPC_CREAT</span>);  </span><br><span class="line">    <span class="keyword">if</span> (msgid == -<span class="number">1</span>) &#123;  </span><br><span class="line">		<span class="title function_">printf</span>(<span class="string">&quot;Error in creating queue\n&quot;</span>);  </span><br><span class="line">		<span class="title function_">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">	<span class="keyword">while</span>(running) &#123;  </span><br><span class="line">		<span class="title function_">printf</span>(<span class="string">&quot;Enter some text:\n&quot;</span>);  </span><br><span class="line">		<span class="title function_">fgets</span>(buffer,<span class="number">50</span>,stdin);  </span><br><span class="line">		some_data.<span class="property">msg_type</span>=<span class="number">1</span>;  </span><br><span class="line">		<span class="title function_">strcpy</span>(some_data.<span class="property">some_text</span>,buffer);  </span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_">msgsnd</span>(msgid,(<span class="keyword">void</span> *)&amp;some_data, <span class="variable constant_">MAX_TEXT</span>,<span class="number">0</span>)==-<span class="number">1</span>) &#123;  </span><br><span class="line">		 	<span class="title function_">printf</span>(<span class="string">&quot;Msg not sent\n&quot;</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_">strncmp</span>(buffer,<span class="string">&quot;end&quot;</span>,<span class="number">3</span>)==<span class="number">0</span>)  &#123;  </span><br><span class="line">			running=<span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>读消息队列：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdlib.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;stdio.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;string.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;unistd.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/types.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/ipc.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/msg.<span class="property">h</span>&gt;  </span><br><span class="line">struct my_msg&#123;  </span><br><span class="line">	long int msg_type;  </span><br><span class="line">	char some_text[<span class="variable constant_">BUFSIZ</span>];  </span><br><span class="line">&#125;;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">	int running=<span class="number">1</span>;  </span><br><span class="line">	int msgid;  </span><br><span class="line">	struct my_msg some_data;  </span><br><span class="line">	long int msg_to_rec=<span class="number">0</span>;  </span><br><span class="line">	msgid=<span class="title function_">msgget</span>((key_t)<span class="number">12345</span>,<span class="number">0666</span>|<span class="variable constant_">IPC_CREAT</span>);  </span><br><span class="line">	<span class="keyword">while</span>(running)  &#123;  </span><br><span class="line">	    <span class="title function_">msgrcv</span>(msgid,(<span class="keyword">void</span> *)&amp;some_data,<span class="variable constant_">BUFSIZ</span>,msg_to_rec,<span class="number">0</span>);                   </span><br><span class="line">	    <span class="title function_">printf</span>(<span class="string">&quot;Data received: %s\n&quot;</span>,some_data.<span class="property">some_text</span>);  </span><br><span class="line">	    <span class="keyword">if</span>(<span class="title function_">strncmp</span>(some_data.<span class="property">some_text</span>,<span class="string">&quot;end&quot;</span>,<span class="number">3</span>)==<span class="number">0</span>)  </span><br><span class="line">	    	running=<span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	 <span class="title function_">msgctl</span>(msgid,<span class="variable constant_">IPC_RMID</span>,<span class="number">0</span>);  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>

<h3 id="3-3、共享内存（Shared-Memory）"><a href="#3-3、共享内存（Shared-Memory）" class="headerlink" title="3.3、共享内存（Shared Memory）"></a>3.3、共享内存（Shared Memory）</h3><p>共享内存是两个或多个进程之间共享的内存,允许多个进程访问和共享相同内存块。每个进程都有自己的地址空间；如果任何进程想要将某些信息从其自己的地址空间与其他进程进行通信，则只能使用 IPC（进程间通信）共享内存技术。</p>
<p><strong>共享内存是最快的进程间通信机制</strong>。操作系统将多个进程的地址空间中的内存段映射到该内存段中读取和写入，而无需调用操作系统函数。</p>
<p>对于交换大量数据的应用程序，共享内存远远优于消息队列技术，因为IPC消息队列需要对每次数据交换进行系统调用。</p>
<p>通常，使用管道或命名管道执行相互关联的进程通信。不相关的进程通信可以使用命名管道或通过共享内存和消息队列等。但是，管道、FIFO和消息队列的问题在于两个进程之间的信息交换要经过内核，总共需要 4 个数据副本（2 个读取和 2 个写入）。因此，共享内存提供了一种方法，让两个或多个进程共享一个内存段。使用共享内存时，数据仅复制两次，从输入文件复制到共享内存，从共享内存复制到输出文件。</p>
<p>在两个或多个进程中建立共享内存区域时，无法保证这些区域将放置在相同的基址上，当需要同步时，可以使用信号量。</p>
<p>有两个函数 <code>shmget()</code> 和 <code>shmat()</code> 用于使用共享内存的 IPC。<code>shmget()</code> 函数用于创建共享内存段，而 <code>shmat()</code>函数用于将共享段与进程的地址空间附加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/ipc.<span class="property">h</span>&gt;   </span><br><span class="line">#include &lt;sys/shm.<span class="property">h</span>&gt;   </span><br><span class="line"></span><br><span class="line">int <span class="title function_">shmget</span> (key_t key, size_t size, int shmflg);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="title function_">shmat</span>(int shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, int shmflg);  </span><br></pre></td></tr></table></figure>

<p><strong>IPC使用共享内存如何工作？</strong> 进程使用 <code>shmget()</code> 创建共享内存段。共享内存段的原始所有者可以使用 <code>shmctl()</code>将所有权分配给另一个用户。它还可以撤销此分配。具有适当权限的其他进程可以使用 <code>shmctl()</code>在共享内存段上执行各种控制功能。</p>
<p>创建后，可以使用 <code>shmat()</code>将共享段附加到进程地址空间。可以使用 <code>shmdt()</code> 将其分离。附加进程必须具有 <code>shmat()</code>的适当权限。附加后，进程可以读取或写入段，因为附加操作中请求的权限允许。共享段可以通过同一进程多次附加。</p>
<p>共享内存段由具有唯一 ID 的控制结构描述，该 ID 指向物理内存区域。段的标识符称为 <code>shmid</code>。共享内存段控制结构和原型的结构定义可以在 <code>&lt;sys/shm.h&gt;</code> 中找到。</p>
<p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;stdlib.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;unistd.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/shm.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;string.<span class="property">h</span>&gt;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">	int i;  </span><br><span class="line">	<span class="keyword">void</span> *shared_memory;  </span><br><span class="line">	char buff[<span class="number">100</span>];  </span><br><span class="line">	int shmid;  </span><br><span class="line">	shmid=<span class="title function_">shmget</span>((key_t)<span class="number">2345</span>, <span class="number">1024</span>, <span class="number">0666</span>|<span class="variable constant_">IPC_CREAT</span>);   </span><br><span class="line">	<span class="comment">//creates shared memory segment with key 2345, having size 1024 bytes. </span></span><br><span class="line">	<span class="title function_">printf</span>(<span class="string">&quot;Key of shared memory is %d\n&quot;</span>,shmid);  </span><br><span class="line">	shared_memory=<span class="title function_">shmat</span>(shmid,<span class="variable constant_">NULL</span>,<span class="number">0</span>);   </span><br><span class="line">	<span class="comment">//process attached to shared memory segment  </span></span><br><span class="line">	<span class="title function_">printf</span>(<span class="string">&quot;Process attached at %p\n&quot;</span>,shared_memory);   </span><br><span class="line">	<span class="comment">//this prints the address where the segment is attached with this process  </span></span><br><span class="line">	<span class="title function_">printf</span>(<span class="string">&quot;Enter some data to write to shared memory\n&quot;</span>);  </span><br><span class="line">	<span class="title function_">read</span>(<span class="number">0</span>,buff,<span class="number">100</span>); <span class="comment">//get some input from user  </span></span><br><span class="line">	<span class="title function_">strcpy</span>(shared_memory,buff); <span class="comment">//data written to shared memory  </span></span><br><span class="line">	<span class="title function_">printf</span>(<span class="string">&quot;You wrote : %s\n&quot;</span>,(char *)shared_memory);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;stdlib.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;unistd.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;sys/shm.<span class="property">h</span>&gt;  </span><br><span class="line">#include&lt;string.<span class="property">h</span>&gt;  </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">	int i;  </span><br><span class="line">	<span class="keyword">void</span> *shared_memory;  </span><br><span class="line">	char buff[<span class="number">100</span>];  </span><br><span class="line">	int shmid;  </span><br><span class="line">	shmid=<span class="title function_">shmget</span>((key_t)<span class="number">2345</span>, <span class="number">1024</span>, <span class="number">0666</span>);  </span><br><span class="line">	<span class="title function_">printf</span>(<span class="string">&quot;Key of shared memory is %d\n&quot;</span>,shmid);  </span><br><span class="line">	shared_memory=<span class="title function_">shmat</span>(shmid,<span class="variable constant_">NULL</span>,<span class="number">0</span>); <span class="comment">//process attached to shared memory segment  </span></span><br><span class="line">	<span class="title function_">printf</span>(<span class="string">&quot;Process attached at %p\n&quot;</span>,shared_memory);  </span><br><span class="line">	<span class="title function_">printf</span>(<span class="string">&quot;Data read from shared memory is : %s\n&quot;</span>,(char *)shared_memory);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="3-4、信号（Signals）"><a href="#3-4、信号（Signals）" class="headerlink" title="3.4、信号（Signals）"></a>3.4、信号（Signals）</h3><p>在操作系统和进程间通信中，信号（Signals）是一种重要的机制，用于通知进程发生了某种事件或异常。</p>
<p>信号是一种异步通知机制，用于在软件层面向进程发送通知。它通常用于以下几种情况：</p>
<ul>
<li><strong>进程间通信（IPC）：</strong> 信号可以用来通知进程某种事件已经发生，比如用户键入了某个中断键（如Ctrl+C），或者子进程结束等。</li>
<li><strong>异常事件：</strong> 比如内存访问错误（如分段错误），浮点数溢出等硬件引发的异常，这些异常会被操作系统转换为信号发送给相应进程。</li>
<li><strong>系统管理：</strong> 操作系统可以通过信号强制进程执行某些动作，如中止进程、重新启动进程等。</li>
</ul>
<p>每种信号都由一个唯一的整数编号表示，这些编号通常以宏的形式定义在 <code>&lt;signal.h&gt;</code> 头文件中。一些常见的信号包括：</p>
<ul>
<li><strong>SIGINT (2):</strong> 终端中断信号，通常由用户键入Ctrl+C触发。</li>
<li><strong>SIGKILL (9):</strong> 无法被忽略的终止信号，用于强制终止进程。</li>
<li><strong>SIGTERM (15):</strong> 终止信号，用于正常结束进程。</li>
<li><strong>SIGSEGV (11):</strong> 无效内存引用导致的段错误。</li>
<li><strong>SIGCHLD (17):</strong> 子进程状态发生变化的通知信号，通常由子进程退出或终止时发送给父进程。</li>
</ul>
<p>信号的发送与处理：</p>
<ul>
<li><strong>发送信号：</strong> 可以使用系统调用 <code>kill(pid, sig)</code> 向指定的进程 <code>pid</code> 发送信号 <code>sig</code>。</li>
<li><strong>捕获信号：</strong> 进程可以通过注册信号处理函数来捕获和处理信号。使用 <code>signal(sig, handler)</code> 或 <code>sigaction(sig, &amp;act, &amp;oldact)</code> 函数来指定信号处理函数。</li>
<li><strong>信号处理函数：</strong> 信号处理函数是一个特殊的函数，用来处理特定信号发生时的行为。这些函数必须满足特定的格式，通常使用 <code>void handler(int sig)</code> 这样的声明。</li>
</ul>
<p>信号处理的注意事项：</p>
<ul>
<li><strong>异步性质：</strong> 信号的到达是异步的，即进程无法预测信号何时到达。因此，信号处理函数应设计为尽可能简单和快速。</li>
<li><strong>可重入性：</strong> 由于信号可以在任何时候中断进程执行，因此信号处理函数必须是可重入的，即可以安全地在其自身执行期间再次调用。</li>
<li><strong>信号屏蔽：</strong> 进程可以使用 <code>sigprocmask()</code> 函数来屏蔽（阻止）或解除屏蔽特定的信号，以控制在什么时候接收某些信号。</li>
</ul>
<p>示例，使用 <code>signal()</code> 函数来捕获并处理 <code>SIGINT</code> 信号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;signal.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;unistd.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sigint_handler</span>(<span class="params">int sig</span>) &#123;</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;Caught SIGINT, exiting...&quot;</span>);</span><br><span class="line">    <span class="title function_">exit</span>(<span class="number">0</span>);  <span class="comment">// 或者执行一些清理工作后退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">signal</span>(<span class="variable constant_">SIGINT</span>, sigint_handler);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;Waiting for SIGINT (Ctrl+C)...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">sleep</span>(<span class="number">1</span>);  <span class="comment">// 让程序持续运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号虽然主要用于通知事件和处理异常，但也可以用于简单的进程间通信。</p>
<p><strong>发送进程 (<code>sender.c</code>)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;stdlib.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;signal.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;unistd.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line">#define <span class="variable constant_">SIG_CUSTOM</span> <span class="title class_">SIGUSR1</span>  <span class="comment">// 自定义信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">error_handling</span>(<span class="params">char *msg</span>) &#123;</span><br><span class="line">    <span class="title function_">perror</span>(msg);</span><br><span class="line">    <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pid_t pid = <span class="title function_">fork</span>();  <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">error_handling</span>(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程（接收进程）</span></span><br><span class="line">        <span class="title function_">execl</span>(<span class="string">&quot;./receiver&quot;</span>, <span class="string">&quot;receiver&quot;</span>, <span class="variable constant_">NULL</span>);  <span class="comment">// 执行接收进程程序</span></span><br><span class="line">        <span class="title function_">error_handling</span>(<span class="string">&quot;Exec error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程（发送进程）</span></span><br><span class="line">        <span class="title function_">sleep</span>(<span class="number">1</span>);  <span class="comment">// 等待子进程初始化完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Sending signal to child process (PID: %d)...\</span></span><br><span class="line"><span class="string">&quot;</span>, pid);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">kill</span>(pid, <span class="variable constant_">SIG_CUSTOM</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">error_handling</span>(<span class="string">&quot;Kill error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Signal sent.\</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接收进程 (<code>receiver.c</code>)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;stdlib.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;signal.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;unistd.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line">#define <span class="variable constant_">SIG_CUSTOM</span> <span class="title class_">SIGUSR1</span>  <span class="comment">// 自定义信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sig_handler</span>(<span class="params">int sig</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == <span class="variable constant_">SIG_CUSTOM</span>) &#123;</span><br><span class="line">        <span class="title function_">printf</span>(<span class="string">&quot;Received custom signal SIGUSR1.\</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    act.<span class="property">sa_handler</span> = sig_handler;</span><br><span class="line">    <span class="title function_">sigemptyset</span>(&amp;act.<span class="property">sa_mask</span>);</span><br><span class="line">    act.<span class="property">sa_flags</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置自定义信号的处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">sigaction</span>(<span class="variable constant_">SIG_CUSTOM</span>, &amp;act, <span class="variable constant_">NULL</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Sigaction error&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;Waiting for signal...\</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">sleep</span>(<span class="number">1</span>);  <span class="comment">// 让程序持续运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gcc sender.<span class="property">c</span> -o sender</span><br><span class="line">gcc receiver.<span class="property">c</span> -o receiver</span><br></pre></td></tr></table></figure>

<p>然后，分别在两个终端窗口中运行编译后的可执行文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">./receiver</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">./sender</span><br></pre></td></tr></table></figure>

<h3 id="3-5、套接字（Sockets）"><a href="#3-5、套接字（Sockets）" class="headerlink" title="3.5、套接字（Sockets）"></a>3.5、套接字（Sockets）</h3><p>套接字（Socket）用于在不同主机或同一主机的不同进程之间进行通信。它是<strong>网络编程中最常用的一种方式</strong>，允许进程通过网络发送和接收数据。</p>
<p>套接字的基本概念：</p>
<ul>
<li><strong>套接字地址：</strong> 套接字由两个地址构成，即 IP 地址和端口号。IP 地址标识网络上的主机，端口号标识主机上的进程。</li>
<li><strong>通信模式：</strong> 套接字可以支持不同的通信模式，包括<strong>面向连接</strong>的和<strong>无连接</strong>的两种主要模式。</li>
<li><strong>数据传输方式：</strong> 套接字可以通过字节流或数据报两种方式传输数据，取决于使用的协议（如 TCP 或 UDP）。</li>
</ul>
<p>本地套接字（Local Socket，也称为 Unix 域套接字）和网络套接字（Network Socket）是两种不同的套接字类型，它们主要在使用场景、实现方式和特性上有所区别。</p>
<p>本地套接字（Local Socket）:</p>
<ul>
<li><strong>使用场景：</strong> 主要用于本地进程间的通信，即在同一台机器上运行的不同进程之间的通信。它们不经过网络协议栈，通信速度更快，适用于需要高效率和安全性的应用场景。</li>
<li><strong>实现方式：</strong> 在文件系统中以文件形式存在，通常位于 <code>/tmp</code> 目录或者系统指定的临时目录下。本地套接字使用文件系统的权限机制来控制访问权限。</li>
<li><strong>地址：</strong> 本地套接字地址是文件系统路径名，通常以文件系统的形式存在，例如 <code>/tmp/mysocket</code>。</li>
<li><strong>优点：</strong> 传输速度快，通信效率高；支持多种协议族（如 UNIX 套接字和 Netlink 套接字等）。</li>
<li><strong>缺点：</strong> 仅限于本地通信，无法跨越网络边界直接进行通信。</li>
</ul>
<p>网络套接字（Network Socket）:</p>
<ul>
<li><strong>使用场景：</strong> 用于网络间的进程通信，可以在不同主机之间进行通信，是实现网络应用的基础。</li>
<li><strong>实现方式：</strong> 使用网络协议栈进行数据传输，通过网络接口进行数据交换。常见的网络套接字有 TCP 套接字和 UDP 套接字等。</li>
<li><strong>地址：</strong> 网络套接字地址由 IP 地址和端口号组成，用于标识网络中的主机和进程。</li>
<li><strong>优点：</strong> 可以实现跨网络的通信，支持广域网（WAN）和局域网（LAN）等不同网络环境下的通信需求。</li>
<li><strong>缺点：</strong> 涉及到网络协议栈的传输，相比本地套接字可能会有一定的传输延迟，同时需要考虑网络安全和稳定性的问题。</li>
</ul>
<p>套接字主要可以根据使用的协议来分类，常见的包括：</p>
<ul>
<li><strong>流套接字（Stream Socket）：</strong> 也称为 <code>SOCK_STREAM</code>，基于 TCP 协议。它提供面向连接的、可靠的数据传输，确保数据按顺序到达目的地，且不丢失、不重复。</li>
<li><strong>数据报套接字（Datagram Socket）：</strong> 也称为 <code>SOCK_DGRAM</code>，基于 UDP 协议。它提供无连接的<a href="https://cloud.tencent.com/product/dts?from_column=20065&from=20065">数据传输服务</a>，数据包可能会丢失或重复，不保证数据的顺序。</li>
<li><strong>原始套接字（Raw Socket）：</strong> 允许直接访问底层网络协议，如 ICMP（用于网络错误报告和诊断）、IGMP（Internet 组管理协议）等。通常需要特殊权限才能使用。</li>
</ul>
<p>在 UNIX 和类 UNIX 系统中，套接字通常使用以下系统调用进行创建、绑定、监听、连接、发送和接收数据等操作：</p>
<ul>
<li><strong><code>socket()</code>：</strong> 创建套接字，返回一个文件描述符。</li>
<li><strong><code>bind()</code>：</strong> 将套接字绑定到一个地址，如 IP 地址和端口号。</li>
<li><strong><code>listen()</code>：</strong> 仅用于流套接字，将套接字标记为被动套接字，等待连接请求。</li>
<li><strong><code>accept()</code>：</strong> 仅用于流套接字，接受客户端的连接请求，返回一个新的文件描述符用于与客户端通信。</li>
<li><strong><code>connect()</code>：</strong> 仅用于流套接字，连接到远程套接字（客户端）。</li>
<li><strong><code>send()</code></strong> <strong>和</strong> <strong><code>recv()</code>：</strong> 发送和接收数据。</li>
<li><strong><code>sendto()</code></strong> <strong>和</strong> <strong><code>recvfrom()</code>：</strong> 用于数据报套接字，发送和接收数据报。</li>
</ul>
<p>示例代码，使用套接字进行基本的客户端-服务器通信：</p>
<p><strong>服务器端 (<code>server.c</code>)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;stdlib.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;string.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;unistd.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;arpa/inet.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;sys/socket.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line">#define <span class="variable constant_">PORT</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    int server_fd, new_socket;</span><br><span class="line">    struct sockaddr_in address;</span><br><span class="line">    int addrlen = <span class="title function_">sizeof</span>(address);</span><br><span class="line">    char buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> char *hello = <span class="string">&quot;Hello from server&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = <span class="title function_">socket</span>(<span class="variable constant_">AF_INET</span>, <span class="variable constant_">SOCK_STREAM</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.<span class="property">sin_family</span> = <span class="variable constant_">AF_INET</span>;</span><br><span class="line">    address.<span class="property">sin_addr</span>.<span class="property">s_addr</span> = <span class="variable constant_">INADDR_ANY</span>;</span><br><span class="line">    address.<span class="property">sin_port</span> = <span class="title function_">htons</span>(<span class="variable constant_">PORT</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字绑定到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">bind</span>(server_fd, (struct sockaddr *)&amp;address, <span class="title function_">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听传入的连接请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">listen</span>(server_fd, <span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Listen failed&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受连接，并处理数据</span></span><br><span class="line">    <span class="keyword">if</span> ((new_socket = <span class="title function_">accept</span>(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Accept failed&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从客户端接收数据，并发送响应</span></span><br><span class="line">    int valread = <span class="title function_">read</span>(new_socket, buffer, <span class="number">1024</span>);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;Received message from client: %s</span></span><br><span class="line"><span class="string">&quot;</span>, buffer);</span><br><span class="line">    <span class="title function_">send</span>(new_socket, hello, <span class="title function_">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;Hello message sent</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端 (<code>client.c</code>)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;stdlib.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;string.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;unistd.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;arpa/inet.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;sys/socket.<span class="property">h</span>&gt;</span><br><span class="line"></span><br><span class="line">#define <span class="variable constant_">PORT</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    int sock = <span class="number">0</span>;</span><br><span class="line">    struct sockaddr_in serv_addr;</span><br><span class="line">    char *hello = <span class="string">&quot;Hello from client&quot;</span>;</span><br><span class="line">    char buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sock = <span class="title function_">socket</span>(<span class="variable constant_">AF_INET</span>, <span class="variable constant_">SOCK_STREAM</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_addr.<span class="property">sin_family</span> = <span class="variable constant_">AF_INET</span>;</span><br><span class="line">    serv_addr.<span class="property">sin_port</span> = <span class="title function_">htons</span>(<span class="variable constant_">PORT</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 IPv4 地址从文本转换为二进制格式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">inet_pton</span>(<span class="variable constant_">AF_INET</span>, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.<span class="property">sin_addr</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Invalid address/ Address not supported&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">connect</span>(sock, (struct sockaddr *)&amp;serv_addr, <span class="title function_">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">perror</span>(<span class="string">&quot;Connection failed&quot;</span>);</span><br><span class="line">        <span class="title function_">exit</span>(<span class="variable constant_">EXIT_FAILURE</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息给服务器</span></span><br><span class="line">    <span class="title function_">send</span>(sock, hello, <span class="title function_">strlen</span>(hello), <span class="number">0</span>);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;Hello message sent to server</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务器的响应</span></span><br><span class="line">    int valread = <span class="title function_">read</span>(sock, buffer, <span class="number">1024</span>);</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6、内存映射文件（Memory-Mapped-Files）"><a href="#3-6、内存映射文件（Memory-Mapped-Files）" class="headerlink" title="3.6、内存映射文件（Memory-Mapped Files）"></a>3.6、内存映射文件（Memory-Mapped Files）</h3><p>内存映射文件（Memory-Mapped Files）是一种高效的文件访问方式，它允许将一个文件的内容直接映射到进程的虚拟内存空间中，使得文件的读取和写入可以像访问内存一样高效。</p>
<p>工作机制：</p>
<ol>
<li><strong>映射创建：</strong> 进程调用 <code>mmap()</code> 系统调用，请求将一个文件的一部分或整个内容映射到自己的虚拟地址空间。<code>mmap()</code> 函数的参数包括文件描述符、映射长度、权限（读、写、执行）、映射标志等。</li>
<li><strong>虚拟内存映射：</strong> 操作系统在进程的虚拟地址空间中创建一段与文件对应的虚拟内存区域，称为内存映射区域。这段虚拟内存区域可能会与文件的一部分或整个文件内容对应，取决于映射时指定的长度。</li>
<li><strong>页表映射：</strong> 操作系统通过页表将虚拟内存区域映射到实际物理内存或者交换空间中。初始时，虚拟内存区域的页面可能并没有实际的物理内存页，而是指向文件中相应位置的数据。</li>
<li><strong>文件访问：</strong> 当进程访问内存映射区域时，如果数据尚未加载到物理内存，则操作系统会将文件中对应部分数据读取到物理内存中的页中。这样，进程就可以通过对内存映射区域的读写操作，实现对文件内容的读写。</li>
<li><strong>同步与更新：</strong> 内存映射文件的修改会直接影响到对应文件的内容，即使文件内容被修改也会反映在内存中。操作系统提供 <code>msync()</code> 函数来同步内存映射区域的修改到文件中，或者在不同进程间共享修改后的数据。</li>
<li><strong>释放映射：</strong> 当不再需要内存映射文件时，进程可以调用 <code>munmap()</code> 函数释放映射，操作系统会取消虚拟地址空间中的映射关系，并根据需要更新文件的修改到磁盘上。</li>
</ol>
<p>关键特点：</p>
<ul>
<li><strong>高效访问：</strong> 内存映射文件允许直接将文件内容映射到内存，避免了传统的读取和写入系统调用的性能开销，提高了文件访问的效率。</li>
<li><strong>共享文件：</strong> 多个进程可以将同一个文件映射到它们的地址空间中，实现共享文件内容。</li>
<li><strong>透明性：</strong> 对内存映射区域的访问操作看起来像对内存的操作，对程序员来说更为方便和直观。</li>
<li><strong>实时更新：</strong> 内存映射文件的修改可以即时反映到文件本身，或者共享给其他进程，无需额外的文件读写操作。</li>
</ul>
<p>应用场景：</p>
<ul>
<li><strong>数据库系统：</strong> 数据库可以使用内存映射文件来直接操作数据文件，提高读写性能。</li>
<li><strong>文件编辑器：</strong> 文本编辑器可以使用内存映射文件来处理大文件，支持快速的搜索和修改操作。</li>
<li><a href="https://cloud.tencent.com/product/mmp?from_column=20065&from=20065"><strong>多媒体处理</strong></a><strong>：</strong> 多媒体应用程序可以使用内存映射文件来处理大文件的读写，如音频和视频文件。</li>
<li><strong>共享内存：</strong> 进程间通信时，可以使用共享的内存映射文件来传递数据，提高通信效率。</li>
</ul>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>进程间通信（IPC）作为现代计算系统中重要的组成部分，扮演着确保多进程协作顺利进行的关键角色。本文从IPC的基本概念出发，深入探讨了多种经典和高级IPC机制的原理、优缺点及实际应用场景。</p>
<p>IPC是在多进程环境中实现进程间通信的关键技术，涉及数据共享、任务协调和状态更新等多个方面。有效的IPC机制可以提高系统性能和响应速度，确保数据的一致性和安全性，是现代计算系统中不可或缺的部分。</p>
<p>学习书籍：</p>
<ul>
<li><strong>《Unix Network Programming, Volume 2: Interprocess Communications》</strong> ：经典的UNIX网络编程系列之一，深入讲解了多种IPC机制，特别是套接字和UNIX域套接字等网络IPC方式。</li>
<li><strong>《Advanced Programming in the UNIX Environment》</strong> ：另一本经典的UNIX编程书籍，详细介绍了UNIX系统编程的方方面面，包括IPC机制。</li>
<li><strong>《****Linux</strong> <strong>System Programming: Talking Directly to the</strong> <strong>Kernel</strong> <strong>and C Library》</strong> ：强调Linux系统编程的技术书籍，包括IPC、信号处理、共享内存等方面的深入讲解。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>多进程编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2025/01/12/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>Lambda 表达式</strong>是一种轻量级的函数对象（或匿名函数），可以在代码中定义并直接使用。它是从 C++11 引入的功能，常用于需要定义短小函数的场景，比如多线程、STL 算法或回调函数中。</p>
<hr>
<h2 id="1-Lambda-表达式的基本语法"><a href="#1-Lambda-表达式的基本语法" class="headerlink" title="1. Lambda 表达式的基本语法"></a><strong>1. Lambda 表达式的基本语法</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>捕获列表</code>**：定义 lambda 可以捕获哪些变量，以及如何捕获（按值或按引用）。</li>
<li>**<code>参数列表</code>**：和普通函数类似，定义函数的参数。</li>
<li>**<code>返回类型</code>**：可选，通常由编译器自动推断。</li>
<li>**<code>函数体</code>**：函数的逻辑部分。</li>
</ul>
<hr>
<h2 id="2-Lambda-表达式的基本示例"><a href="#2-Lambda-表达式的基本示例" class="headerlink" title="2. Lambda 表达式的基本示例"></a><strong>2. Lambda 表达式的基本示例</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最简单的 Lambda</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, Lambda!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda</span>(); <span class="comment">// 调用 lambda</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的 Lambda</span></span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, Lambda!</span><br><span class="line">Sum: 8</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-捕获列表"><a href="#3-捕获列表" class="headerlink" title="3. 捕获列表"></a><strong>3. 捕获列表</strong></h2><p>Lambda 可以通过 <strong>捕获列表</strong> 访问外部变量。捕获列表控制外部变量的作用域和捕获方式。</p>
<h3 id="1-按值捕获"><a href="#1-按值捕获" class="headerlink" title="(1) 按值捕获"></a><strong>(1) 按值捕获</strong></h3><ul>
<li>Lambda 会复制外部变量的值。</li>
<li>外部变量的值在 Lambda 定义时捕获，不受后续修改影响。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> byValue = [x] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Captured by value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">20</span>; <span class="comment">// 修改外部变量</span></span><br><span class="line">    <span class="built_in">byValue</span>(); <span class="comment">// 输出仍然是 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Captured by value: 10</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-按引用捕获"><a href="#2-按引用捕获" class="headerlink" title="(2) 按引用捕获"></a><strong>(2) 按引用捕获</strong></h3><ul>
<li>Lambda 捕获外部变量的引用，因此可以修改外部变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> byReference = [&amp;x] &#123;</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Captured by reference: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">byReference</span>(); <span class="comment">// 修改了 x</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Captured by reference: 20</span><br><span class="line">Modified x: 20</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-捕获所有变量"><a href="#3-捕获所有变量" class="headerlink" title="(3) 捕获所有变量"></a><strong>(3) 捕获所有变量</strong></h3><ul>
<li><strong>按值捕获所有变量</strong>：使用 <code>[=]</code>。</li>
<li><strong>按引用捕获所有变量</strong>：使用 <code>[&amp;]</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> captureAllByValue = [=] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> captureAllByReference = [&amp;] &#123;</span><br><span class="line">        x += <span class="number">5</span>;</span><br><span class="line">        y += <span class="number">5</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">captureAllByValue</span>(); <span class="comment">// 按值捕获，不影响外部变量</span></span><br><span class="line">    <span class="built_in">captureAllByReference</span>(); <span class="comment">// 按引用捕获，修改外部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x: 10, y: 20</span><br><span class="line">Modified x: 15, y: 25</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Lambda-的返回类型"><a href="#4-Lambda-的返回类型" class="headerlink" title="4. Lambda 的返回类型"></a><strong>4. Lambda 的返回类型</strong></h2><h3 id="1-自动推断返回类型"><a href="#1-自动推断返回类型" class="headerlink" title="(1) 自动推断返回类型"></a><strong>(1) 自动推断返回类型</strong></h3><ul>
<li>如果函数体只有一条 <code>return</code> 语句，返回类型会自动推断。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b; <span class="comment">// 自动推断为 int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-显式指定返回类型"><a href="#2-显式指定返回类型" class="headerlink" title="(2) 显式指定返回类型"></a><strong>(2) 显式指定返回类型</strong></h3><ul>
<li>如果返回类型不能自动推断，可以显式指定。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="type">double</span>)a / b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="5-Lambda-在-STL-中的使用"><a href="#5-Lambda-在-STL-中的使用" class="headerlink" title="5. Lambda 在 STL 中的使用"></a><strong>5. Lambda 在 STL 中的使用</strong></h2><p>Lambda 通常用作回调函数，尤其在 STL 算法中非常常见。</p>
<h3 id="1-用于-std-sort"><a href="#1-用于-std-sort" class="headerlink" title="(1) 用于 std::sort"></a><strong>(1) 用于 <code>std::sort</code></strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式自定义排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 按降序排序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5 3 2 1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-用于-std-for-each"><a href="#2-用于-std-for-each" class="headerlink" title="(2) 用于 std::for_each"></a><strong>(2) 用于 <code>std::for_each</code></strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并打印每个元素</span></span><br><span class="line">    std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-带状态的-Lambda"><a href="#6-带状态的-Lambda" class="headerlink" title="6. 带状态的 Lambda"></a><strong>6. 带状态的 Lambda</strong></h2><ul>
<li>Lambda 本质是一个函数对象，因此它可以存储状态。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [counter]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter; <span class="comment">// 由于捕获的是值，必须加 `mutable` 才能修改</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">increment</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">increment</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><strong>Lambda 表达式</strong>是一种简洁的方式定义匿名函数，非常适合短小的逻辑。</li>
<li><strong>捕获列表</strong>允许访问外部变量，通过值或引用捕获，甚至可以捕获所有变量。</li>
<li>在现代 C++ 中，Lambda 经常用于 STL 算法、多线程、回调等场景，是高效编写代码的重要工具。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Github拒绝push</title>
    <url>/2024/09/19/Github%E6%8B%92%E7%BB%9Dpush/</url>
    <content><![CDATA[<h2 id="Github-拒绝了你的push"><a href="#Github-拒绝了你的push" class="headerlink" title="Github 拒绝了你的push"></a>Github 拒绝了你的push</h2><p>你有没有出现以下问题？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ! [remote rejected] HEAD -&gt; main (push declined due to repository rule violations)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/cmzcc/cmzcc.github.io.git&#x27;</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教"><a href="#今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教" class="headerlink" title="今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教."></a>今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教.</h4><h3 id="1-出现问题的原因"><a href="#1-出现问题的原因" class="headerlink" title="1.出现问题的原因"></a>1.出现问题的原因</h3><h4 id="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用"><a href="#出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用" class="headerlink" title="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用."></a>出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用.</h4><h4 id="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用"><a href="#我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用" class="headerlink" title="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用."></a>我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用.</h4><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><h4 id="（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下"><a href="#（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下" class="headerlink" title="（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下."></a>（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下.</h4><h4 id="（2）找到你放网站的仓库，add-file看到没有"><a href="#（2）找到你放网站的仓库，add-file看到没有" class="headerlink" title="（2）找到你放网站的仓库，add file看到没有"></a>（2）找到你放网站的仓库，add file看到没有</h4><h4 id="然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去-（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"><a href="#然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去-（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）" class="headerlink" title="然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去.（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"></a>然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去.（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）</h4><h4 id="等上传完毕后，不要退出！！！"><a href="#等上传完毕后，不要退出！！！" class="headerlink" title="等上传完毕后，不要退出！！！"></a>等上传完毕后，不要退出！！！</h4><h4 id="点下面的提交即可，你的网站就水灵灵的更新啦"><a href="#点下面的提交即可，你的网站就水灵灵的更新啦" class="headerlink" title="点下面的提交即可，你的网站就水灵灵的更新啦."></a>点下面的提交即可，你的网站就水灵灵的更新啦.</h4>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>error</tag>
        <tag>hexo</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Rangers库</title>
    <url>/2025/10/06/Rangers%E5%BA%93/</url>
    <content><![CDATA[<p> 好的，我们来详细聊聊 C++20 引入的 <strong>Ranges 库</strong>。</p>
<p>Ranges 库是 C++20 中一个非常重要的特性，它彻底改变了我们在 C++ 中处理序列（集合、容器）的方式。它的核心思想是提供一种<strong>组合式 (composable)<strong>、</strong>声明式 (declarative)<strong>、</strong>惰性求值 (lazy evaluation)</strong> 的方式来操作数据序列，从而使得代码更简洁、更易读、更安全、更高效。</p>
<h3 id="1-为什么需要-Ranges-库？"><a href="#1-为什么需要-Ranges-库？" class="headerlink" title="1. 为什么需要 Ranges 库？"></a>1. 为什么需要 Ranges 库？</h3><p>在 C++20 之前，我们主要使用标准库算法（如 <code>std::for_each</code>, <code>std::transform</code>, <code>std::sort</code> 等）配合迭代器对来操作序列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// for std::transform, std::for_each</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>   <span class="comment">// for std::iota</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// nums: &#123;1, 2, ..., 10&#125;</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; squares;</span><br><span class="line">    squares.<span class="built_in">reserve</span>(nums.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 转换：计算平方</span></span><br><span class="line">    std::<span class="built_in">transform</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),</span><br><span class="line">                   std::<span class="built_in">back_inserter</span>(squares), <span class="comment">// 输出迭代器</span></span><br><span class="line">                   [](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n * n; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 过滤：只保留偶数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; even_squares;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s : squares) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            even_squares.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 打印</span></span><br><span class="line">    std::for_each(even_squares.<span class="built_in">begin</span>(), even_squares.<span class="built_in">end</span>(),</span><br><span class="line">                  [](<span class="type">int</span> n) &#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 4 16 36 64 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然可以工作，但存在一些问题：</p>
<ul>
<li><strong>冗长和重复：</strong> 每次操作都需要 <code>begin()</code> 和 <code>end()</code> 迭代器，并且需要显式地创建中间容器（<code>squares</code>, <code>even_squares</code>）。</li>
<li><strong>非组合式：</strong> 多个操作链式调用时，需要嵌套或使用临时变量，可读性差。</li>
<li><strong>即时求值：</strong> 每个算法都会立即执行并生成新的数据，可能导致不必要的内存分配和计算。</li>
<li><strong>迭代器&#x2F;哨兵对的复杂性：</strong> 对于初学者来说，迭代器对的概念有时比较抽象，容易出错。</li>
</ul>
<p>Ranges 库旨在解决这些痛点，提供一种更现代、更函数式、更 C++ 的方式来处理序列。</p>
<h3 id="2-Ranges-库的核心概念"><a href="#2-Ranges-库的核心概念" class="headerlink" title="2. Ranges 库的核心概念"></a>2. Ranges 库的核心概念</h3><p>Ranges 库主要由以下几个核心概念组成：</p>
<h4 id="2-1-Range-范围"><a href="#2-1-Range-范围" class="headerlink" title="2.1 Range (范围)"></a>2.1 Range (范围)</h4><p>一个 <strong>Range</strong> 是一个可以被迭代器对 <code>[begin(), end())</code> 访问的序列。简单来说，任何可以用于范围 <code>for</code> 循环的东西都是一个 Range。<br>标准库容器（<code>std::vector</code>, <code>std::list</code>, <code>std::array</code>）、C 风格数组、<code>std::string</code> 等都是 Range。</p>
<h4 id="2-2-View-视图"><a href="#2-2-View-视图" class="headerlink" title="2.2 View (视图)"></a>2.2 View (视图)</h4><p><strong>View</strong> 是 Ranges 库的魔法所在。它是一个<strong>轻量级</strong>、<strong>非拥有 (non-owning)</strong> 的 Range，它通过<strong>惰性求值</strong>的方式对底层数据进行转换、过滤等操作。View 本身不存储数据，它只是提供了对底层数据的“视图”或“投影”。</p>
<p>View 的关键特性：</p>
<ul>
<li><strong>惰性求值：</strong> 只有当真正需要访问元素时，View 才会执行其转换逻辑。</li>
<li><strong>非拥有：</strong> View 不管理底层数据的生命周期。</li>
<li><strong>O(1) 复制&#x2F;移动：</strong> 复制或移动 View 对象非常廉价，因为它只包含少量状态（通常是迭代器）。</li>
<li><strong>可组合性：</strong> View 可以通过管道操作符 <code>|</code> 像 Unix 管道一样链式组合起来。</li>
</ul>
<h4 id="2-3-Range-Adaptor-范围适配器"><a href="#2-3-Range-Adaptor-范围适配器" class="headerlink" title="2.3 Range Adaptor (范围适配器)"></a>2.3 Range Adaptor (范围适配器)</h4><p><strong>Range Adaptor</strong> 是用于创建 View 的函数对象。它们接受一个 Range 作为输入，并返回一个新的 View。<br>例如：<code>std::views::filter</code>, <code>std::views::transform</code>, <code>std::views::take</code>, <code>std::views::drop</code>, <code>std::views::reverse</code> 等。</p>
<h4 id="2-4-Range-Algorithm-范围算法"><a href="#2-4-Range-Algorithm-范围算法" class="headerlink" title="2.4 Range Algorithm (范围算法)"></a>2.4 Range Algorithm (范围算法)</h4><p>Range 算法是标准库算法的“Range-aware”版本。它们接受一个 Range 作为参数，而不是迭代器对。<br>例如：<code>std::ranges::sort</code>, <code>std::ranges::find</code>, <code>std::ranges::for_each</code> 等。</p>
<h3 id="3-如何使用-Ranges-库？"><a href="#3-如何使用-Ranges-库？" class="headerlink" title="3. 如何使用 Ranges 库？"></a>3. 如何使用 Ranges 库？</h3><p>使用 Ranges 库，上面的例子可以改写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span> <span class="comment">// 引入 Ranges 库的主要头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// nums: &#123;1, 2, ..., 10&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Ranges 库进行链式操作</span></span><br><span class="line">    <span class="keyword">auto</span> result_view = nums</span><br><span class="line">                     | std::views::<span class="built_in">transform</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n * n; &#125;) <span class="comment">// 计算平方</span></span><br><span class="line">                     | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;); <span class="comment">// 过滤偶数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 惰性求值：此时 result_view 还没有真正计算任何东西</span></span><br><span class="line">    <span class="comment">// 只有在迭代时才会执行计算</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Even squares: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : result_view) &#123; <span class="comment">// 遍历 View，触发计算</span></span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 4 16 36 64 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你也可以将 View 转换为实际的容器</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">final_vec</span><span class="params">(result_view.begin(), result_view.end())</span></span>;</span><br><span class="line">    <span class="comment">// 或者更简洁 (C++23)</span></span><br><span class="line">    <span class="comment">// std::vector&lt;int&gt; final_vec = result_view | std::ranges::to&lt;std::vector&gt;();</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : final_vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 4 16 36 64 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，代码变得：</p>
<ul>
<li><strong>更简洁：</strong> 没有 <code>begin()</code>, <code>end()</code>, <code>back_inserter</code> 和中间容器。</li>
<li><strong>更可读：</strong> 管道操作符 <code>|</code> 使得操作流程一目了然，从左到右依次应用。</li>
<li><strong>更高效：</strong> 避免了不必要的中间容器分配和数据复制。</li>
</ul>
<h3 id="4-常见的-Range-Adaptors"><a href="#4-常见的-Range-Adaptors" class="headerlink" title="4. 常见的 Range Adaptors"></a>4. 常见的 Range Adaptors</h3><p><code>std::views</code> 命名空间下提供了大量的 Range Adaptors：</p>
<ul>
<li><p><strong>转换 (Transformation):</strong></p>
<ul>
<li><code>std::views::transform(func)</code>: 对每个元素应用函数。</li>
<li><code>std::views::elements&lt;N&gt;()</code> (C++23): 从元组或结构体中提取第 N 个元素。</li>
<li><code>std::views::keys()</code>, <code>std::views::values()</code> (C++23): 从 <code>std::map</code> 等中提取键或值。</li>
</ul>
</li>
<li><p><strong>过滤 (Filtering):</strong></p>
<ul>
<li><code>std::views::filter(pred)</code>: 只保留满足谓词的元素。</li>
<li><code>std::views::take_while(pred)</code>: 从开头取满足谓词的元素，直到不满足为止。</li>
<li><code>std::views::drop_while(pred)</code>: 从开头丢弃满足谓词的元素，直到不满足为止。</li>
<li><code>std::views::take(n)</code>: 取前 <code>n</code> 个元素。</li>
<li><code>std::views::drop(n)</code>: 丢弃前 <code>n</code> 个元素。</li>
</ul>
</li>
<li><p><strong>组合 (Composition):</strong></p>
<ul>
<li><code>std::views::join</code>: 将一个 Range of Ranges 扁平化为一个 Range。</li>
<li><code>std::views::zip</code> (C++23): 将多个 Range 的元素按索引组合成元组。</li>
<li><code>std::views::cartesian_product</code> (C++23): 计算多个 Range 的笛卡尔积。</li>
</ul>
</li>
<li><p><strong>生成 (Generation):</strong></p>
<ul>
<li><code>std::views::iota(start, end)</code>: 生成一个整数序列。</li>
<li><code>std::views::repeat(val, count)</code> (C++23): 重复生成一个值。</li>
<li><code>std::views::empty&lt;T&gt;()</code>: 生成一个空的 Range。</li>
</ul>
</li>
<li><p><strong>其他 (Miscellaneous):</strong></p>
<ul>
<li><code>std::views::reverse</code>: 反转 Range。</li>
<li><code>std::views::counted(it, n)</code>: 从迭代器 <code>it</code> 开始，取 <code>n</code> 个元素。</li>
<li><code>std::views::common</code>: 将 Range 转换为具有相同迭代器和哨兵类型的 Range。</li>
<li><code>std::views::split</code> (C++23): 按分隔符分割 Range。</li>
<li><code>std::views::slide</code> (C++23): 创建滑动窗口。</li>
</ul>
</li>
</ul>
<h4 id="示例：更多-Range-Adaptors"><a href="#示例：更多-Range-Adaptors" class="headerlink" title="示例：更多 Range Adaptors"></a>示例：更多 Range Adaptors</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 过滤偶数，取前3个，然后平方</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Filtered, taken, squared: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : numbers</span><br><span class="line">                   | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;) <span class="comment">// 2, 4, 6, 8, 10</span></span><br><span class="line">                   | std::views::<span class="built_in">take</span>(<span class="number">3</span>)                                 <span class="comment">// 2, 4, 6</span></span><br><span class="line">                   | std::views::<span class="built_in">transform</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n * n; &#125;)) &#123; <span class="comment">// 4, 16, 36</span></span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// Output: 4 16 36</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 反转并跳过前3个</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reversed, dropped: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : numbers</span><br><span class="line">                   | std::views::reverse <span class="comment">// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span></span><br><span class="line">                   | std::views::<span class="built_in">drop</span>(<span class="number">3</span>)) &#123; <span class="comment">// 7, 6, 5, 4, 3, 2, 1</span></span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// Output: 7 6 5 4 3 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生成序列 (iota)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iota view: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : std::views::<span class="built_in">iota</span>(<span class="number">10</span>, <span class="number">15</span>)) &#123; <span class="comment">// 10, 11, 12, 13, 14</span></span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// Output: 10 11 12 13 14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 字符串分割 (C++23)</span></span><br><span class="line">    <span class="comment">// std::string sentence = &quot;hello world how are you&quot;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Split view: &quot;;</span></span><br><span class="line">    <span class="comment">// for (auto word_view : sentence | std::views::split(&#x27; &#x27;)) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; std::string(word_view.begin(), word_view.end()) &lt;&lt; &quot; | &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl; // Output: hello | world | how | are | you |</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 使用 std::views::zip (C++23)</span></span><br><span class="line">    <span class="comment">// std::vector&lt;std::string&gt; names = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;;</span></span><br><span class="line">    <span class="comment">// std::vector&lt;int&gt; ages = &#123;30, 25, 35&#125;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Zipped view: &quot;;</span></span><br><span class="line">    <span class="comment">// for (auto [name, age] : std::views::zip(names, ages)) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;(&quot; &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; age &lt;&lt; &quot;) &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl; // Output: (Alice, 30) (Bob, 25) (Charlie, 35)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 使用 std::views::keys / std::views::values (C++23)</span></span><br><span class="line">    <span class="comment">// std::map&lt;std::string, int&gt; scores = &#123;&#123;&quot;Alice&quot;, 90&#125;, &#123;&quot;Bob&quot;, 85&#125;, &#123;&quot;Charlie&quot;, 92&#125;&#125;;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Map keys: &quot;;</span></span><br><span class="line">    <span class="comment">// for (const auto&amp; key : scores | std::views::keys) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; key &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl; // Output: Alice Bob Charlie</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;Map values: &quot;;</span></span><br><span class="line">    <span class="comment">// for (int score : scores | std::views::values) &#123;</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; score &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl; // Output: 90 85 92</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Range-Algorithms"><a href="#5-Range-Algorithms" class="headerlink" title="5. Range Algorithms"></a>5. Range Algorithms</h3><p><code>std::ranges</code> 命名空间下的算法是传统的 <code>std::algorithm</code> 的 Range-aware 版本。它们可以直接接受 Range 作为参数，而无需 <code>begin()</code> 和 <code>end()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span>       <span class="comment">// for ranges::sort, ranges::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// for ranges::sort, ranges::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>      <span class="comment">// for std::iota</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序整个 vector</span></span><br><span class="line">    std::ranges::<span class="built_in">sort</span>(data);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted data: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : data) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// Output: 1 2 4 5 8 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::ranges::<span class="built_in">find</span>(data, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != data.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found 8 at index: &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(data.<span class="built_in">begin</span>(), it) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结合 View 和 Algorithm</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// 1, 2, ..., 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第一个大于 5 的偶数</span></span><br><span class="line">    <span class="keyword">auto</span> result_it = std::ranges::<span class="built_in">find_if</span>(</span><br><span class="line">        numbers | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;), <span class="comment">// 2, 4, 6, 8, 10</span></span><br><span class="line">        [](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n &gt; <span class="number">5</span>; &#125; <span class="comment">// 找到 6</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result_it != std::<span class="built_in">end</span>(numbers | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;))) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First even number greater than 5: &quot;</span> &lt;&lt; *result_it &lt;&lt; std::endl; <span class="comment">// Output: 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Ranges-库的优势总结"><a href="#6-Ranges-库的优势总结" class="headerlink" title="6. Ranges 库的优势总结"></a>6. Ranges 库的优势总结</h3><ul>
<li><strong>高可读性：</strong> 管道操作符 <code>|</code> 使得数据流向和操作顺序清晰明了。</li>
<li><strong>简洁性：</strong> 减少了 <code>begin()</code>, <code>end()</code>, 临时变量和循环的样板代码。</li>
<li><strong>惰性求值：</strong> 避免了不必要的中间数据结构和计算，提高了性能和内存效率。</li>
<li><strong>组合性：</strong> 各种 View 可以灵活地组合，实现复杂的逻辑。</li>
<li><strong>通用性：</strong> 适用于任何满足 Range 概念的序列，包括自定义容器。</li>
<li><strong>安全性：</strong> 减少了迭代器错误和边界错误的可能性。</li>
<li><strong>函数式编程风格：</strong> 鼓励声明式编程，更关注“做什么”而不是“怎么做”。</li>
</ul>
<h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a>7. 注意事项</h3><ul>
<li><strong>生命周期管理：</strong> View 是非拥有的，它只是底层数据的视图。确保底层数据在 View 的生命周期内是有效的，否则会导致悬空引用和未定义行为。</li>
<li><strong>编译时间：</strong> 复杂的 Ranges 管道可能会增加编译时间，但通常可以接受。</li>
<li><strong>学习曲线：</strong> 对于习惯了传统迭代器&#x2F;算法的开发者来说，Ranges 库可能需要一些时间来适应其新的编程范式。</li>
</ul>
<p>Ranges 库是 C++ 泛型编程演进的重要一步，它使得 C++ 能够以更现代、更富有表现力的方式处理数据序列。在 C++20 及以后的项目中，强烈推荐使用 Ranges 库来简化和优化你的代码。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++20</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和UDP</title>
    <url>/2025/06/22/TCP%E5%92%8CUDP/</url>
    <content><![CDATA[<p>期末月叠加面试真是嘎嘎上压力，周二快手一面，呜呜呜，我要当手孝子。</p>
<p>我们一般说网络有七层，是指OSI模型，从下到上依次为：</p>
<ol>
<li>物理层 (Physical Layer)</li>
<li>数据链路层 (Data Link Layer)</li>
<li>网络层 (Network Layer)</li>
<li>传输层 (Transport Layer)</li>
<li>会话层 (Session Layer)</li>
<li>表示层 (Presentation Layer)</li>
<li>应用层 (Application Layer)</li>
</ol>
<p>而实际上我们采用的都是TCP&#x2F;IP模型，只有四层（有时也说五层）</p>
<p>从下到上依次为：</p>
<ol>
<li>网络接口层，也叫链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>应用层</li>
</ol>
<p>五层模型将网络接口层拆开，分为物理层、数据链路层</p>
<p>而TCP和UDP都是两种常见的传输层协议</p>
<h2 id="TCP-面向连接的，可靠的，基于字节流的传输层通信协议"><a href="#TCP-面向连接的，可靠的，基于字节流的传输层通信协议" class="headerlink" title="TCP:面向连接的，可靠的，基于字节流的传输层通信协议"></a>TCP:面向连接的，可靠的，基于字节流的传输层通信协议</h2><ul>
<li>tcp是一种面向连接的协议，在通信之前要在发送方和接收方之间建立连接，然后通信结束后关闭连接。建立和关闭的过程被称为三次握手和四次挥手，确保数据的可靠传输。</li>
<li>可靠性：它使用序列号和确认机制来确保数据包的有序性和完整性，如果数据包丢失或者损坏，tcp会重新发送丢失的数据包，直到接收方正确接收为止。</li>
<li>流量控制和拥塞控制：TCP采用流量控制和拥塞控制算法，确保数据发送的速率不会超过接收方的接收能力，并防止网络拥塞</li>
<li>有序传输：TCP确保数据包按照发送的顺序到达，并在接收方重新组装成正确的顺序</li>
<li>适用于可靠传输的场景：文件传输，电子邮件，网页浏览</li>
</ul>
<h2 id="UDP：无连接的，不可靠的，基于数据报的传输层通信协议"><a href="#UDP：无连接的，不可靠的，基于数据报的传输层通信协议" class="headerlink" title="UDP：无连接的，不可靠的，基于数据报的传输层通信协议"></a>UDP：无连接的，不可靠的，基于数据报的传输层通信协议</h2><ul>
<li>UDP是一种无连接的协议，与tcp不同，UDP在通信之前不需要建立连接，直接发送数据包，使得UDP比TCP更加轻量级</li>
<li>不可靠性：UDP不提供可靠的数据传输。它发送数据包之后不会关心数据包是否会到达接收方，因此，如果数据包丢失或者损坏，UDP不会重新发送，也不会提供确认机制</li>
<li>速度较快：没有连接建立和确认过程，UDP传输速度较快，适用于实时传输，如实时音频，和视频流</li>
<li>无序传输：UDP不保证数据包的有序性，因此接收方接收到的数据包是无序的</li>
<li>适用于实时传输的场景：UDP适用于对数据传输可靠性不高的场景，如实时游戏、流媒体等，其中实时性比准确性更重要</li>
</ul>
<h1 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h1><ol>
<li><p><strong>连接性</strong>：</p>
<ul>
<li>TCP：面向连接，通信前需建立三次握手，确保可靠连接。</li>
<li>UDP：无连接，直接发送数据，无需建立连接。</li>
</ul>
</li>
<li><p><strong>可靠性</strong>：</p>
<ul>
<li>TCP：提供可靠传输，通过序列号、确认机制、重传机制和流量控制确保数据无丢失、无差错、按序到达。</li>
<li>UDP：不可靠，无确认机制，数据可能丢失、乱序或重复。</li>
</ul>
</li>
<li><p><strong>传输效率</strong>：</p>
<ul>
<li>TCP：因有连接建立、确认和重传等机制，效率较低，延迟较高。</li>
<li>UDP：无额外开销，效率高，延迟低，适合实时传输。</li>
</ul>
</li>
<li><p><strong>数据传输方式</strong>：</p>
<ul>
<li>TCP：基于字节流，无消息边界，数据按流传输。</li>
<li>UDP：基于数据报，保留消息边界，每个数据报独立。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>TCP：适合需要高可靠性的场景，如 HTTP、FTP、SMTP（网页浏览、文件传输、邮件）。</li>
<li>UDP：适合实时性要求高、允许少量丢包的场景，如视频流、语音通话（VoIP）、DNS 查询、游戏。</li>
</ul>
</li>
<li><p><strong>服务形式</strong>：</p>
<ul>
<li>TCP提供一对一的全双工通信，确保数据按序、无差错、无丢失地传输。</li>
<li>UDP支持一对一、一对多（多播）、多对多通信，适合广播或多播场景。</li>
</ul>
</li>
<li><p><strong>分片方式</strong>：</p>
<p>TCP</p>
<ul>
<li>数据以<strong>字节流</strong>形式传输，无明确的消息边界。</li>
<li>分片由 TCP 协议栈自动处理，将数据分割为适合的段（Segment），每个段包含序列号以确保按序重组。</li>
<li>分片大小根据最大段大小（MSS, Maximum Segment Size）动态调整，通常由网络 MTU（最大传输单元）决定。</li>
<li>接收端会根据序列号重组数据流，处理乱序或丢失的段。</li>
</ul>
<p>UDP</p>
<ul>
<li>数据以<strong>数据报</strong>形式传输，每个数据报独立，保留消息边界。</li>
<li>分片由应用层或网络层（IP层）处理，UDP 本身不对数据报分片。</li>
<li>如果 UDP 数据报大小超过 MTU，IP 层会进行分片，接收端由 IP 层重组。</li>
<li>UDP 不负责乱序或丢失的数据报重组，应用层需自行处理。</li>
</ul>
</li>
</ol>
<h2 id="TCP的重传机制是如何实现的"><a href="#TCP的重传机制是如何实现的" class="headerlink" title="TCP的重传机制是如何实现的"></a>TCP的重传机制是如何实现的</h2><p>在TCP通信中，每个发送的字节都有唯一的序号，而每一个接收的字节都有一个ack确认号。发送方维护了一个发送窗口，接收方维护了一个接收窗口，发送方发送完数据后等待接收方的确认。</p>
<p>数据发送失败后有两个重传机制，一个是超时重传，一个是快重传。</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>发送方为每一个发送的数据设置一个定时器，这个定时器的时长称为超时时间（RTO,是根据往返时间RTT确定的）。发送方假设在这个RTO时间内，数据能够到达接收方并得到确认，如果在超时时间内没有收到确认ack信号，发送方就认为数据丢包或者损坏，触发超时重传。<strong>超时后，发送方重传未确认的最早数据段，并调整拥塞窗口（通常降为1 MSS，进入慢启动）。</strong></p>
<p><strong>缺点</strong>：</p>
<ul>
<li>RTO较长，延迟高。</li>
<li>进入慢启动</li>
</ul>
<p>适用于连续丢包或者网络严重拥塞</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><ul>
<li><p>接收方收到乱序数据段（Out-of-Order），重复发送最近确认的ACK（即期望的下一个字节序号）。</p>
</li>
<li><p>发送方收到3个相同ACK，推测该ACK后的数据段丢失，立即重传。</p>
</li>
<li><p>快重传常与快恢复（Fast Recovery）结合：</p>
<ul>
<li>拥塞窗口减半（cwnd&#x3D;cwnd&#x2F;2+3⋅MSS），进入快速恢复而非慢启动。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>比慢重传快，减少不必要的等待。</li>
<li>结合快速恢复，拥塞控制更平滑。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>需足够重复ACK（至少3个），对大量丢包或尾部丢包效果差。</li>
<li>可能误判（重复ACK可能由重排序引起）。</li>
</ul>
</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h4 id="流量控制的核心机制：滑动窗口"><a href="#流量控制的核心机制：滑动窗口" class="headerlink" title="流量控制的核心机制：滑动窗口"></a>流量控制的核心机制：滑动窗口</h4><ul>
<li><strong>定义</strong>：TCP使用<strong>滑动窗口协议</strong>（Sliding Window Protocol）实现流量控制。接收方通过通告窗口大小（Advertised Window，简称rwnd）限制发送方的发送速率。</li>
<li>原理：<ul>
<li>接收方在TCP报头中携带<strong>窗口大小字段</strong>（16位，单位字节），告知发送方其接收缓冲区剩余容量。</li>
<li>发送方根据接收方的窗口大小（rwnd）和拥塞窗口（cwnd）选择实际发送窗口：Effective Window&#x3D;min⁡(rwnd,cwnd)Effective Window&#x3D;min(rwnd,cwnd)</li>
<li>发送方只能发送未确认数据和窗口允许的数据量，确保不超过接收方处理能力。</li>
</ul>
</li>
<li>滑动窗口运作：<ul>
<li>窗口随ACK左移，释放已确认数据的空间。</li>
<li>接收方处理数据后，窗口右移，通告新的rwnd。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-实现步骤"><a href="#2-实现步骤" class="headerlink" title="2. 实现步骤"></a>2. 实现步骤</h4><ol>
<li>接收方通告窗口<ul>
<li>接收方在每次ACK中携带rwnd，反映其缓冲区可用空间。</li>
<li>初始rwnd由接收方缓冲区大小决定（典型为几KB到几十KB）。</li>
</ul>
</li>
<li>发送方调整发送速率：<ul>
<li>发送方根据rwnd动态调整未确认数据量（in-flight data）。</li>
<li>若rwnd&#x3D;0，发送方暂停发送，但可发送1字节<strong>探测包</strong>（Zero Window Probe）检查窗口是否恢复。</li>
</ul>
</li>
<li>窗口更新：<ul>
<li>接收方处理缓冲区数据后，发送新的ACK，更新rwnd。</li>
<li>若rwnd增大，发送方恢复或增加发送。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-关键特性"><a href="#3-关键特性" class="headerlink" title="3. 关键特性"></a>3. 关键特性</h4><ul>
<li>动态调整：<ul>
<li>rwnd随接收方缓冲区状态实时变化，适应应用层处理速度。</li>
</ul>
</li>
<li>防止缓冲区溢出：<ul>
<li>确保发送数据量不超过接收方缓冲区容量。</li>
</ul>
</li>
<li>零窗口处理：<ul>
<li>当rwnd&#x3D;0，发送方等待窗口更新，定时发送探测包避免死锁。</li>
</ul>
</li>
<li>与拥塞控制协同：<ul>
<li>流量控制（基于rwnd）与拥塞控制（基于cwnd）结合，发送窗口取两者最小值。</li>
</ul>
</li>
</ul>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>首先是慢启动阶段，初始阶段TCP会以较小的发送窗口开始传输数据，一般是2个或者3个四个MSS，随着每次成功收到ack信号，发送窗口每次变为上次的两倍，指数型增长，直到大于临界窗口之后，变为拥塞避免阶段，线性增长，每次增加一个MSS。</p>
<p>初始的临界窗口一般根据上次的拥塞点确定或者一个较大的值（16MSS)</p>
<p>超时重传之后，重新进入慢启动，这时临界窗口的大小是发生拥塞时未被确认的数据量的二分之一（近似为cwnd的一半），但不能小于2个MSS</p>
<p>而快重传，临界窗口也被设置为发生拥塞时未被确认的数据量的二分之一（近似为cwnd的一半），然后拥塞窗口设置为临界窗口加三个MSS。</p>
<h3 id="什么是TCP粘包？"><a href="#什么是TCP粘包？" class="headerlink" title="什么是TCP粘包？"></a>什么是TCP粘包？</h3><p><strong>粘包</strong>是指在TCP传输中，多个应用层数据包在接收端被合并为一个数据块，导致无法直接区分原始数据包边界。TCP是<strong>面向流的协议</strong>，不保证数据包的独立性，发送端可能将多个小数据包合并，接收端可能将数据分段或合并处理。</p>
<h4 id="粘包原因"><a href="#粘包原因" class="headerlink" title="粘包原因"></a>粘包原因</h4><ol>
<li><p>发送端优化</p>
<p>：</p>
<ul>
<li>TCP的Nagle算法将小数据包合并，减少网络开销。</li>
<li>发送缓冲区可能一次性发送多个应用层数据。</li>
</ul>
</li>
<li><p>接收端处理</p>
<p>：</p>
<ul>
<li>接收缓冲区可能将多个数据包合并为一个读操作。</li>
<li>接收数据不按发送时的包边界分割。</li>
</ul>
</li>
<li><p>网络传输</p>
<p>：</p>
<ul>
<li>数据在网络中可能因时序或分段重组，导致粘包或分包。</li>
</ul>
</li>
</ol>
<h4 id="粘包示例"><a href="#粘包示例" class="headerlink" title="粘包示例"></a>粘包示例</h4><ul>
<li>发送端连续发送 “Hello” 和 “World”，接收端可能为 “HelloWorld”。</li>
<li>发送端发送 “Msg1|Msg2”，接收端可能将 “|Msg2” 分到下一次读操作。</li>
</ul>
<hr>
<h3 id="如何解决粘包？"><a href="#如何解决粘包？" class="headerlink" title="如何解决粘包？"></a>如何解决粘包？</h3><p>解决粘包需要在<strong>应用层</strong>定义协议，确保接收端能正确解析数据包边界。以下是几种常见方法：</p>
<h4 id="1-固定长度头部"><a href="#1-固定长度头部" class="headerlink" title="1. 固定长度头部"></a>1. 固定长度头部</h4><ul>
<li>方法：<ul>
<li>每个数据包前加固定长度的头部（如4字节），表示数据包长度。</li>
<li>接收端先读取头部，解析长度，再读取指定长度的数据。</li>
</ul>
</li>
<li><strong>优点</strong>：简单，易实现。</li>
<li><strong>缺点</strong>：头部长度限制最大数据包大小（如4字节限制4GB）。</li>
<li>示例：<ul>
<li>发送格式：<code>[4字节长度][数据]</code></li>
<li>接收伪代码：length&#x3D;read(4 bytes)data&#x3D;&#x3D;read(length bytes)length&#x3D;read(4 bytes)data&#x3D;&#x3D;read(length bytes)</li>
</ul>
</li>
</ul>
<h4 id="2-分隔符"><a href="#2-分隔符" class="headerlink" title="2. 分隔符"></a>2. 分隔符</h4><ul>
<li>方法：<ul>
<li>在数据包间插入特定分隔符（如 “\n” 或 “|”)。</li>
<li>接收端按分隔符分割数据。</li>
</ul>
</li>
<li><strong>优点</strong>：灵活，适合文本数据。</li>
<li><strong>缺点</strong>：需确保数据内不含分隔符，或进行转义处理。</li>
<li>示例：<ul>
<li>发送：”Hello\nWorld\n”</li>
<li>接收端按 “\n” 拆分。</li>
</ul>
</li>
</ul>
<h4 id="3-固定长度数据包"><a href="#3-固定长度数据包" class="headerlink" title="3. 固定长度数据包"></a>3. 固定长度数据包</h4><ul>
<li>方法：<ul>
<li>每个数据包固定长度，不足补填充（如空格或0）。</li>
<li>接收端按固定长度读取。</li>
</ul>
</li>
<li><strong>优点</strong>：实现简单，边界清晰。</li>
<li><strong>缺点</strong>：浪费带宽，适合长度一致的场景。</li>
<li>示例：<ul>
<li>每个包固定100字节，”Hello” 补95字节填充。</li>
</ul>
</li>
</ul>
<h4 id="4-消息格式化（如TLV或JSON）"><a href="#4-消息格式化（如TLV或JSON）" class="headerlink" title="4. 消息格式化（如TLV或JSON）"></a>4. 消息格式化（如TLV或JSON）</h4><ul>
<li>方法：<ul>
<li>使用结构化格式（如Tag-Length-Value或JSON）定义消息。</li>
<li>接收端按格式解析。</li>
</ul>
</li>
<li><strong>优点</strong>：支持复杂数据，扩展性强。</li>
<li><strong>缺点</strong>：解析复杂度较高。</li>
<li>示例：<ul>
<li>JSON格式：<code>&#123;&quot;len&quot;:5,&quot;data&quot;:&quot;Hello&quot;&#125;</code></li>
</ul>
</li>
</ul>
<h4 id="5-应用层超时机制"><a href="#5-应用层超时机制" class="headerlink" title="5. 应用层超时机制"></a>5. 应用层超时机制</h4><ul>
<li>方法：<ul>
<li>在接收端设置超时，若一段时间未收到完整包，视为粘包或分包，触发重试或错误处理。</li>
</ul>
</li>
<li><strong>优点</strong>：辅助解决分包问题。</li>
<li><strong>缺点</strong>：需调优超时时间，避免误判。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>tcp</tag>
        <tag>udp</tag>
      </tags>
  </entry>
  <entry>
    <title>STL再探</title>
    <url>/2025/06/07/STL%E5%86%8D%E6%8E%A2/</url>
    <content><![CDATA[<p>看了半天的手撕STL最后面试答的依托答辩，真服了，重新看一下吧</p>
<h1 id="C-STL-容器的底层实现"><a href="#C-STL-容器的底层实现" class="headerlink" title="C++ STL 容器的底层实现"></a>C++ STL 容器的底层实现</h1><p>C++ 标准模板库（STL）中的容器是高效、灵活的数据结构实现，用于存储和管理数据集合。STL 容器分为三大类：<strong>序列容器</strong>、<strong>关联容器</strong>、<strong>无序关联容器</strong>，以及一类特殊的<strong>容器适配器</strong>。</p>
<h2 id="1-序列容器-Sequence-Containers"><a href="#1-序列容器-Sequence-Containers" class="headerlink" title="1. 序列容器 (Sequence Containers)"></a>1. 序列容器 (Sequence Containers)</h2><p>序列容器以线性方式存储元素，支持按顺序访问。底层实现通常基于数组或链表。</p>
<h3 id="1-1-std-vector"><a href="#1-1-std-vector" class="headerlink" title="1.1 std::vector"></a>1.1 <code>std::vector</code></h3><ul>
<li><strong>底层实现</strong>：动态数组（Dynamic Array）<ul>
<li>元素存储在<strong>连续内存</strong>中。</li>
<li>使用三个指针管理：<code>begin</code>（指向数组开头）、<code>end</code>（指向最后一个元素的下一位置）、<code>capacity</code>（指向分配内存的末尾）。</li>
<li>当插入元素导致大小超过容量时，重新分配更大的内存（通常按 1.5x 或 2x 增长），复制现有元素，并释放旧内存。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>随机访问：O(1)（通过索引）。</li>
<li>末尾插入&#x2F;删除：均摊 O(1)（可能触发重新分配）。</li>
<li>中间插入&#x2F;删除：O(n)，需移动后续元素。</li>
<li>内存分配使用 <code>std::allocator</code>。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>扩容时通常倍增容量（常见实现为 2x，但标准未强制）。</li>
<li>使用 placement new 在预分配内存上构造元素。</li>
</ul>
</li>
<li><strong>为何选择动态数组</strong>：<ul>
<li>连续内存提供高效的随机访问和缓存友好性。</li>
<li>适合需要频繁访问但插入&#x2F;删除较少的场景。</li>
</ul>
</li>
</ul>
<h3 id="1-2-std-array-C-11"><a href="#1-2-std-array-C-11" class="headerlink" title="1.2 std::array (C++11)"></a>1.2 <code>std::array</code> (C++11)</h3><ul>
<li><strong>底层实现</strong>：固定大小的静态数组<ul>
<li>封装了 C 风格数组，存储在栈上或嵌入对象中。</li>
<li>大小在编译期确定，内存布局与 <code>T[N]</code> 完全一致。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>随机访问：O(1)。</li>
<li>无动态分配，插入&#x2F;删除不可用。</li>
<li>提供 STL 容器接口（如 <code>begin()</code>、<code>end()</code>）。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>内存布局与原始数组相同，零开销。</li>
<li>不管理动态内存，无需 <code>std::allocator</code>。</li>
</ul>
</li>
<li><strong>为何选择静态数组</strong>：<ul>
<li>适合固定大小、性能敏感的场景（如嵌入式系统）。</li>
<li>提供与 STL 算法兼容的接口，优于裸数组。</li>
</ul>
</li>
</ul>
<h3 id="1-3-std-deque-Double-Ended-Queue"><a href="#1-3-std-deque-Double-Ended-Queue" class="headerlink" title="1.3 std::deque (Double-Ended Queue)"></a>1.3 <code>std::deque</code> (Double-Ended Queue)</h3><ul>
<li><strong>底层实现</strong>：分块数组（Block Array）<ul>
<li>使用多个固定大小的连续内存块（通常为数组），通过一个索引数组（或指针数组）连接。</li>
<li>每个块存储若干元素，索引数组记录块的地址。</li>
<li>支持两端高效插入&#x2F;删除。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>随机访问：O(1)（通过计算块索引和块内偏移）。</li>
<li>两端插入&#x2F;删除：O(1)（通常不触发重新分配）。</li>
<li>中间插入&#x2F;删除：O(n)，需移动元素。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>索引数组（称为“map”）存储指向各内存块的指针。</li>
<li>内存块大小通常为固定值（如 512 字节），由实现定义。</li>
<li>使用 placement new 构造元素。</li>
</ul>
</li>
<li><strong>为何选择分块数组</strong>：<ul>
<li>兼顾随机访问和两端操作的效率。</li>
<li>比 <code>std::vector</code> 更适合频繁两端插入的场景，但内存不完全连续，缓存友好性稍差。</li>
</ul>
</li>
</ul>
<h3 id="1-4-std-list"><a href="#1-4-std-list" class="headerlink" title="1.4 std::list"></a>1.4 <code>std::list</code></h3><ul>
<li><strong>底层实现</strong>：双向链表（Doubly-Linked List）<ul>
<li>每个节点包含元素、指向前驱和后继的指针。</li>
<li>节点动态分配，内存非连续。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>无随机访问，需遍历：O(n)。</li>
<li>插入&#x2F;删除：O(1)（已知节点位置）。</li>
<li>迭代器在插入&#x2F;删除后保持有效（除非删除当前节点）。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>通常包含哨兵节点（dummy node）简化边界操作。</li>
<li>使用 <code>std::allocator</code> 分配节点。</li>
</ul>
</li>
<li><strong>为何选择双向链表</strong>：<ul>
<li>适合频繁插入&#x2F;删除但不需随机访问的场景。</li>
<li>内存非连续，缓存性能较差。</li>
</ul>
</li>
</ul>
<h2 id="2-关联容器-Associative-Containers"><a href="#2-关联容器-Associative-Containers" class="headerlink" title="2. 关联容器 (Associative Containers)"></a>2. 关联容器 (Associative Containers)</h2><p>关联容器存储键值对或键，元素按键排序，提供高效查找。底层实现通常基于平衡二叉树。</p>
<h3 id="2-1-std-set-和-std-multiset"><a href="#2-1-std-set-和-std-multiset" class="headerlink" title="2.1 std::set 和 std::multiset"></a>2.1 <code>std::set</code> 和 <code>std::multiset</code></h3><ul>
<li><strong>底层实现</strong>：红黑树（Red-Black Tree）<ul>
<li>自平衡二叉搜索树，保持键的排序。</li>
<li>每个节点包含键、颜色（红&#x2F;黑）、左右子节点和父节点指针。</li>
<li><code>std::multiset</code> 允许重复键。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>查找、插入、删除：O(log n)。</li>
<li>元素按键排序，自动去重（<code>std::set</code>）。</li>
<li>迭代器提供有序遍历。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>使用 <code>std::allocator</code> 分配节点。</li>
<li>红黑树保证平衡，插入&#x2F;删除后通过旋转和颜色调整维持 O(log n)。</li>
</ul>
</li>
<li><strong>为何选择红黑树</strong>：<ul>
<li>提供稳定的 O(log n) 性能。</li>
<li>适合需要排序和快速查找的场景。</li>
</ul>
</li>
</ul>
<h3 id="2-2-std-map-和-std-multimap"><a href="#2-2-std-map-和-std-multimap" class="headerlink" title="2.2 std::map 和 std::multimap"></a>2.2 <code>std::map</code> 和 <code>std::multimap</code></h3><ul>
<li><strong>底层实现</strong>：红黑树（Red-Black Tree）<ul>
<li>类似 <code>std::set</code>，但节点存储键值对（<code>std::pair&lt;const Key, T&gt;</code>）。</li>
<li><code>std::multimap</code> 允许重复键。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>查找、插入、删除：O(log n)。</li>
<li>按键排序，迭代器返回键值对。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>红黑树节点包含 <code>std::pair&lt;const Key, T&gt;</code>。</li>
<li>使用比较器（默认 <code>std::less&lt;Key&gt;</code>）维护键的顺序。</li>
</ul>
</li>
<li><strong>为何选择红黑树</strong>：<ul>
<li>高效的键值查找和排序。</li>
<li>适合需要键值映射且保持排序的场景。</li>
</ul>
</li>
</ul>
<h2 id="3-无序关联容器-Unordered-Associative-Containers-C-11"><a href="#3-无序关联容器-Unordered-Associative-Containers-C-11" class="headerlink" title="3. 无序关联容器 (Unordered Associative Containers, C++11)"></a>3. 无序关联容器 (Unordered Associative Containers, C++11)</h2><p>无序关联容器提供快速查找，元素不排序，基于哈希表实现。</p>
<h3 id="3-1-std-unordered-set-和-std-unordered-multiset"><a href="#3-1-std-unordered-set-和-std-unordered-multiset" class="headerlink" title="3.1 std::unordered_set 和 std::unordered_multiset"></a>3.1 <code>std::unordered_set</code> 和 <code>std::unordered_multiset</code></h3><ul>
<li><strong>底层实现</strong>：哈希表（Hash Table）<ul>
<li>使用桶（buckets）数组，每个桶存储一个链表（或类似结构）处理冲突。</li>
<li>哈希函数将键映射到桶，冲突通过链表（或红黑树，C++11 起部分实现优化）解决。</li>
<li><code>std::unordered_multiset</code> 允许重复键。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>查找、插入、删除：均摊 O(1)，最坏 O(n)（冲突严重时）。</li>
<li>无序，迭代器不保证顺序。</li>
<li>负载因子（load factor）控制桶数量，影响性能。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>默认哈希函数为 <code>std::hash&lt;Key&gt;</code>，可自定义。</li>
<li>桶数量动态调整（rehash），保持负载因子低于最大值。</li>
</ul>
</li>
<li><strong>为何选择哈希表</strong>：<ul>
<li>提供接近 O(1) 的查找性能。</li>
<li>适合不需要排序的高速查找场景。</li>
</ul>
</li>
</ul>
<h3 id="3-2-std-unordered-map-和-std-unordered-multimap"><a href="#3-2-std-unordered-map-和-std-unordered-multimap" class="headerlink" title="3.2 std::unordered_map 和 std::unordered_multimap"></a>3.2 <code>std::unordered_map</code> 和 <code>std::unordered_multimap</code></h3><ul>
<li><strong>底层实现</strong>：哈希表（Hash Table）<ul>
<li>与 <code>std::unordered_set</code> 类似，但存储键值对（<code>std::pair&lt;const Key, T&gt;</code>）。</li>
<li><code>std::unordered_multimap</code> 允许重复键。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>查找、插入、删除：均摊 O(1)，最坏 O(n)。</li>
<li>无序，键值对存储。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>桶内冲突通常用链表解决，部分实现（如 libstdc++）在高冲突时用红黑树优化。</li>
<li>使用 <code>std::allocator</code> 分配桶和节点。</li>
</ul>
</li>
<li><strong>为何选择哈希表</strong>：<ul>
<li>高效键值查找，适合无序键值映射。</li>
</ul>
</li>
</ul>
<h2 id="4-容器适配器-Container-Adaptors"><a href="#4-容器适配器-Container-Adaptors" class="headerlink" title="4. 容器适配器 (Container Adaptors)"></a>4. 容器适配器 (Container Adaptors)</h2><p>容器适配器基于其他容器提供受限接口，底层实现依赖基础容器。</p>
<h3 id="4-1-std-stack"><a href="#4-1-std-stack" class="headerlink" title="4.1 std::stack"></a>4.1 <code>std::stack</code></h3><ul>
<li><strong>底层实现</strong>：基于 <code>std::deque</code>（默认），可指定 <code>std::vector</code> 或 <code>std::list</code><ul>
<li>提供 LIFO（后进先出）接口，仅支持 <code>push</code>、<code>pop</code>、<code>top</code>。</li>
<li>底层容器管理元素存储。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>插入&#x2F;删除（<code>push</code>&#x2F;<code>pop</code>）：O(1)（依赖底层容器）。</li>
<li>无迭代器，仅访问栈顶。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>默认使用 <code>std::deque</code> 提供高效尾部操作。</li>
<li>可通过模板参数自定义底层容器（需支持 <code>push_back</code>、<code>pop_back</code>、<code>back</code>）。</li>
</ul>
</li>
<li>**为何选择 <code>std::deque</code>**：<ul>
<li>尾部操作高效，内存管理灵活。</li>
<li><code>std::vector</code> 也可用于节省内存，<code>std::list</code> 适合频繁插入。</li>
</ul>
</li>
</ul>
<h3 id="4-2-std-queue"><a href="#4-2-std-queue" class="headerlink" title="4.2 std::queue"></a>4.2 <code>std::queue</code></h3><ul>
<li><strong>底层实现</strong>：基于 <code>std::deque</code>（默认），可指定 <code>std::list</code><ul>
<li>提供 FIFO（先进先出）接口，支持 <code>push</code>（尾部）、<code>pop</code>（头部）、<code>front</code>、<code>back</code>。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>插入（<code>push</code>）：O(1)。</li>
<li>删除（<code>pop</code>）：O(1)（依赖底层容器）。</li>
<li>无迭代器，仅访问队首&#x2F;队尾。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>默认 <code>std::deque</code> 支持高效两端操作。</li>
<li>不使用 <code>std::vector</code>，因为头部删除效率低（O(n)）。</li>
</ul>
</li>
<li>**为何选择 <code>std::deque</code>**：<ul>
<li>两端操作高效，适合队列语义。</li>
</ul>
</li>
</ul>
<h3 id="4-3-std-priority-queue"><a href="#4-3-std-priority-queue" class="headerlink" title="4.3 std::priority_queue"></a>4.3 <code>std::priority_queue</code></h3><ul>
<li><strong>底层实现</strong>：基于 <code>std::vector</code>（默认），使用堆（Heap）算法<ul>
<li>底层容器存储元素，堆算法（<code>std::make_heap</code>、<code>std::push_heap</code>、<code>std::pop_heap</code>）维护优先级。</li>
<li>默认大顶堆（最大元素优先）。</li>
</ul>
</li>
<li><strong>关键特性</strong>：<ul>
<li>插入（<code>push</code>）：O(log n)。</li>
<li>删除（<code>pop</code>）：O(log n)。</li>
<li>访问最大&#x2F;最小元素：O(1)。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>使用 <code>std::vector</code> 提供连续内存，适合堆操作。</li>
<li>可自定义比较器（如 <code>std::less&lt;T&gt;</code> 或 <code>std::greater&lt;T&gt;</code>）。</li>
</ul>
</li>
<li>**为何选择 <code>std::vector</code>**：<ul>
<li>连续内存适合堆算法的随机访问。</li>
<li>扩容效率高，尾部插入快。</li>
</ul>
</li>
</ul>
<h2 id="5-其他注意事项"><a href="#5-其他注意事项" class="headerlink" title="5. 其他注意事项"></a>5. 其他注意事项</h2><ul>
<li><strong>标准未强制具体实现</strong>：C++ 标准仅规定容器的时间复杂度和行为，具体数据结构由实现决定。例如，<code>std::map</code> 可能使用红黑树或其他平衡树（如 AVL 树），但红黑树是主流选择。<a href="https://stackoverflow.com/questions/46925007/how-are-stl-containers-in-c-actually-implemented"></a></li>
<li><strong>内存管理</strong>：所有容器使用 <code>std::allocator</code>（或自定义分配器）管理内存，确保灵活性和可扩展性。</li>
<li><strong>线程安全</strong>：STL 容器不提供内置线程安全，需用户自行加锁。<a href="https://embeddedartistry.com/blog/2017/08/02/an-overview-of-c-stl-containers/"></a></li>
<li><strong>迭代器失效</strong>：<ul>
<li><code>std::vector</code>：插入可能导致所有迭代器失效（若重新分配内存）。</li>
<li><code>std::list</code>：插入&#x2F;删除不影响其他迭代器。</li>
<li><code>std::map</code>&#x2F;<code>std::set</code>：插入不失效，删除可能失效被删除元素的迭代器。<a href="https://en.cppreference.com/w/cpp/container.html"></a></li>
</ul>
</li>
</ul>
<h2 id="6-总结表格"><a href="#6-总结表格" class="headerlink" title="6. 总结表格"></a>6. 总结表格</h2><table>
<thead>
<tr>
<th>容器</th>
<th>底层数据结构</th>
<th>插入复杂度</th>
<th>删除复杂度</th>
<th>查找复杂度</th>
<th>随机访问</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::vector</code></td>
<td>动态数组</td>
<td>O(1) 均摊</td>
<td>O(1) 均摊</td>
<td>O(1)</td>
<td>是</td>
<td>动态数组、随机访问</td>
</tr>
<tr>
<td><code>std::array</code></td>
<td>静态数组</td>
<td>不支持</td>
<td>不支持</td>
<td>O(1)</td>
<td>是</td>
<td>固定大小数组</td>
</tr>
<tr>
<td><code>std::deque</code></td>
<td>分块数组</td>
<td>O(1) 两端</td>
<td>O(1) 两端</td>
<td>O(1)</td>
<td>是</td>
<td>双端队列</td>
</tr>
<tr>
<td><code>std::list</code></td>
<td>双向链表</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>否</td>
<td>频繁插入&#x2F;删除</td>
</tr>
<tr>
<td><code>std::forward_list</code></td>
<td>单向链表</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
<td>否</td>
<td>内存敏感、前向遍历</td>
</tr>
<tr>
<td><code>std::set</code>&#x2F;<code>multiset</code></td>
<td>红黑树</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>否</td>
<td>有序集合、去重</td>
</tr>
<tr>
<td><code>std::map</code>&#x2F;<code>multimap</code></td>
<td>红黑树</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>否</td>
<td>有序键值映射</td>
</tr>
<tr>
<td><code>std::unordered_set</code>&#x2F;<code>multiset</code></td>
<td>哈希表</td>
<td>O(1) 均摊</td>
<td>O(1) 均摊</td>
<td>O(1) 均摊</td>
<td>否</td>
<td>无序集合、快速查找</td>
</tr>
<tr>
<td><code>std::unordered_map</code>&#x2F;<code>multimap</code></td>
<td>哈希表</td>
<td>O(1) 均摊</td>
<td>O(1) 均摊</td>
<td>O(1) 均摊</td>
<td>否</td>
<td>无序键值映射</td>
</tr>
<tr>
<td><code>std::stack</code></td>
<td><code>std::deque</code> (默认)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>不支持</td>
<td>否</td>
<td>LIFO 栈</td>
</tr>
<tr>
<td><code>std::queue</code></td>
<td><code>std::deque</code> (默认)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>不支持</td>
<td>否</td>
<td>FIFO 队列</td>
</tr>
<tr>
<td><code>std::priority_queue</code></td>
<td><code>std::vector</code> + 堆</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(1) 顶部</td>
<td>否</td>
<td>优先级队列</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++，STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity（一）</title>
    <url>/2024/09/19/Unity%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="平动和转动"><a href="#平动和转动" class="headerlink" title="平动和转动"></a>平动和转动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class instance : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public float moveSpeed = 10f;</span><br><span class="line">    public float turnSpeed = 50f;</span><br><span class="line">    private void Update()//update是每帧更新的函数</span><br><span class="line">    &#123;</span><br><span class="line">        if(Input.GetKey(KeyCode.UpArrow))</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Translate(Vector3.forward * moveSpeed*Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        //translate是平移，vector3是一个三维数组，forward代表（0，0，1)</span><br><span class="line">        //deltatime是两帧之间的时间间隔</span><br><span class="line">        //没有使用 Time.deltaTime 的问题</span><br><span class="line">        //如果你只是使用 moveSpeed 来移动物体，而不使用 Time.deltaTime，</span><br><span class="line">        //物体每帧的移动量将是恒定的.如果帧率提高，物体移动的频率就会增加</span><br><span class="line">        //移动速度就会变快；如果帧率降低，物体的移动频率减小，移动速度就会变慢.</span><br><span class="line">        //使用 Time.deltaTime</span><br><span class="line">        //通过乘以 Time.deltaTime，可以保证物体每秒的移动量保持一致，不受帧率影响.</span><br><span class="line">        if (Input.GetKey(KeyCode.LeftArrow)) </span><br><span class="line">        &#123;</span><br><span class="line">            transform.Rotate(Vector3.up,turnSpeed*Time.deltaTime); </span><br><span class="line">        &#125;</span><br><span class="line">        //rotate是旋转，vector3.up表示（0，1，0），这里是转动的轴</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="摄像机的平滑跟随和视角锁定"><a href="#摄像机的平滑跟随和视角锁定" class="headerlink" title="摄像机的平滑跟随和视角锁定"></a>摄像机的平滑跟随和视角锁定</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SerializeField] Transform target;</span><br><span class="line">[SerializeField] Vector3 offset;</span><br><span class="line">[SerializeField] float transitionSpeed = 2;</span><br><span class="line"></span><br><span class="line">private void LateUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    if (target != null)</span><br><span class="line">    &#123;</span><br><span class="line">       Vector3 targetPos = target.position + offset;</span><br><span class="line">        transform.position = Vector3.Lerp(transform.position, targetPos, transitionSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Transform target;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.LookAt(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两种对摄像头的设置<br>第一种是摄像机的平滑跟随，第二种是视角锁定（摄像机不动，只转动）</p>
<h1 id="GetAxis"><a href="#GetAxis" class="headerlink" title="GetAxis"></a>GetAxis</h1><p>在 <strong>Unity</strong> 的 <strong>Input Manager</strong> 中，<code>Positive Button</code> 和 <code>Negative Button</code> 是用来处理轴输入（axis input）的.当你配置诸如 <code>&quot;Horizontal&quot;</code> 或 <code>&quot;Vertical&quot;</code> 这样代表方向或动作的输入轴时，这两个按钮起到了重要的作用.</p>
<h3 id="轴输入（Axis-Input）简介"><a href="#轴输入（Axis-Input）简介" class="headerlink" title="轴输入（Axis Input）简介"></a>轴输入（Axis Input）简介</h3><p>Unity 中的轴输入通常用来处理类似于左右、上下移动这样的操作.输入轴是一种 <strong>模拟输入</strong>，而不是简单的二元按键（开&#x2F;关）.例如：</p>
<ul>
<li><code>&quot;Horizontal&quot;</code> 轴可以映射到 <strong>A&#x2F;D</strong> 键或 <strong>左&#x2F;右</strong> 方向键，表示横向移动.</li>
<li><code>&quot;Vertical&quot;</code> 轴可以映射到 <strong>W&#x2F;S</strong> 键或 <strong>上&#x2F;下</strong> 方向键，表示纵向移动.</li>
</ul>
<p>这些轴输入返回的值在 <strong>-1 到 1</strong> 之间，用来表示不同的方向或强度.</p>
<h3 id="Positive-Button-和-Negative-Button-的作用"><a href="#Positive-Button-和-Negative-Button-的作用" class="headerlink" title="Positive Button 和 Negative Button 的作用"></a><code>Positive Button</code> 和 <code>Negative Button</code> 的作用</h3><ul>
<li><strong>Positive Button</strong> 是用来指定当你按下该按钮时，输入轴返回正向值（如 <code>1</code>）.例如，”D” 键或右方向键通常用作 <code>Positive Button</code>，它会让角色向右移动.</li>
<li><strong>Negative Button</strong> 是用来指定当你按下该按钮时，输入轴返回负向值（如 <code>-1</code>）.例如，”A” 键或左方向键通常用作 <code>Negative Button</code>，它会让角色向左移动.</li>
</ul>
<h3 id="示例：Horizontal-轴配置"><a href="#示例：Horizontal-轴配置" class="headerlink" title="示例：Horizontal 轴配置"></a>示例：<code>Horizontal</code> 轴配置</h3><p>假设我们在 <strong>Input Manager</strong> 中配置了一个名为 <code>&quot;Horizontal&quot;</code> 的输入轴.常见的设置可能是这样的：</p>
<ul>
<li><strong>Name</strong>: Horizontal</li>
<li><strong>Negative Button</strong>: A (或 Left Arrow)</li>
<li><strong>Positive Button</strong>: D (或 Right Arrow)</li>
<li><strong>Gravity</strong>: 3</li>
<li><strong>Dead</strong>: 0.001</li>
<li><strong>Sensitivity</strong>: 3</li>
<li><strong>Type</strong>: Key or Mouse Button</li>
<li><strong>Axis</strong>: X axis</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>当你按下 <code>Positive Button</code>（比如 <code>&quot;D&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个正值，接近 <code>1</code>.</li>
<li>当你按下 <code>Negative Button</code>（比如 <code>&quot;A&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个负值，接近 <code>-1</code>.</li>
<li>如果没有按下任何按钮，<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 将返回 <code>0</code>，表示没有水平输入.</li>
</ol>
<h3 id="为什么使用-Positive-和-Negative-按钮？"><a href="#为什么使用-Positive-和-Negative-按钮？" class="headerlink" title="为什么使用 Positive 和 Negative 按钮？"></a>为什么使用 Positive 和 Negative 按钮？</h3><p>它们的主要作用是提供一种简便的方式来处理方向性输入.例如，移动角色时，可以根据返回的轴值决定角色的移动方向：</p>
<ul>
<li>如果 <code>Input.GetAxis(&quot;Horizontal&quot;)</code> 返回正值（如 1），角色向右移动.</li>
<li>如果返回负值（如 -1），角色向左移动.</li>
</ul>
<h3 id="示例：检测水平轴输入并移动角色"><a href="#示例：检测水平轴输入并移动角色" class="headerlink" title="示例：检测水平轴输入并移动角色"></a>示例：检测水平轴输入并移动角色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float move = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">    transform.Translate(Vector3.right * move * Time.deltaTime * speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果玩家按下 <strong>“D”</strong> 或 <strong>右方向键</strong>（<code>Positive Button</code>），<code>move</code> 会变成正值，角色向右移动.</li>
<li>如果玩家按下 <strong>“A”</strong> 或 <strong>左方向键</strong>（<code>Negative Button</code>），<code>move</code> 会变成负值，角色向左移动.</li>
</ul>
<h3 id="配置解释"><a href="#配置解释" class="headerlink" title="配置解释"></a>配置解释</h3><ul>
<li><strong>Gravity</strong>: 控制按键松开后，轴值回到零的速度.数值越大，返回到 0 的速度越快.</li>
<li><strong>Sensitivity</strong>: 控制按键按下时，轴值从 0 加速到 1（或 -1）的速度.数值越大，响应越快.</li>
<li><strong>Dead</strong>: 一个小阈值，避免微小输入造成意外响应.小于该值的输入会被视为 0.</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Positive Button</strong>：用于正方向的输入，通常映射为右&#x2F;上方向键或控制器的正向输入.</li>
<li><strong>Negative Button</strong>：用于负方向的输入，通常映射为左&#x2F;下方向键或控制器的反向输入.</li>
<li>它们是用于控制方向性输入的核心元素，特别是在控制角色移动时.</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>打卡</tag>
        <tag>闲得无聊所以发发</tag>
      </tags>
  </entry>
  <entry>
    <title>atomic</title>
    <url>/2025/06/30/atomic/</url>
    <content><![CDATA[<h1 id="atomic-是什么及相关操作介绍"><a href="#atomic-是什么及相关操作介绍" class="headerlink" title="atomic 是什么及相关操作介绍"></a><code>atomic</code> 是什么及相关操作介绍</h1><h2 id="1-atomic-是什么"><a href="#1-atomic-是什么" class="headerlink" title="1. atomic 是什么"></a>1. <strong><code>atomic</code> 是什么</strong></h2><p>在 C++ 中，<code>std::atomic</code> 是 C++11 引入的模板类，位于 <code>&lt;atomic&gt;</code> 头文件中，用于实现线程安全的原子操作。原子操作是指在多线程环境中不可分割的操作，保证操作要么完全完成，要么完全不执行，避免数据竞争（data race）。</p>
<ul>
<li><strong>作用</strong>：<ul>
<li>提供线程安全的变量读写，防止多线程并发访问导致的数据不一致。</li>
<li>避免使用锁（如互斥锁），减少锁竞争和上下文切换开销。</li>
<li>支持基本数据类型（如 <code>int</code>、<code>bool</code>、指针）和其他自定义类型的原子操作。</li>
</ul>
</li>
<li><strong>典型场景</strong>：<ul>
<li>多线程计数器。</li>
<li>无锁数据结构（如无锁队列）。</li>
<li>标志位或状态变量的线程安全更新。</li>
</ul>
</li>
</ul>
<h2 id="2-std-atomic-的核心特性"><a href="#2-std-atomic-的核心特性" class="headerlink" title="2. std::atomic 的核心特性"></a>2. <strong><code>std::atomic</code> 的核心特性</strong></h2><ul>
<li><strong>原子性</strong>：操作不可中断，确保线程安全。</li>
<li><strong>内存序</strong>：通过 <code>std::memory_order</code> 控制内存访问顺序，优化性能和一致性。</li>
<li><strong>支持类型</strong>：<ul>
<li>内置类型：<code>std::atomic&lt;int&gt;</code>、<code>std::atomic&lt;bool&gt;</code> 等。</li>
<li>指针类型：<code>std::atomic&lt;T*&gt;</code>。</li>
<li>自定义类型：需满足“平凡可复制”条件（Trivially Copyable）。</li>
</ul>
</li>
</ul>
<h2 id="3-主要操作"><a href="#3-主要操作" class="headerlink" title="3. 主要操作"></a>3. <strong>主要操作</strong></h2><p>以下是 <code>std::atomic</code> 的常用操作，假设 <code>std::atomic&lt;T&gt; var</code> 是一个原子变量：</p>
<h3 id="1-基本读写操作"><a href="#1-基本读写操作" class="headerlink" title="(1) 基本读写操作"></a><strong>(1) 基本读写操作</strong></h3><ul>
<li><strong>load</strong>：读取原子变量的值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T value = var.<span class="built_in">load</span>(std::memory_order_acquire);</span><br></pre></td></tr></table></figure>
<ul>
<li>获取 <code>var</code> 的当前值，保证读取最新值。</li>
</ul>
</li>
<li><strong>store</strong>：写入新值到原子变量。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var.<span class="built_in">store</span>(new_value, std::memory_order_release);</span><br></pre></td></tr></table></figure>
<ul>
<li>将 <code>new_value</code> 写入 <code>var</code>，确保对其他线程可见。</li>
</ul>
</li>
<li><strong>exchange</strong>：原子地替换值并返回旧值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T old_value = var.<span class="built_in">exchange</span>(new_value, std::memory_order_acq_rel);</span><br></pre></td></tr></table></figure>
<ul>
<li>将 <code>var</code> 替换为 <code>new_value</code>，返回替换前的值。</li>
</ul>
</li>
</ul>
<h3 id="2-比较并交换（CAS）"><a href="#2-比较并交换（CAS）" class="headerlink" title="(2) 比较并交换（CAS）"></a><strong>(2) 比较并交换（CAS）</strong></h3><ul>
<li><strong>compare_exchange_strong</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T expected = current_value;</span><br><span class="line"><span class="type">bool</span> success = var.<span class="built_in">compare_exchange_strong</span>(expected, desired, std::memory_order_acq_rel);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>var == expected</code>，则将 <code>var</code> 替换为 <code>desired</code>，返回 <code>true</code>。</li>
<li>否则，<code>expected</code> 被更新为 <code>var</code> 的当前值，返回 <code>false</code>。</li>
<li>适合无锁算法，处理竞争。</li>
</ul>
</li>
<li><strong>compare_exchange_weak</strong>：<ul>
<li>类似 <code>compare_exchange_strong</code>，但在某些架构上可能因伪失败（spurious failure）返回 <code>false</code>，需配合循环重试。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T expected = current_value;</span><br><span class="line"><span class="keyword">while</span> (!var.<span class="built_in">compare_exchange_weak</span>(expected, desired, std::memory_order_acq_rel)) &#123;</span><br><span class="line">    <span class="comment">// 重试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-算术和位操作"><a href="#3-算术和位操作" class="headerlink" title="(3) 算术和位操作"></a><strong>(3) 算术和位操作</strong></h3><p>仅对 <code>std::atomic</code> 的整型或指针类型支持：</p>
<ul>
<li><strong>fetch_add &#x2F; fetch_sub</strong>：原子加&#x2F;减，返回旧值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T old = var.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// var += 1</span></span><br></pre></td></tr></table></figure></li>
<li><strong>fetch_and &#x2F; fetch_or &#x2F; fetch_xor</strong>：原子位操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T old = var.<span class="built_in">fetch_and</span>(mask, std::memory_order_relaxed); <span class="comment">// var &amp;= mask</span></span><br></pre></td></tr></table></figure></li>
<li>**operator++ &#x2F; operator–**：原子自增&#x2F;自减。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var++; <span class="comment">// 等价于 fetch_add(1) + 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-其他操作"><a href="#4-其他操作" class="headerlink" title="(4) 其他操作"></a><strong>(4) 其他操作</strong></h3><ul>
<li><strong>is_lock_free</strong>：检查原子操作是否无锁。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_lock_free = var.<span class="built_in">is_lock_free</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>返回 <code>true</code> 表示操作由硬件支持，<code>false</code> 表示可能使用内部锁。</li>
</ul>
</li>
<li><strong>wait &#x2F; notify_one &#x2F; notify_all</strong>（C++20）：<ul>
<li>等待原子变量值变化（类似条件变量）。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var.<span class="built_in">wait</span>(old_value, std::memory_order_acquire); <span class="comment">// 等待 var 变化</span></span><br><span class="line">var.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个等待线程</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="4-内存序（Memory-Order）"><a href="#4-内存序（Memory-Order）" class="headerlink" title="4. 内存序（Memory Order）"></a>4. <strong>内存序（Memory Order）</strong></h2><p><code>std::atomic</code> 操作支持指定内存序，控制多线程间的内存访问顺序，平衡正确性和性能：</p>
<ul>
<li>**<code>std::memory_order_relaxed</code>**：<ul>
<li>仅保证原子性，不保证内存访问顺序。</li>
<li>适合独立操作，如计数器。</li>
</ul>
</li>
<li>**<code>std::memory_order_acquire</code>**：<ul>
<li>确保操作后的读取看到其他线程的 <code>release</code> 操作结果。</li>
<li>用于消费者线程。</li>
</ul>
</li>
<li>**<code>std::memory_order_release</code>**：<ul>
<li>确保操作前的写入对其他线程的 <code>acquire</code> 操作可见。</li>
<li>用于生产者线程。</li>
</ul>
</li>
<li>**<code>std::memory_order_acq_rel</code>**：<ul>
<li>结合 <code>acquire</code> 和 <code>release</code>，用于读写操作（如 <code>exchange</code>）。</li>
</ul>
</li>
<li>**<code>std::memory_order_seq_cst</code>**（默认）：<ul>
<li>提供最强的顺序一致性，保证所有线程看到一致的操作顺序。</li>
<li>开销较大，但最安全。</li>
</ul>
</li>
</ul>
<h2 id="5-代码示例"><a href="#5-代码示例" class="headerlink" title="5. 代码示例"></a>5. <strong>代码示例</strong></h2><p>以下是一个使用 <code>std::atomic</code> 实现线程安全计数器的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment, <span class="number">1000</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 2000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>说明</strong>：多个线程并发调用 <code>fetch_add</code>，计数器保持线程安全。</li>
</ul>
<h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. <strong>注意事项</strong></h2><ul>
<li><strong>性能</strong>：<ul>
<li>原子操作通常比锁更快，但 CAS 重试可能导致性能波动。</li>
<li>选择合适的内存序（如 <code>relaxed</code>）可优化性能。</li>
</ul>
</li>
<li><strong>限制</strong>：<ul>
<li>仅支持简单数据类型或指针，复杂类型需自定义无锁机制。</li>
<li><code>compare_exchange_weak</code> 可能因伪失败需重试，适合循环场景。</li>
</ul>
</li>
<li><strong>ABA 问题</strong>：<ul>
<li>在 CAS 操作中，值可能被修改后恢复为原值，导致误判。</li>
<li>解决方法：使用版本计数或双字 CAS。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>适合高并发、低冲突场景，如无锁队列、计数器、状态标志。</li>
<li>高冲突场景可能仍需锁机制。</li>
</ul>
</li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h2><ul>
<li>**<code>std::atomic</code>**：提供线程安全的原子操作，避免锁开销。</li>
<li><strong>核心操作</strong>：<code>load</code>、<code>store</code>、<code>exchange</code>、<code>compare_exchange_strong/weak</code>、算术&#x2F;位操作。</li>
<li><strong>内存序</strong>：通过 <code>memory_order</code> 控制同步和性能。</li>
<li><strong>应用</strong>：无锁数据结构、线程安全计数器、标志位管理。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>bind和回调函数的关系</title>
    <url>/2025/01/27/bind%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="回调（Callback）函数"><a href="#回调（Callback）函数" class="headerlink" title="回调（Callback）函数"></a><strong>回调（Callback）函数</strong></h3><p>回调函数是一种设计模式，指的是将一个函数作为参数传递给另一个函数，并在某个事件发生时由后者调用这个函数。简单来说，回调函数是被“回调”执行的函数。</p>
<h4 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a><strong>回调函数的作用</strong></h4><ul>
<li>允许你在程序中实现灵活的控制流。</li>
<li>通过回调，你可以将具体的业务逻辑交给调用者来定义，而不是在框架或库中硬编码。</li>
</ul>
<h4 id="回调函数的典型示例"><a href="#回调函数的典型示例" class="headerlink" title="回调函数的典型示例"></a><strong>回调函数的典型示例</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Callback function called with value: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用回调的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(<span class="type">void</span> (*cb)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">cb</span>(data);  <span class="comment">// 调用回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">processData</span>(callback);  <span class="comment">// 传递回调函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>processData</code> 函数接受一个回调函数 <code>callback</code> 作为参数，并在适当时机调用它。<code>callback</code> 在 <code>processData</code> 中被回调。</p>
<h3 id="bind-的作用"><a href="#bind-的作用" class="headerlink" title="bind 的作用"></a><strong><code>bind</code> 的作用</strong></h3><p><code>bind</code> 是 C++11 中引入的标准库函数，用来创建一个新的可调用对象，将某些参数预先绑定到函数上，生成一个新的函数对象。<code>std::bind</code> 可以让你灵活地创建自定义回调函数，或者将部分函数参数预先填充。</p>
<h4 id="std-bind-的工作原理"><a href="#std-bind-的工作原理" class="headerlink" title="std::bind 的工作原理"></a><strong><code>std::bind</code> 的工作原理</strong></h4><ul>
<li><code>std::bind</code> 用于将某些参数“绑定”到函数上，创建一个新的函数对象，这个新的函数对象可以稍后被调用。</li>
<li>这与回调的关系在于，<code>bind</code> 可以帮助我们构造一个回调函数，而无需显式地定义一个回调函数。</li>
</ul>
<h4 id="std-bind-示例"><a href="#std-bind-示例" class="headerlink" title="std::bind 示例"></a><strong><code>std::bind</code> 示例</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  <span class="comment">// 包含 std::bind</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 来绑定参数</span></span><br><span class="line">    <span class="keyword">auto</span> bound_function = std::<span class="built_in">bind</span>(print_sum, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用绑定后的函数对象</span></span><br><span class="line">    <span class="built_in">bound_function</span>();  <span class="comment">// 输出：Sum: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::bind</code> 创建了一个新的函数对象 <code>bound_function</code>，它预先绑定了 <code>print_sum</code> 函数的两个参数。当调用 <code>bound_function()</code> 时，它会执行 <code>print_sum(10, 20)</code>。</p>
<h4 id="与回调的关系"><a href="#与回调的关系" class="headerlink" title="与回调的关系"></a><strong>与回调的关系</strong></h4><ul>
<li><code>std::bind</code> 是创建回调函数的一种方式。你可以将 <code>std::bind</code> 与事件驱动或异步处理机制结合起来，使用它来生成回调函数。</li>
<li>通过 <code>std::bind</code>，你可以将一些函数的参数预先填充，生成一个新的可调用对象，这个对象可以作为回调传递给其他函数。</li>
</ul>
<h3 id="回调与-bind-的关系"><a href="#回调与-bind-的关系" class="headerlink" title="回调与 bind 的关系"></a><strong>回调与 <code>bind</code> 的关系</strong></h3><ol>
<li><p><strong>回调函数</strong>是一个被传递并在未来某时被调用的函数。你可以通过回调让某个函数将控制权交给另一个函数。回调通常是在异步、事件驱动或接口设计中使用的。</p>
</li>
<li><p><strong><code>std::bind</code></strong> 是用于<strong>创建回调函数</strong>的一种方式，它将函数及其部分参数绑定在一起，生成一个新的可调用对象，方便将其作为回调传递给其他函数。</p>
</li>
</ol>
<hr>
<h3 id="示例：结合-bind-和回调"><a href="#示例：结合-bind-和回调" class="headerlink" title="示例：结合 bind 和回调"></a><strong>示例：结合 <code>bind</code> 和回调</strong></h3><p>假设我们有一个函数 <code>processData</code>，它接受一个回调函数。在这个例子中，我们使用 <code>std::bind</code> 来预先绑定参数，然后将生成的函数作为回调传递给 <code>processData</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  <span class="comment">// 包含 std::bind</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要回调的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processData</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; cb)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing data...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">cb</span>();  <span class="comment">// 调用回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定回调函数的参数</span></span><br><span class="line">    <span class="keyword">auto</span> bound_callback = std::<span class="built_in">bind</span>(print_sum, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将绑定后的函数作为回调传递</span></span><br><span class="line">    <span class="built_in">processData</span>(bound_callback);  <span class="comment">// 输出：Sum: 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::bind</code> 创建了一个绑定了参数 10 和 20 的回调函数 <code>bound_callback</code>，然后它被传递到 <code>processData</code> 函数中执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>回调函数</strong>：允许将一个函数作为参数传递给另一个函数，稍后在适当的时机调用。</li>
<li>**<code>std::bind</code>**：是 C++11 引入的一个工具，用于绑定函数的部分参数，创建一个新的可调用对象。它常用于回调函数的生成，简化函数参数的传递和调用。</li>
</ul>
<p>两者的关系可以看作，**<code>bind</code> 是构建回调函数的一种方式**，尤其是当你希望提前指定回调函数的部分参数时。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性之emplace</title>
    <url>/2024/11/25/c++11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bemplace/</url>
    <content><![CDATA[<p><code>emplace</code> 是 C++ 中标准库（STL）提供的一种高效的元素插入方式，常用于容器（如 <code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code> 等）中。<code>emplace</code> 通过直接在容器内部构造元素，避免了不必要的拷贝或移动操作，从而提高了性能。</p>
<h3 id="emplace-和-insert-的区别"><a href="#emplace-和-insert-的区别" class="headerlink" title="emplace 和 insert 的区别"></a><code>emplace</code> 和 <code>insert</code> 的区别</h3><ul>
<li><p>**<code>insert</code>**：将一个已构造的对象插入到容器中。通常需要通过拷贝或移动构造将元素插入容器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">vec.<span class="built_in">insert</span>(vec.<span class="built_in">end</span>(), x);  <span class="comment">// 插入时会发生一次拷贝构造</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace</code>**：直接在容器内部构造元素，避免了额外的拷贝或移动操作。<code>emplace</code> 接受构造元素所需的参数，然后直接在容器中构造该元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">5</span>);  <span class="comment">// 在容器内部构造元素，避免拷贝</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么使用-emplace？"><a href="#为什么使用-emplace？" class="headerlink" title="为什么使用 emplace？"></a>为什么使用 <code>emplace</code>？</h3><ol>
<li><p><strong>避免不必要的拷贝或移动</strong>：</p>
<ul>
<li><code>insert</code> 必须先构造一个对象，然后将该对象插入容器，这可能涉及拷贝或移动构造。</li>
<li><code>emplace</code> 直接在容器中构造元素，省去了额外的拷贝或移动操作。</li>
</ul>
</li>
<li><p><strong>提高效率</strong>：</p>
<ul>
<li>特别是在容器中插入复杂对象时，使用 <code>emplace</code> 能显著提高性能，因为它直接传递构造参数，而不需要先创建一个对象。</li>
</ul>
</li>
</ol>
<h3 id="常见的-emplace-使用场景"><a href="#常见的-emplace-使用场景" class="headerlink" title="常见的 emplace 使用场景"></a>常见的 <code>emplace</code> 使用场景</h3><ul>
<li><p>**<code>emplace_back</code>**：用于 <code>std::vector</code> 等容器，在容器的末尾构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);  <span class="comment">// 直接构造元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace</code>**：对于 <code>std::map</code>、<code>std::unordered_map</code> 等关联容器，在指定位置构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">m.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);  <span class="comment">// 直接在 map 中构造一个键值对</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace_front</code>**：用于 <code>std::list</code> 等容器，在容器的前面构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line">lst.<span class="built_in">emplace_front</span>(<span class="number">10</span>);  <span class="comment">// 在容器前面直接构造一个元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="emplace-示例代码"><a href="#emplace-示例代码" class="headerlink" title="emplace 示例代码"></a><code>emplace</code> 示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 emplace_back 在 vector 中插入元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">10</span>);  <span class="comment">// 直接构造元素</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 10 20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace 在 map 中插入元素</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">    m.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    m.<span class="built_in">emplace</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : m) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// 1: apple</span></span><br><span class="line">    <span class="comment">// 2: banana</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>emplace</code> 提供了比 <code>insert</code> 更高效的方式来插入元素，因为它避免了不必要的对象构造、拷贝或移动操作。</li>
<li><code>emplace</code> 通过传递构造元素所需的参数，直接在容器内构造元素，而不是先创建元素再插入。</li>
<li>常见的 <code>emplace</code> 变种有 <code>emplace_back</code>（用于 <code>std::vector</code>）、<code>emplace</code>（用于 <code>std::map</code>, <code>std::unordered_map</code> 等）以及 <code>emplace_front</code>（用于 <code>std::list</code>）。</li>
</ul>
<p>使用 <code>emplace</code> 可以让你的程序更加高效，尤其是在需要频繁插入复杂对象时。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中关于深拷贝与重载赋值运算符的思考</title>
    <url>/2024/09/17/c++%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class instance</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">	int* height;</span><br><span class="line">instance(int a,int h)</span><br><span class="line">&#123;</span><br><span class="line">	age = a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	height=new int(h);</span><br><span class="line">	cout &lt;&lt; *height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~instance()</span><br><span class="line">&#123;</span><br><span class="line">	if (height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete height;</span><br><span class="line">		height = NULL;</span><br><span class="line">		cout &lt;&lt; &quot;已清空&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">instance(const instance&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	age = p.age;</span><br><span class="line">	//height = p.height;编译器默认实现的就是这行代码</span><br><span class="line">	//深拷贝如下</span><br><span class="line">	height = new int(*p.height); </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//浅拷贝使两个height指向同一内存地址，会导致将已释放的内存再次释放，引发双重释放安全问题</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	instance p1(18,160);</span><br><span class="line">	instance p2(p1);</span><br><span class="line">	cout &lt;&lt; p2.age &lt;&lt;*p2.height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h1><p>众所周知，运算符重载后使运算符能实现原本无法完成的工作<br>赋值运算符，这里我们实现类对类的赋值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    char* data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数</span><br><span class="line">    MyClass(const char* str = &quot;&quot;) &#123;</span><br><span class="line">        data = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    MyClass(const MyClass&amp; other) &#123;</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重载赋值运算符</span><br><span class="line">    MyClass&amp; operator=(const MyClass&amp; other) &#123;</span><br><span class="line">        if (this == &amp;other) &#123;</span><br><span class="line">            return *this;  // 处理自赋值情况</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先释放原有资源</span><br><span class="line">        delete[] data;</span><br><span class="line"></span><br><span class="line">        // 分配新内存并拷贝数据</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line"></span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 析构函数</span><br><span class="line">    ~MyClass() &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印数据</span><br><span class="line">    void print() const &#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass a(&quot;Hello&quot;);</span><br><span class="line">    MyClass b(&quot;World&quot;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Before assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;Hello&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    a = b; // 使用重载的赋值运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;After assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;World&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="注意：一定要将被赋值对象中在堆中的数据释放掉"><a href="#注意：一定要将被赋值对象中在堆中的数据释放掉" class="headerlink" title="注意：一定要将被赋值对象中在堆中的数据释放掉."></a>注意：一定要将被赋值对象中在堆中的数据释放掉.</h3><h3 id="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"><a href="#否则会导致旧资源直接被新资源赋值后，内存覆盖掉" class="headerlink" title="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"></a>否则会导致旧资源直接被新资源赋值后，内存覆盖掉</h3><h2 id="有内存泄露，资源浪费的风险，以及未定义行为的风险"><a href="#有内存泄露，资源浪费的风险，以及未定义行为的风险" class="headerlink" title="有内存泄露，资源浪费的风险，以及未定义行为的风险"></a>有内存泄露，资源浪费的风险，以及未定义行为的风险</h2><h4 id="具体会不会发生所谓的双重释放，个人认为不会"><a href="#具体会不会发生所谓的双重释放，个人认为不会" class="headerlink" title="具体会不会发生所谓的双重释放，个人认为不会"></a>具体会不会发生所谓的双重释放，个人认为不会</h4>]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>重载</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的I/O流</title>
    <url>/2024/11/25/c++%E4%B8%AD%E7%9A%84IO%E6%B5%81/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>输入输出（I&#x2F;O）库</strong>提供了流（<code>stream</code>）的状态管理功能。每个流对象（如 <code>cin</code>, <code>cout</code>, <code>ifstream</code>, <code>ofstream</code> 等）都有一个与之相关的状态，标志着当前流的操作是否成功。流的状态主要通过流的<strong>条件标志</strong>（flags）来表示。这些标志通常用于检查流是否处于有效的状态，以便在进行输入输出操作时处理异常或错误。</p>
<h3 id="流的条件状态（Flags）"><a href="#流的条件状态（Flags）" class="headerlink" title="流的条件状态（Flags）"></a>流的条件状态（Flags）</h3><p>流的条件状态通过 <code>ios</code> 类中的几个成员标志进行管理，这些标志包括：</p>
<ol>
<li>**<code>good()</code>**：流是否处于正常状态，即没有发生任何错误。</li>
<li>**<code>eof()</code>**：流是否已经到达文件末尾。</li>
<li>**<code>fail()</code>**：流是否遇到输入&#x2F;输出错误。</li>
<li>**<code>bad()</code>**：流是否发生严重错误，导致无法继续读取或写入。</li>
</ol>
<p>这些状态标志可以通过流对象的方法访问，通常用于判断流的状态。</p>
<h3 id="流的状态检查"><a href="#流的状态检查" class="headerlink" title="流的状态检查"></a>流的状态检查</h3><h4 id="1-good"><a href="#1-good" class="headerlink" title="1. good()"></a>1. <code>good()</code></h4><ul>
<li><p><strong><code>good()</code></strong> 返回 <code>true</code> 如果流没有遇到任何错误，输入输出操作可以继续进行。它相当于检查流的状态是否为 <code>ios::goodbit</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入流状态正常。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-eof"><a href="#2-eof" class="headerlink" title="2. eof()"></a>2. <code>eof()</code></h4><ul>
<li><p><strong><code>eof()</code></strong> 检查流是否已经到达文件末尾或输入结束标志。对于从文件读取或从输入流读取数据时，可以使用该标志判断是否已读取完所有数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;已到达输入的末尾。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-fail"><a href="#3-fail" class="headerlink" title="3. fail()"></a>3. <code>fail()</code></h4><ul>
<li><p><strong><code>fail()</code></strong> 检查流是否发生了格式错误或输入输出错误。如果输入的数据类型不匹配或文件无法打开等操作失败时，会返回 <code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入数据失败，数据格式错误。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-bad"><a href="#4-bad" class="headerlink" title="4. bad()"></a>4. <code>bad()</code></h4><ul>
<li><p><strong><code>bad()</code></strong> 返回 <code>true</code>，如果流处于严重错误状态，通常在硬件故障或流被意外关闭时会发生。这是最严重的错误状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发生了严重错误，流无法继续使用。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见的流状态标志"><a href="#常见的流状态标志" class="headerlink" title="常见的流状态标志"></a>常见的流状态标志</h3><ul>
<li>**<code>ios::goodbit</code>**：正常状态，表示流没有错误。</li>
<li>**<code>ios::eofbit</code>**：表示流已到达文件末尾或输入结束。</li>
<li>**<code>ios::failbit</code>**：表示流遇到非致命错误，通常是格式错误或读取错误。</li>
<li>**<code>ios::badbit</code>**：表示流遇到致命错误，通常是硬件故障或无法继续操作。</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例 1: 标准输入流 (cin)</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个整数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入失败，格式错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你输入的整数是: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2: 文件输入流 (ifstream)</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否读取到末尾</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;已到达文件末尾。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3: 检查文件流是否出现严重错误</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件流出现严重错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>good()</code></strong> 用于检查流是否没有任何错误。</li>
<li><strong><code>eof()</code></strong> 用于检查是否已到达输入流的末尾。</li>
<li><strong><code>fail()</code></strong> 用于检查流是否发生了可恢复的错误（如输入数据不匹配）。</li>
<li><strong><code>bad()</code></strong> 用于检查流是否发生了致命错误。</li>
</ul>
<p>通过检查这些状态标志，你可以更加精确地控制和管理程序中的输入输出操作，及时捕获和处理异常。</p>
<h1 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h1><p>在 C++ 中，<code>string</code> 流（<code>stringstream</code>）是用于处理字符串输入和输出的流类，它包含在 <code>&lt;sstream&gt;</code> 头文件中。<code>stringstream</code> 可以被用来从字符串中提取数据，或者将数据格式化并输出到字符串中。它是 <code>iostream</code> 库的扩展，结合了输入流（<code>istringstream</code>）、输出流（<code>ostringstream</code>）和读写流（<code>stringstream</code>）。</p>
<h3 id="使用-stringstream（stringstream即可代替istringstream与ostringstream）"><a href="#使用-stringstream（stringstream即可代替istringstream与ostringstream）" class="headerlink" title="使用 stringstream（stringstream即可代替istringstream与ostringstream）"></a>使用 <code>stringstream</code>（stringstream即可代替istringstream与ostringstream）</h3><ol>
<li><p><strong>创建和初始化：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream ss; <span class="comment">// 创建一个空的 stringstream 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 &lt;&lt; 操作符向 stringstream 中写入数据</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot; world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 stringstream 中的内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stringstream content: &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们创建了一个空的 <code>stringstream</code> 对象 <code>ss</code>，并通过 <code>&lt;&lt;</code> 操作符向其中写入数据。通过 <code>ss.str()</code> 可以获取当前 <code>stringstream</code> 中的字符串。</p>
</li>
<li><p><strong>从字符串中提取数据：</strong><br>使用 <code>istringstream</code> 来从字符串中读取数据，类似于从文件或标准输入中读取数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;123 45.67 Hello&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>; <span class="comment">// 创建一个从字符串读取数据的 istringstream</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 stringstream 中提取数据</span></span><br><span class="line">    iss &gt;&gt; i &gt;&gt; d &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>iss &gt;&gt; i &gt;&gt; d &gt;&gt; s;</code>，我们从字符串 <code>str</code> 中依次提取数据，将其赋值给变量 <code>i</code>（整数）、<code>d</code>（浮动数）和 <code>s</code>（字符串）。</p>
</li>
<li><p><strong>向字符串写入数据：</strong><br>使用 <code>ostringstream</code> 可以将数据写入到一个字符串中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ostringstream oss; <span class="comment">// 创建一个输出流对象</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">    string name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 stringstream 写入数据</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取存储在 stringstream 中的字符串</span></span><br><span class="line">    string result = oss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们使用 <code>ostringstream</code> 将变量 <code>name</code> 和 <code>age</code> 写入字符串流 <code>oss</code> 中，然后通过 <code>oss.str()</code> 获取最终的字符串。</p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>**<code>istringstream</code>**：从字符串中读取数据。</li>
<li>**<code>ostringstream</code>**：将数据写入字符串。</li>
<li>**<code>stringstream</code>**：既能从字符串读取数据，也能将数据写入字符串。</li>
</ul>
<p>这种流的使用场景很多，常用于处理复杂的字符串格式转换、提取和拼接。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>I/O流</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的协程（一）</title>
    <url>/2025/09/24/c++%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>在学习协程之前，我们再重新回顾一下进程，线程</p>
<ul>
<li><strong>进程 (Process)：</strong> 操作系统分配资源（内存、文件句柄等）的基本单位。每个进程有独立的地址空间。</li>
<li><strong>线程 (Thread)：</strong> CPU 调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的地址空间和资源。线程比进程更轻量级。</li>
</ul>
<hr>
<h3 id="1-内核线程-Kernel-Thread"><a href="#1-内核线程-Kernel-Thread" class="headerlink" title="1. 内核线程 (Kernel Thread)"></a>1. 内核线程 (Kernel Thread)</h3><ul>
<li><strong>定义：</strong> 内核线程是由操作系统内核直接创建、管理和调度的线程。也就是我们说的LWP(轻量级进程)，在linux系统中，内核线程和用户态线程是1：1的。</li>
<li><strong>实现：</strong> 操作系统内核维护所有内核线程的上下文信息（如寄存器状态、栈指针等）。当需要进行线程切换时，内核会执行上下文切换。</li>
<li><strong>调度：</strong> 由操作系统的调度器负责调度。调度器根据优先级、时间片等策略决定哪个线程在哪个 CPU 上运行。</li>
<li><strong>开销：</strong><ul>
<li><strong>创建&#x2F;销毁：</strong> 创建和销毁内核线程的开销相对较大，因为它涉及到系统调用和内核数据结构的操作。</li>
<li><strong>上下文切换：</strong> 上下文切换的开销也相对较大，因为它需要保存和恢复大量的寄存器信息，并且可能涉及到 TLB (Translation Lookaside Buffer) 刷新等操作。</li>
</ul>
</li>
<li><strong>并行性：</strong> 多个内核线程可以在多核 CPU 上真正并行执行。</li>
<li><strong>阻塞：</strong> 当一个内核线程执行阻塞式系统调用（如 I&#x2F;O 操作）时，只有该线程会被阻塞，同一进程中的其他内核线程可以继续运行。</li>
<li><strong>优点：</strong><ul>
<li>能够充分利用多核 CPU 的并行能力。</li>
<li>一个线程阻塞不会影响同一进程中的其他线程。</li>
<li>由操作系统管理，更稳定可靠。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>创建、销毁和切换开销较大，不适合创建大量线程的场景。</li>
<li>线程数量受限于操作系统资源。</li>
</ul>
</li>
<li><strong>例子：</strong> Linux 上的 POSIX 线程 (pthreads) 在默认情况下就是内核线程（1:1 模型）。Windows 上的线程也是内核线程。</li>
</ul>
<hr>
<h3 id="2-用户态线程-User-Level-Thread"><a href="#2-用户态线程-User-Level-Thread" class="headerlink" title="2. 用户态线程 (User-Level Thread)"></a>2. 用户态线程 (User-Level Thread)</h3><ul>
<li><strong>定义：</strong> 用户态线程是由用户空间的线程库（而不是操作系统内核）创建、管理和调度的线程。内核对这些线程一无所知，它只知道运行这些用户态线程的进程。</li>
<li><strong>实现：</strong> 线程库负责维护用户态线程的上下文信息（如程序计数器、栈指针、寄存器等）。线程的切换完全在用户空间完成，不涉及系统调用。</li>
<li><strong>调度：</strong> 由用户态的线程库自行调度。库可以实现自己的调度算法（例如，基于优先级、协作式调度或抢占式调度）。</li>
<li><strong>开销：</strong><ul>
<li><strong>创建&#x2F;销毁：</strong> 开销非常小，因为不涉及系统调用。</li>
<li><strong>上下文切换：</strong> 开销非常小，因为完全在用户空间完成，不需要进入内核态。</li>
</ul>
</li>
<li><strong>并行性：</strong> 多个用户态线程<strong>无法在多核 CPU 上真正并行执行</strong>。因为内核只知道一个进程，它会将整个进程调度到一个 CPU 上。即使进程中有多个用户态线程，在同一时刻，也只有一个用户态线程能运行。</li>
<li><strong>阻塞：</strong> 这是用户态线程的一个主要缺点。如果一个用户态线程执行了阻塞式系统调用，那么<strong>整个进程（包括所有其他用户态线程）都会被阻塞</strong>，直到该系统调用完成。这也是协程重点解决的问题，</li>
<li><strong>优点：</strong><ul>
<li>创建、销毁和切换开销极小，可以创建非常大量的线程。</li>
<li>用户可以自定义调度策略。</li>
</ul>
</li>
<li>缺点：<ul>
<li>无法利用多核 CPU 的并行性。</li>
<li>一个用户态线程阻塞会导致整个进程阻塞。</li>
<li>需要用户态线程库来管理，增加了编程复杂性。</li>
</ul>
</li>
<li><strong>例子：</strong> 早期的 Java 线程（在某些 JVM 实现中）、一些绿色线程 (Green Thread) 实现。</li>
</ul>
<hr>
<h3 id="3-协程-Coroutine"><a href="#3-协程-Coroutine" class="headerlink" title="3. 协程 (Coroutine)"></a>3. 协程 (Coroutine)</h3><ul>
<li><strong>定义：</strong> 协程是一种<strong>用户态的、协作式多任务</strong>的程序组件。它不是由操作系统调度，而是由程序自身控制其执行流程。协程可以在执行过程中暂停，并将控制权交回给调用者（或另一个协程），然后在需要时从暂停的地方恢复执行。</li>
<li><strong>实现：</strong> 完全在用户空间实现，不涉及任何系统调用。协程的切换是<strong>非抢占式</strong>的，即一个协程只有在主动让出控制权时才会被切换。</li>
<li><strong>调度：</strong> 由程序逻辑或协程库负责调度。它不是操作系统调度器的一部分。</li>
<li><strong>开销：</strong><ul>
<li><strong>创建&#x2F;销毁：</strong> 开销极小，通常只是分配一个小的栈空间。</li>
<li><strong>上下文切换：</strong> 开销极小，因为只保存和恢复最少的上下文信息（主要是程序计数器和栈指针），不涉及内核态切换，也没有 TLB 刷新等开销。</li>
</ul>
</li>
<li><strong>并行性：</strong> 协程<strong>无法在多核 CPU 上并行执行</strong>。在任何给定时刻，一个进程中只能有一个协程在运行。它们是并发的，而不是并行的。</li>
<li><strong>阻塞：</strong> 协程是<strong>非阻塞的</strong>。当一个协程需要等待 I&#x2F;O 或其他事件时，它会主动暂停执行，并将控制权交还给调度器。调度器可以运行其他协程，直到等待的事件完成，然后该协程再被恢复。这避免了整个进程或线程的阻塞。</li>
<li><strong>优点：</strong><ul>
<li>极低的创建、销毁和切换开销，可以创建数百万个协程。</li>
<li>避免了传统线程的同步问题（因为同一时间只有一个协程运行）。</li>
<li>代码逻辑更清晰，可以用同步的方式编写异步代码（“回调地狱”的终结者）。</li>
<li>非常适合 I&#x2F;O 密集型任务。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>协作式调度：</strong> 如果一个协程内部有长时间的计算任务，它不主动让出控制权，就会阻塞整个进程，导致其他协程无法执行（“饿死”）。</li>
<li>无法利用多核 CPU 的并行能力，如果需要并行计算，仍需结合多线程。</li>
</ul>
</li>
<li><strong>例子：</strong> Python 的 <code>asyncio</code>，Go 语言的 Goroutines，Lua 的协程，C++20 的 Coroutines。</li>
</ul>
<hr>
<h3 id="区别总结表"><a href="#区别总结表" class="headerlink" title="区别总结表"></a>区别总结表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">内核线程 (Kernel Thread)</th>
<th align="left">用户态线程 (User-Level Thread)</th>
<th align="left">LWP (Lightweight Process)</th>
<th align="left">协程 (Coroutine)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>管理方</strong></td>
<td align="left">操作系统内核</td>
<td align="left">用户态线程库</td>
<td align="left">操作系统内核</td>
<td align="left">用户态程序&#x2F;协程库</td>
</tr>
<tr>
<td align="left"><strong>调度方</strong></td>
<td align="left">操作系统调度器</td>
<td align="left">用户态线程库</td>
<td align="left">操作系统调度器</td>
<td align="left">程序逻辑&#x2F;协程库</td>
</tr>
<tr>
<td align="left"><strong>调度方式</strong></td>
<td align="left">抢占式</td>
<td align="left">抢占式或协作式</td>
<td align="left">抢占式</td>
<td align="left"><strong>协作式</strong></td>
</tr>
<tr>
<td align="left"><strong>上下文切换</strong></td>
<td align="left">内核态，开销大</td>
<td align="left">用户态，开销小</td>
<td align="left">内核态，开销大</td>
<td align="left">用户态，开销极小</td>
</tr>
<tr>
<td align="left"><strong>并行性</strong></td>
<td align="left"><strong>可并行</strong> (多核)</td>
<td align="left"><strong>不可并行</strong></td>
<td align="left"><strong>可并行</strong> (多核)</td>
<td align="left"><strong>不可并行</strong></td>
</tr>
<tr>
<td align="left"><strong>阻塞影响</strong></td>
<td align="left">单个线程阻塞</td>
<td align="left"><strong>整个进程阻塞</strong></td>
<td align="left">单个 LWP 阻塞</td>
<td align="left"><strong>不阻塞</strong> (主动让出控制)</td>
</tr>
<tr>
<td align="left"><strong>创建数量</strong></td>
<td align="left">相对有限</td>
<td align="left">可大量创建</td>
<td align="left">相对有限</td>
<td align="left"><strong>可大量创建 (百万级)</strong></td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left">较大</td>
<td align="left">较小</td>
<td align="left">较大</td>
<td align="left">极小</td>
</tr>
<tr>
<td align="left"><strong>主要优点</strong></td>
<td align="left">利用多核，稳定</td>
<td align="left">开销小，可定制调度</td>
<td align="left">利用多核，提供执行上下文</td>
<td align="left">开销极小，非阻塞 I&#x2F;O，同步代码写异步逻辑</td>
</tr>
<tr>
<td align="left"><strong>主要缺点</strong></td>
<td align="left">开销大</td>
<td align="left">无法并行，阻塞整个进程</td>
<td align="left">开销大</td>
<td align="left">无法并行，协作式调度需小心</td>
</tr>
<tr>
<td align="left"><strong>现代应用</strong></td>
<td align="left">Linux pthreads (1:1)</td>
<td align="left">极少直接使用</td>
<td align="left">Linux 内核线程的别称</td>
<td align="left">Go Goroutines, Python asyncio, C++20 Coroutines</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>内核线程</strong>是操作系统提供的最基本的并发执行单元，开销相对大，但能充分利用多核。</li>
<li><strong>用户态线程</strong>是用户空间库实现的并发，开销极小，但无法并行，且阻塞时会影响整个进程。</li>
<li><strong>LWP</strong> 是内核调度实体，在 Linux 中几乎等同于内核线程，它为用户态线程提供了内核上下文。</li>
<li><strong>协程</strong>是用户态的协作式任务，开销极小，通过主动让出控制权实现非阻塞，非常适合高并发 I&#x2F;O 密集型任务，但无法并行。</li>
</ul>
<p><strong>这里简单总结一下，一个pthread对应一个内核线程，用户态线程：内核线程&#x3D;n:1的，所以用户态线程无法并行执行，甚至遇到阻塞时连并发都做不到。</strong></p>
<p><strong>而对于协程而言，其实和用户态线程差不多，只是不会阻塞，也是只能做到并发而无法并行，比如python中的协程。但是go和java中的协程引入了调度器，实现m:n的映射，让多个协程映射到多个内核线程，从而可以实现真正的并行</strong></p>
<p>但是这里引入了一个很有意思的问题，在同一个程序（进程）里面通过pthread库实现了多个内核线程，并将其绑定在不同的内核上，就要考虑缓存一致性这个问题。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>c中的协程(三)</title>
    <url>/2025/10/11/c++%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p> 在 C++20 中，协程由多个部分组成，其中 <strong>等待体</strong>、<strong>协程体</strong> 和 <strong><code>promise_type</code></strong> 是关键组成部分。它们各自负责协程的不同方面，密切配合，共同完成协程的生命周期管理、执行与返回值的处理。</p>
<h3 id="关系概述："><a href="#关系概述：" class="headerlink" title="关系概述："></a>关系概述：</h3><ol>
<li><p><strong>协程体</strong>（Coroutine Body）是我们定义的协程函数，即用户定义的异步操作逻辑，通常包含 <code>co_await</code>、<code>co_yield</code> 和 <code>co_return</code> 等操作。</p>
</li>
<li><p><strong>等待体</strong>（Awaitable）是协程体中通过 <code>co_await</code> 关键字进行挂起的对象。它定义了协程如何挂起并等待某些异步操作的完成。</p>
</li>
<li><p><strong><code>promise_type</code></strong> 是协程的内部管理对象，负责协程的生命周期，包括挂起、恢复、返回值以及异常的处理。每个协程都会有一个与之关联的 <code>promise_type</code>，它控制协程体的行为和返回值的处理。</p>
</li>
</ol>
<h3 id="它们的具体关系："><a href="#它们的具体关系：" class="headerlink" title="它们的具体关系："></a>它们的具体关系：</h3><ul>
<li><strong>协程体</strong> 会依赖 <strong><code>promise_type</code></strong> 来控制协程的执行和返回值。</li>
<li><strong><code>promise_type</code></strong> 负责管理协程的状态，包括决定何时挂起和恢复协程，以及处理协程的返回值。</li>
<li><strong>等待体</strong> 是协程体中通过 <code>co_await</code> 进行挂起的对象，它决定协程何时挂起，并提供恢复协程的机制。</li>
</ul>
<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>为了更清晰地理解这些组件之间的关系，下面我将通过一个完整的实例展示它们是如何协同工作的。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的 awaitable 类型，模拟一个异步任务</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAwaitable</span> &#123;</span><br><span class="line">    <span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果已经准备好，不挂起协程</span></span><br><span class="line">        <span class="keyword">return</span> ready;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Suspending coroutine...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 模拟异步操作（通过一个线程来延迟）</span></span><br><span class="line">        std::<span class="built_in">thread</span>([h]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟异步操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Resuming coroutine!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            h.<span class="built_in">resume</span>();  <span class="comment">// 2秒后恢复协程</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复协程后执行的操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resuming coroutine and returning result!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义协程体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCoroutine</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span>;  <span class="comment">// 协程的 promise_type</span></span><br><span class="line">    <span class="keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">    handle_type h;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyCoroutine</span>(handle_type h) : <span class="built_in">h</span>(h) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyCoroutine</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (h) &#123;</span><br><span class="line">            h.<span class="built_in">destroy</span>();  <span class="comment">// 协程结束时销毁协程句柄</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h) h.<span class="built_in">resume</span>();  <span class="comment">// 恢复协程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过协程句柄访问 promise_type</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> h.<span class="built_in">done</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义协程的 promise_type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCoroutine</span>::promise_type &#123;</span><br><span class="line">    <span class="function">MyCoroutine <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyCoroutine&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 协程一开始时挂起</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 协程结束时挂起</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Returning value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unhandled exception in coroutine!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义协程函数</span></span><br><span class="line"><span class="function">MyCoroutine <span class="title">example_coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before co_await&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 awaitable 对象挂起协程</span></span><br><span class="line">    MyAwaitable awaitable;</span><br><span class="line">    <span class="keyword">co_await</span> awaitable;  <span class="comment">// 挂起协程，直到 awaitable 完成</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After co_await&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">42</span>;  <span class="comment">// 返回值并结束协程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine started!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> coroutine = <span class="built_in">example_coroutine</span>();  <span class="comment">// 启动协程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待协程完成</span></span><br><span class="line">    <span class="keyword">while</span> (!coroutine.<span class="built_in">done</span>()) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));  <span class="comment">// 主线程休眠</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine finished!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h3><h4 id="1-MyAwaitable（等待体）"><a href="#1-MyAwaitable（等待体）" class="headerlink" title="1. MyAwaitable（等待体）"></a>1. <strong><code>MyAwaitable</code>（等待体）</strong></h4><ul>
<li>这是一个 <code>awaitable</code> 类型，表示一个可以被 <code>co_await</code> 等待的对象。它模拟了一个异步任务，通过 <code>await_suspend()</code> 来延迟协程的执行。</li>
<li><code>await_ready()</code>：检查是否可以立刻继续执行协程，如果返回 <code>false</code>，则协程会挂起。</li>
<li><code>await_suspend()</code>：协程挂起的地方，这里模拟了一个耗时 2 秒的异步操作（通过 <code>std::thread</code>）。</li>
<li><code>await_resume()</code>：协程恢复后，执行此函数。</li>
</ul>
<h4 id="2-promise-type"><a href="#2-promise-type" class="headerlink" title="2. promise_type"></a>2. <strong><code>promise_type</code></strong></h4><ul>
<li>每个协程都会有一个与之关联的 <code>promise_type</code>，它负责管理协程的生命周期，包括挂起和恢复协程的时机。</li>
<li><code>get_return_object()</code>：创建并返回协程的最终对象（<code>MyCoroutine</code>）。</li>
<li><code>initial_suspend()</code>：协程开始时挂起，直到满足恢复条件（通常是异步任务完成）。</li>
<li><code>final_suspend()</code>：协程结束时挂起，允许执行一些清理工作。</li>
<li><code>return_value()</code>：协程的返回值处理函数，这里输出返回值 <code>42</code>。</li>
</ul>
<h4 id="3-MyCoroutine（协程体）"><a href="#3-MyCoroutine（协程体）" class="headerlink" title="3. MyCoroutine（协程体）"></a>3. <strong><code>MyCoroutine</code>（协程体）</strong></h4><ul>
<li>这是我们定义的协程体，它包含协程的逻辑。通过 <code>co_await</code> 挂起协程并等待 <code>MyAwaitable</code> 对象的完成。</li>
<li>协程体通过 <code>promise_type</code> 来获取协程句柄，句柄管理协程的状态（执行、恢复、销毁）。</li>
</ul>
<h4 id="4-example-coroutine-（协程函数）"><a href="#4-example-coroutine-（协程函数）" class="headerlink" title="4. example_coroutine()（协程函数）"></a>4. <strong><code>example_coroutine()</code>（协程函数）</strong></h4><ul>
<li>协程函数是用户定义的异步操作。它通过 <code>co_await</code> 挂起协程，等待 <code>MyAwaitable</code> 对象的完成。</li>
<li>协程完成后，使用 <code>co_return</code> 返回一个值（<code>42</code>）。</li>
</ul>
<h4 id="5-main"><a href="#5-main" class="headerlink" title="5. main()"></a>5. <strong><code>main()</code></strong></h4><ul>
<li>在主线程中启动协程，等待协程完成。主线程通过 <code>while</code> 循环检查协程是否完成，直到协程执行结束。</li>
</ul>
<h3 id="程序输出："><a href="#程序输出：" class="headerlink" title="程序输出："></a>程序输出：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Coroutine started!</span><br><span class="line">Before co_await</span><br><span class="line">Suspending coroutine...</span><br><span class="line">Resuming coroutine!</span><br><span class="line">Resuming coroutine and returning result!</span><br><span class="line">After co_await</span><br><span class="line">Returning value: 42</span><br><span class="line">Coroutine finished!</span><br></pre></td></tr></table></figure>

<h3 id="关键点总结："><a href="#关键点总结：" class="headerlink" title="关键点总结："></a>关键点总结：</h3><ul>
<li><strong>协程体（<code>example_coroutine</code>）</strong> 包含了实际的异步任务，它通过 <code>co_await</code> 等待 <code>awaitable</code> 对象的完成。</li>
<li><strong><code>promise_type</code></strong> 管理协程的生命周期，包括初始化、挂起、恢复和结束时的操作。</li>
<li><strong>等待体（<code>MyAwaitable</code>）</strong> 是协程体中通过 <code>co_await</code> 等待的对象，它负责挂起协程，直到某个异步事件发生（在本例中是模拟的 2 秒延迟）。</li>
</ul>
<p>但是实际上，对于异步操作，我们不是必须要实现自定义的awaitable结构体，c++为future等标准库接口都实现了内置的awaitable组件，可以直接用于co_await</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;coroutine&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">std::future&lt;int&gt; async_task() &#123;</span><br><span class="line">    return std::async(std::launch::async, []() &#123;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(2));</span><br><span class="line">        return 42;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct my_coroutine &#123;</span><br><span class="line">    struct promise_type;  // 协程的 promise_type</span><br><span class="line">    using handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">    handle_type h;</span><br><span class="line"></span><br><span class="line">    my_coroutine(handle_type h) : h(h) &#123;&#125;</span><br><span class="line">    ~my_coroutine() &#123; if (h) h.destroy(); &#125;</span><br><span class="line"></span><br><span class="line">    void resume() &#123; if (h) h.resume(); &#125;</span><br><span class="line">    bool done() const &#123; return h.done(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct my_coroutine::promise_type &#123;</span><br><span class="line">    my_coroutine get_return_object() &#123;</span><br><span class="line">        return my_coroutine&#123;std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::suspend_always initial_suspend() &#123; return &#123;&#125;; &#125;</span><br><span class="line">    std::suspend_always final_suspend() noexcept &#123; return &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    void return_value(int value) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Returning value: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void unhandled_exception() &#123; std::cout &lt;&lt; &quot;Unhandled exception!&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">my_coroutine example_coroutine() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Before co_await&quot; &lt;&lt; std::endl;</span><br><span class="line">    auto result = co_await async_task();  // co_await 未来的结果</span><br><span class="line">    std::cout &lt;&lt; &quot;After co_await, result = &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    co_return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Coroutine started!&quot; &lt;&lt; std::endl;</span><br><span class="line">    auto coro = example_coroutine();  // 启动协程</span><br><span class="line">    while (!coro.done()) &#123;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;Coroutine finished!&quot; &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> C++20 中的协程通过语言特性对异步编程进行了极大的简化。它们的基本组成包括了 <strong>协程体（coroutine body）</strong>、<strong>promise 类型（promise_type）</strong>、<strong>协程句柄（coroutine handle）</strong> 和 <strong>协程的挂起与恢复机制</strong>。每个协程的实现都由几个关键组件组成，下面我将详细描述 C++20 协程的主要组成部分。</p>
<h3 id="C-20-协程的主要组成部分"><a href="#C-20-协程的主要组成部分" class="headerlink" title="C++20 协程的主要组成部分"></a>C++20 协程的主要组成部分</h3><ol>
<li><p><strong>协程体（Coroutine Body）</strong></p>
<ul>
<li>协程体是用户编写的函数，它定义了协程的具体逻辑。</li>
<li>协程体内可以使用 <code>co_await</code>、<code>co_yield</code> 和 <code>co_return</code>，这些关键字用于挂起、恢复和返回协程的结果。</li>
</ul>
</li>
<li><p><strong>Promise 类型（Promise Type）</strong></p>
<ul>
<li>每个协程都有一个与之关联的 <code>promise_type</code>，它管理协程的状态和返回值。</li>
<li><code>promise_type</code> 负责协程的执行和控制流程的挂起与恢复。</li>
<li>它会暴露一些特殊的成员函数来处理协程的生命周期，包括初始化、最终挂起、返回值、异常处理等。</li>
</ul>
</li>
<li><p><strong>协程句柄（Coroutine Handle）</strong></p>
<ul>
<li>协程句柄 <code>std::coroutine_handle</code> 是协程的核心，它允许我们在协程被挂起时保存协程的状态，并在适当的时候恢复协程。</li>
<li>协程句柄的功能包括：恢复协程、销毁协程等。</li>
<li>协程句柄通过 <code>std::coroutine_handle&lt;promise_type&gt;</code> 实现，它用于访问协程的 <code>promise_type</code>。</li>
</ul>
</li>
<li><p><strong>协程挂起与恢复机制</strong></p>
<ul>
<li><code>co_await</code>：用于等待一个可等待对象（awaitable），并在该对象准备好时恢复协程。</li>
<li><code>co_yield</code>：用于生成一个值并挂起当前协程，这在生成器（如异步流、迭代器）中特别有用。</li>
<li><code>co_return</code>：用于返回协程的结果并结束协程的执行。</li>
</ul>
</li>
<li><p><strong>协程的返回值与结果处理</strong></p>
<ul>
<li>协程的返回值由 <code>promise_type</code> 的 <code>return_value</code> 方法来定义。返回值会通过 <code>co_return</code> 被传递给 <code>promise_type</code>，从而影响协程的最终结果。</li>
<li>协程的结果会通过协程句柄的 <code>promise_type</code> 被访问和处理。</li>
</ul>
</li>
<li><p><strong>协程的生命周期管理</strong></p>
<ul>
<li>协程的生命周期由编译器和标准库自动管理，程序员不需要显式地管理栈和上下文切换。通过 <code>co_await</code> 和 <code>co_return</code>，协程的生命周期会被适当挂起和恢复。</li>
<li>协程的销毁（在协程结束时）由协程句柄自动处理。</li>
</ul>
</li>
<li><p><strong>协程的异常处理</strong></p>
<ul>
<li>协程的异常处理通常通过 <code>promise_type</code> 的 <code>unhandled_exception</code> 函数来处理。在协程执行过程中，如果发生了异常，<code>unhandled_exception</code> 方法会被调用，并可以决定是否继续执行或者退出。</li>
<li><code>co_return</code> 也可以处理协程返回时的异常情况。</li>
</ul>
</li>
</ol>
<h3 id="协程的结构与执行流程"><a href="#协程的结构与执行流程" class="headerlink" title="协程的结构与执行流程"></a>协程的结构与执行流程</h3><p>C++20 协程的执行流程可以分为以下几个步骤：</p>
<ol>
<li><p><strong>协程启动：</strong></p>
<ul>
<li>当协程被调用时，它首先会执行 <code>promise_type</code> 中定义的 <code>initial_suspend</code> 函数，通常这个函数会返回一个 <code>std::suspend_always</code> 或者 <code>std::suspend_never</code> 对象，决定协程是否立刻挂起。</li>
</ul>
</li>
<li><p><strong>协程挂起：</strong></p>
<ul>
<li>在协程体内，遇到 <code>co_await</code> 时，协程会挂起，并等待可等待对象的结果。</li>
<li><code>co_await</code> 关键字会在底层调用 <code>awaitable</code> 类型的 <code>await_suspend</code> 方法，通常这个方法会将当前协程挂起，并等待某些异步事件（如网络响应或文件读取）完成。</li>
</ul>
</li>
<li><p><strong>协程恢复：</strong></p>
<ul>
<li>当协程挂起的条件（如异步操作完成）满足时，<code>awaitable</code> 类型的 <code>await_resume</code> 方法会被调用，从而恢复协程的执行。</li>
<li>协程恢复后，控制流继续从挂起的地方执行。</li>
</ul>
</li>
<li><p><strong>协程结束：</strong></p>
<ul>
<li>当协程体执行到 <code>co_return</code> 或者末尾时，协程将会结束，并通过 <code>promise_type</code> 的 <code>return_value</code> 返回最终的值。</li>
<li>最后，协程会调用 <code>final_suspend</code> 函数，这个函数通常会决定协程在结束时是否挂起，或者协程结束时是否执行一些清理操作。</li>
</ul>
</li>
</ol>
<h3 id="协程各部分详解"><a href="#协程各部分详解" class="headerlink" title="协程各部分详解"></a>协程各部分详解</h3><h4 id="1-协程体（Coroutine-Body）"><a href="#1-协程体（Coroutine-Body）" class="headerlink" title="1. 协程体（Coroutine Body）"></a>1. 协程体（Coroutine Body）</h4><p>协程体是用户定义的函数，里面的 <code>co_await</code>、<code>co_yield</code> 和 <code>co_return</code> 会使得协程在执行过程中可以挂起、恢复和返回值。一个基本的协程体的代码可能如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::coroutine_handle&lt;&gt; <span class="built_in">example_coroutine</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">some_async_task</span><span class="params">()</span></span>;  <span class="comment">// 挂起</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Resumed coroutine&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_return</span>;  <span class="comment">// 结束协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Promise-类型（Promise-Type）"><a href="#2-Promise-类型（Promise-Type）" class="headerlink" title="2. Promise 类型（Promise Type）"></a>2. Promise 类型（Promise Type）</h4><p>协程的 <code>promise_type</code> 是一个关键组件，它定义了协程的生命周期，包括如何挂起、如何返回结果和如何处理异常。一个 <code>promise_type</code> 可能包括以下方法：</p>
<ul>
<li><code>initial_suspend()</code>：在协程开始时执行，决定协程是否立刻挂起。</li>
<li><code>final_suspend()</code>：在协程结束时执行，决定协程是否挂起。</li>
<li><code>return_value()</code>：当协程返回值时调用。</li>
<li><code>unhandled_exception()</code>：处理协程中的异常。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; value = v; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-协程句柄（Coroutine-Handle）"><a href="#3-协程句柄（Coroutine-Handle）" class="headerlink" title="3. 协程句柄（Coroutine Handle）"></a>3. 协程句柄（Coroutine Handle）</h4><p>协程句柄是一个表示协程执行状态的对象，它允许我们恢复协程，检查协程的状态，甚至销毁协程。通过 <code>std::coroutine_handle&lt;promise_type&gt;</code>，我们可以访问协程的 <code>promise_type</code>，并通过句柄来恢复协程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::coroutine_handle&lt;&gt; handle = <span class="built_in">example_coroutine</span>();</span><br><span class="line">handle.<span class="built_in">resume</span>();  <span class="comment">// 恢复协程</span></span><br></pre></td></tr></table></figure>

<h4 id="4-协程挂起与恢复机制"><a href="#4-协程挂起与恢复机制" class="headerlink" title="4. 协程挂起与恢复机制"></a>4. 协程挂起与恢复机制</h4><ul>
<li>**<code>co_await</code>**：等待一个 <code>awaitable</code> 对象，挂起协程直到对象准备好。</li>
<li>**<code>co_yield</code>**：生成一个值并挂起协程，适用于生成器类型的协程。</li>
<li>**<code>co_return</code>**：返回一个值并结束协程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">co_await</span> <span class="title">some_async_task</span><span class="params">()</span></span>;  <span class="comment">// 协程挂起，等待异步任务完成</span></span><br><span class="line"><span class="keyword">co_yield</span> some_value;         <span class="comment">// 挂起协程并生成一个值</span></span><br><span class="line"><span class="keyword">co_return</span> some_result;       <span class="comment">// 协程结束并返回一个结果</span></span><br></pre></td></tr></table></figure>

<h4 id="5-协程的生命周期管理"><a href="#5-协程的生命周期管理" class="headerlink" title="5. 协程的生命周期管理"></a>5. 协程的生命周期管理</h4><p>C++20 协程的生命周期管理通常由编译器和标准库自动处理，包括协程的挂起、恢复、返回值和销毁。我们通过 <code>co_await</code> 和 <code>co_return</code> 来触发协程的状态转变。</p>
<h4 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h4><p>C++20 协程支持在协程中处理异常。当协程抛出异常时，可以在 <code>promise_type</code> 中通过 <code>unhandled_exception()</code> 方法进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理异常，或直接退出程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++20 协程的实现涉及多个核心组件，每个部分协同工作，使得异步编程变得更加直观和高效。协程体、<code>promise_type</code>、协程句柄以及协程的挂起与恢复机制共同组成了 C++20 协程的基础结构。理解这些组成部分并掌握其使用，可以帮助你高效地编写异步代码。</p>
<p> 是的，**<code>co_await</code>** 等待的 <code>awaitable</code> 对象通常会在任务完成时恢复（<code>resume</code>）原协程。关于 **<code>co_yield</code>**，它的作用和行为稍有不同，尤其是在生成器和协程之间的交互方面。</p>
<p>我们逐个详细讲解：</p>
<h3 id="1-co-await-和-awaitable-对象"><a href="#1-co-await-和-awaitable-对象" class="headerlink" title="1. co_await 和 awaitable 对象"></a>1. <strong><code>co_await</code> 和 <code>awaitable</code> 对象</strong></h3><ul>
<li><strong><code>co_await</code></strong> 的作用是挂起协程，直到 <code>awaitable</code> 对象的操作完成。**<code>awaitable</code>** 是一种描述异步任务的对象，它通常会提供一个 <code>await_suspend()</code> 方法，当任务完成时，<code>await_suspend()</code> 会调用协程句柄（<code>coroutine_handle</code>）的 <code>resume()</code> 方法，恢复原协程的执行。</li>
</ul>
<p>   <strong>总结：</strong> <code>co_await</code> 等待的 <code>awaitable</code> 对象的任务完成时，<strong>一定会</strong> 让原协程恢复执行，除非发生了异常或其他错误，协程的状态是无法继续的。</p>
<h4 id="示例：co-await-恢复协程"><a href="#示例：co-await-恢复协程" class="headerlink" title="示例：co_await 恢复协程"></a>示例：<code>co_await</code> 恢复协程</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 awaitable 类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAsyncTask</span> &#123;</span><br><span class="line">    <span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ready;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Suspending coroutine...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">thread</span>([h]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));  <span class="comment">// 模拟异步操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Resuming coroutine!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            h.<span class="built_in">resume</span>();  <span class="comment">// 完成后恢复协程</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async task completed, resuming coroutine!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 co_await 的协程函数</span></span><br><span class="line">std::coroutine_handle&lt;&gt; <span class="built_in">my_coroutine</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before co_await&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    MyAsyncTask task;</span><br><span class="line">    <span class="keyword">co_await</span> task;  <span class="comment">// 挂起协程，等待任务完成</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After co_await&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine started!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> handle = <span class="built_in">my_coroutine</span>();</span><br><span class="line">    handle.<span class="built_in">resume</span>();  <span class="comment">// 启动协程</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));  <span class="comment">// 等待协程完成</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine finished!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Coroutine started!</span><br><span class="line">Before co_await</span><br><span class="line">Suspending coroutine...</span><br><span class="line">Resuming coroutine!</span><br><span class="line">Async task completed, resuming coroutine!</span><br><span class="line">After co_await</span><br><span class="line">Coroutine finished!</span><br></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>co_await task;</code> 让协程挂起，直到 <code>MyAsyncTask</code> 的任务完成。</li>
<li>在 <code>await_suspend()</code> 中，我们模拟了一个异步操作（<code>std::thread</code>），并在操作完成后通过 <code>h.resume()</code> 恢复协程的执行。</li>
<li>结果是：协程在挂起 2 秒后恢复，继续执行 <code>co_await</code> 之后的代码。</li>
</ul>
<h3 id="2-co-yield-和返回值"><a href="#2-co-yield-和返回值" class="headerlink" title="2. co_yield 和返回值"></a>2. <strong><code>co_yield</code> 和返回值</strong></h3><ul>
<li><strong><code>co_yield</code></strong> 的作用是挂起协程，并将一个值返回给协程的调用者或迭代器。这个返回的值通常用于生成器模式中，让协程“生成”一个值，并在之后的执行中继续。</li>
<li><code>co_yield</code> 不会完全结束协程，而是挂起协程并允许协程生成一个值，之后可以通过协程的恢复继续生成下一个值。</li>
</ul>
<h4 id="co-yield-的值："><a href="#co-yield-的值：" class="headerlink" title="co_yield 的值："></a><strong><code>co_yield</code> 的值：</strong></h4><ul>
<li>当使用 <code>co_yield</code> 时，协程会挂起并将一个值返回给调用者。这个值通常是用户定义的类型，或者是协程函数返回的类型。</li>
<li>例如，在生成器中，<code>co_yield</code> 生成一个序列中的下一个值，并且协程可以在继续生成下一个值时恢复。</li>
</ul>
<h4 id="示例：生成器模式（co-yield）"><a href="#示例：生成器模式（co-yield）" class="headerlink" title="示例：生成器模式（co_yield）"></a>示例：生成器模式（<code>co_yield</code>）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义生成器类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span>;</span><br><span class="line">    <span class="keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">    handle_type h;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Generator</span>(handle_type h) : <span class="built_in">h</span>(h) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Generator</span>() &#123; <span class="keyword">if</span> (h) h.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        h.<span class="built_in">resume</span>();</span><br><span class="line">        <span class="keyword">return</span> !h.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">current_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h.<span class="built_in">promise</span>().current_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="type">int</span> current_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Generator&#123;handle_type::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            current_value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器协程函数</span></span><br><span class="line"><span class="function">Generator <span class="title">counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">co_yield</span> i;  <span class="comment">// 挂起协程并返回当前值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> g = <span class="built_in">counter</span>(); <span class="comment">//生成协程对象，惰性启动</span></span><br><span class="line">    <span class="keyword">while</span> (g.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Generated value: &quot;</span> &lt;&lt; g.<span class="built_in">current_value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finished!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Generated value: 1</span><br><span class="line">Generated value: 2</span><br><span class="line">Generated value: 3</span><br><span class="line">Generated value: 4</span><br><span class="line">Generated value: 5</span><br><span class="line">Finished!</span><br></pre></td></tr></table></figure>

<h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>co_yield i;</code> 挂起协程并返回当前值 <code>i</code>，每次调用 <code>g.next()</code> 都会恢复协程，生成下一个值。</li>
<li>每次 <code>co_yield</code> 都将一个整数返回给调用者（主程序），并且协程保持挂起，等待下次恢复。</li>
</ul>
<h3 id="3-挂起后如何恢复协程："><a href="#3-挂起后如何恢复协程：" class="headerlink" title="3. 挂起后如何恢复协程："></a>3. <strong>挂起后如何恢复协程：</strong></h3><ul>
<li>在 <code>co_yield</code> 中，协程的挂起和恢复是由协程句柄（<code>std::coroutine_handle</code>）控制的。当协程执行到 <code>co_yield</code> 时，它会返回一个值并挂起。</li>
<li>协程的恢复是通过 <code>next()</code> 或类似的机制来实现的。每次恢复时，协程会从挂起点继续执行，直到完成或再次遇到 <code>co_yield</code> 或 <code>co_return</code>。</li>
<li>对于生成器，恢复通常是通过调用 <code>next()</code> 方法来驱动协程的继续执行。在生成器的情况下，<code>next()</code> 会在每次 <code>co_yield</code> 后恢复协程。</li>
</ul>
<h3 id="4-co-return-的行为："><a href="#4-co-return-的行为：" class="headerlink" title="4. co_return 的行为："></a>4. <strong><code>co_return</code> 的行为：</strong></h3><ul>
<li><code>co_return</code> 用于从协程中返回一个最终值，并结束协程的执行。与 <code>co_yield</code> 不同，<code>co_return</code> 会完全结束协程的生命周期，不能再恢复。</li>
</ul>
<h4 id="示例：co-return"><a href="#示例：co-return" class="headerlink" title="示例：co_return"></a>示例：<code>co_return</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_coroutine</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span>;</span><br><span class="line">    <span class="keyword">using</span> handle_type = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line"></span><br><span class="line">    handle_type h;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">my_coroutine</span>(handle_type h) : <span class="built_in">h</span>(h) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">my_coroutine</span>() &#123; <span class="keyword">if</span> (h) h.<span class="built_in">destroy</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (h) h.<span class="built_in">resume</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> h.<span class="built_in">done</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_coroutine</span>::promise_type &#123;</span><br><span class="line">    <span class="type">int</span> return_value;</span><br><span class="line"></span><br><span class="line">    <span class="function">my_coroutine <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> my_coroutine&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        return_value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123; std::<span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">my_coroutine <span class="title">example_coroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before co_return&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">42</span>;  <span class="comment">// 直接返回一个值，结束协程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This line will never be printed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> coro = <span class="built_in">example_coroutine</span>();</span><br><span class="line">    coro.<span class="built_in">resume</span>();  <span class="comment">// 启动协程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Coroutine finished!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before co_return</span><br><span class="line">Coroutine finished!</span><br></pre></td></tr></table></figure>

<h4 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h4><ul>
<li>在 <code>co_return 42;</code> 中，协程立即返回 42，并结束协程的执行。任何在 <code>co_return</code> 后的代码都不会被执行。</li>
</ul>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>**<code>co_await</code>**：通过 <code>awaitable</code> 对象挂起协程，<code>awaitable</code> 完成任务后，协程会自动恢复。</li>
<li>**<code>co_yield</code>**：挂起协程并返回一个值给调用者，协程可以继续生成多个值，直到</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>c中的协程(二)</title>
    <url>/2025/10/10/c++%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%BA%8C)/</url>
    <content><![CDATA[<p> 栈协程（<strong>Stackful Coroutine</strong>）和无栈协程（<strong>Stackless Coroutine</strong>）的底层原理和实现方式有很大的区别，特别是在如何管理协程的执行状态、内存和栈的分配上。它们分别采用不同的策略来实现协程的暂停与恢复，以下是它们的具体实现方式、区别和底层原理的详细解析。</p>
<hr>
<h2 id="1-栈协程（Stackful-Coroutine）"><a href="#1-栈协程（Stackful-Coroutine）" class="headerlink" title="1. 栈协程（Stackful Coroutine）"></a>1. <strong>栈协程（Stackful Coroutine）</strong></h2><p>栈协程的基本原理是为每个协程分配一个独立的栈空间。栈空间用于保存协程的局部变量、函数调用的状态（比如返回地址、参数、局部数据）以及执行的上下文。当协程暂停时，整个栈内容（包括程序计数器、寄存器等）都会被保存；当协程恢复时，这些状态会被恢复，栈继续执行。</p>
<h3 id="栈协程的实现方式："><a href="#栈协程的实现方式：" class="headerlink" title="栈协程的实现方式："></a><strong>栈协程的实现方式：</strong></h3><p>栈协程的底层实现一般需要依赖操作系统提供的线程或者使用一些低级的上下文切换机制，常见的有：</p>
<ol>
<li><p><strong>使用线程</strong>：栈协程的实现有时会通过操作系统的线程来模拟。每个协程有独立的栈和线程上下文，操作系统调度器负责协程的切换。</p>
<p><strong>例子</strong>： <code>boost::context</code> 或 <code>libco</code> 等库，使用 <code>setjmp</code> 和 <code>longjmp</code> 来保存和恢复栈状态，或者使用线程来模拟协程。</p>
</li>
<li><p>**使用 <code>setjmp</code> 和 <code>longjmp</code>**：</p>
<ul>
<li><code>setjmp</code>：保存当前的执行状态（程序计数器、寄存器值等）。</li>
<li><code>longjmp</code>：恢复先前通过 <code>setjmp</code> 保存的执行状态，使程序回到 <code>setjmp</code> 处继续执行。</li>
</ul>
<p><strong>流程</strong>：</p>
<ul>
<li>在创建协程时，栈协程的执行状态会被保存到一个特定的数据结构中，通常是一个上下文（包括程序计数器、寄存器等）。</li>
<li>当协程被调度时，执行状态被恢复，栈继续执行。</li>
<li>每个协程会有自己的栈空间，操作系统或用户空间的调度器负责切换。</li>
</ul>
</li>
<li><p><strong>基于操作系统线程</strong>：栈协程还可以基于操作系统线程来实现，每个协程对应一个线程。操作系统负责切换这些线程，但通常这种方式的性能较低，因为线程切换的开销较大。</p>
</li>
</ol>
<h3 id="栈协程的原理："><a href="#栈协程的原理：" class="headerlink" title="栈协程的原理："></a><strong>栈协程的原理</strong>：</h3><ul>
<li><strong>独立栈</strong>：每个协程拥有独立的栈空间，这使得它能够执行像普通函数那样的调用（包括递归调用、深度堆栈的函数等）。</li>
<li><strong>上下文保存和恢复</strong>：通过 <code>setjmp</code>&#x2F;<code>longjmp</code> 或者其他机制保存和恢复协程的上下文信息。栈协程在暂停时保存的栈数据非常完整，恢复时直接恢复到暂停时的状态。</li>
<li><strong>调度</strong>：协程调度通常是由用户手动控制的。可以在某个协程内通过某些机制（比如 <code>yield</code> 或 <code>co_await</code>）来主动让出执行权。</li>
</ul>
<h3 id="栈协程的优缺点："><a href="#栈协程的优缺点：" class="headerlink" title="栈协程的优缺点："></a><strong>栈协程的优缺点：</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>支持递归和复杂的函数调用</strong>：每个协程有独立的栈，可以像线程一样支持复杂的调用栈。</li>
<li><strong>灵活性强</strong>：能处理各种函数调用，支持较为复杂的控制流。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>内存开销大</strong>：每个协程都需要分配一个独立的栈，内存消耗较大，尤其是在高并发场景下。</li>
<li><strong>上下文切换开销高</strong>：每个栈协程的上下文切换可能会涉及到完整的线程切换或较重的栈操作。</li>
</ul>
<hr>
<h2 id="2-无栈协程（Stackless-Coroutine）"><a href="#2-无栈协程（Stackless-Coroutine）" class="headerlink" title="2. 无栈协程（Stackless Coroutine）"></a>2. <strong>无栈协程（Stackless Coroutine）</strong></h2><p>无栈协程与栈协程的区别在于，它并不为每个协程分配独立的栈空间，而是共享一个栈，或者使用堆内存来保存协程的执行状态。无栈协程通过显式的上下文切换来保存协程的状态，而不是依赖栈上的调用。</p>
<h3 id="无栈协程的实现方式："><a href="#无栈协程的实现方式：" class="headerlink" title="无栈协程的实现方式："></a><strong>无栈协程的实现方式：</strong></h3><p>无栈协程的底层实现通常依赖于更轻量的上下文切换机制，例如：</p>
<ol>
<li><p><strong>程序计数器（PC）保存</strong>：无栈协程通常只保存程序计数器和协程的局部变量，栈的内容并不会保存。协程的状态仅限于当前函数的上下文。</p>
</li>
<li><p><strong>协程栈共享</strong>：多个协程共享同一个栈，协程的状态仅通过寄存器、程序计数器和指令指针等上下文信息来保存。</p>
</li>
<li><p><strong><code>setjmp</code> 和 <code>longjmp</code>（或类似机制）</strong>：无栈协程依赖于保存和恢复执行状态来实现上下文切换。通过 <code>setjmp</code> 保存上下文，通过 <code>longjmp</code> 恢复上下文。无栈协程通常不会在调用栈中分配空间，而是通过堆栈保存一些关键数据。</p>
</li>
<li><p><strong>手动管理堆栈</strong>：在一些轻量级的协程库（如 <code>libco</code>）中，协程的栈可能完全由用户管理（例如放在堆上）。协程调度器需要显式地管理每个协程的执行栈。</p>
</li>
</ol>
<h3 id="无栈协程的原理："><a href="#无栈协程的原理：" class="headerlink" title="无栈协程的原理："></a><strong>无栈协程的原理</strong>：</h3><ul>
<li><strong>共享栈</strong>：多个协程共享同一个栈，栈上的数据仅在需要保存协程状态时才会保存，而非每个协程都有独立的栈。</li>
<li><strong>上下文切换</strong>：无栈协程的上下文切换开销非常低。通过保存程序计数器（PC）、寄存器和指令指针等信息来管理协程的状态。当切换协程时，恢复这些保存的状态。</li>
<li><strong>调度方式</strong>：协程之间的切换非常高效，一般是由用户空间的调度器控制，而不需要操作系统的线程调度。</li>
</ul>
<h3 id="无栈协程的优缺点："><a href="#无栈协程的优缺点：" class="headerlink" title="无栈协程的优缺点："></a><strong>无栈协程的优缺点：</strong></h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>内存开销小</strong>：由于没有为每个协程分配独立的栈，因此内存开销较低。</li>
<li><strong>高效的上下文切换</strong>：上下文切换不需要保存和恢复大量的栈数据，因此切换非常高效。</li>
<li><strong>适合大量并发</strong>：由于内存消耗较小，可以创建成千上万的协程，适用于大量轻量级任务。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>不支持递归</strong>：无栈协程不支持深度的函数调用栈，无法进行递归调用，因为它没有独立的栈空间。</li>
<li><strong>编程限制</strong>：使用无栈协程时，编程模型必须遵循一定的限制，例如避免复杂的函数调用或局部变量的复杂操作。</li>
</ul>
<hr>
<h2 id="3-栈协程与无栈协程的底层原理对比"><a href="#3-栈协程与无栈协程的底层原理对比" class="headerlink" title="3. 栈协程与无栈协程的底层原理对比"></a>3. <strong>栈协程与无栈协程的底层原理对比</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>栈协程（Stackful Coroutine）</th>
<th>无栈协程（Stackless Coroutine）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>栈分配</strong></td>
<td>每个协程有独立的栈</td>
<td>所有协程共享同一个栈</td>
</tr>
<tr>
<td><strong>上下文保存</strong></td>
<td>保存完整的栈帧、寄存器、返回地址等</td>
<td>只保存程序计数器、寄存器等少量信息</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>高（每个协程都有独立的栈）</td>
<td>低（多个协程共享栈）</td>
</tr>
<tr>
<td><strong>递归支持</strong></td>
<td>支持递归调用</td>
<td>不支持递归调用</td>
</tr>
<tr>
<td><strong>上下文切换开销</strong></td>
<td>高（涉及栈的保存和恢复）</td>
<td>低（只保存少量的状态）</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>较高（需要管理栈、上下文切换等）</td>
<td>较低（只需保存寄存器和程序计数器）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适合递归、复杂控制流的应用</td>
<td>适合大量并发、轻量级任务的场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>栈协程</strong>通过为每个协程分配独立的栈来管理其执行状态，适用于需要递归和复杂控制流的场景，但内存开销较大。</li>
<li><strong>无栈协程</strong>共享栈并通过轻量级的上下文切换来实现高效的调度，适用于大规模并发和高效任务调度的场景，但无法处理递归调用。</li>
</ul>
<p>然后又协程又分为独立栈和共享栈，举个例子，传统的线程模型就是独立栈，独立栈对于上下文切换是相对重量级的。一般有栈协程就是独立栈，无栈协程就是共享栈。</p>
<p>这里顺便说一下go中的goroutine的栈模型，一般我们说有栈协程对于高并发是相对没那么支持的，但是go中的协程进行优化，使得其性能相对优秀。</p>
<p> Go 语言的协程（goroutines）栈管理是其轻量级并发模型的一个重要特点。与传统线程相比，goroutines 的栈管理更为高效，能够支持数以万计的并发任务而不会导致过大的内存开销。Go 的栈是动态增长的，并且由 Go 的运行时调度器管理。</p>
<p>以下是 Go 中协程栈实现的详细解释：</p>
<h3 id="1-Go-协程栈的基本概念"><a href="#1-Go-协程栈的基本概念" class="headerlink" title="1. Go 协程栈的基本概念"></a>1. <strong>Go 协程栈的基本概念</strong></h3><ul>
<li><strong>栈大小动态调整</strong>：每个 goroutine 一开始的栈非常小，通常只有 <strong>2 KB</strong> 左右。这使得 Go 能够高效地创建大量协程，而不会像传统线程那样每个线程需要分配几 MB 的栈空间。</li>
<li><strong>栈的增长与收缩</strong>：goroutine 的栈是可以在运行时根据需要动态增长的。当栈的空间不足时，Go 的运行时会自动扩展栈。而如果栈有剩余空间并且某些 goroutine 被挂起较长时间，栈也会缩小，以节省内存。</li>
</ul>
<h3 id="2-栈的初始分配和增长机制"><a href="#2-栈的初始分配和增长机制" class="headerlink" title="2. 栈的初始分配和增长机制"></a>2. <strong>栈的初始分配和增长机制</strong></h3><ul>
<li><p><strong>初始栈大小</strong>：每个新的 goroutine 在创建时会分配一个非常小的栈，通常是 <strong>2 KB</strong>。这远小于传统线程的栈大小（通常为 1 MB 或更大）。</p>
</li>
<li><p><strong>栈增长</strong>：当 goroutine 执行时，如果栈空间不足以存放更多的局部变量和函数调用，Go 会自动增加栈的大小。这个过程是通过 <strong>栈复制</strong> 来完成的，即将原来栈中的内容拷贝到一个更大的栈中，然后丢弃原有的栈。</p>
<ol>
<li><strong>栈扩展</strong>：当 goroutine 执行到某个点，需要更多的栈空间时，Go 会把现有栈的内容复制到一个新的更大的栈上。新的栈大小通常是原栈的 <strong>2 倍</strong>，栈的增长是指数级的。</li>
<li><strong>栈收缩</strong>：当栈不再需要那么多空间时，Go 运行时也会尝试缩小栈的大小，以节省内存。比如如果栈的空闲空间很大，而该 goroutine 长时间没有执行任务，栈会缩小到合适的大小。</li>
</ol>
</li>
</ul>
<h3 id="3-栈的实现细节"><a href="#3-栈的实现细节" class="headerlink" title="3. 栈的实现细节"></a>3. <strong>栈的实现细节</strong></h3><ul>
<li><p><strong>栈的布局</strong>：Go 协程的栈包括栈帧（存放函数的局部变量、返回地址等）和一些额外的元数据（例如栈的起始地址、当前栈的大小等）。栈的底部通常是由运行时管理的，Go 的调度器使用这个底部的地址来管理栈。</p>
</li>
<li><p><strong>栈分配和切换</strong>：Go 运行时将栈的分配和上下文切换（协程切换）设计得非常高效。每当协程被挂起（例如发生阻塞、等待 I&#x2F;O 等），其栈内容会被保存在内存中，直到调度器决定恢复该协程的执行。</p>
</li>
</ul>
<h3 id="4-栈的拷贝过程（栈增长过程）"><a href="#4-栈的拷贝过程（栈增长过程）" class="headerlink" title="4. 栈的拷贝过程（栈增长过程）"></a>4. <strong>栈的拷贝过程（栈增长过程）</strong></h3><p>当一个 goroutine 的栈不足以继续执行时，Go 会进行栈增长。具体过程如下：</p>
<ol>
<li><p><strong>栈复制</strong>：Go 会将当前栈的内容（栈帧、局部变量、返回地址等）复制到一个新的栈中。新的栈会比旧栈大两倍。这个复制操作是在 goroutine 执行时进行的，因此需要高效的内存管理策略。</p>
</li>
<li><p><strong>调整栈的指针</strong>：复制栈后，运行时将 goroutine 的栈指针指向新的栈。这样，goroutine 就可以继续执行，而不需要重新分配大量的内存。</p>
</li>
<li><p><strong>栈指针的更新</strong>：在扩展栈时，运行时会更新栈指针，使其指向新的栈空间，同时也会更新栈上的元数据，确保栈的状态正确。</p>
</li>
</ol>
<h3 id="5-栈增长和调度"><a href="#5-栈增长和调度" class="headerlink" title="5. 栈增长和调度"></a>5. <strong>栈增长和调度</strong></h3><ul>
<li><p><strong>调度器与栈管理</strong>：Go 的调度器负责在多个 goroutine 之间进行切换，每当一个 goroutine 切换出 CPU 时，调度器会保存该 goroutine 的执行状态（包括栈指针）。当 goroutine 被切换回来时，调度器会恢复其栈，继续执行。</p>
</li>
<li><p><strong>栈的内存布局</strong>：Go 的运行时使用 <strong>分配的栈</strong> 来实现 goroutine 上下文切换的高效性，而栈的扩展和收缩是透明的，应用程序通常不会感知到栈的变化。</p>
</li>
</ul>
<h3 id="6-栈管理的高效性"><a href="#6-栈管理的高效性" class="headerlink" title="6. 栈管理的高效性"></a>6. <strong>栈管理的高效性</strong></h3><ul>
<li><p><strong>栈内存回收</strong>：Go 的运行时会定期回收不再使用的栈空间。当协程被销毁或其栈不再需要时，Go 会尝试回收内存，从而避免内存泄漏。</p>
</li>
<li><p><strong>垃圾回收与栈</strong>：Go 的垃圾回收机制（GC）与栈的管理紧密配合。当栈中有大量对象不再使用时，GC 会清理这些对象并回收内存。</p>
</li>
</ul>
<h3 id="7-栈增长的实现难点"><a href="#7-栈增长的实现难点" class="headerlink" title="7. 栈增长的实现难点"></a>7. <strong>栈增长的实现难点</strong></h3><ul>
<li><p><strong>效率问题</strong>：栈的扩展和收缩是一个内存密集型的操作，需要在保证高效的同时避免性能瓶颈。Go 通过栈的指数增长（每次扩展是原栈的两倍）和局部栈压缩（减少内存浪费）来确保程序性能。</p>
</li>
<li><p><strong>并发访问的同步</strong>：栈的扩展和收缩操作是线程安全的，Go 运行时确保多核并发环境中，多个 goroutine 访问栈时不会发生竞争。</p>
</li>
</ul>
<h3 id="8-栈分配与调度的结合"><a href="#8-栈分配与调度的结合" class="headerlink" title="8. 栈分配与调度的结合"></a>8. <strong>栈分配与调度的结合</strong></h3><p>Go 的调度器在运行时会根据实际情况来决定每个 goroutine 所需要的栈大小。调度器将 goroutine 的栈当作调度的一部分，随着执行的深入动态地管理栈的大小，尽量避免不必要的内存分配和过度的栈增长。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>Go 协程的栈管理非常高效</strong>，初始栈小，通常为 <strong>2 KB</strong>，并且能够根据需要动态扩展，最大可以达到几 MB。</li>
<li><strong>栈增长是指数级的</strong>，每次扩展都会翻倍，保证了内存开销的线性增长，同时避免了过度扩展的浪费。</li>
<li><strong>栈的管理和调度是紧密结合的</strong>，Go 运行时会自动为协程管理栈的扩展与收缩，确保内存使用的高效性。</li>
<li><strong>栈管理的高效性</strong>和<strong>调度器的优化</strong>使得 Go 可以在单机上运行数以万计的协程，而不会导致内存溢出或过多的资源消耗。</li>
</ul>
<h4 id="Go-goroutines-的优势："><a href="#Go-goroutines-的优势：" class="headerlink" title="Go goroutines 的优势："></a><strong>Go goroutines 的优势</strong>：</h4><ul>
<li><strong>内存占用小</strong>：由于每个 goroutine 的栈非常小，且可以动态扩展，因此它比传统的线程模型（每个线程有独立栈空间，通常 1MB 或更大）消耗的内存要少得多。这使得在高并发场景下，Go 可以创建更多的 goroutines 而不容易导致内存耗尽。</li>
<li><strong>高效的调度器</strong>：Go 的调度器可以非常高效地在多个 CPU 核心之间调度成千上万的 goroutines。它使用了 <strong>M:N</strong> 调度模型（多个 goroutine 映射到多个操作系统线程上），这一点使得它能更好地适应高并发环境。</li>
</ul>
<h4 id="Go-goroutines-的劣势："><a href="#Go-goroutines-的劣势：" class="headerlink" title="Go goroutines 的劣势："></a><strong>Go goroutines 的劣势</strong>：</h4><ul>
<li><strong>栈扩展的开销</strong>：尽管 Go 的栈是动态扩展的，但每当一个 goroutine 的栈需要扩展时，仍然会有一定的开销。特别是在一些栈深的操作中，扩展栈和管理栈的操作可能会影响性能，尤其是在非常高并发的场景下。</li>
<li><strong>调度延迟</strong>：Go 的调度器虽然设计得相当高效，但在极端高并发的情况下，调度器仍然可能会成为瓶颈。尤其是当 goroutines 的数量非常庞大时（例如几百万个 goroutines），调度器的负担会增大，可能会导致一定的延迟。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>协程</tag>
        <tag>有栈协程</tag>
        <tag>无栈协程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的四种命名的强制类型转换</title>
    <url>/2024/11/19/c++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在 C++ 中，有四种强制类型转换操作符，分别是：</p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<p>这四种类型转换都属于强制类型转换,值得一提的是其实这四种强制转换都是较为危险的，很容易出现错误，尽量少用</p>
<h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><code>static_cast</code> 用于在类型之间进行转换时，进行编译时类型检查。</p>
<p>它适用于转换那些在语义上兼容的类型，例如基本数据类型、类之间的转换等。</p>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><ul>
<li><strong>类之间的转换</strong>（如父类和子类的转换）。</li>
<li><strong>基本数据类型之间的转换</strong>。</li>
<li><strong>指针类型之间的转换</strong>，当有继承关系时，可以转换指向基类的指针和指向派生类的指针。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//类之间的转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Base* 转换为 Derived*，这里是安全的</span></span><br><span class="line">    Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 上行是通过 static_cast</span></span><br><span class="line">    d-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);  <span class="comment">// 基本数据类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="comment">// 输出 10.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static_cast</code> 会进行类型检查，并且不允许不兼容的类型之间的转换。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//进行强制类型转换以便执行浮点数除法</span><br><span class="line">int i,j;</span><br><span class="line">double slope=static_cast&lt;double&gt;(j)/i;</span><br><span class="line">//进行指针的转换</span><br><span class="line">void *p=&amp;i;//任何非常量的对象的地址都能存入void*</span><br><span class="line">int *ij=static_cast&lt;int*&gt;(p);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 主要用于处理类层次结构中的指针或引用转换。它用于在类之间进行转换时，确保类型安全。<code>dynamic_cast</code> 在运行时进行类型检查，因此它适用于多态类型的转换（即包含虚函数的类）。</p>
<h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于处理继承体系中的转换，确保安全的类型转换。</li>
<li>可以用于将基类指针或引用转换为派生类指针或引用，前提是基类至少有一个虚函数（多态）。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 错误的转换，d会为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">        d-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 输出 Conversion failed!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dynamic_cast</code> 在运行时检查类型，如果转换失败，返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。它主要用于确保在继承关系中指针或引用的类型转换安全。</li>
</ul>
<h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><code>const_cast</code> 用于修改对象的常量性。</p>
<p>它允许去除或添加 <code>const</code> 限定符。注意，此处只能修改底层const</p>
<p>常见的用途包括将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型，或者反之。</p>
<h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>去除 <code>const</code> 限定符：可以将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型。</li>
<li>添加 <code>const</code> 限定符：可以将非 <code>const</code> 类型的指针或引用转换为 <code>const</code> 类型。</li>
</ul>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去除 const 限定符，允许修改对象</span></span><br><span class="line">    <span class="type">int</span>* modifiablePtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);</span><br><span class="line">    *modifiablePtr = <span class="number">20</span>;  <span class="comment">// 修改原对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除 const 限定符</span></span><br><span class="line">    <span class="built_in">modify</span>(ptr);  <span class="comment">// 此处会导致未定义行为</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 未定义行为，x值不可预测</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>警告</strong>：如果你去除 <code>const</code> 限定符并修改对象，该对象实际上可能是常量，修改它会导致未定义行为，因此这种转换应谨慎使用。</li>
</ul>
<h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 是最强大的类型转换操作符，它允许将一种类型的指针或引用转换为另一种完全不相关类型的指针或引用。它不进行任何类型检查，因此使用时必须非常小心。</p>
<h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于进行指针或引用之间的转换，即使它们在类型上没有任何继承关系。</li>
<li>可以将指针转换为整数类型，或将整数转换为指针类型。</li>
</ul>
<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> int_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pointer as integer: &quot;</span> &lt;&lt; int_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回指针</span></span><br><span class="line">    <span class="type">int</span>* new_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(int_ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dereferenced pointer: &quot;</span> &lt;&lt; *new_ptr &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reinterpret_cast</code> 可以将指针转换为整数，或将整数转换为指针，甚至可以在没有任何类型关系的类型之间进行转换。使用时需要非常小心，因为它可以绕过编译器的类型检查。</li>
</ul>
<h3 id="总结：四种类型转换的对比"><a href="#总结：四种类型转换的对比" class="headerlink" title="总结：四种类型转换的对比"></a>总结：四种类型转换的对比</h3><table>
<thead>
<tr>
<th>转换操作符</th>
<th>适用场景</th>
<th>编译时检查</th>
<th>运行时检查</th>
<th>类型安全</th>
</tr>
</thead>
<tbody><tr>
<td><code>static_cast</code></td>
<td>基本类型转换，类之间的转换，指针之间的转换</td>
<td>是</td>
<td>否</td>
<td>高</td>
</tr>
<tr>
<td><code>dynamic_cast</code></td>
<td>类之间的安全转换，主要用于多态（继承）</td>
<td>是</td>
<td>是</td>
<td>高</td>
</tr>
<tr>
<td><code>const_cast</code></td>
<td>修改对象的常量性（去除或添加 <code>const</code> 限定符）</td>
<td>是</td>
<td>否</td>
<td>中</td>
</tr>
<tr>
<td><code>reinterpret_cast</code></td>
<td>强制转换，指针与整数之间的转换，指针之间的任意转换</td>
<td>否</td>
<td>否</td>
<td>低（非常危险）</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>static_cast</code></strong> 用于编译时类型安全转换，适合大多数常规类型转换。</li>
<li><strong><code>dynamic_cast</code></strong> 用于多态类型的安全转换，尤其是指针和引用之间的转换，支持运行时类型检查。</li>
<li><strong><code>const_cast</code></strong> 用于修改 <code>const</code> 限定符（添加或去除 <code>const</code>）。</li>
<li><strong><code>reinterpret_cast</code></strong> 用于底层转换，指针和整数之间的转换，不进行类型检查，需要小心使用。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>强制类型转换操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的线程</title>
    <url>/2025/01/12/c++%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在 C++ 中，线程是用来实现并发编程的重要工具，它允许程序同时执行多个任务。C++11 标准引入了多线程支持，主要通过 <strong><code>&lt;thread&gt;</code></strong> 标头文件提供相关功能，包括线程创建、管理和同步等。</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h2><ul>
<li><strong>线程</strong>是程序执行的基本单位，一个程序可以包含多个线程。</li>
<li><strong>多线程</strong>可以提高程序效率，特别是在多核 CPU 上，每个线程可以在不同的核上运行。</li>
<li>C++ 提供的多线程功能包括：<ul>
<li>线程的创建与管理（<code>std::thread</code>）。</li>
<li>同步机制（如互斥锁 <code>std::mutex</code>、条件变量 <code>std::condition_variable</code> 等）。</li>
<li>数据保护（如线程安全的操作）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-创建和管理线程"><a href="#2-创建和管理线程" class="headerlink" title="2. 创建和管理线程"></a><strong>2. 创建和管理线程</strong></h2><h3 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1) 创建线程"></a><strong>1) 创建线程</strong></h3><p>线程可以通过 <strong><code>std::thread</code></strong> 创建，并且可以使用函数、lambda 表达式或可调用对象作为线程入口。</p>
<h4 id="a-使用普通函数"><a href="#a-使用普通函数" class="headerlink" title="(a) 使用普通函数"></a><strong>(a) 使用普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建线程</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>std::thread t(threadFunction)</code>**：创建线程并执行 <code>threadFunction</code>。</li>
<li>**<code>t.join()</code>**：主线程等待 <code>t</code> 线程执行完成。</li>
</ul>
<hr>
<h4 id="b-使用-lambda-表达式"><a href="#b-使用-lambda-表达式" class="headerlink" title="(b) 使用 lambda 表达式"></a><strong>(b) 使用 lambda 表达式</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread running with lambda!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="c-使用类的成员函数"><a href="#c-使用类的成员函数" class="headerlink" title="(c) 使用类的成员函数"></a><strong>(c) 使用类的成员函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread running with functor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker worker;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>; <span class="comment">// 创建线程并执行 Worker 的重载函数</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-分离线程（detach）"><a href="#2-分离线程（detach）" class="headerlink" title="2) 分离线程（detach）"></a><strong>2) 分离线程（<code>detach</code>）</strong></h3><p>分离线程允许主线程与新线程独立运行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Detached thread completed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 分离线程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：分离的线程在程序结束前需要完成，否则会出现未定义行为。</p>
<hr>
<h3 id="3-获取线程-ID"><a href="#3-获取线程-ID" class="headerlink" title="3) 获取线程 ID"></a><strong>3) 获取线程 ID</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::thread::id id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3. 线程同步"></a><strong>3. 线程同步</strong></h2><p>由于线程是并发执行的，因此多个线程访问共享资源时可能会导致数据竞争（Race Condition）。C++ 提供了多种同步工具来避免这种问题。</p>
<h3 id="1-互斥锁（std-mutex）"><a href="#1-互斥锁（std-mutex）" class="headerlink" title="1) 互斥锁（std::mutex）"></a><strong>1) 互斥锁（<code>std::mutex</code>）</strong></h3><p><strong>互斥锁</strong>用于保证只有一个线程可以访问共享资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁和解锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Thread 1: Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Thread 2: World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>std::lock_guard</code>**：管理锁的生命周期，防止忘记解锁。</li>
<li>**<code>mtx.lock()</code> 和 <code>mtx.unlock()</code>**：手动加锁和解锁，但可能导致死锁，不推荐使用。</li>
</ul>
<hr>
<h3 id="2-条件变量（std-condition-variable）"><a href="#2-条件变量（std-condition-variable）" class="headerlink" title="2) 条件变量（std::condition_variable）"></a><strong>2) 条件变量（<code>std::condition_variable</code>）</strong></h3><p>条件变量用于实现线程间的协调，例如一个线程等待某个条件成立时再执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件成立</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>; <span class="comment">// 修改条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个等待线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(notify)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-原子操作（std-atomic）"><a href="#3-原子操作（std-atomic）" class="headerlink" title="3) 原子操作（std::atomic）"></a><strong>3) 原子操作（<code>std::atomic</code>）</strong></h3><p><strong>原子操作</strong>用于多线程中对单个变量的操作，避免数据竞争。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter; <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a><strong>4. 注意事项</strong></h2><ol>
<li><strong>数据竞争</strong>：多个线程同时修改共享资源可能导致错误，需要使用同步机制。</li>
<li><strong>死锁</strong>：多个线程互相等待资源，导致程序无法继续。</li>
<li><strong>分离线程的风险</strong>：主线程结束时，分离的线程未完成可能会导致崩溃。</li>
<li><strong>性能开销</strong>：线程切换会带来一定的系统开销。</li>
</ol>
<hr>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h2><ul>
<li><strong>线程创建</strong>：<code>std::thread</code> 提供简单易用的接口。</li>
<li><strong>线程同步</strong>：使用 <code>std::mutex</code>、<code>std::condition_variable</code> 等工具保护共享数据。</li>
<li><strong>线程安全</strong>：推荐使用 <code>std::atomic</code> 或其他同步机制避免数据竞争。</li>
</ul>
<p>线程是 C++ 中实现并发的核心工具，但需要小心处理共享资源和线程生命周期，确保程序的正确性和性能。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的多线程写时复制</title>
    <url>/2025/02/27/c++%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;mutex&gt;</span><br><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;shared_mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//写时复制包装器模板类</span><br><span class="line">template&lt;typename	T&gt;</span><br><span class="line">class CowPtr</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	mutable shared_ptr&lt;T&gt; ptr; //mutable 关键字允许在 const 方法中修改这个成员变量</span><br><span class="line">	mutable shared_mutex mutex;//mutable 关键字允许在 const 方法中使用锁,shared_mutex为可读锁</span><br><span class="line">public:</span><br><span class="line">	CowPtr(T* p = nullptr):ptr(p) &#123;&#125;//构造函数</span><br><span class="line">	CowPtr(const shared_ptr&lt;T&gt;&amp; p):ptr(p)&#123;&#125;//通过shared_ptr构造</span><br><span class="line">	CowPtr(const CowPtr&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		lock_guard&lt;shared_mutex&gt;lock(other.mutex);</span><br><span class="line">		ptr = other.ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	CowPtr(CowPtr&amp;&amp; other)noexcept//noexcept用来声明一个函数不会抛出任何异常</span><br><span class="line">	&#123;</span><br><span class="line">		/*</span><br><span class="line">		* 这里的 CowPtr(CowPtr&amp;&amp; other) 表示 接受一个右值引用 类型的 other 参数。它通常用于“移动”资源而不是“复制”资源。</span><br><span class="line">		  std::move(other.ptr) 将 other.ptr 从一个左值变为右值，并允许移动其内部资源，而不是复制它们</span><br><span class="line">		*/</span><br><span class="line">		lock_guard&lt;shared_mutex&gt;lock(other.mutex);//确保在移动资源时，不会发生数据竞争</span><br><span class="line">		ptr = move(other.ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	//赋值操作符</span><br><span class="line">	CowPtr&amp; operator=(const CowPtr&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		if (this != &amp;other)</span><br><span class="line">		&#123;</span><br><span class="line">			unique_lock&lt;shared_mutex&gt;lock_this(mutex, defer_lock);</span><br><span class="line">			unique_lock&lt;shared_mutex&gt;lock_other(other.mutex, defer_lock);</span><br><span class="line">			/*</span><br><span class="line">			* std::unique_lock 比 lock_guard 更灵活，允许延迟锁定（std::defer_lock） </span><br><span class="line">			  std::lock 函数可以同时锁定多个互斥锁，且能避免死锁</span><br><span class="line">			*/</span><br><span class="line">			lock(lock_this, lock_other);</span><br><span class="line">			ptr = other.ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	// 移动赋值操作符</span><br><span class="line">	CowPtr&amp; operator=(CowPtr&amp;&amp; other) noexcept &#123;</span><br><span class="line">		if (this != &amp;other) &#123;</span><br><span class="line">			std::unique_lock&lt;shared_mutex&gt; lock_this(mutex, std::defer_lock);</span><br><span class="line">			std::unique_lock&lt;shared_mutex&gt; lock_other(other.mutex, std::defer_lock);</span><br><span class="line"></span><br><span class="line">			std::lock(lock_this, lock_other);</span><br><span class="line"></span><br><span class="line">			ptr = std::move(other.ptr);</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 析构函数</span><br><span class="line">	~CowPtr() = default;</span><br><span class="line"></span><br><span class="line">	// 读取操作 - 返回常量引用</span><br><span class="line">	const T&amp; read() const &#123;</span><br><span class="line">		std::lock_guard&lt;std::shared_mutex&gt; lock(mutex);</span><br><span class="line">		return *ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 写入操作 - 返回可修改的引用，需要时执行写时复制</span><br><span class="line">	T&amp; write() &#123;</span><br><span class="line">		std::lock_guard&lt;shared_mutex&gt; lock(mutex);</span><br><span class="line"></span><br><span class="line">		// 检查引用计数，如果不是唯一拥有者，则复制一份</span><br><span class="line">		if (!ptr.unique()) &#123;</span><br><span class="line">			ptr = std::make_shared&lt;T&gt;(*ptr);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return *ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	* 写时复制策略，它的核心目的是 保证多个线程能够安全地共享资源，直到其中一个线程需要修改该资源时，才会复制该资源</span><br><span class="line">	* 实质上，当有需要写入的操作时，首先判断是否为唯一引用，如果是，那么直接修改不会影响</span><br><span class="line">	* 如果不是唯一引用，那么则复制一份数据的副本，原数据与副本各自独立，复制过程中用锁保证不会被其他线程修改</span><br><span class="line">	* 然后将副本修改，独自占用，其他读的操作，仍然读取原始数据</span><br><span class="line">	*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>智能指针</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的重写与重载</title>
    <url>/2025/06/16/c++%E4%B8%AD%E7%9A%84%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>明天就是面试了啊啊啊啊啊啊啊啊啊啊，面试题没有几个会的还，日了，好想去实习，想去蚂蚁OceanBase呜呜呜</p>
<p>我要进大厂口牙！</p>
<p>c++中的多态实际上是通过重载（overload）和重写（override)实现的，两者区别其实蛮大的。</p>
<p>在这之前我们先介绍一些我不会的基础知识吧。</p>
<h3 id="首先就是三种访问修饰符，private-public-protected"><a href="#首先就是三种访问修饰符，private-public-protected" class="headerlink" title="首先就是三种访问修饰符，private,public,protected"></a>首先就是三种访问修饰符，private,public,protected</h3><p>相对而言protected较为少见</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public修饰符用于指定类中的成员可以被类中的成员函数访问，也可以被类外成员访问</span><br><span class="line">private修饰符用于指定类中的成员可以被类中的成员函数访问，类外代码不可见</span><br><span class="line">protected修饰符，除了类中的成员函数可以访问，其子类（派生类）也是可见的，但对于其他类外成员不可访问</span><br></pre></td></tr></table></figure>

<h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><p><strong>重载</strong>是在同一作用域里面，不同的函数，但具有同样的函数名，依靠不同的参数区分（参数类型，参数个数，以及参数类型不同时的参数顺序）。使得同一个函数可以有多个不同的版本，<strong>这属于编译时多态</strong>。</p>
<p>规则：</p>
<ol>
<li>不能根据函数的访问权限，返回值类型，抛出的异常进行重载，只能根据参数</li>
<li>不同的参数类型可以是不同的参数类型，不同的参数个数，不同的参数顺序（不一样的参数类型）</li>
</ol>
<p><strong>重写</strong>则是指在派生类中重新实现父类中的虚函数，以提供特定于派生类的实现，强调覆盖。<strong>是运行时多态</strong></p>
<p>规则：</p>
<ol>
<li>重写方法的参数列表，返回值，抛出的异常于父类中的方法是一样的</li>
<li>被重写的方法不能是private</li>
<li>重写方法的访问权限必须大于等于父类中的被重写的方法权限</li>
<li>静态方法不能被重写为非静态方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void print()</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line">class Derived</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void print() override</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多态是为了避免基类中有太多臃肿的重载代码且难以维护</p>
<p>重写与重载的本质就是，重写引入overrided关键字，且有且仅有一个方法</p>
<p>在下一节中我们会继续讲一下重写这个运行时多态的详细内容</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>重载</tag>
        <tag>多态</tag>
        <tag>重写</tag>
      </tags>
  </entry>
  <entry>
    <title>c++17/20新特性</title>
    <url>/2025/06/17/c-17-20%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="C-17-和-C-20-新特性"><a href="#C-17-和-C-20-新特性" class="headerlink" title="C++17 和 C++20 新特性"></a>C++17 和 C++20 新特性</h3><hr>
<h2 id="C-17-新特性"><a href="#C-17-新特性" class="headerlink" title="C++17 新特性"></a>C++17 新特性</h2><p>C++17（2017 年发布）引入了许多实用功能，改进语言的表达力和标准库的可用性。</p>
<h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><ol>
<li><p><strong>结构化绑定（Structured Bindings）</strong></p>
<ul>
<li>允许解构 tuple、pair 或结构体到多个变量。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, std::string&gt; p&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, value] = p; <span class="comment">// id=1, value=&quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>用途：简化多返回值处理。</li>
</ul>
</li>
<li><p><strong>if 和 switch 初始化语句</strong></p>
<ul>
<li>在 if&#x2F;switch 中初始化变量，限制作用域。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = map.<span class="built_in">find</span>(key); it != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：代码更紧凑，减少作用域污染。</li>
</ul>
</li>
<li><p><strong>内联变量（Inline Variables）</strong></p>
<ul>
<li>允许在头文件中定义内联静态变量。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>; <span class="comment">// 多翻译单元共享</span></span><br></pre></td></tr></table></figure></li>
<li>用途：简化全局常量或静态变量定义。</li>
</ul>
</li>
<li><p><strong>折叠表达式（Fold Expressions）</strong></p>
<ul>
<li>简化变参模板的递归处理。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123; <span class="keyword">return</span> (args + ...); &#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：优雅处理可变参数模板。</li>
</ul>
</li>
<li><p><strong>constexpr if</strong></p>
<ul>
<li>编译期条件分支。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_value</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> <span class="keyword">return</span> t * 2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：优化模板代码，减少分支开销。</li>
</ul>
</li>
<li><p><strong>类模板参数推导（CTAD）</strong></p>
<ul>
<li>自动推导类模板参数。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::pair p&#123;<span class="number">1</span>, <span class="number">2.0</span>&#125;; <span class="comment">// 推导为 std::pair&lt;int, double&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>用途：简化模板类实例化。</li>
</ul>
</li>
</ol>
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><ol>
<li><p><strong>std::optional</strong></p>
<ul>
<li>表示可能为空的值。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">if</span> (opt) std::cout &lt;&lt; *opt; <span class="comment">// 42</span></span><br></pre></td></tr></table></figure></li>
<li>用途：安全处理可能不存在的值。</li>
</ul>
</li>
<li><p><strong>std::variant</strong></p>
<ul>
<li>类型安全的联合体。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::variant&lt;<span class="type">int</span>, std::string&gt; v = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; x) &#123; std::cout &lt;&lt; x; &#125;, v);</span><br></pre></td></tr></table></figure></li>
<li>用途：替代 union，类型安全。</li>
</ul>
</li>
<li><p><strong>std::any</strong></p>
<ul>
<li>存储任意类型的值。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::any a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> x = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a);</span><br></pre></td></tr></table></figure></li>
<li>用途：动态类型场景。</li>
</ul>
</li>
<li><p><strong>std::filesystem</strong></p>
<ul>
<li>文件系统操作库。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::filesystem::path p = <span class="string">&quot;file.txt&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (std::filesystem::<span class="built_in">exists</span>(p)) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：跨平台文件操作。</li>
</ul>
</li>
<li><p><strong>并行算法</strong></p>
<ul>
<li>标准算法支持并行执行。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">sort</span>(std::execution::par, v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li>
<li>用途：利用多核提升性能。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="C-20-新特性"><a href="#C-20-新特性" class="headerlink" title="C++20 新特性"></a>C++20 新特性</h2><p>C++20（2020 年发布）是 C++ 的一次重大更新，引入了模块、概念、协程等变革性特性。</p>
<h3 id="语言特性-1"><a href="#语言特性-1" class="headerlink" title="语言特性"></a>语言特性</h3><ol>
<li><p><strong>模块（Modules）</strong></p>
<ul>
<li>替代头文件，改进编译速度和封装。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> math;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">import</span> math;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); &#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：减少头文件依赖，加速编译。</li>
</ul>
</li>
<li><p><strong>概念（Concepts）</strong></p>
<ul>
<li>约束模板参数，增强类型检查。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Integral T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">square</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：提高模板代码可读性和错误提示。</li>
</ul>
</li>
<li><p><strong>Lambda 增强</strong></p>
<ul>
<li>支持无状态 lambda 在 constexpr、显式模板参数。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> id = []&lt;<span class="keyword">typename</span> T&gt;(T x) &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = []&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;();</span><br></pre></td></tr></table></figure></li>
<li>用途：更灵活的 lambda 应用。</li>
</ul>
</li>
<li><p><strong>Ranges 库</strong></p>
<ul>
<li>提供范围视图和管道操作。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> even = v | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : even) std::cout &lt;&lt; x; <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure></li>
<li>用途：函数式编程风格，简化迭代。</li>
</ul>
</li>
<li><p><strong>协程（Coroutines）</strong></p>
<ul>
<li>支持暂停和恢复函数执行。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">generator&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">co_yield</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：异步编程、生成器。</li>
</ul>
</li>
<li><p><strong>consteval 和 constinit</strong></p>
<ul>
<li><code>consteval</code>：强制编译期执行。</li>
<li><code>constinit</code>：确保静态变量初始化。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> global = <span class="number">42</span>;</span><br></pre></td></tr></table></figure></li>
<li>用途：优化编译期计算，控制初始化。</li>
</ul>
</li>
<li><p><strong>三路比较（Spaceship Operator）</strong></p>
<ul>
<li><code>operator&lt;=&gt;</code> 自动生成比较运算符。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp;) <span class="type">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>用途：简化比较逻辑。</li>
</ul>
</li>
</ol>
<h3 id="标准库-1"><a href="#标准库-1" class="headerlink" title="标准库"></a>标准库</h3><ol>
<li><p><strong>std::span</strong></p>
<ul>
<li>轻量视图，表示连续内存视图。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::span&lt;<span class="type">int</span>&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : s) std::cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：安全访问连续数据。</li>
</ul>
</li>
<li><p><strong>std::bit_cast</strong></p>
<ul>
<li>类型安全的字节级转换。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">uint32_t</span> u = std::<span class="built_in">bit_cast</span>&lt;<span class="type">uint32_t</span>&gt;(f);</span><br></pre></td></tr></table></figure></li>
<li>用途：低级数据转换。</li>
</ul>
</li>
<li><p><strong>std::format</strong></p>
<ul>
<li>格式化字符串库。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = std::format(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>用途：更安全、现代化的字符串格式化。</li>
</ul>
</li>
<li><p><strong>std::source_location</strong></p>
<ul>
<li>获取调用位置信息。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(std::source_location loc = std::source_location::current())</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; loc.<span class="built_in">file_name</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; loc.<span class="built_in">line</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用途：日志记录。</li>
</ul>
</li>
<li><p><strong>日历和时区（Calendar&#x2F;Timezone）</strong></p>
<ul>
<li>支持日期时间操作。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> date = std::year_month_day&#123;std::<span class="built_in">floor</span>&lt;std::chrono::days&gt;(now)&#125;;</span><br></pre></td></tr></table></figure></li>
<li>用途：跨平台处理时间。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="比较与选择"><a href="#比较与选择" class="headerlink" title="比较与选择"></a>比较与选择</h3><ul>
<li><strong>C++17</strong>：实用性强，适合过渡项目，特性如结构化绑定、<code>std::optional</code> 立即提升代码质量。</li>
<li><strong>C++20</strong>：更现代化，模块、概念、协程适合新项目，但编译器支持（如 GCC 10+、Clang 10+）和生态成熟度需考虑。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++内存管理</title>
    <url>/2025/06/29/c-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="C-内存管理与-malloc（无垃圾回收机制）"><a href="#C-内存管理与-malloc（无垃圾回收机制）" class="headerlink" title="C++ 内存管理与 malloc（无垃圾回收机制）"></a>C++ 内存管理与 <code>malloc</code>（无垃圾回收机制）</h1><p>C++ 是一种手动管理内存的编程语言，开发者需要显式分配和释放内存。与依赖垃圾回收（Garbage Collection, GC）的语言（如 Java）不同，C++ 不提供内置的 GC 机制，内存管理主要通过 <code>new</code>&#x2F;<code>delete</code> 和 C 风格的 <code>malloc</code>&#x2F;<code>free</code> 实现。以下是 C++ 内存管理的核心内容，重点介绍 <code>malloc</code> 及相关概念。</p>
<h2 id="1-C-内存管理概述"><a href="#1-C-内存管理概述" class="headerlink" title="1. C++ 内存管理概述"></a>1. <strong>C++ 内存管理概述</strong></h2><p>C++ 程序的内存分为以下主要区域：</p>
<ul>
<li><strong>栈（Stack）</strong>：<ul>
<li>存储局部变量、函数参数和返回地址。</li>
<li>由编译器自动分配和释放，速度快，生命周期固定。</li>
<li>示例：<code>int x = 10;</code>（栈上分配）。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>用于动态分配内存，生命周期由程序员控制。</li>
<li>使用 <code>new</code>&#x2F;<code>delete</code> 或 <code>malloc</code>&#x2F;<code>free</code> 管理。</li>
<li>示例：<code>int* p = new int;</code>（堆上分配）。</li>
</ul>
</li>
<li><strong>全局&#x2F;静态存储区</strong>：<ul>
<li>存储全局变量和静态变量，程序运行期间存在。</li>
</ul>
</li>
<li><strong>常量存储区</strong>：<ul>
<li>存储字符串字面量和常量，生命周期为程序运行期间。</li>
</ul>
</li>
<li><strong>代码区</strong>：<ul>
<li>存储程序的机器代码。</li>
</ul>
</li>
</ul>
<p>C++ 的内存管理由程序员负责，需确保分配的内存正确释放，否则可能导致<strong>内存泄漏</strong>或<strong>野指针</strong>。</p>
<h2 id="2-malloc-和-free"><a href="#2-malloc-和-free" class="headerlink" title="2. malloc 和 free"></a>2. <strong><code>malloc</code> 和 <code>free</code></strong></h2><p><code>malloc</code> 和 <code>free</code> 是 C 语言提供的动态内存管理函数，C++ 继承并兼容它们，定义在 <code>&lt;cstdlib&gt;</code> 头文件中。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h3><ul>
<li>**<code>malloc</code>**：<ul>
<li>全称：<strong>memory allocation</strong>。</li>
<li>原型：<code>void* malloc(size_t size);</code></li>
<li>分配指定大小（以字节为单位）的连续内存块，返回指向该内存的指针（<code>void*</code>）。</li>
<li>分配的内存未初始化，内容为未定义值。</li>
<li>若分配失败，返回 <code>nullptr</code>。</li>
</ul>
</li>
<li>**<code>free</code>**：<ul>
<li>原型：<code>void free(void* ptr);</code></li>
<li>释放由 <code>malloc</code>、<code>calloc</code> 或 <code>realloc</code> 分配的内存。</li>
<li>指针必须指向 <code>malloc</code> 分配的内存起始地址，否则会导致未定义行为。</li>
</ul>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul>
<li><strong>手动管理</strong>：程序员需显式调用 <code>free</code> 释放内存，C++ 无自动 GC。</li>
<li><strong>无构造函数&#x2F;析构函数</strong>：<code>malloc</code> 只分配原始内存，不调用对象的构造函数，适合基本类型或 C 风格代码。</li>
<li><strong>类型不安全</strong>：返回 <code>void*</code>，需显式转换为目标类型。</li>
<li><strong>性能</strong>：通常比 <code>new</code> 稍快（因不涉及 C++ 的对象初始化），但功能较简单。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配 10 个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    arr = <span class="literal">nullptr</span>; <span class="comment">// 避免野指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ul>
<li><strong>内存泄漏</strong>：忘记调用 <code>free</code> 会导致内存无法回收。</li>
<li><strong>重复释放</strong>：对同一指针多次调用 <code>free</code> 导致未定义行为。</li>
<li><strong>野指针</strong>：释放后未置空指针，可能导致非法访问。</li>
<li><strong>类型转换</strong>：<code>malloc</code> 返回 <code>void*</code>，C++ 中需显式转换（如 <code>(int*)</code>）。</li>
</ul>
<h2 id="3-C-中的-new-delete-与-malloc-free-的对比"><a href="#3-C-中的-new-delete-与-malloc-free-的对比" class="headerlink" title="3. C++ 中的 new&#x2F;delete 与 malloc&#x2F;free 的对比"></a>3. <strong>C++ 中的 <code>new</code>&#x2F;<code>delete</code> 与 <code>malloc</code>&#x2F;<code>free</code> 的对比</strong></h2><p>C++ 更推荐使用 <code>new</code> 和 <code>delete</code>，它们是 C++ 的原生内存管理操作符。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>malloc</code>&#x2F;<code>free</code></th>
<th><code>new</code>&#x2F;<code>delete</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所属语言</strong></td>
<td>C（C++ 兼容）</td>
<td>C++</td>
</tr>
<tr>
<td><strong>分配内存</strong></td>
<td>分配原始内存，未初始化</td>
<td>分配内存并调用构造函数</td>
</tr>
<tr>
<td><strong>释放内存</strong></td>
<td>不调用析构函数</td>
<td>调用析构函数</td>
</tr>
<tr>
<td><strong>类型安全</strong></td>
<td>返回 <code>void*</code>，需手动转换</td>
<td>类型安全，返回正确类型的指针</td>
</tr>
<tr>
<td><strong>数组支持</strong></td>
<td><code>malloc(size * sizeof(T))</code></td>
<td><code>new T[size]</code>（自动计算大小）</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>返回 <code>nullptr</code> 表示失败</td>
<td>抛出 <code>std::bad_alloc</code> 异常</td>
</tr>
<tr>
<td><strong>重载</strong></td>
<td>不可重载</td>
<td>可重载（如自定义内存分配策略）</td>
</tr>
</tbody></table>
<h3 id="代码示例（new-delete）"><a href="#代码示例（new-delete）" class="headerlink" title="代码示例（new&#x2F;delete）"></a><strong>代码示例（<code>new</code>&#x2F;<code>delete</code>）</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配并初始化对象</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>](); <span class="comment">// 默认初始化为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    arr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-C-中无内置垃圾回收（GC）"><a href="#4-C-中无内置垃圾回收（GC）" class="headerlink" title="4. C++ 中无内置垃圾回收（GC）"></a>4. <strong>C++ 中无内置垃圾回收（GC）</strong></h2><ul>
<li><strong>无 GC 机制</strong>：C++ 不像 Java 或 Python 提供自动垃圾回收，内存管理完全由程序员控制。</li>
<li><strong>手动管理优缺点</strong>：<ul>
<li><strong>优点</strong>：高性能，精确控制内存分配和释放，适合实时系统或高性能应用。</li>
<li><strong>缺点</strong>：容易出错（如内存泄漏、野指针），开发效率低于 GC 语言。</li>
</ul>
</li>
<li><strong>替代方案</strong>：<ul>
<li><strong>智能指针</strong>：C++11 引入 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code>，通过 RAII（资源获取即初始化）自动管理内存。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; arr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无需手动 delete，离开作用域自动释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>第三方 GC 库</strong>：如 Boehm-Demers-Weiser GC，可为 C++ 添加垃圾回收，但不常用。</li>
<li><strong>容器类</strong>：<code>std::vector</code>、<code>std::string</code> 等封装动态内存管理，减少手动操作。</li>
</ul>
</li>
</ul>
<h2 id="5-内存管理最佳实践"><a href="#5-内存管理最佳实践" class="headerlink" title="5. 内存管理最佳实践"></a>5. <strong>内存管理最佳实践</strong></h2><ul>
<li><strong>优先使用智能指针</strong>：<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 防止内存泄漏。</li>
<li>**避免 <code>malloc</code>&#x2F;<code>free</code>**：除非与 C 代码交互，否则使用 <code>new</code>&#x2F;<code>delete</code> 或智能指针。</li>
<li><strong>初始化内存</strong>：<code>malloc</code> 分配的内存需手动初始化，<code>new</code> 可自动初始化（如 <code>new int[10]()</code>）。</li>
<li><strong>检查分配失败</strong>：<code>malloc</code> 返回 <code>nullptr</code> 时需处理；<code>new</code> 抛出异常需捕获。</li>
<li><strong>匹配分配&#x2F;释放</strong>：<code>new</code> 与 <code>delete</code> 配对，<code>new[]</code> 与 <code>delete[]</code> 配对，<code>malloc</code> 与 <code>free</code> 配对。</li>
<li><strong>使用标准库容器</strong>：如 <code>std::vector</code> 自动管理动态数组内存。</li>
</ul>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><ul>
<li><strong>C++ 内存管理</strong>：手动管理，依赖栈、堆等内存区域，无内置 GC。</li>
<li>**<code>malloc</code>&#x2F;<code>free</code>**：C 风格内存分配，适合简单场景，但无类型安全和对象初始化。</li>
<li>**<code>new</code>&#x2F;<code>delete</code>**：C++ 原生操作符，支持对象构造&#x2F;析构，推荐使用。</li>
<li><strong>智能指针</strong>：C++11 后推荐方式，自动管理内存，减少错误。</li>
<li><strong>无 GC</strong>：C++ 强调性能和控制力，需开发者谨慎管理内存。</li>
</ul>
<p>如需更深入的内存管理分析（如内存池、自定义分配器）或特定场景的代码示例，请提供进一步要求！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>concepts</title>
    <url>/2025/10/06/concepts/</url>
    <content><![CDATA[<p> 在 C++20 中，”约束” (Constraints) 主要指的是 **概念 (Concepts)**。它是 C++ 模板编程中的一个革命性特性，旨在解决传统模板编程中的一些核心痛点。</p>
<p>简单来说，<strong>概念 (Concept) 允许你指定模板参数必须满足的条件或要求。</strong></p>
<h3 id="1-为什么需要概念-Concepts-？"><a href="#1-为什么需要概念-Concepts-？" class="headerlink" title="1. 为什么需要概念 (Concepts)？"></a>1. 为什么需要概念 (Concepts)？</h3><p>在 C++20 之前，我们编写泛型代码（模板）时，编译器通常只在实例化模板时才检查模板参数是否“合适”。如果参数不合适，就会导致非常冗长、难以理解的编译错误信息，这被称为 <strong>SFINAE (Substitution Failure Is Not An Error)</strong> 的副作用。</p>
<p>考虑一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11/14/17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_sum</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">print_sum</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello &quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>)); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print_sum(std::vector&lt;int&gt;&#123;1&#125;, std::vector&lt;int&gt;&#123;2&#125;); // 编译错误！</span></span><br><span class="line">    <span class="comment">// 错误信息会非常长，因为 std::vector 没有定义 operator+</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>print_sum</code> 被 <code>std::vector&lt;int&gt;</code> 实例化时，<code>a + b</code> 操作会失败，导致编译器抛出一大堆错误，告诉你 <code>operator+</code> 不适用于 <code>std::vector</code>。这些错误信息往往是模板内部的实现细节，而不是清晰地指出“你传入的类型不支持加法操作”。</p>
<p><strong>概念就是为了解决这些问题而生：</strong></p>
<ul>
<li><strong>改善错误信息：</strong> 编译器可以在实例化之前检查模板参数是否满足概念要求，并给出清晰、友好的错误信息。</li>
<li><strong>提高可读性：</strong> 模板的接口变得自文档化，开发者可以一眼看出模板参数需要具备哪些能力。</li>
<li><strong>简化模板元编程：</strong> 替代了复杂的 SFINAE 技术，使条件编译更加直观。</li>
<li><strong>更好的重载解析：</strong> 概念可以参与函数模板的重载解析，帮助编译器选择最合适的模板。</li>
</ul>
<h3 id="2-概念-Concepts-是什么？"><a href="#2-概念-Concepts-是什么？" class="headerlink" title="2. 概念 (Concepts) 是什么？"></a>2. 概念 (Concepts) 是什么？</h3><p>一个概念定义了一组编译时可检查的约束，这些约束描述了模板参数必须支持的操作或特性。</p>
<p><strong>核心思想：</strong> 不再关注类型本身是什么，而是关注类型<strong>能做什么</strong>。</p>
<h3 id="3-如何定义和使用概念？"><a href="#3-如何定义和使用概念？" class="headerlink" title="3. 如何定义和使用概念？"></a>3. 如何定义和使用概念？</h3><p>C++20 引入了 <code>concept</code> 关键字和 <code>requires</code> 关键字（<code>requires</code> 表达式和 <code>requires</code> 子句）。</p>
<h4 id="3-1-定义一个概念"><a href="#3-1-定义一个概念" class="headerlink" title="3.1 定义一个概念"></a>3.1 定义一个概念</h4><p>使用 <code>concept</code> 关键字定义一个概念。概念的定义体是一个 <code>requires</code> 表达式，其中列出了对模板参数的各种要求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span> <span class="comment">// C++20 标准库概念</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个名为 Addable 的概念</span></span><br><span class="line"><span class="comment">// T 类型必须支持 operator+，并且结果类型可以打印到 ostream</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requires</span>(T a, T b) &#123;</span><br><span class="line">    &#123; a + b &#125; -&gt; std::same_as&lt;T&gt;; <span class="comment">// 要求 a + b 的结果类型与 T 相同</span></span><br><span class="line">    &#123; std::cout &lt;&lt; (a + b) &#125; -&gt; std::same_as&lt;std::ostream&amp;&gt;; <span class="comment">// 要求 a + b 的结果可以打印</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>concept Addable = ...</code>：声明一个名为 <code>Addable</code> 的概念。</li>
<li><code>requires(T a, T b)</code>：这是一个 <code>requires</code> 表达式，它定义了对类型 <code>T</code> 的要求。括号内的 <code>T a, T b</code> 声明了用于测试的变量，这些变量不会实际存在于运行时，仅用于编译时检查。</li>
<li><code>&#123; a + b &#125; -&gt; std::same_as&lt;T&gt;;</code>：这是一个**复合要求 (Compound Requirement)**。<ul>
<li><code>&#123; a + b &#125;</code>：要求表达式 <code>a + b</code> 是有效的。</li>
<li><code>-&gt; std::same_as&lt;T&gt;</code>：要求表达式 <code>a + b</code> 的结果类型与 <code>T</code> 相同。</li>
</ul>
</li>
<li><code>&#123; std::cout &lt;&lt; (a + b) &#125; -&gt; std::same_as&lt;std::ostream&amp;&gt;;</code>：要求 <code>a + b</code> 的结果可以被 <code>std::cout</code> 操作符 <code>&lt;&lt;</code> 输出，并且返回类型是 <code>std::ostream&amp;</code>。</li>
</ul>
<h4 id="3-2-使用概念约束模板参数"><a href="#3-2-使用概念约束模板参数" class="headerlink" title="3.2 使用概念约束模板参数"></a>3.2 使用概念约束模板参数</h4><p>有几种方式可以使用概念来约束模板参数：</p>
<p><strong>a) 作为模板参数的类型限制 (最常见和推荐)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Addable 概念约束模板参数 T</span></span><br><span class="line"><span class="keyword">template</span> &lt;Addable T&gt; <span class="comment">// 只有满足 Addable 概念的类型才能作为 T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_sum</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// OK (int 满足 Addable)</span></span><br><span class="line">    <span class="built_in">print_sum</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello &quot;</span>), std::<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>)); <span class="comment">// OK (std::string 满足 Addable)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// print_sum(std::vector&lt;int&gt;&#123;1&#125;, std::vector&lt;int&gt;&#123;2&#125;);</span></span><br><span class="line">    <span class="comment">// 编译错误！错误信息清晰地指出：</span></span><br><span class="line">    <span class="comment">// error: &#x27;std::vector&lt;int&gt;&#x27; does not satisfy &#x27;Addable&#x27;</span></span><br><span class="line">    <span class="comment">// because the required expression &#x27;a + b&#x27; is invalid</span></span><br><span class="line">    <span class="comment">// (std::vector does not have operator+)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b) 使用 <code>requires</code> 子句 (Trailing <code>requires</code> Clause)</strong></p>
<p>当概念定义比较简单，或者不想单独定义一个概念时，可以直接在模板声明后使用 <code>requires</code> 子句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum_v2</span><span class="params">(T a, T b)</span> <span class="keyword">requires</span> <span class="title">requires</span><span class="params">(T x, T y)</span> </span>&#123; x + y; &#125; <span class="comment">// 简单的要求：x+y 表达式有效</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用已定义的概念</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum_v3</span><span class="params">(T a, T b)</span> <span class="keyword">requires</span> Addable&lt;T&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c) 使用 <code>requires</code> 表达式作为 <code>if constexpr</code> 的条件</strong></p>
<p>虽然概念主要用于模板参数约束，但 <code>requires</code> 表达式也可以在 <code>if constexpr</code> 中用于编译时条件判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Addable&lt;T&gt;)</span> </span>&#123; <span class="comment">// 编译时检查 T 是否满足 Addable</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type is addable. Sum with itself: &quot;</span> &lt;&lt; val + val &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type is not addable.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">5</span>); <span class="comment">// Type is addable. Sum with itself: 10</span></span><br><span class="line">    <span class="built_in">process</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// Type is not addable.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-标准库概念"><a href="#3-3-标准库概念" class="headerlink" title="3.3 标准库概念"></a>3.3 标准库概念</h4><p>C++20 标准库也提供了许多预定义的概念，例如：</p>
<ul>
<li><code>std::integral</code>：要求类型是整数类型。</li>
<li><code>std::floating_point</code>：要求类型是浮点类型。</li>
<li><code>std::signed_integral</code>, <code>std::unsigned_integral</code></li>
<li><code>std::same_as&lt;T, U&gt;</code>：要求 <code>T</code> 和 <code>U</code> 是相同的类型。</li>
<li><code>std::totally_ordered&lt;T&gt;</code>：要求类型 <code>T</code> 支持所有比较运算符 (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)。</li>
<li><code>std::invocable&lt;F, Args...&gt;</code>：要求函数对象 <code>F</code> 可以用 <code>Args...</code> 参数调用。</li>
<li><code>std::ranges::range</code>：要求类型是一个范围 (Ranges)。</li>
</ul>
<p>你可以直接使用这些概念来约束你的模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span> <span class="comment">// 包含标准概念</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::integral T&gt; <span class="comment">// 约束 T 必须是整数类型</span></span><br><span class="line"><span class="function">T <span class="title">multiply</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// OK</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; multiply(5.0, 3.0) &lt;&lt; std::endl; // 编译错误！double 不满足 std::integral</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-总结概念-Concepts-的优势"><a href="#4-总结概念-Concepts-的优势" class="headerlink" title="4. 总结概念 (Concepts) 的优势"></a>4. 总结概念 (Concepts) 的优势</h3><ul>
<li><strong>清晰的接口定义：</strong> 模板的意图一目了然，提高了代码的可读性和可维护性。</li>
<li><strong>友好的编译错误：</strong> 编译器能给出准确、易懂的错误信息，大大缩短了调试时间。</li>
<li><strong>编译时检查：</strong> 在编译阶段就能发现类型不匹配的问题，而不是等到运行时。</li>
<li><strong>更好的重载解析：</strong> 概念可以帮助编译器在多个模板重载中选择最匹配的一个。</li>
<li><strong>替代 SFINAE：</strong> 避免了复杂的模板元编程技巧，使泛型代码更易于编写和理解。</li>
<li><strong>零运行时开销：</strong> 概念是纯粹的编译时特性，不会增加任何运行时性能负担。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++20</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>const和constexpr</title>
    <url>/2025/06/15/const%E5%92%8Cconstexpr/</url>
    <content><![CDATA[<h3 id="constexpr-和-const-的区别"><a href="#constexpr-和-const-的区别" class="headerlink" title="constexpr 和 const 的区别"></a>constexpr 和 const 的区别</h3><p>在 C++ 中，<code>const</code> 和 <code>constexpr</code> 都用于定义常量，但它们的用途和行为有显著区别。</p>
<p>简单来说const可以是运行时变量也可以是编译时变量，而constexpr必须是编译时变量</p>
<p>而数组的大小这种就必须是编译时变量</p>
<p>以下是详细对比：</p>
<hr>
<h4 id="1-定义和用途"><a href="#1-定义和用途" class="headerlink" title="1. 定义和用途"></a>1. <strong>定义和用途</strong></h4><ul>
<li><p>**<code>const</code>**：</p>
<ul>
<li>表示变量的值在初始化后不可修改（只读）。</li>
<li>可以用于运行时常量或编译时常量，具体取决于初始化方式。</li>
<li>适用场景：需要确保变量不被修改，但不一定要求编译时求值。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 编译时常量</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = y; <span class="comment">// 运行时常量（y 的值在运行时确定）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>constexpr</code>**：</p>
<ul>
<li>表示变量或函数的值或结果必须在编译时可求值。</li>
<li>用于定义编译时常量或编译时计算的函数，确保结果在编译阶段确定。</li>
<li>适用场景：需要编译时常量（如数组大小、模板参数）或性能敏感的编译时计算。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 编译时常量</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">square</span>(<span class="number">5</span>)]; <span class="comment">// square(5) 在编译时求值为 25</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-初始化要求"><a href="#2-初始化要求" class="headerlink" title="2. 初始化要求"></a>2. <strong>初始化要求</strong></h4><ul>
<li><p>**<code>const</code>**：</p>
<ul>
<li>可以用编译时常量或运行时变量初始化。</li>
<li>初始化后不可修改，但初始化时间可以是运行时。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> input;</span><br><span class="line">std::cin &gt;&gt; input;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> value = input; <span class="comment">// 运行时初始化</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>constexpr</code>**：</p>
<ul>
<li>必须用编译时可求值的表达式初始化。</li>
<li>初始化必须在编译时完成，不能依赖运行时值。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 合法</span></span><br><span class="line"><span class="type">int</span> input;</span><br><span class="line">std::cin &gt;&gt; input;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> error = input; <span class="comment">// 错误：input 是运行时值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-作用范围"><a href="#3-作用范围" class="headerlink" title="3. 作用范围"></a>3. <strong>作用范围</strong></h4><ul>
<li><p>**<code>const</code>**：</p>
<ul>
<li>可以修饰变量、指针、成员函数等，强调不可修改性。</li>
<li>作用广泛，不限于编译时场景。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x; <span class="comment">// 指针指向的值不可修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 成员函数不修改对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>constexpr</code>**：</p>
<ul>
<li>主要用于变量和函数，强调编译时求值。</li>
<li>C++11 中仅限简单函数，C++14 及以后支持更复杂逻辑（如循环、条件语句）。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> f = <span class="built_in">factorial</span>(<span class="number">5</span>); <span class="comment">// 编译时计算 120</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-函数中的区别"><a href="#4-函数中的区别" class="headerlink" title="4. 函数中的区别"></a>4. <strong>函数中的区别</strong></h4><ul>
<li><p>**<code>const</code>**：</p>
<ul>
<li>用于成员函数，表示函数不会修改对象状态。</li>
<li>不涉及编译时求值。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 不会修改 x</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>constexpr</code>**：</p>
<ul>
<li>用于函数，表示函数的结果可在编译时求值（如果输入是编译时常量）。</li>
<li>函数体必须满足编译时求值的约束（如避免运行时操作）。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 编译时求值为 7</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="built_in">add</span>(x, y); <span class="comment">// 运行时调用，仍然合法</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-存储和性能"><a href="#5-存储和性能" class="headerlink" title="5. 存储和性能"></a>5. <strong>存储和性能</strong></h4><ul>
<li><p>**<code>const</code>**：</p>
<ul>
<li><code>const</code> 变量可能占用内存（除非优化为常量折叠）。</li>
<li>如果是运行时常量，存储在栈或堆上。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = std::<span class="built_in">rand</span>(); <span class="comment">// 运行时初始化，占用内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>constexpr</code>**：</p>
<ul>
<li><code>constexpr</code> 变量通常不占用运行时内存（编译器直接内联常量值）。</li>
<li>提高性能，因为值在编译时确定。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 编译时常量，通常不占用内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-兼容性和限制"><a href="#6-兼容性和限制" class="headerlink" title="6. 兼容性和限制"></a>6. <strong>兼容性和限制</strong></h4><ul>
<li><p>**<code>const</code>**：</p>
<ul>
<li>C++98 就存在，兼容性强。</li>
<li>限制较少，适用于各种场景。</li>
<li>不保证编译时求值，不能直接用于模板参数或数组大小。</li>
</ul>
</li>
<li><p>**<code>constexpr</code>**：</p>
<ul>
<li>C++11 引入，功能在 C++14、C++17 等版本中扩展。</li>
<li>限制严格（如函数体需满足编译时求值规则）。</li>
<li>可用于模板参数、数组大小等编译时场景。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[n]; <span class="comment">// 合法，n 是编译时常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr2[m]; <span class="comment">// 合法，但依赖编译器优化</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>const</code></th>
<th><code>constexpr</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>含义</strong></td>
<td>值不可修改</td>
<td>编译时可求值</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>可运行时或编译时初始化</td>
<td>必须编译时初始化</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>运行时&#x2F;编译时常量，成员函数修饰</td>
<td>编译时常量，编译时计算函数</td>
</tr>
<tr>
<td><strong>函数支持</strong></td>
<td>成员函数不可修改对象</td>
<td>编译时求值函数</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>可能占用内存</td>
<td>通常不占用内存（内联）</td>
</tr>
<tr>
<td><strong>引入版本</strong></td>
<td>C++98</td>
<td>C++11</td>
</tr>
</tbody></table>
<hr>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul>
<li>需要编译时常量或性能敏感的场景（如模板参数、数组大小），使用 <code>constexpr</code>。</li>
<li>需要运行时常量或只读保护，使用 <code>const</code>。</li>
<li>两者可结合使用，例如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 既是编译时常量，又不可修改</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>const</tag>
        <tag>constexpr</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu的乱序执行与内存顺序</title>
    <url>/2025/04/30/cpu%E7%9A%84%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>乱序执行是现代高性能处理器（CPU）中一种非常重要的<strong>性能优化技术</strong>。它的核心思想是：<strong>CPU 不严格按照程序代码中指令的顺序来执行它们，而是根据指令是否“准备好”来决定执行顺序，但最终要保证程序的结果与按顺序执行时一致。</strong></p>
<p><strong>为什么需要乱序执行？</strong></p>
<p>传统的 CPU 执行模式是**顺序执行 (In-Order Execution)**：CPU 严格按照程序代码的指令顺序一条接一条地执行。然而，这种方式效率不高，原因在于：</p>
<ol>
<li><p><strong>指令依赖 (Instruction Dependencies):</strong> 后一条指令可能需要等待前一条指令的结果才能执行。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD R1, R2, R3   ; R1 = R2 + R3</span><br><span class="line">SUB R4, R1, R5   ; R4 = R1 - R5  (需要等待 ADD 指令的结果 R1)</span><br></pre></td></tr></table></figure>
<p>在顺序执行中，SUB 指令必须等待 ADD 指令完成后才能开始。这会造成 CPU 的执行单元（如算术逻辑单元 ALU）在这段时间内处于空闲状态，浪费了计算资源。</p>
</li>
<li><p><strong>内存延迟 (Memory Latency):</strong> 从内存中读取数据通常比执行算术运算慢得多。如果一条指令需要从内存加载数据，CPU 可能需要等待几十甚至几百个时钟周期。在顺序执行中，CPU 会一直等待，直到数据加载完成才能继续执行下一条指令，导致整个流水线停顿。</p>
</li>
</ol>
<p>乱序执行就是为了解决这些问题，通过<strong>提高 CPU 执行单元的利用率</strong>和<strong>隐藏延迟</strong>来提升性能。</p>
<p><strong>乱序执行是如何工作的？</strong></p>
<p>现代支持乱序执行的 CPU 通常包含以下关键组件和流程（简化版）：</p>
<ol>
<li><strong>指令预取 (Instruction Fetch):</strong> CPU 仍然会按照程序顺序从内存中预取指令，并放入一个缓冲区。</li>
<li><strong>指令解码 (Instruction Decode):</strong> 预取的指令被解码，识别出它们的操作类型、操作数等。</li>
<li><strong>指令分发&#x2F;发射 (Instruction Dispatch&#x2F;Issue):</strong> 解码后的指令被放入一个<strong>指令窗口 (Instruction Window)</strong> 或<strong>重排序缓冲区 (Reorder Buffer - ROB)<strong>。CPU 会在这个窗口中扫描，寻找那些</strong>操作数已经准备好</strong>并且<strong>所需的执行单元空闲</strong>的指令。找到后，就将这些“准备好”的指令分发到相应的执行单元。<ul>
<li>注意：这里的关键是，分发出去的指令顺序可能与它们进入窗口的顺序不同，这就是“乱序执行”的体现。</li>
</ul>
</li>
<li><strong>指令执行 (Instruction Execution):</strong> 被分发到执行单元的指令开始执行。不同的执行单元可以并行工作（例如，一个 ALU 在做加法，一个浮点单元 FPU 在做乘法，一个加载&#x2F;存储单元 L&#x2F;S Unit 在从内存加载数据）。</li>
<li><strong>结果写回 (Result Write-back):</strong> 指令执行完成后，结果会被临时保存在一个地方（例如，重排序缓冲区或寄存器文件）。</li>
<li><strong>指令提交&#x2F;退休 (Instruction Commit&#x2F;Retirement):</strong> 这是乱序执行中最关键的一步，用于保证程序的正确性。CPU 会按照<strong>原始程序顺序</strong>来提交指令的结果。只有当一条指令在原始程序顺序中排在它前面的所有指令都已成功提交后，它才能提交其结果。提交意味着将最终结果写入到架构寄存器或主内存中，使其对后续指令和外部世界可见。<ul>
<li>这个“按序提交”的过程确保了即使执行是乱序的，程序的状态变化（如寄存器值、内存内容）看起来仍然像是按顺序发生的。这对于处理异常、中断以及保证多线程程序的正确性至关重要。</li>
</ul>
</li>
</ol>
<p><strong>核心思想总结：</strong></p>
<ul>
<li><strong>取指和提交是顺序的 (In-Order Fetch and Commit)。</strong></li>
<li><strong>执行是乱序的 (Out-of-Order Execution)。</strong></li>
</ul>
<p><strong>乱序执行带来的好处：</strong></p>
<ul>
<li><strong>提高指令级并行性 (Instruction-Level Parallelism - ILP):</strong> CPU 可以同时执行多个独立的指令。</li>
<li><strong>隐藏延迟:</strong> 当一条指令因为等待内存数据而停顿时，CPU 可以去执行窗口中其他不依赖该数据的指令，从而避免流水线停顿。</li>
<li><strong>提高执行单元利用率:</strong> 保持 CPU 的各个执行单元尽可能地忙碌。</li>
<li><strong>提升整体程序执行速度。</strong></li>
</ul>
<p><strong>乱序执行的挑战：</strong></p>
<ul>
<li><strong>硬件设计的复杂性:</strong> 需要复杂的逻辑来跟踪指令依赖、管理重排序缓冲区、实现寄存器重命名等。</li>
<li><strong>保持程序正确性:</strong> 必须精确地处理异常、中断，并确保内存操作的可见性（尤其在多处理器系统中，需要内存屏障等机制来保证内存一致性）。</li>
<li><strong>分支预测的依赖:</strong> 乱序执行通常与分支预测结合使用，预测错误会导致大量投机执行的工作被丢弃，影响效率。</li>
<li><strong>安全漏洞:</strong> 近年来发现的 Spectre 和 Meltdown 等安全漏洞就与乱序执行和投机执行（Speculative Execution，乱序执行的一个重要组成部分，CPU 预测未来可能执行的路径并提前执行指令）有关，可能导致敏感信息泄露。</li>
</ul>
<p><strong>简单类比：</strong></p>
<p>想象一个厨师要做几道菜。如果他严格按照每道菜的步骤一步一步做完一道再做下一道（顺序执行），效率会很低。而一个经验丰富的厨师会同时处理多道菜：先把需要炖的肉下锅（长时间操作），然后去切另一道菜的菜，同时看看烤箱里的蛋糕，再回来翻炒第一道菜的配料（乱序执行）。但他最终上菜（提交）时，仍然会按照客人点的顺序或菜单的顺序一道一道上。</p>
<p>总而言之，乱序执行是现代 CPU 为了榨取更多性能而采用的一种复杂但高效的技术，它通过打破指令的原始顺序来执行，但在结果上保持与顺序执行一致，从而显著提高了处理器的吞吐量。</p>
<h3 id="乱序执行的多线程挑战"><a href="#乱序执行的多线程挑战" class="headerlink" title="乱序执行的多线程挑战"></a>乱序执行的多线程挑战</h3><p>在多线程环境中，乱序执行可能来自：</p>
<ol>
<li><strong>编译器优化</strong>：编译器可能重排无关的内存操作以优化性能。</li>
<li><strong>CPU 乱序执行</strong>：处理器可能将指令重新排序以提高流水线效率。</li>
<li><strong>缓存一致性延迟</strong>：一个线程的写入可能停留在本地缓存中，延迟对其他线程可见。</li>
</ol>
<p>这些行为可能导致线程观察到的共享变量状态不符合程序员预期。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; x = <span class="number">1</span>; y = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (y == <span class="number">1</span>) <span class="built_in">assert</span>(x == <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>直觉上，线程 2 看到 <code>y == 1</code> 时，<code>x</code> 应为 1，但由于乱序，线程 2 可能看到 <code>y = 1</code> 而 <code>x</code> 仍为 0。</p>
<h3 id="C-内存模型应对乱序"><a href="#C-内存模型应对乱序" class="headerlink" title="C++ 内存模型应对乱序"></a>C++ 内存模型应对乱序</h3><p>C++11 引入的内存模型通过 <code>std::atomic</code> 和 <code>std::memory_order</code> 提供工具，控制内存操作的顺序和可见性：</p>
<ol>
<li><p>**<code>std::atomic</code>**：</p>
<ul>
<li>保证操作的原子性，防止线程间操作撕裂。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; x&#123;<span class="number">0</span>&#125;, y&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; x.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed); y.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; <span class="keyword">while</span> (y.<span class="built_in">load</span>(std::memory_order_acquire) != <span class="number">1</span>); <span class="built_in">assert</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure></li>
<li>这里，<code>release</code> 和 <code>acquire</code> 确保线程 2 看到 <code>y = 1</code> 时，<code>x = 1</code> 已可见。</li>
</ul>
</li>
<li><p>**内存顺序 (<code>std::memory_order</code>)**：</p>
<ul>
<li><p><code>memory_order_seq_cst</code>：默认，提供全局一致的顺序，最严格但开销较高。</p>
</li>
<li><p><code>memory_order_acquire</code>：确保后续操作看到 <code>release</code> 前的写入。</p>
</li>
<li><p><code>memory_order_release</code>：确保前面的写入在 <code>release</code> 后对 <code>acquire</code> 线程可见。</p>
</li>
<li><p><code>memory_order_acp_rel</code>：acquire+release</p>
</li>
<li><p><code>memory_order_relaxed</code>：仅保证原子性，允许最大乱序，适用于无需同步的场景（如计数器）。</p>
</li>
<li><p><strong>配对形成同步</strong>：<code>release</code> 保证生产者线程在设置标志前，所有写入（比如数据）都完成并对其他线程“可见”；<code>acquire</code> 保证消费者线程在看到标志后，能看到生产者 <code>release</code> 前的所有写入。两者一起工作，就像主厨和服务员通过牌子协调，确保菜做好了才端上桌。</p>
</li>
<li><p><strong>内存顺序保证</strong>：<code>release</code> 防止生产者线程的写入被重排到标志设置之后；<code>acquire</code> 防止消费者线程的读取被重排到标志检查之前。这种“半场屏障”组合确保了正确的因果顺序。</p>
</li>
</ul>
</li>
<li><p><strong>同步原语</strong>：</p>
<ul>
<li>**互斥锁 (<code>std::mutex</code>)**：自动引入内存屏障，强制内存操作按锁的获取&#x2F;释放顺序。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; x = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="built_in">assert</span>(x == <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure></li>
<li>**条件变量 (<code>std::condition_variable</code>)**：与锁配合，确保信号传递和数据同步。</li>
<li>这些原语在底层使用内存屏障（如 <code>mfence</code> 或平台特定的指令），限制乱序。</li>
</ul>
</li>
</ol>
<h3 id="优化与权衡"><a href="#优化与权衡" class="headerlink" title="优化与权衡"></a>优化与权衡</h3><ul>
<li><strong>选择合适的内存顺序</strong>：<ul>
<li>使用 <code>seq_cst</code> 简单但可能牺牲性能。</li>
<li><code>acquire</code>&#x2F;<code>release</code> 适合生产者-消费者模式，效率更高。</li>
<li><code>relaxed</code> 用于无需严格同步的场景，如性能敏感的计数器。</li>
</ul>
</li>
<li><strong>避免过度同步</strong>：过多屏障会降低性能。例如，过多使用 <code>seq_cst</code> 或锁可能导致线程争用和性能瓶颈。</li>
<li><strong>调试复杂性</strong>：乱序问题难以复现，建议使用工具（如 ThreadSanitizer）检测数据竞争。</li>
</ul>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在高性能多线程程序（如服务器、游戏引擎）中，合理使用 <code>std::atomic</code> 和 <code>memory_order</code> 能显著提高效率。例如，无锁队列常使用 <code>acquire</code>&#x2F;<code>release</code> 语义实现高效同步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;Node*&gt; head&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    Node* old_head = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node-&gt;next = old_head;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, node, std::memory_order_release));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* node = head.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; !head.<span class="built_in">compare_exchange_weak</span>(node, node-&gt;next, std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++11</tag>
        <tag>多线程</tag>
        <tag>计算机架构</tag>
      </tags>
  </entry>
  <entry>
    <title>explicit关键字</title>
    <url>/2025/01/22/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a><strong><code>explicit</code> 关键字</strong></h3><p>在 C++ 中，<code>explicit</code> 是一个用于构造函数的修饰符，其主要作用是 <strong>防止隐式类型转换</strong>，从而避免某些情况下的代码歧义或意外错误。</p>
<hr>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><ol>
<li>修饰构造函数，防止隐式类型转换。</li>
<li>修饰带有单个参数的构造函数，避免单参数的构造函数被用作隐式类型转换运算符。</li>
</ol>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ClassName</span><span class="params">(Type param)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="为什么需要-explicit？"><a href="#为什么需要-explicit？" class="headerlink" title="为什么需要 explicit？"></a><strong>为什么需要 <code>explicit</code>？</strong></h3><ul>
<li>默认情况下，C++ 会允许单参数构造函数被隐式调用，用于进行类型转换。这种行为有时会导致意外的错误。</li>
<li>使用 <code>explicit</code> 可以禁止这样的隐式转换。</li>
</ul>
<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><h4 id="1-没有使用-explicit"><a href="#1-没有使用-explicit" class="headerlink" title="1. 没有使用 explicit"></a><strong>1. 没有使用 <code>explicit</code></strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单参数构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">42</span>; <span class="comment">// 隐式调用 MyClass(int) 构造函数</span></span><br><span class="line">    obj.<span class="built_in">display</span>();    <span class="comment">// 输出：Value: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h4><ul>
<li><code>MyClass obj = 42;</code> 中，整数 <code>42</code> 被隐式转换为 <code>MyClass</code> 类型的对象。</li>
<li>这种隐式转换可能导致意想不到的错误，尤其当构造函数的逻辑复杂或多义时。</li>
</ul>
<hr>
<h4 id="2-使用-explicit"><a href="#2-使用-explicit" class="headerlink" title="2. 使用 explicit"></a><strong>2. 使用 <code>explicit</code></strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> : m_value(value) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MyClass obj = 42; // 错误：因为 explicit 禁止隐式转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;    <span class="comment">// 必须显式调用构造函数</span></span><br><span class="line">    obj.<span class="built_in">display</span>();      <span class="comment">// 输出：Value: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a><strong>结果</strong></h4><ul>
<li>使用 <code>explicit</code> 后，<code>MyClass obj = 42;</code> 会编译报错。</li>
<li>必须显式调用构造函数：<code>MyClass obj(42);</code>。</li>
</ul>
<hr>
<h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a><strong>更多例子</strong></h3><h4 id="1-防止误用"><a href="#1-防止误用" class="headerlink" title="1. 防止误用"></a><strong>1. 防止误用</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> seconds)</span> : m_seconds(seconds) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer started for &quot;</span> &lt;&lt; m_seconds &lt;&lt; <span class="string">&quot; seconds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_seconds;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTimer</span><span class="params">(Timer t)</span> </span>&#123;</span><br><span class="line">    t.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// setTimer(10); // 错误：需要显式构造 Timer 对象</span></span><br><span class="line">    <span class="built_in">setTimer</span>(<span class="built_in">Timer</span>(<span class="number">10</span>)); <span class="comment">// 正确：显式构造</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>Timer</code> 构造函数未被 <code>explicit</code> 修饰，<code>setTimer(10)</code> 会隐式转换为 <code>Timer(10)</code>，可能导致意外行为。</li>
</ul>
<hr>
<h4 id="2-避免容器中意外类型转换"><a href="#2-避免容器中意外类型转换" class="headerlink" title="2. 避免容器中意外类型转换"></a><strong>2. 避免容器中意外类型转换</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyClass&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vec.push_back(10); // 错误：explicit 禁止隐式转换</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">MyClass</span>(<span class="number">10</span>)); <span class="comment">// 正确：显式构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="与非-explicit-的对比"><a href="#与非-explicit-的对比" class="headerlink" title="与非 explicit 的对比"></a><strong>与非 <code>explicit</code> 的对比</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>没有 <code>explicit</code></strong></th>
<th><strong>使用 <code>explicit</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>构造函数调用方式</strong></td>
<td>允许隐式和显式调用</td>
<td>仅允许显式调用</td>
</tr>
<tr>
<td><strong>隐式转换</strong></td>
<td>支持隐式类型转换，可能导致意外错误</td>
<td>禁止隐式类型转换，减少歧义和错误风险</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td>可省略显式构造调用（<code>Type obj = value;</code>）</td>
<td>必须显式调用构造函数（<code>Type obj(value);</code>）</td>
</tr>
</tbody></table>
<hr>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li><strong>单参数构造函数</strong>：当类有单参数构造函数时，避免隐式转换带来的歧义。</li>
<li><strong>限制类型转换</strong>：需要明确控制何时允许类型转换。</li>
<li><strong>模板类</strong>：显式控制模板参数的构造，避免意外的模板匹配。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li><p><strong><code>explicit</code> 的作用</strong>：</p>
<ul>
<li>防止隐式类型转换。</li>
<li>提高代码的安全性和可读性，避免意外错误。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>单参数构造函数。</li>
<li>需要限制隐式转换时。</li>
</ul>
</li>
<li><p><strong>编程建议</strong>：</p>
<ul>
<li>如果类的构造函数中有单参数，且你不希望它被隐式调用，**请使用 <code>explicit</code>**。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>enum和enum class</title>
    <url>/2025/09/23/enum%E5%92%8Cenum-class/</url>
    <content><![CDATA[<hr>
<h3 id="一、-enum-传统枚举-Unscoped-Enum"><a href="#一、-enum-传统枚举-Unscoped-Enum" class="headerlink" title="一、 enum (传统枚举 &#x2F; Unscoped Enum)"></a>一、 <code>enum</code> (传统枚举 &#x2F; Unscoped Enum)</h3><p><code>enum</code> 是 C 语言就有的特性，在 C++ 中也得到了支持。它定义了一组具名的整数常量。</p>
<p><strong>特点：</strong></p>
<ol>
<li><p><strong>作用域污染 (Scope Pollution)：</strong> <code>enum</code> 的枚举器（即具名常量）会<strong>泄露到定义它们的命名空间或全局作用域中</strong>。这意味着你不能在同一个作用域中定义同名的枚举器，即使它们属于不同的 <code>enum</code> 类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TrafficLight</span> &#123; RED_LIGHT, YELLOW_LIGHT, GREEN_LIGHT &#125;; <span class="comment">// 编译错误：RED_LIGHT 与 Color::RED 冲突 (如果 RED_LIGHT 也叫 RED)</span></span><br><span class="line">                                                          <span class="comment">// 实际上这里不会冲突，因为名字不同。但如果 TrafficLight 也有一个叫 RED 的枚举器，就会冲突。</span></span><br><span class="line"><span class="comment">// 假设：</span></span><br><span class="line"><span class="comment">// enum Color &#123; RED, GREEN, BLUE &#125;;</span></span><br><span class="line"><span class="comment">// enum Feeling &#123; HAPPY, SAD, RED &#125;; // 编译错误：RED 重定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式类型转换 (Implicit Conversion)：</strong> <code>enum</code> 的枚举器可以<strong>隐式转换为整数类型</strong>（如 <code>int</code>），也可以隐式地与其他整数类型进行比较或算术运算。这可能导致类型不安全的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line">Color c = RED;</span><br><span class="line"><span class="type">int</span> i = c; <span class="comment">// 隐式转换为 int，i = 0，合法</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 隐式比较，合法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Color another_c = BLUE;</span><br><span class="line"><span class="keyword">if</span> (c == another_c) &#123; <span class="comment">// 合法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>底层类型不确定 (Underlying Type)：</strong> 编译器会为 <code>enum</code> 选择一个合适的整数类型来存储枚举值（例如 <code>int</code>、<code>char</code> 等），这个类型是<strong>实现定义的</strong>，通常是能够容纳所有枚举器值的最小整数类型。你也可以显式指定底层类型（C++11 引入），但这在传统 <code>enum</code> 中不常见。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="comment">// sizeof(Color) 可能是 4 (int)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认值：</strong> 如果没有显式赋值，第一个枚举器的值为 <code>0</code>，后续枚举器的值在前一个的基础上递增 <code>1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    OK,      <span class="comment">// 0</span></span><br><span class="line">    ERROR,   <span class="comment">// 1</span></span><br><span class="line">    WARNING = <span class="number">5</span>, <span class="comment">// 5</span></span><br><span class="line">    FATAL    <span class="comment">// 6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH, <span class="comment">// 0</span></span><br><span class="line">    EAST,  <span class="comment">// 1</span></span><br><span class="line">    SOUTH, <span class="comment">// 2</span></span><br><span class="line">    WEST   <span class="comment">// 3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    DOG = <span class="number">10</span>,</span><br><span class="line">    CAT,   <span class="comment">// 11</span></span><br><span class="line">    BIRD   <span class="comment">// 12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_direction</span><span class="params">(Direction d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">        <span class="keyword">case</span> NORTH: std::cout &lt;&lt; <span class="string">&quot;North&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EAST:  std::cout &lt;&lt; <span class="string">&quot;East&quot;</span> &lt;&lt; std::endl;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOUTH: std::cout &lt;&lt; <span class="string">&quot;South&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEST:  std::cout &lt;&lt; <span class="string">&quot;West&quot;</span> &lt;&lt; std::endl;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:    std::cout &lt;&lt; <span class="string">&quot;Unknown Direction&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Direction my_dir = NORTH;</span><br><span class="line">    <span class="built_in">print_direction</span>(my_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作用域污染：可以直接使用 NORTH，而不是 Direction::NORTH</span></span><br><span class="line">    <span class="keyword">if</span> (my_dir == NORTH) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It&#x27;s North!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式转换：</span></span><br><span class="line">    <span class="type">int</span> dir_val = my_dir; <span class="comment">// OK, dir_val = 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Direction value: &quot;</span> &lt;&lt; dir_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式比较：</span></span><br><span class="line">    <span class="keyword">if</span> (my_dir == <span class="number">0</span>) &#123; <span class="comment">// OK</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;North is 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型不安全问题示例：</span></span><br><span class="line">    <span class="comment">// Animal a = NORTH; // 编译错误，因为类型不匹配。但如果 Direction 和 Animal 的底层类型相同，且值匹配，可能可以通过强制转换绕过。</span></span><br><span class="line">    <span class="comment">// int x = 1;</span></span><br><span class="line">    <span class="comment">// Direction d2 = static_cast&lt;Direction&gt;(x); // 允许将任意整数转换为枚举类型，可能得到无效值</span></span><br><span class="line">    <span class="comment">// print_direction(d2); // 如果 x=1，输出 East；如果 x=100，输出 Unknown Direction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、-enum-class-枚举类-Scoped-Enum-C-11"><a href="#二、-enum-class-枚举类-Scoped-Enum-C-11" class="headerlink" title="二、 enum class (枚举类 &#x2F; Scoped Enum) (C++11)"></a>二、 <code>enum class</code> (枚举类 &#x2F; Scoped Enum) (C++11)</h3><p><code>enum class</code> 是 C++11 引入的，旨在解决传统 <code>enum</code> 的主要缺点：作用域污染和类型不安全。</p>
<p><strong>特点：</strong></p>
<ol>
<li><p><strong>强作用域 (Strongly Scoped)：</strong> <code>enum class</code> 的枚举器只在其枚举类型的作用域内可见。你需要使用 <code>EnumTypeName::EnumeratorName</code> 的方式来引用它们。这完全消除了作用域污染问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TrafficLight</span> &#123; RED, YELLOW, GREEN &#125;; <span class="comment">// 合法！两个 RED 不冲突</span></span><br><span class="line"></span><br><span class="line">Color c = Color::RED; <span class="comment">// 必须使用作用域限定符</span></span><br><span class="line"><span class="comment">// TrafficLight tl = RED; // 编译错误：RED 未定义</span></span><br><span class="line">TrafficLight tl = TrafficLight::RED; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>强类型 (Strongly Typed)：</strong> <code>enum class</code> 的枚举器不会隐式转换为整数类型。你也不能将整数隐式赋值给 <code>enum class</code> 类型。这大大提高了类型安全性，避免了许多潜在的错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line">Color c = Color::RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int i = c; // 编译错误：不能隐式转换为 int</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c); <span class="comment">// 必须显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if (c == 0) &#123; // 编译错误：不能隐式比较</span></span><br><span class="line"><span class="comment">//     // ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">if</span> (c == Color::RED) &#123; <span class="comment">// 合法，同类型比较</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Color another_c = TrafficLight::RED; // 编译错误：不同枚举类型不能直接比较或赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>默认底层类型为 <code>int</code>：</strong> 如果不显式指定，<code>enum class</code> 的底层类型默认为 <code>int</code>。你可以显式指定底层类型，这在传统 <code>enum</code> 中也是可行的，但对于 <code>enum class</code> 来说，这种控制更为重要。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">unsigned</span> <span class="type">char</span> &#123; RED, GREEN, BLUE &#125;; <span class="comment">// 显式指定底层类型为 unsigned char</span></span><br><span class="line"><span class="comment">// sizeof(Color) 会是 1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH, <span class="comment">// 0</span></span><br><span class="line">    EAST,  <span class="comment">// 1</span></span><br><span class="line">    SOUTH, <span class="comment">// 2</span></span><br><span class="line">    WEST   <span class="comment">// 3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    DOG = <span class="number">10</span>,</span><br><span class="line">    CAT,   <span class="comment">// 11</span></span><br><span class="line">    BIRD   <span class="comment">// 12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_direction_class</span><span class="params">(Direction d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (d) &#123;</span><br><span class="line">        <span class="keyword">case</span> Direction::NORTH: std::cout &lt;&lt; <span class="string">&quot;North&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Direction::EAST:  std::cout &lt;&lt; <span class="string">&quot;East&quot;</span> &lt;&lt; std::endl;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Direction::SOUTH: std::cout &lt;&lt; <span class="string">&quot;South&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Direction::WEST:  std::cout &lt;&lt; <span class="string">&quot;West&quot;</span> &lt;&lt; std::endl;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:    std::cout &lt;&lt; <span class="string">&quot;Unknown Direction&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Direction my_dir = Direction::NORTH;</span><br><span class="line">    <span class="built_in">print_direction_class</span>(my_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强作用域：必须使用 Direction::NORTH</span></span><br><span class="line">    <span class="keyword">if</span> (my_dir == Direction::NORTH) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It&#x27;s North!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强类型：不能隐式转换为 int</span></span><br><span class="line">    <span class="comment">// int dir_val = my_dir; // 编译错误</span></span><br><span class="line">    <span class="type">int</span> dir_val = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(my_dir); <span class="comment">// 必须显式转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Direction value: &quot;</span> &lt;&lt; dir_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强类型：不能隐式比较</span></span><br><span class="line">    <span class="comment">// if (my_dir == 0) &#123; // 编译错误</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;North is 0&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强类型：不同枚举类型不能直接比较或赋值</span></span><br><span class="line">    <span class="comment">// Animal a = Direction::NORTH; // 编译错误</span></span><br><span class="line">    <span class="comment">// if (Direction::NORTH == Animal::DOG) &#123; // 编译错误</span></span><br><span class="line">    <span class="comment">//     // ...</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许将整数转换为枚举类型，但仍需显式转换</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    Direction d2 = <span class="built_in">static_cast</span>&lt;Direction&gt;(x); <span class="comment">// 合法，但仍需小心无效值</span></span><br><span class="line">    <span class="built_in">print_direction_class</span>(d2); <span class="comment">// 如果 x=1，输出 East；如果 x=100，输出 Unknown Direction</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、-总结与选择"><a href="#三、-总结与选择" class="headerlink" title="三、 总结与选择"></a>三、 总结与选择</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>enum</code> (传统枚举)</th>
<th align="left"><code>enum class</code> (枚举类 &#x2F; 作用域枚举)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>C++版本</strong></td>
<td align="left">C++98 及更高版本</td>
<td align="left">C++11 及更高版本</td>
</tr>
<tr>
<td align="left"><strong>作用域</strong></td>
<td align="left">枚举器泄露到父作用域，可能导致命名冲突</td>
<td align="left"><strong>强作用域</strong>，枚举器只在枚举类型内部可见</td>
</tr>
<tr>
<td align="left"><strong>引用方式</strong></td>
<td align="left"><code>EnumeratorName</code> 或 <code>EnumTypeName::EnumeratorName</code></td>
<td align="left"><strong>必须</strong> <code>EnumTypeName::EnumeratorName</code></td>
</tr>
<tr>
<td align="left"><strong>类型安全性</strong></td>
<td align="left"><strong>弱类型</strong>，可隐式转换为整数，可与整数比较</td>
<td align="left"><strong>强类型</strong>，不能隐式转换为整数，不能与整数比较</td>
</tr>
<tr>
<td align="left"><strong>底层类型</strong></td>
<td align="left">编译器决定 (实现定义)，默认为 <code>int</code></td>
<td align="left">默认为 <code>int</code>，可显式指定</td>
</tr>
<tr>
<td align="left"><strong>隐式转换</strong></td>
<td align="left"><code>enum</code> -&gt; <code>int</code> (是)</td>
<td align="left"><code>enum class</code> -&gt; <code>int</code> (否，需要 <code>static_cast</code>)</td>
</tr>
<tr>
<td align="left"><strong>不同枚举类型比较</strong></td>
<td align="left">如果底层值相同，可能隐式比较 (不安全)</td>
<td align="left"><strong>否</strong>，编译错误</td>
</tr>
<tr>
<td align="left"><strong>主要优点</strong></td>
<td align="left">兼容 C 语言，在某些遗留代码中可能更方便</td>
<td align="left"><strong>避免命名冲突，提高类型安全性，代码更清晰</strong></td>
</tr>
<tr>
<td align="left"><strong>主要缺点</strong></td>
<td align="left">作用域污染，类型不安全</td>
<td align="left">需要显式作用域限定符和类型转换</td>
</tr>
</tbody></table>
<p><strong>何时选择哪种？</strong></p>
<ul>
<li><strong>推荐使用 <code>enum class</code>：</strong> 在现代 C++ 编程中，几乎所有情况下都应该优先使用 <code>enum class</code>。它解决了传统 <code>enum</code> 的主要痛点，提供了更好的类型安全性和代码清晰度，减少了潜在的错误。</li>
<li><strong>使用 <code>enum</code> 的场景：</strong><ul>
<li><strong>与 C 语言代码兼容：</strong> 如果你需要与 C 语言代码进行接口交互，并且 C 代码期望接收或返回传统的 <code>enum</code> 类型，那么可能需要使用 <code>enum</code>。</li>
<li><strong>作为位标志 (Bit Flags)：</strong> 传统 <code>enum</code> 的隐式转换为整数的特性，有时在作为位标志使用时会显得“方便”（尽管仍然不安全）。然而，即使是位标志，也可以通过重载运算符等方式让 <code>enum class</code> 也能很好地工作，并且更安全。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb的使用</title>
    <url>/2025/06/24/gdb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="使用-GDB-调试-C-程序"><a href="#使用-GDB-调试-C-程序" class="headerlink" title="使用 GDB 调试 C++ 程序"></a>使用 GDB 调试 C++ 程序</h3><p><strong>GDB</strong>（GNU Debugger）是 Linux 环境下强大的调试工具，可用于调试程序崩溃、多线程程序以及检测内存泄漏。以下是详细的 GDB 调试方法，涵盖程序崩溃、多线程调试和内存泄漏检测，格式为 Markdown。</p>
<hr>
<h3 id="1-基本-GDB-使用"><a href="#1-基本-GDB-使用" class="headerlink" title="1. 基本 GDB 使用"></a>1. 基本 GDB 使用</h3><h4 id="编译程序以启用调试"><a href="#编译程序以启用调试" class="headerlink" title="编译程序以启用调试"></a>编译程序以启用调试</h4><p>要使用 GDB 调试，需在编译时添加 <code>-g</code> 标志以包含调试信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -o myprogram myprogram.cpp</span><br></pre></td></tr></table></figure>

<h4 id="启动-GDB"><a href="#启动-GDB" class="headerlink" title="启动 GDB"></a>启动 GDB</h4><p>启动 GDB 并加载程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./myprogram</span><br></pre></td></tr></table></figure>

<h4 id="常用-GDB-命令"><a href="#常用-GDB-命令" class="headerlink" title="常用 GDB 命令"></a>常用 GDB 命令</h4><ul>
<li><code>run</code>（或 <code>r</code>）：运行程序。</li>
<li><code>break &lt;位置&gt;</code>（或 <code>b</code>）：设置断点，如 <code>break main</code> 或 <code>break myprogram.cpp:10</code>。</li>
<li><code>next</code>（或 <code>n</code>）：单步执行（不进入函数）。</li>
<li><code>step</code>（或 <code>s</code>）：单步执行（进入函数）。</li>
<li><code>continue</code>（或 <code>c</code>）：继续运行至下一个断点。</li>
<li><code>print &lt;变量&gt;</code>（或 <code>p</code>）：打印变量值，如 <code>print x</code>。</li>
<li><code>backtrace</code>（或 <code>bt</code>）：显示调用栈。</li>
<li><code>quit</code>（或 <code>q</code>）：退出 GDB。</li>
</ul>
<hr>
<h3 id="2-调试程序崩溃"><a href="#2-调试程序崩溃" class="headerlink" title="2. 调试程序崩溃"></a>2. 调试程序崩溃</h3><p>当程序崩溃（例如段错误，Segmentation Fault），GDB 可帮助定位问题。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p><strong>编译带调试信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -o myprogram myprogram.cpp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 GDB 并运行程序</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./myprogram</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure>
<p>如果程序崩溃，GDB 会停在崩溃点，并显示错误信息，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00005555555551c3 in main () at myprogram.cpp:10</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析崩溃原因</strong>：</p>
<ul>
<li>使用 <code>backtrace</code> 查看调用栈：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br></pre></td></tr></table></figure>
输出调用栈，显示崩溃前的函数调用链。</li>
<li>使用 <code>frame &lt;n&gt;</code> 切换到特定栈帧，检查变量：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) frame 0</span><br><span class="line">(gdb) print *ptr</span><br></pre></td></tr></table></figure>
检查指针是否为空（如 <code>ptr = nullptr</code>）或访问非法内存。</li>
<li>使用 <code>info locals</code> 和 <code>info args</code> 查看局部变量和函数参数。</li>
</ul>
</li>
<li><p><strong>设置断点定位问题</strong>：</p>
<ul>
<li>在可疑代码处设置断点：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break myprogram.cpp:10</span><br></pre></td></tr></table></figure></li>
<li>运行程序并逐步检查变量状态。</li>
</ul>
</li>
<li><p><strong>启用核心转储（Core Dump）</strong>：<br>如果程序崩溃但未在 GDB 中运行，可分析核心转储文件：</p>
<ul>
<li>启用核心转储：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure></li>
<li>运行程序，崩溃后生成 <code>core</code> 文件。</li>
<li>使用 GDB 加载核心转储：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./myprogram core</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>bt</code> 查看崩溃时的调用栈。</li>
</ul>
</li>
</ol>
<h4 id="示例：调试段错误"><a href="#示例：调试段错误" class="headerlink" title="示例：调试段错误"></a>示例：调试段错误</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    *ptr = <span class="number">42</span>; <span class="comment">// 段错误</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Never reached\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -o crash crash.cpp</span><br><span class="line">gdb ./crash</span><br><span class="line">(gdb) run</span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00005555555551c3 <span class="keyword">in</span> main () at crash.cpp:4</span><br><span class="line">4           *ptr = 42;</span><br><span class="line">(gdb) <span class="built_in">print</span> ptr</span><br><span class="line"><span class="variable">$1</span> = (int *) 0x0</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  main () at crash.cpp:4</span></span><br></pre></td></tr></table></figure>
<p>问题：<code>ptr</code> 为空导致解引用失败。</p>
<hr>
<h3 id="3-多线程-GDB-调试"><a href="#3-多线程-GDB-调试" class="headerlink" title="3. 多线程 GDB 调试"></a>3. 多线程 GDB 调试</h3><p>多线程程序可能因竞争条件、死锁或线程特定错误导致问题。GDB 提供多线程调试支持。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p><strong>编译带调试信息和线程支持</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -pthread -o myprogram myprogram.cpp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 GDB 并运行</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./myprogram</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程相关命令</strong>：</p>
<ul>
<li><code>info threads</code>：列出所有线程及其状态。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">Id   Target Id         Frame</span><br><span class="line">* 1    Thread 0x7ffff7fc4740 (LWP 1234) main () at myprogram.cpp:10</span><br><span class="line">  2    Thread 0x7ffff75c3700 (LWP 1235) worker () at myprogram.cpp:20</span><br></pre></td></tr></table></figure></li>
<li><code>thread &lt;id&gt;</code>：切换到指定线程（如 <code>thread 2</code>）。</li>
<li><code>break &lt;位置&gt; thread &lt;id&gt;</code>：为特定线程设置断点，如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break myprogram.cpp:20 thread 2</span><br></pre></td></tr></table></figure></li>
<li><code>thread apply all &lt;命令&gt;</code>：对所有线程执行命令，如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) thread apply all bt</span><br></pre></td></tr></table></figure>
显示所有线程的调用栈。</li>
<li><code>set scheduler-locking on</code>：锁定调度，仅运行当前线程（便于调试特定线程）。</li>
</ul>
</li>
<li><p><strong>调试死锁或竞争条件</strong>：</p>
<ul>
<li>设置断点在共享资源访问点（如锁操作）。</li>
<li>使用 <code>watch &lt;变量&gt;</code> 设置观察点，监控共享变量变化：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch shared_data</span><br></pre></td></tr></table></figure></li>
<li>检查线程状态，分析是否因锁未释放导致死锁。</li>
</ul>
</li>
</ol>
<h4 id="示例：调试多线程程序"><a href="#示例：调试多线程程序" class="headerlink" title="示例：调试多线程程序"></a>示例：调试多线程程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    shared_data++; <span class="comment">// 可能引发竞争</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; incremented to &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -pthread -o threads threads.cpp</span><br><span class="line">gdb ./threads</span><br><span class="line">(gdb) <span class="built_in">break</span> worker</span><br><span class="line">(gdb) run</span><br><span class="line">(gdb) info threads</span><br><span class="line">(gdb) thread 2</span><br><span class="line">(gdb) next</span><br><span class="line">(gdb) <span class="built_in">print</span> shared_data</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-检测内存泄漏"><a href="#4-检测内存泄漏" class="headerlink" title="4. 检测内存泄漏"></a>4. 检测内存泄漏</h3><p>GDB 本身不直接检测内存泄漏，但可结合工具（如 <strong>Valgrind</strong> 或 <strong>AddressSanitizer</strong>）分析内存问题。以下是方法：</p>
<h4 id="使用-GDB-辅助分析"><a href="#使用-GDB-辅助分析" class="headerlink" title="使用 GDB 辅助分析"></a>使用 GDB 辅助分析</h4><ol>
<li><p><strong>检查指针和分配</strong>：</p>
<ul>
<li>在分配内存处设置断点（如 <code>malloc</code> 或 <code>new</code>）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) break malloc</span><br><span class="line">(gdb) break operator new</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>print</code> 检查分配的指针是否被正确释放。</li>
<li>使用 <code>watch</code> 监控指针是否被覆盖或未释放。</li>
</ul>
</li>
<li><p><strong>调用栈分析</strong>：</p>
<ul>
<li>如果怀疑内存泄漏，使用 <code>bt</code> 检查分配和释放的调用路径。</li>
</ul>
</li>
</ol>
<h4 id="使用-Valgrind（推荐）"><a href="#使用-Valgrind（推荐）" class="headerlink" title="使用 Valgrind（推荐）"></a>使用 Valgrind（推荐）</h4><p>Valgrind 的 <code>memcheck</code> 工具可检测内存泄漏：</p>
<ol>
<li>编译带调试信息：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -o myprogram myprogram.cpp</span><br></pre></td></tr></table></figure></li>
<li>运行 Valgrind：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --leak-check=full ./myprogram</span><br></pre></td></tr></table></figure></li>
<li>分析输出：<ul>
<li>Valgrind 报告未释放的内存块及其分配位置。</li>
<li>示例输出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==1234== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==1234==    at 0x4C2DB8D: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==1234==    by 0x4005B3: main (myprogram.cpp:10)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="使用-AddressSanitizer（ASan）"><a href="#使用-AddressSanitizer（ASan）" class="headerlink" title="使用 AddressSanitizer（ASan）"></a>使用 AddressSanitizer（ASan）</h4><ol>
<li>编译时启用 ASan：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -fsanitize=address -o myprogram myprogram.cpp</span><br></pre></td></tr></table></figure></li>
<li>运行程序，ASan 自动报告内存泄漏：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==5678==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line">Direct leak of 40 byte(s) in 1 object(s) allocated from:</span><br><span class="line">    #0 0x7f8b6c4b7a90 in operator new</span><br><span class="line">    #1 0x4005b3 in main myprogram.cpp:10</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="示例：检测内存泄漏"><a href="#示例：检测内存泄漏" class="headerlink" title="示例：检测内存泄漏"></a>示例：检测内存泄漏</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 未释放</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Allocated memory\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Valgrind：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g -o leak leak.cpp</span><br><span class="line">valgrind --leak-check=full ./leak</span><br></pre></td></tr></table></figure>
<p>输出显示 40 字节未释放，定位到 <code>new</code> 调用。</p>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>调试信息</strong>：始终使用 <code>-g</code> 编译，确保 GDB 能显示行号和变量信息。</li>
<li><strong>优化级别</strong>：避免高优化（如 <code>-O2</code>），可能导致调试信息不准确。</li>
<li><strong>多线程调试</strong>：<ul>
<li>使用 <code>info threads</code> 和 <code>thread apply all</code> 管理复杂线程场景。</li>
<li>注意竞争条件，结合锁或 <code>scheduler-locking</code> 隔离线程。</li>
</ul>
</li>
<li><strong>内存泄漏</strong>：<ul>
<li>Valgrind 和 ASan 比 GDB 更适合检测内存问题。</li>
<li>对于复杂程序，定期检查分配和释放匹配。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li>GDB 调试可能影响程序性能，生产环境中谨慎使用。</li>
<li>Valgrind 和 ASan 运行时开销较大，适合开发阶段。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h3><ul>
<li><strong>时间复杂度</strong>：<ul>
<li>GDB 断点设置&#x2F;单步执行：( O(1) )（依赖硬件支持）。</li>
<li>Valgrind 内存检查：( O(n) )，其中 ( n ) 为内存操作数，运行时显著慢于原程序。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：<ul>
<li>GDB：仅占用调试符号表，约为 ( O(1) )。</li>
<li>Valgrind&#x2F;ASan：额外内存开销，约为 ( O(m) )，其中 ( m ) 为分配的内存大小。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>程序崩溃</strong>：用 GDB 的 <code>bt</code>、<code>print</code> 和核心转储定位问题。</li>
<li><strong>多线程调试</strong>：用 <code>info threads</code>、<code>thread</code> 和 <code>watch</code> 分析线程行为。</li>
<li><strong>内存泄漏</strong>：结合 Valgrind 或 ASan 检测未释放内存，GDB 辅助定位分配点。</li>
<li><strong>建议</strong>：熟悉 GDB 基本命令，结合 Valgrind&#x2F;ASan 提高调试效率。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>gdb</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>http,tcp与websocket</title>
    <url>/2025/06/30/http-tcp%E4%B8%8Ewebsocket/</url>
    <content><![CDATA[<h1 id="HTTP协议、TCP协议、WebSocket的区别"><a href="#HTTP协议、TCP协议、WebSocket的区别" class="headerlink" title="HTTP协议、TCP协议、WebSocket的区别"></a>HTTP协议、TCP协议、WebSocket的区别</h1><p>以下是HTTP协议、TCP协议和WebSocket的区别，从定义、功能、特点等多个方面进行比较：</p>
<h2 id="1-TCP协议"><a href="#1-TCP协议" class="headerlink" title="1. TCP协议"></a>1. <strong>TCP协议</strong></h2><ul>
<li><strong>定义</strong>：TCP（Transmission Control Protocol，传输控制协议）是<strong>传输层</strong>协议，属于OSI模型的第四层或TCP&#x2F;IP模型的传输层。</li>
<li><strong>功能</strong>：<ul>
<li>提供可靠的、面向连接的数据传输。</li>
<li>确保数据按序到达、无丢失、无重复，通过三次握手建立连接、四次挥手断开连接。</li>
<li>提供流量控制和拥塞控制机制。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>可靠性</strong>：通过确认机制（ACK）、重传机制和错误检测确保数据完整性。</li>
<li><strong>面向连接</strong>：通信前需建立连接，通信后需断开连接。</li>
<li><strong>适用场景</strong>：需要高可靠性的场景，如文件传输（FTP）、电子邮件（SMTP）、HTTP等。</li>
<li><strong>缺点</strong>：相比UDP，开销较大，速度较慢。</li>
</ul>
</li>
<li><strong>与HTTP&#x2F;WebSocket的关系</strong>：<ul>
<li>TCP是HTTP和WebSocket的底层传输协议，HTTP和WebSocket依赖TCP提供可靠的数据传输。</li>
</ul>
</li>
</ul>
<h2 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2. HTTP协议"></a>2. <strong>HTTP协议</strong></h2><ul>
<li><strong>定义</strong>：HTTP（HyperText Transfer Protocol，超文本传输协议）是<strong>应用层</strong>协议，基于TCP，用于Web浏览器与服务器之间的数据交互。</li>
<li><strong>功能</strong>：<ul>
<li>用于传输超文本数据（如HTML、图片等），是Web浏览的基础。</li>
<li>基于请求-响应模型，客户端发送请求，服务器返回响应。</li>
<li>HTTP&#x2F;1.1支持持久连接（Keep-Alive），HTTP&#x2F;2引入多路复用，HTTP&#x2F;3基于UDP（QUIC）。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>无状态</strong>：每个请求独立，服务器不保存客户端状态（可用Cookie&#x2F;Session解决）。</li>
<li><strong>单向通信</strong>：客户端主动发起请求，服务器被动响应。</li>
<li><strong>短连接（HTTP&#x2F;1.0）或持久连接（HTTP&#x2F;1.1）</strong>：早期每次请求需新建TCP连接，HTTP&#x2F;1.1优化为复用连接。</li>
<li><strong>适用场景</strong>：网页浏览、API调用、文件下载等。</li>
<li><strong>缺点</strong>：不支持服务器主动推送，实时性较差；频繁建立连接（HTTP&#x2F;1.0）效率低。</li>
</ul>
</li>
<li><strong>与WebSocket的关系</strong>：<ul>
<li>HTTP用于初始握手建立WebSocket连接，WebSocket随后接管通信。</li>
</ul>
</li>
</ul>
<h2 id="3-WebSocket"><a href="#3-WebSocket" class="headerlink" title="3. WebSocket"></a>3. <strong>WebSocket</strong></h2><ul>
<li><strong>定义</strong>：WebSocket是<strong>应用层</strong>协议（基于TCP），通过HTTP&#x2F;1.1的Upgrade机制建立，提供全双工通信。</li>
<li><strong>功能</strong>：<ul>
<li>在客户端和服务器之间建立持久的双向通信通道。</li>
<li>支持服务器主动向客户端推送数据。</li>
<li>数据以帧的形式传输，支持文本和二进制数据。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li><strong>全双工</strong>：客户端和服务器可同时发送和接收数据。</li>
<li><strong>持久连接</strong>：一次握手后保持连接，减少重复建立连接的开销。</li>
<li><strong>低开销</strong>：相比HTTP，数据帧头部较小，适合实时通信。</li>
<li><strong>适用场景</strong>：实时应用，如聊天、在线游戏、实时通知、股票行情推送等。</li>
<li><strong>缺点</strong>：实现复杂，服务器需维护大量连接，消耗资源；对代理&#x2F;防火墙支持不够友好。</li>
</ul>
</li>
<li><strong>与HTTP的关系</strong>：<ul>
<li>WebSocket通过HTTP的Upgrade头从HTTP协议切换到WebSocket协议。</li>
</ul>
</li>
</ul>
<h2 id="比较表"><a href="#比较表" class="headerlink" title="比较表"></a>比较表</h2><table>
<thead>
<tr>
<th>特性</th>
<th>TCP协议</th>
<th>HTTP协议</th>
<th>WebSocket</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OSI层</strong></td>
<td>传输层</td>
<td>应用层</td>
<td>应用层</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>面向连接、可靠传输</td>
<td>请求-响应、单向</td>
<td>全双工、双向</td>
</tr>
<tr>
<td><strong>连接特性</strong></td>
<td>需三次握手建立连接</td>
<td>短连接或持久连接</td>
<td>持久连接</td>
</tr>
<tr>
<td><strong>数据格式</strong></td>
<td>字节流</td>
<td>文本（请求&#x2F;响应头+正文）</td>
<td>帧（文本或二进制）</td>
</tr>
<tr>
<td><strong>状态管理</strong></td>
<td>无状态</td>
<td>无状态（可通过Cookie等实现状态）</td>
<td>有状态（连接保持期间）</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>不直接涉及实时性</td>
<td>较差（轮询或长轮询实现伪实时）</td>
<td>优秀（适合实时通信）</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>较高（可靠性和连接管理）</td>
<td>中等（HTTP头较大）</td>
<td>较低（帧头部小）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>基础传输（如FTP、HTTP）</td>
<td>网页、API调用</td>
<td>实时应用（聊天、游戏）</td>
</tr>
<tr>
<td><strong>依赖</strong></td>
<td>底层协议（IP）</td>
<td>依赖TCP</td>
<td>依赖TCP，初始握手用HTTP</td>
</tr>
</tbody></table>
<h2 id="示例代码（简要对比）"><a href="#示例代码（简要对比）" class="headerlink" title="示例代码（简要对比）"></a>示例代码（简要对比）</h2><ul>
<li><strong>HTTP请求</strong>（C++使用libcurl库）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CURL* curl = <span class="built_in">curl_easy_init</span>();</span><br><span class="line">    <span class="keyword">if</span> (curl) &#123;</span><br><span class="line">        <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, <span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line">        <span class="built_in">curl_easy_perform</span>(curl); <span class="comment">// 发送HTTP请求</span></span><br><span class="line">        <span class="built_in">curl_easy_cleanup</span>(curl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>WebSocket连接</strong>（C++使用websocketpp库）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/client.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;websocketpp/config/asio_no_tls.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    websocketpp::client&lt;websocketpp::config::asio&gt; client;</span><br><span class="line">    client.<span class="built_in">set_open_handler</span>([](websocketpp::<span class="type">connection_hdl_t</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WebSocket connected\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    client.<span class="built_in">init_asio</span>();</span><br><span class="line">    websocketpp::lib::error_code ec;</span><br><span class="line">    <span class="keyword">auto</span> con = client.<span class="built_in">get_connection</span>(<span class="string">&quot;ws://example.com&quot;</span>, ec);</span><br><span class="line">    client.<span class="built_in">connect</span>(con);</span><br><span class="line">    client.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>TCP通信</strong>（C++ socket编程）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server.sin_addr);</span><br><span class="line">    <span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;server, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="comment">// 发送/接收数据</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>TCP</strong>是底层传输协议，提供可靠数据传输，HTTP和WebSocket依赖它。</li>
<li><strong>HTTP</strong>适合基于请求-响应的Web应用，无状态，实时性较差。</li>
<li><strong>WebSocket</strong>适合实时、双向通信，效率高但实现复杂。<br>根据应用场景选择合适的协议：HTTP用于传统Web，WebSocket用于实时交互，TCP用于自定义传输需求。</li>
</ul>
<h1 id="WebSocket-协议详解"><a href="#WebSocket-协议详解" class="headerlink" title="WebSocket 协议详解"></a>WebSocket 协议详解</h1><p>WebSocket 是一种基于 TCP 的全双工通信协议，设计用于在客户端和服务器之间建立持久、低延迟的连接，适用于实时应用场景，如聊天、在线游戏、实时数据推送等。以下是对 WebSocket 协议的详细介绍。</p>
<h2 id="1-WebSocket-协议概述"><a href="#1-WebSocket-协议概述" class="headerlink" title="1. WebSocket 协议概述"></a>1. <strong>WebSocket 协议概述</strong></h2><p>WebSocket 协议（定义于 RFC 6455）允许客户端和服务器通过单个 TCP 连接进行双向通信，解决了 HTTP 协议在实时通信中的局限性（如轮询的高延迟和高开销）。其主要特点包括：</p>
<ul>
<li><strong>全双工通信</strong>：客户端和服务器可同时发送和接收消息。</li>
<li><strong>持久连接</strong>：建立后保持连接，直到显式关闭，减少连接建立&#x2F;断开的开销。</li>
<li><strong>低开销</strong>：WebSocket 数据帧头部较小（2-14 字节），相比 HTTP 请求&#x2F;响应更高效。</li>
<li><strong>基于 HTTP 握手</strong>：通过 HTTP&#x2F;1.1 的 Upgrade 机制建立连接，兼容现有 Web 基础设施。</li>
<li><strong>跨域支持</strong>：通过 WebSocket URL（<code>ws://</code> 或 <code>wss://</code>）支持跨域通信。</li>
</ul>
<h2 id="2-WebSocket-协议工作原理"><a href="#2-WebSocket-协议工作原理" class="headerlink" title="2. WebSocket 协议工作原理"></a>2. <strong>WebSocket 协议工作原理</strong></h2><h3 id="2-1-连接建立（握手过程）"><a href="#2-1-连接建立（握手过程）" class="headerlink" title="2.1 连接建立（握手过程）"></a><strong>2.1 连接建立（握手过程）</strong></h3><p>WebSocket 连接通过 HTTP 协议的 Upgrade 机制建立，过程如下：</p>
<ol>
<li><strong>客户端发起握手请求</strong>：<ul>
<li>客户端发送 HTTP GET 请求，包含特定头部：<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Upgrade: websocket</code>：请求协议升级。</li>
<li><code>Connection: Upgrade</code>：表示连接需要升级。</li>
<li><code>Sec-WebSocket-Key</code>：随机生成的 base64 编码字符串，用于握手验证。</li>
<li><code>Sec-WebSocket-Version</code>：指定 WebSocket 协议版本（通常为 13）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器响应</strong>：<ul>
<li>服务器验证请求，返回 HTTP 101 状态码，表示协议切换：<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Sec-WebSocket-Accept</code>：由服务器基于客户端的 <code>Sec-WebSocket-Key</code> 计算生成（算法：对 <code>Sec-WebSocket-Key</code> 拼接固定 GUID，计算 SHA-1 哈希并 base64 编码）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>连接建立</strong>：<ul>
<li>握手完成后，连接升级为 WebSocket 协议，双方可通过该连接发送数据帧。</li>
</ul>
</li>
</ol>
<h3 id="2-2-数据传输"><a href="#2-2-数据传输" class="headerlink" title="2.2 数据传输"></a><strong>2.2 数据传输</strong></h3><ul>
<li><p>WebSocket 使用<strong>数据帧</strong>传输消息，支持文本（UTF-8）和二进制数据。</p>
</li>
<li><p><strong>掩码机制</strong>：</p>
<ul>
<li>客户端发送的数据需使用掩码（随机 4 字节）对负载进行 XOR 加密，防止恶意脚本攻击代理服务器。</li>
<li>服务器发送的数据通常不需掩码。</li>
</ul>
</li>
</ul>
<h3 id="2-3-连接关闭"><a href="#2-3-连接关闭" class="headerlink" title="2.3 连接关闭"></a><strong>2.3 连接关闭</strong></h3><ul>
<li>关闭连接通过发送 <strong>Close 帧</strong>（Opcode &#x3D; 0x8）完成，包含关闭状态码和可选原因。</li>
<li>状态码示例：<ul>
<li>1000：正常关闭。</li>
<li>1001：一方离开（如页面关闭）。</li>
<li>1002：协议错误。</li>
</ul>
</li>
<li>双方关闭连接后，TCP 连接断开。</li>
</ul>
<h2 id="3-WebSocket-与-HTTP-的对比"><a href="#3-WebSocket-与-HTTP-的对比" class="headerlink" title="3. WebSocket 与 HTTP 的对比"></a>3. <strong>WebSocket 与 HTTP 的对比</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>WebSocket</th>
<th>HTTP&#x2F;1.1</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信方式</strong></td>
<td>全双工，持久连接</td>
<td>半双工，请求-响应模型</td>
</tr>
<tr>
<td><strong>协议开销</strong></td>
<td>低（帧头部 2-14 字节）</td>
<td>高（每次请求包含完整 HTTP 头部）</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>高，适合实时应用</td>
<td>低，需轮询或长轮询实现实时</td>
</tr>
<tr>
<td><strong>连接管理</strong></td>
<td>单次握手，长期保持</td>
<td>每次请求需新建连接（除 Keep-Alive）</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>聊天、实时通知、游戏</td>
<td>网页加载、API 请求</td>
</tr>
</tbody></table>
<h2 id="4-WebSocket-的优势与局限性"><a href="#4-WebSocket-的优势与局限性" class="headerlink" title="4. WebSocket 的优势与局限性"></a>4. <strong>WebSocket 的优势与局限性</strong></h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h3><ul>
<li><strong>低延迟</strong>：持久连接避免了 HTTP 轮询的延迟。</li>
<li><strong>高效</strong>：数据帧头部小，减少网络开销。</li>
<li><strong>双向通信</strong>：支持服务器主动推送消息。</li>
<li><strong>跨平台</strong>：广泛支持于浏览器、服务器和移动端。</li>
</ul>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a><strong>局限性</strong></h3><ul>
<li><strong>复杂性</strong>：需要服务器支持 WebSocket 协议，握手和帧处理较复杂。</li>
<li><strong>资源占用</strong>：持久连接可能增加服务器资源消耗。</li>
<li><strong>代理兼容性</strong>：某些代理服务器可能不支持 WebSocket 或需要额外配置。</li>
<li><strong>安全性</strong>：需使用 <code>wss://</code>（TLS 加密）确保数据安全。</li>
</ul>
<h2 id="6-典型应用场景"><a href="#6-典型应用场景" class="headerlink" title="6. 典型应用场景"></a>6. <strong>典型应用场景</strong></h2><ul>
<li><strong>实时聊天</strong>：如 WhatsApp、Slack。</li>
<li><strong>实时数据推送</strong>：股票价格更新、通知系统。</li>
<li><strong>在线游戏</strong>：多人游戏的状态同步。</li>
<li><strong>协同编辑</strong>：如 Google Docs 的实时协作。</li>
<li><strong>物联网</strong>：设备与服务器的实时通信。</li>
</ul>
<h2 id="7-WebSocket-协议扩展"><a href="#7-WebSocket-协议扩展" class="headerlink" title="7. WebSocket 协议扩展"></a>7. <strong>WebSocket 协议扩展</strong></h2><ul>
<li><strong>子协议</strong>：握手时可通过 <code>Sec-WebSocket-Protocol</code> 指定子协议（如 <code>chat</code>、<code>mqtt</code>）。</li>
<li><strong>扩展</strong>：通过 <code>Sec-WebSocket-Extensions</code> 支持数据压缩（如 <code>permessage-deflate</code>）。</li>
<li><strong>心跳机制</strong>：使用 Ping&#x2F;Pong 帧（Opcode 0x9&#x2F;0xA）保持连接活跃。</li>
</ul>
<h2 id="8-安全性考虑"><a href="#8-安全性考虑" class="headerlink" title="8. 安全性考虑"></a>8. <strong>安全性考虑</strong></h2><ul>
<li>使用 <code>wss://</code>（WebSocket over TLS）加密通信，防止中间人攻击。</li>
<li>验证 <code>Origin</code> 头部，防止未经授权的跨域连接。</li>
<li>实现适当的认证机制（如 token）以验证客户端身份。</li>
<li>限制连接数量，避免资源耗尽。</li>
</ul>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. <strong>总结</strong></h2><ul>
<li><strong>WebSocket 协议</strong>：基于 TCP 的全双工通信协议，通过 HTTP 握手建立，适合实时、低延迟应用。</li>
<li><strong>核心机制</strong>：握手建立连接，数据帧传输消息，支持文本和二进制数据。</li>
<li><strong>优势</strong>：高效、双向、实时，广泛应用于聊天、游戏、数据推送等场景。</li>
<li><strong>实现</strong>：客户端通过浏览器 API（如 JavaScript 的 WebSocket），服务器通过支持 WebSocket 的框架（如 Node.js 的 <code>ws</code>、Python 的 <code>websockets</code>）。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>http/https</title>
    <url>/2025/06/24/http-https/</url>
    <content><![CDATA[<p> HTTP（超文本传输协议）作为Web通信的核心协议，具有简单，灵活易于扩展，无状态，明文传输，不安全的特点。</p>
<p>简单：基本报文格式是head+body的形式，头部信息也是key-value的简单文本形式，易于理解。</p>
<p>灵活和易于扩展：http工作在第七层应用层，https在http和tcp之间加入了ssl&#x2F;tls的安全传输层，http把tcp换成了udp</p>
<hr>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a><strong>HTTP&#x2F;1.0</strong></h3><p><strong>新机制</strong>：</p>
<ul>
<li><strong>基本请求-响应模型</strong>：HTTP&#x2F;1.0定义了客户端向服务器发送请求并接收响应的基本机制，支持GET、POST和HEAD方法。</li>
<li><strong>头部字段</strong>：引入了请求和响应的头部字段（如Content-Type、Content-Length），用于传递元数据。</li>
<li><strong>状态码</strong>：定义了状态码（如200 OK、404 Not Found）来表示请求的结果。</li>
<li><strong>单次连接</strong>：每个请求-响应对使用一个新的TCP连接。</li>
</ul>
<p><strong>解决的问题</strong>：</p>
<ul>
<li>提供了标准化的Web通信协议，使浏览器和服务器能够以统一的方式交换超文本数据。</li>
<li>支持基本的HTML文档传输，奠定了Web发展的基础。</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>性能瓶颈</strong>：每次请求都需要建立和关闭TCP连接，导致高延迟和高开销（TCP三次握手和慢启动）。</li>
<li><strong>无持久连接</strong>：无法复用连接，效率低下，尤其是在加载包含多个资源的页面时。</li>
<li><strong>头部冗余</strong>：头部信息以纯文本传输，每次请求重复发送相同的头部数据，增加了带宽消耗。</li>
<li><strong>有限的功能</strong>：不支持复杂的功能，如缓存控制、内容协商或压缩。</li>
</ul>
<hr>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a><strong>HTTP&#x2F;1.1</strong></h3><p><strong>新机制</strong>：</p>
<ul>
<li><strong>持久连接（Keep-Alive）</strong>：引入了Connection: Keep-Alive头部，允许在单个TCP连接上处理多个请求-响应对，减少连接建立的开销。</li>
<li><strong>管道化（Pipelining）</strong>：支持客户端在不等待响应的情况下连续发送多个请求，进一步减少延迟。</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>队头阻塞（HOL Blocking）</strong>：尽管支持管道化，但响应仍需按请求顺序返回，如果某个响应延迟，会阻塞后续响应。只解决了发送的队头响应问题，没有解决接收的队头阻塞</li>
<li><strong>管道化限制</strong>：管道化实现复杂，浏览器支持不一致，实际使用较少。</li>
<li><strong>头部冗余</strong>：头部仍以纯文本传输，未压缩，增加了带宽消耗。</li>
<li><strong>明文传输</strong>：HTTP&#x2F;1.1默认不加密，存在安全隐患（如数据窃听和篡改）。</li>
</ul>
<hr>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a><strong>HTTP&#x2F;2</strong></h3><p><strong>新机制</strong>：</p>
<ul>
<li><strong>二进制帧</strong>：将HTTP消息分为二进制帧（headers帧和data帧），取代了HTTP&#x2F;1.x的文本格式，解析更高效。</li>
<li><strong>多路复用</strong>：在单个TCP连接上并行处理多个请求和响应，帧可以交错传输，消除了队头阻塞。</li>
<li><strong>头部压缩（HPACK）</strong>：使用专门的HPACK算法压缩头部，减少冗余数据传输。</li>
<li><strong>服务器推送（Server Push）</strong>：服务器可主动推送客户端可能需要的资源（如CSS、JS文件），无需等待客户端请求。</li>
<li><strong>流优先级</strong>：允许客户端指定流的优先级，优化资源加载顺序。</li>
<li><strong>流量控制</strong>：通过窗口机制控制数据传输，防止过载。</li>
</ul>
<p><strong>解决的问题</strong>：</p>
<ul>
<li><strong>队头阻塞</strong>：多路复用允许并行处理请求和响应，显著降低延迟。</li>
<li><strong>带宽效率</strong>：头部压缩减少了元数据的传输开销，特别适合频繁的小请求。</li>
<li><strong>页面加载速度</strong>：服务器推送和优先级机制优化了资源加载，改善了用户体验。</li>
<li><strong>解析效率</strong>：二进制格式比文本格式更易于解析，减少了处理开销。</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>TCP队头阻塞</strong>：虽然HTTP&#x2F;2解决了应用层的队头阻塞，但TCP层的队头阻塞依然存在（丢包会导致整个连接暂停）。</li>
<li><strong>复杂性</strong>：二进制协议和多路复用增加了实现和调试的复杂性。</li>
<li><strong>依赖单一TCP连接</strong>：单个TCP连接的丢包或延迟会影响所有流，缺乏连接级并行性。</li>
<li><strong>仍需TLS</strong>：HTTP&#x2F;2通常与TLS一起使用，增加了握手延迟和计算开销。</li>
</ul>
<hr>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a><strong>HTTP&#x2F;3</strong></h3><p><strong>新机制</strong>：</p>
<ul>
<li><strong>基于QUIC协议</strong>：HTTP&#x2F;3使用QUIC（基于UDP的协议）替代TCP，QUIC集成了传输层和加密功能。</li>
<li><strong>独立流控制</strong>：QUIC的每个流独立传输，解决了TCP的队头阻塞问题（一个流的丢包不影响其他流）。</li>
<li><strong>更快连接建立</strong>：QUIC将TLS握手与传输层握手合并，0-RTT（零往返时间）连接可重用会话数据，减少延迟。</li>
<li><strong>连接迁移</strong>：QUIC使用连接ID而非IP地址和端口，支持网络切换（如Wi-Fi到移动网络）而不中断连接。</li>
<li><strong>改进的拥塞控制</strong>：QUIC提供更灵活的拥塞控制算法，适应不同的网络环境。</li>
<li><strong>加密默认</strong>：QUIC内置TLS 1.3，数据传输始终加密。</li>
</ul>
<p><strong>解决的问题</strong>：</p>
<ul>
<li><strong>TCP队头阻塞</strong>：QUIC的独立流机制确保一个流的丢包不影响其他流，提升了性能。</li>
<li><strong>连接延迟</strong>：0-RTT和合并握手显著减少了连接建立时间，特别是在移动网络中。</li>
<li><strong>网络切换</strong>：连接迁移支持无缝切换网络，适合移动设备场景。</li>
<li><strong>安全性</strong>：内置加密提高了数据传输的安全性，减少了中间人攻击的风险。</li>
<li><strong>适应性</strong>：改进的拥塞控制算法更好地适应不稳定的网络环境。</li>
</ul>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>部署复杂性</strong>：QUIC基于UDP，部分网络环境可能阻止UDP流量（如防火墙或NAT限制）。</li>
<li><strong>兼容性</strong>：HTTP&#x2F;3需要服务器和客户端都支持QUIC，普及仍需时间。</li>
<li><strong>CPU开销</strong>：QUIC的加密和流管理增加了计算开销，尤其在高负载场景下。</li>
<li><strong>不成熟的生态</strong>：工具和中间件的支持（如调试工具、代理服务器）尚未完全成熟。</li>
<li><strong>带宽竞争</strong>：多路复用可能导致流之间的带宽竞争，尤其在低带宽网络中。</li>
</ul>
<hr>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><strong>总结对比</strong></h3><table>
<thead>
<tr>
<th>版本</th>
<th>核心机制</th>
<th>解决的问题</th>
<th>仍存在的问题</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP&#x2F;1.0</strong></td>
<td>基本请求-响应、头部字段、状态码</td>
<td>标准化Web通信</td>
<td>性能差、无持久连接、功能有限</td>
</tr>
<tr>
<td><strong>HTTP&#x2F;1.1</strong></td>
<td>持久连接、管道化、分块传输、缓存</td>
<td>连接效率、动态内容、缓存优化</td>
<td>队头阻塞、头部冗余、不安全</td>
</tr>
<tr>
<td><strong>HTTP&#x2F;2</strong></td>
<td>二进制分帧、多路复用、头部压缩、推送</td>
<td>应用层队头阻塞、带宽效率、加载速度</td>
<td>TCP队头阻塞、复杂性、依赖TLS</td>
</tr>
<tr>
<td><strong>HTTP&#x2F;3</strong></td>
<td>QUIC、独立流、0-RTT、连接迁移</td>
<td>TCP队头阻塞、连接延迟、安全性</td>
<td>部署复杂、兼容性、CPU开销</td>
</tr>
</tbody></table>
<hr>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><strong>补充说明</strong></h3><ul>
<li><strong>演进趋势</strong>：HTTP从简单的文本协议发展为高效、安全的二进制协议，逐步解决了延迟、效率和安全问题，适应了现代Web的复杂需求（如低延迟、高并发、移动场景）。</li>
<li><strong>权衡</strong>：每代协议在引入新功能的同时也带来了新的复杂性，开发者需在性能和实现成本之间权衡。</li>
<li><strong>未来方向</strong>：HTTP&#x2F;3仍在推广中，未来可能进一步优化QUIC的性能，解决UDP兼容性问题，并增强对边缘计算和物联网的支持。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>if contexpr和decltype</title>
    <url>/2025/09/23/if-contexpr%E5%92%8Cdecltype/</url>
    <content><![CDATA[<h3 id="1-if-constexpr-C-17"><a href="#1-if-constexpr-C-17" class="headerlink" title="1. if constexpr (C++17)"></a>1. <code>if constexpr</code> (C++17)</h3><p><code>if constexpr</code> 是 C++17 引入的一种<strong>编译期条件语句</strong>。它与普通的 <code>if</code> 语句不同，普通的 <code>if</code> 语句是在运行时评估条件，并根据结果执行相应的代码块。而 <code>if constexpr</code> 的条件必须是一个<strong>常量表达式</strong>，并且在<strong>编译时</strong>进行评估。</p>
<p><strong>核心思想：</strong><br><code>if constexpr</code> 的主要目的是在编译时根据条件<strong>选择性地编译代码路径</strong>。这意味着不满足条件的 <code>if constexpr</code> 分支在编译时会被完全丢弃，不会参与到最终的可执行文件中。这对于模板编程来说非常有用，因为它允许我们根据模板参数的特性（例如，是否是某个类型，是否支持某个操作）来生成不同的代码。</p>
<p><strong>语法：</strong><br><code>if constexpr (constant_expression)</code></p>
<p><strong>为什么需要 <code>if constexpr</code>？</strong><br>在 C++17 之前，为了实现编译期条件选择，我们通常需要使用模板特化、SFINAE (Substitution Failure Is Not An Error) 或标签分发等技术，这些方法往往比较复杂和冗长。<code>if constexpr</code> 提供了一种更简洁、更直观的方式来完成同样的事情。</p>
<p><strong>使用场景：</strong></p>
<ol>
<li><p><strong>根据类型特性选择实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// 用于 std::is_integral, std::is_floating_point</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123; <span class="comment">// 如果 T 是整数类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing integral: &quot;</span> &lt;&lt; value * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_floating_point_v&lt;T&gt;) &#123; <span class="comment">// 如果 T 是浮点类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing floating point: &quot;</span> &lt;&lt; value * <span class="number">1.5</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Processing unknown type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(<span class="number">10</span>);       <span class="comment">// 调用第一个分支</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="number">3.14</span>);     <span class="comment">// 调用第二个分支</span></span><br><span class="line">    <span class="built_in">process</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 调用第三个分支</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当 <code>T</code> 是 <code>int</code> 时，只有 <code>std::cout &lt;&lt; &quot;Processing integral: &quot; &lt;&lt; value * 2 &lt;&lt; std::endl;</code> 这一行会被编译到 <code>process&lt;int&gt;</code> 的实现中。其他分支的代码会被编译器完全忽略。</p>
</li>
<li><p><strong>避免编译错误：</strong><br>当某些操作只对特定类型有效时，<code>if constexpr</code> 可以避免在不适用的类型上尝试编译这些操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_size</span><span class="params">(<span class="type">const</span> T&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_arithmetic_v&lt;T&gt;)</span> </span>&#123; <span class="comment">// 如果是算术类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Arithmetic type, value: &quot;</span> &lt;&lt; obj &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="keyword">requires</span> &#123; obj.<span class="built_in">size</span>(); &#125;) &#123; <span class="comment">// C++20 concept-like syntax for checking if .size() exists</span></span><br><span class="line">        <span class="comment">// C++17 之前可能用 SFINAE 或 std::void_t 来检查</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type with .size() method, size: &quot;</span> &lt;&lt; obj.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type without .size() method, cannot determine size.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_size</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">print_size</span>(std::<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="built_in">print_size</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    <span class="built_in">print_size</span>(<span class="literal">true</span>); <span class="comment">// bool 也是算术类型</span></span><br><span class="line">    <span class="comment">// print_size(nullptr); // 会走到 else 分支</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果 <code>T</code> 是 <code>int</code>，编译器不会尝试编译 <code>obj.size()</code>，从而避免了编译错误。</p>
</li>
</ol>
<p><strong>与普通 <code>if</code> 的区别：</strong></p>
<ul>
<li><strong>编译期 vs 运行时：</strong> <code>if constexpr</code> 在编译期决定执行哪个分支，不执行的分支不会被编译；普通 <code>if</code> 在运行时决定。</li>
<li><strong>条件要求：</strong> <code>if constexpr</code> 的条件必须是常量表达式；普通 <code>if</code> 的条件可以是任何可转换为 <code>bool</code> 的表达式。</li>
<li><strong>代码生成：</strong> <code>if constexpr</code> 导致不同的代码生成路径；普通 <code>if</code> 生成包含所有分支的运行时条件跳转代码。</li>
<li><strong>适用场景：</strong> <code>if constexpr</code> 主要用于模板元编程和泛型编程，根据类型特性生成特化的代码；普通 <code>if</code> 用于运行时逻辑控制。</li>
</ul>
<h3 id="2-decltype-C-11"><a href="#2-decltype-C-11" class="headerlink" title="2. decltype (C++11)"></a>2. <code>decltype</code> (C++11)</h3><p><code>decltype</code> 是 C++11 引入的一个关键字，用于<strong>推断表达式的类型</strong>。它在编译时评估其操作数，并返回该表达式的类型，而<strong>不实际执行</strong>该表达式。</p>
<p><strong>核心思想：</strong><br><code>decltype</code> 的主要用途是获取一个表达式的精确类型，包括其引用性（lvalue&#x2F;rvalue reference）和常量性（const&#x2F;volatile）。这在泛型编程中非常有用，例如在编写一个函数模板时，我们可能需要根据其参数的类型来推断返回类型。</p>
<p><strong>语法：</strong><br><code>decltype(expression)</code></p>
<p><strong>使用场景：</strong></p>
<ol>
<li><p><strong>推断函数返回类型 (Trailing Return Type)：</strong><br>在 C++11 之前，如果函数的返回类型依赖于其参数的类型，特别是当参数是模板类型时，很难直接指定返回类型。<code>decltype</code> 与 C++11 的尾置返回类型语法结合，解决了这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123; <span class="comment">// 返回 t + u 的类型</span></span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">add</span>(a, b); <span class="comment">// result 的类型是 double</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;, type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(result).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取变量的精确类型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">decltype</span>(x) a = <span class="number">20</span>;       <span class="comment">// a 是 int</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = x;        <span class="comment">// b 是 const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(std::<span class="built_in">move</span>(x)) c = <span class="number">30</span>; <span class="comment">// c 是 int&amp;&amp; (xvalue)</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) d = x;      <span class="comment">// d 是 int&amp; (因为 (x) 是一个左值表达式)</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;type of a: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;type of b: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;type of c: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;type of d: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p><strong>注意 <code>decltype((x))</code> 和 <code>decltype(x)</code> 的区别：</strong></p>
<ul>
<li><code>decltype(variable)</code>：如果操作数是一个没有括号的变量名，<code>decltype</code> 返回该变量的声明类型。</li>
<li><code>decltype((expression))</code>：如果操作数是任何其他表达式（包括带括号的变量名），<code>decltype</code> 返回该表达式的<strong>值类别</strong>（value category）对应的类型。如果表达式是左值，则返回 <code>T&amp;</code>；如果表达式是右值，则返回 <code>T&amp;&amp;</code>。</li>
</ul>
</li>
<li><p><strong>在模板中获取成员类型或嵌套类型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_first_element_type</span><span class="params">(<span class="type">const</span> Container&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取容器中元素的类型</span></span><br><span class="line">    <span class="keyword">using</span> ElementType = <span class="keyword">decltype</span>(*c.<span class="built_in">begin</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(ElementType).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">print_first_element_type</span>(v); <span class="comment">// Element type: i (int)</span></span><br><span class="line"></span><br><span class="line">    std::map&lt;std::string, <span class="type">double</span>&gt; m;</span><br><span class="line">    <span class="built_in">print_first_element_type</span>(m); <span class="comment">// Element type: St4pairIKSt6stringdE (std::pair&lt;const std::string, double&gt;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><code>decltype</code> 的推断规则：</strong></p>
<p><code>decltype(e)</code> 的推断规则比较复杂，但可以简化为：</p>
<ol>
<li>如果 <code>e</code> 是一个<strong>没有括号的变量名</strong>，<code>decltype(e)</code> 的类型就是该变量的声明类型。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) var1; <span class="comment">// var1 是 int</span></span><br></pre></td></tr></table></figure></li>
<li>如果 <code>e</code> 是一个<strong>右值表达式</strong>，<code>decltype(e)</code> 的类型是 <code>T</code>。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="number">10</span>) var2;       <span class="comment">// var2 是 int</span></span><br><span class="line"><span class="keyword">decltype</span>(i + <span class="number">10</span>) var3;   <span class="comment">// var3 是 int</span></span><br></pre></td></tr></table></figure></li>
<li>如果 <code>e</code> 是一个<strong>左值表达式</strong>，<code>decltype(e)</code> 的类型是 <code>T&amp;</code>。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) var4 = i; <span class="comment">// var4 是 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(++i) var5 = i; <span class="comment">// ++i 是左值表达式，var5 是 int&amp;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>if constexpr</code> (C++17)</th>
<th align="left"><code>decltype</code> (C++11)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>功能</strong></td>
<td align="left">编译期条件分支，选择性编译代码</td>
<td align="left">编译期推断表达式的类型</td>
</tr>
<tr>
<td align="left"><strong>作用时机</strong></td>
<td align="left">编译时</td>
<td align="left">编译时</td>
</tr>
<tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left">常量表达式作为条件</td>
<td align="left">任何表达式</td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left">模板元编程，根据类型特性生成不同代码，避免编译错误</td>
<td align="left">泛型编程，推断函数返回类型，获取精确类型，实现类型依赖</td>
</tr>
<tr>
<td align="left"><strong>结果</strong></td>
<td align="left">编译后的代码中只包含满足条件的分支</td>
<td align="left">返回一个类型</td>
</tr>
<tr>
<td align="left"><strong>与普通 <code>if</code></strong></td>
<td align="left">编译期选择，不满足条件的分支不编译</td>
<td align="left">无直接关系</td>
</tr>
</tbody></table>
<p><strong>共同点：</strong></p>
<ul>
<li>两者都是在<strong>编译时</strong>工作的。</li>
<li>两者都极大地增强了 C++ 的<strong>泛型编程能力</strong>，使得编写更灵活、更通用的模板代码成为可能。</li>
</ul>
<p>在现代 C++ 中，<code>if constexpr</code> 和 <code>decltype</code> 常常结合使用，以实现更高级的模板编程技巧。例如，你可以使用 <code>decltype</code> 来推断一个表达式的类型，然后使用 <code>if constexpr</code> 根据这个类型来选择不同的实现路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inspect_and_print</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 decltype 获取表达式的类型</span></span><br><span class="line">    <span class="keyword">using</span> ExprType = <span class="keyword">decltype</span>(val + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;ExprType&gt;)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Expression (val + 1) results in an integral type: &quot;</span> &lt;&lt; val + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_floating_point_v&lt;ExprType&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Expression (val + 1) results in a floating point type: &quot;</span> &lt;&lt; val + <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Expression (val + 1) results in an unknown type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">inspect_and_print</span>(<span class="number">5</span>);     <span class="comment">// ExprType is int</span></span><br><span class="line">    <span class="built_in">inspect_and_print</span>(<span class="number">3.5f</span>);  <span class="comment">// ExprType is float</span></span><br><span class="line">    <span class="comment">// inspect_and_print(std::string(&quot;hello&quot;)); // 编译错误，string + int 不合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子展示了如何结合使用 <code>decltype</code> 推断 <code>val + 1</code> 的类型，然后使用 <code>if constexpr</code> 根据推断出的类型选择不同的打印行为。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++17</tag>
      </tags>
  </entry>
  <entry>
    <title>inline内联函数的使用</title>
    <url>/2025/04/28/inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>又是好久没有更新了，家人们，主播最近写完了c++的几个轮子项目，工程能力有了一内内的提高，现在在准备八股，希望暑假or大三能找到一个满意的实习吧（虽然就目前来看，c++全是劝退，我真服了，后悔没有选java了，后面主播慢慢转go吧）</p>
<p>在C++中，<code>inline</code> 关键字主要用于定义内联函数，具有以下两个主要作用：</p>
<ol>
<li><p><strong>优化性能</strong>：<br>使用 <code>inline</code> 修饰的函数，建议编译器在调用该函数时，将函数体的代码直接插入到调用点。</p>
<p>相比正常的函数调用过程：寄存器保存，参数压栈，跳转到函数地址，执行函数体，返回并恢复寄存器</p>
<p>这可以减少函数调用的开销，尤其适用于小型、频繁调用的函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>square(5)</code> 时，编译器可能将代码替换为 <code>5 * 5</code>，避免函数调用开销。<br><strong>注意</strong>：<code>inline</code> 只是建议，编译器可能忽略它，尤其在以下情况下：</p>
<ul>
<li>函数体过大</li>
<li>函数包含循环、递归、静态变量、switch 或 goto 语句</li>
<li>函数地址被取用（如通过函数指针）</li>
</ul>
</li>
<li><p><strong>允许多个定义</strong>：<br><code>inline</code> 函数可以在头文件中定义，并被多个编译单元（.cpp 文件）包含，而不会导致链接错误（违反“单一定义规则”）。这是因为 <code>inline</code> 函数允许多个相同的定义，链接器会选择一个定义并丢弃其他重复定义。<br>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure>

<p>多个 .cpp 文件包含此头文件时，不会引发重定义错误。</p>
</li>
</ol>
<p>看到第二个作用，主播不禁想到了自己在项目开发的过程中，hpp文件那是嘎嘎重复被cpp文件使用啊（虽然有#program once）,而头文件中的类中难免有一些成员函数是直接定义在类里面的，那为什么没有事呢。</p>
<p>（正常情况下，函数只能在头文件中声明,而不能在头文件中定义）</p>
<h3 id="1-类内函数的内联特性"><a href="#1-类内函数的内联特性" class="headerlink" title="1. 类内函数的内联特性"></a>1. 类内函数的内联特性</h3><ul>
<li><p><strong>隐式内联</strong>：</p>
<ul>
<li><p>在类定义中<strong>直接定义</strong>的成员函数（包括普通成员函数、构造函数、析构函数等）<strong>默认是 <code>inline</code> 函数</strong>，无需显式使用 <code>inline</code> 关键字。</p>
</li>
<li><p>这是 C++ 标准规定的行为，原因是为了方便在头文件中定义类时，允许函数体直接嵌入类定义，而不会违反单一定义规则（ODR）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myclass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 隐式内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getValue</code> 的定义在类体内，自动视为 <code>inline</code>，可以在头文件中安全使用，多个 <code>.cpp</code> 文件包含时不会导致多重定义错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>**显式 <code>inline</code>**：</p>
<ul>
<li><p>如果成员函数在类内仅<strong>声明</strong>，在类外定义，则需要显式使用 <code>inline</code> 关键字来指定内联行为，否则它将是普通函数（非内联）。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myclass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>; <span class="comment">// 仅声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MyClass::getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 显式内联</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在类外定义的 <code>getValue</code> 使用 <code>inline</code>，确保它可以在头文件中定义，且允许多个翻译单元使用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>效果</strong>：</p>
<ul>
<li>无论是隐式还是显式内联，编译器可能将函数体直接插入调用点，减少调用开销。</li>
<li>链接器会处理多份定义，确保符合 ODR。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-类内-inline-函数的实际作用"><a href="#2-类内-inline-函数的实际作用" class="headerlink" title="2. 类内 inline 函数的实际作用"></a>2. 类内 <code>inline</code> 函数的实际作用</h3><p>类内 <code>inline</code> 函数的作用与普通 <code>inline</code> 函数一致，主要包括：</p>
<ul>
<li><p>性能优化</p>
<p>：</p>
<ul>
<li><p>适合小型、频繁调用的成员函数（如 getter&#x2F;setter、状态检查）。</p>
</li>
<li><p>在嵌入式系统中，内联可以减少函数调用开销，优化实时性能。例如，在 FreeRTOS 中，检查任务状态的函数可以定义为内联：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaskRunning</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> taskState == RUNNING; &#125; <span class="comment">// 隐式内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskState taskState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>允许多定义</p>
<p>：</p>
<ul>
<li><p>类定义通常放在头文件中，隐式或显式内联的成员函数允许在多个 <code>.cpp</code> 文件中包含头文件，而不会导致链接错误。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// task.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">()</span> </span>&#123; counter++; &#125; <span class="comment">// 隐式内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123; Task t; t.<span class="built_in">incrementCounter</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123; Task t; t.<span class="built_in">incrementCounter</span>(); &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>incrementCounter</code> 是隐式内联，多个源文件包含 <code>task.h</code> 不会报错。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>接下来是inline函数的使用注意事项</p>
<ul>
<li>不能存在任何形式的循环语句</li>
<li>不能存在过多的条件判断语句</li>
<li>函数体不能过于庞大</li>
<li>内联函数声明必须存在于调用语句之前</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>inline</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>kahn算法实现拓扑排序</title>
    <url>/2024/10/21/kahn%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1-拓扑排序（Topological-Sorting）是什么？"><a href="#1-拓扑排序（Topological-Sorting）是什么？" class="headerlink" title="1. 拓扑排序（Topological Sorting）是什么？"></a>1. <strong>拓扑排序</strong>（Topological Sorting）是什么？</h3><p><strong>拓扑排序</strong>是一种用于 <strong>有向无环图</strong>（DAG, Directed Acyclic Graph） 的节点排序算法。它的目标是将图中的所有节点排成一个 <strong>线性序列</strong>，使得对于图中每一条从节点 <code>u</code> 到节点 <code>v</code> 的有向边 <code>u -&gt; v</code>，在排序中节点 <code>u</code> 都排在节点 <code>v</code> 的前面。</p>
<p><strong>简单来说</strong>，如果图中有一条边 <code>u -&gt; v</code>，那么在拓扑排序中，节点 <code>u</code> 必须排在节点 <code>v</code> 的前面。这个排序是图中所有节点的线性排列，并且保证了这种有向依赖关系。</p>
<h3 id="2-拓扑序列是什么？"><a href="#2-拓扑序列是什么？" class="headerlink" title="2. 拓扑序列是什么？"></a>2. <strong>拓扑序列</strong>是什么？</h3><p><strong>拓扑序列</strong>是拓扑排序的结果，即节点的一个线性排列，满足上述的依赖关系。对于给定的有向无环图，可能存在多个不同的拓扑序列，只要它们满足图中所有边的依赖关系。</p>
<h3 id="3-拓扑排序的应用场景"><a href="#3-拓扑排序的应用场景" class="headerlink" title="3. 拓扑排序的应用场景"></a>3. <strong>拓扑排序的应用场景</strong></h3><p>拓扑排序通常用于需要考虑依赖关系的场景，比如：</p>
<ul>
<li><strong>任务调度</strong>：例如，某些任务需要在其他任务完成后才能开始工作，可以将任务的依赖关系表示为有向无环图，通过拓扑排序确定任务的执行顺序。</li>
<li><strong>课程安排</strong>：如果某些课程有先修课要求，可以用拓扑排序来安排课程学习的顺序。</li>
<li><strong>构建系统</strong>：如果某些模块需要依赖其他模块编译，可以通过拓扑排序决定编译顺序。</li>
</ul>
<h3 id="4-如何进行拓扑排序？"><a href="#4-如何进行拓扑排序？" class="headerlink" title="4. 如何进行拓扑排序？"></a>4. <strong>如何进行拓扑排序？</strong></h3><p>有多种算法可以实现拓扑排序，最常用的有以下两种：</p>
<h4 id="（1）Kahn算法（基于入度的算法）"><a href="#（1）Kahn算法（基于入度的算法）" class="headerlink" title="（1）Kahn算法（基于入度的算法）"></a>（1）<strong>Kahn算法</strong>（基于入度的算法）</h4><ul>
<li><p><strong>思路</strong>：</p>
<ul>
<li>找到所有 <strong>入度为0</strong> 的节点（即没有任何节点指向它们的节点）。</li>
<li>将这些节点从图中移除，并将它们的邻接节点的入度减1。</li>
<li>如果某个邻接节点的入度减为0，将它也加入排序序列中。</li>
<li>重复该过程，直到所有节点都被处理。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>计算图中每个节点的 <strong>入度</strong>（指向该节点的边的数量）。</li>
<li>将所有 <strong>入度为0</strong> 的节点加入队列。</li>
<li>从队列中取出一个节点，加入拓扑序列，并将该节点的邻接节点入度减1。</li>
<li>如果某个邻接节点的入度变为0，将其加入队列。</li>
<li>重复步骤3和4，直到队列为空。如果此时拓扑序列包含了所有节点，则排序成功；否则，说明图中存在环，无法进行拓扑排序。</li>
</ol>
</li>
<li><p><strong>Kahn算法的时间复杂度</strong>：<code>O(V + E)</code>，其中 <code>V</code> 是节点数，<code>E</code> 是边数。</p>
</li>
</ul>
<h4 id="（2）深度优先搜索（DFS）法"><a href="#（2）深度优先搜索（DFS）法" class="headerlink" title="（2）深度优先搜索（DFS）法"></a>（2）<strong>深度优先搜索（DFS）法</strong></h4><ul>
<li><p><strong>思路</strong>：</p>
<ul>
<li>对图进行 <strong>DFS</strong> 遍历，在每次访问完成一个节点的所有邻接节点后，将该节点加入一个栈。</li>
<li>当所有节点都被访问完后，栈中的节点顺序即为拓扑排序的逆序。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>对图中的每个未访问的节点执行 DFS。</li>
<li>当遍历到某个节点时，先递归访问它的所有邻接节点（即访问所有依赖它的节点）。</li>
<li>在访问完所有邻接节点后，将该节点加入栈。</li>
<li>最后栈中节点的顺序就是拓扑序列。</li>
</ol>
</li>
<li><p><strong>DFS法的时间复杂度</strong>：<code>O(V + E)</code>，其中 <code>V</code> 是节点数，<code>E</code> 是边数。</p>
</li>
</ul>
<h3 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. <strong>举例说明</strong></h3><h4 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 → 0 ← 4</span><br><span class="line">↓       ↑</span><br><span class="line">2 → 3 → 1</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>有向图</strong> 表示：</p>
<ul>
<li>任务 <code>5</code> 和 <code>4</code> 是任务 <code>0</code> 的前置任务，任务 <code>5</code> 也是任务 <code>2</code> 的前置任务。</li>
<li>任务 <code>2</code> 是任务 <code>3</code> 的前置任务，任务 <code>3</code> 是任务 <code>1</code> 的前置任务。</li>
<li>任务 <code>4</code> 是任务 <code>0</code> 的前置任务。</li>
</ul>
</li>
<li><p><strong>拓扑排序结果</strong>：</p>
<ul>
<li>可能的 <strong>拓扑序列</strong> 为：<code>4, 5, 2, 3, 1, 0</code>。</li>
<li>也可能是：<code>5, 4, 2, 3, 1, 0</code>。</li>
</ul>
</li>
</ul>
<h4 id="Kahn算法实现（队列实现）："><a href="#Kahn算法实现（队列实现）：" class="headerlink" title="Kahn算法实现（队列实现）："></a><strong>Kahn算法实现（队列实现）</strong>：</h4><p>个人理解：将每个入度为0的顶点加入队列，然后依次处理，先加入拓扑序列，将其邻接结点入度减1后再判断是否为0，如果是就加入队列，然后将原节点推出队列，再获取队列第一个，直到队列为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">kahnTopologicalSort</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;  <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="comment">// 邻接表表示的图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList = &#123;</span><br><span class="line">        &#123;&#125;,       <span class="comment">// 节点 0</span></span><br><span class="line">        &#123;<span class="number">0</span>&#125;,      <span class="comment">// 节点 1 指向 0</span></span><br><span class="line">        &#123;<span class="number">3</span>&#125;,      <span class="comment">// 节点 2 指向 3</span></span><br><span class="line">        &#123;<span class="number">1</span>&#125;,      <span class="comment">// 节点 3 指向 1</span></span><br><span class="line">        &#123;<span class="number">0</span>&#125;,      <span class="comment">// 节点 4 指向 0</span></span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>&#125;    <span class="comment">// 节点 5 指向 0 和 2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topoOrder = <span class="built_in">kahnTopologicalSort</span>(n, adjList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查拓扑排序结果</span></span><br><span class="line">    <span class="keyword">if</span> (topoOrder.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拓扑排序结果: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : topoOrder) &#123;</span><br><span class="line">            cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;图中存在环，无法进行拓扑排序。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kahn算法实现</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">kahnTopologicalSort</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// 记录每个节点的入度</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topoOrder;       <span class="comment">// 存储拓扑排序的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[i]) &#123;</span><br><span class="line">            inDegree[neighbor]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">// 用于存放入度为0的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有入度为0的节点加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理队列中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        topoOrder.<span class="built_in">push_back</span>(node);  <span class="comment">// 将节点加入拓扑排序结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的所有邻接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[node]) &#123;</span><br><span class="line">            inDegree[neighbor]--;  <span class="comment">// 将邻接节点的入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (inDegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);  <span class="comment">// 如果邻接节点的入度为0，加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topoOrder;  <span class="comment">// 返回拓扑排序结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-如何判断是否存在拓扑排序？"><a href="#6-如何判断是否存在拓扑排序？" class="headerlink" title="6. 如何判断是否存在拓扑排序？"></a>6. <strong>如何判断是否存在拓扑排序？</strong></h3><p>拓扑排序仅适用于 <strong>有向无环图</strong>（DAG），也就是说图中不能有环。如果图中存在环，则无法进行拓扑排序，因为环中的节点之间存在相互依赖，无法线性排序。因此，在进行拓扑排序的过程中，如果图中存在环，算法将无法处理完所有节点。对于 Kahn 算法而言，如果最终没有处理完所有节点（即队列中还有节点入度不为 0），则说明图中存在环。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>拓扑排序</strong> 是将 <strong>有向无环图（DAG）</strong> 的所有节点按照依赖关系排序的过程。</li>
<li><strong>拓扑序列</strong> 是拓扑排序的结果，满足在图中每条边 <code>u -&gt; v</code> 中，节点 <code>u</code> 必须在节点 <code>v</code> 之前。</li>
<li>常见的拓扑排序算法有 <strong>Kahn算法</strong>（基于入度）和 <strong>DFS算法</strong>。</li>
<li>拓扑排序广泛应用于任务调度、编译依赖等需要考虑顺序依赖的场景。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode心得</title>
    <url>/2024/11/02/leetcode%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>1.对于复杂条件的题，看能不能将条件简化，比如通过排序让题目简单，比如去掉多余空格，让后序算法简化操作</p>
<p>2.双指针对于局部的变化有奇效</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>mutex底层原理</title>
    <url>/2025/09/26/mutex%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p> <code>std::mutex</code>（互斥锁）是 C++ 中用于实现互斥访问共享资源的关键工具。它的底层原理涉及到操作系统、CPU硬件指令以及内存模型等多个层面。理解这些底层机制对于编写高效、正确的并发程序至关重要。</p>
<h3 id="1-为什么需要-Mutex？"><a href="#1-为什么需要-Mutex？" class="headerlink" title="1. 为什么需要 Mutex？"></a>1. 为什么需要 Mutex？</h3><p>在多线程环境中，当多个线程尝试同时访问和修改同一个共享资源（如变量、数据结构、文件等）时，如果没有适当的同步机制，就可能发生**竞态条件 (Race Condition)**，导致数据损坏或程序行为不可预测。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 这不是一个原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个线程同时调用 increment()，counter 的最终值可能不是 200000</span></span><br></pre></td></tr></table></figure>
<p><code>counter++</code> 表面上是一行代码，但在 CPU 层面可能被分解为以下步骤：</p>
<ol>
<li>读取 <code>counter</code> 的当前值到寄存器。</li>
<li>寄存器中的值加 1。</li>
<li>将寄存器中的新值写回 <code>counter</code>。</li>
</ol>
<p>如果两个线程同时执行这些步骤，就可能出现以下情况：</p>
<ul>
<li>线程 A 读取 <code>counter</code> (0)。</li>
<li>线程 B 读取 <code>counter</code> (0)。</li>
<li>线程 A 将寄存器中的值加 1 (1)。</li>
<li>线程 B 将寄存器中的值加 1 (1)。</li>
<li>线程 A 将 1 写回 <code>counter</code>。</li>
<li>线程 B 将 1 写回 <code>counter</code>。<br>最终 <code>counter</code> 的值是 1，而不是 2。</li>
</ul>
<p>Mutex 的作用就是确保在任何给定时刻，只有一个线程能够进入**临界区 (Critical Section)**，即访问共享资源的代码段。</p>
<h3 id="2-Mutex-的核心思想"><a href="#2-Mutex-的核心思想" class="headerlink" title="2. Mutex 的核心思想"></a>2. Mutex 的核心思想</h3><p>Mutex 可以被想象成一个房间的钥匙。</p>
<ul>
<li>当一个线程想要进入房间（临界区）时，它必须先拿到钥匙（调用 <code>lock()</code>）。</li>
<li>如果钥匙已经被其他线程拿走，当前线程就必须在门外等待。</li>
<li>当持有钥匙的线程离开房间（临界区）时，它会归还钥匙（调用 <code>unlock()</code>）。</li>
<li>等待的线程中会有一个被选中（通常是第一个等待的），拿到钥匙并进入房间。</li>
</ul>
<h3 id="3-底层原理：原子操作-Atomic-Operations"><a href="#3-底层原理：原子操作-Atomic-Operations" class="headerlink" title="3. 底层原理：原子操作 (Atomic Operations)"></a>3. 底层原理：原子操作 (Atomic Operations)</h3><p>Mutex 的实现本身也需要防止竞态条件。如果 <code>lock()</code> 和 <code>unlock()</code> 操作不是原子的，那么两个线程可能同时认为自己获得了锁。因此，Mutex 的最底层依赖于 CPU 提供的<strong>原子指令</strong>。</p>
<p>原子指令是指在执行过程中不会被中断的 CPU 指令。即使在多核处理器上，这些指令也能保证其操作的完整性。</p>
<p>常见的原子指令有：</p>
<ul>
<li><p><strong>Test-and-Set (TAS) &#x2F; Test-and-Set-Lock (TSL):</strong></p>
<ul>
<li>读取一个内存位置的值，将其设置为 1（或 true），并返回原始值。</li>
<li>这个“读取-设置-返回”操作是原子的。</li>
<li>如果返回的值是 0（或 false），表示之前是未锁定状态，当前线程成功获取锁。</li>
<li>如果返回的值是 1（或 true），表示之前是锁定状态，当前线程未能获取锁。</li>
</ul>
</li>
<li><p><strong>Compare-and-Swap (CAS) &#x2F; Compare-Exchange (CMPXCHG):</strong></p>
<ul>
<li>更通用的原子操作。</li>
<li>它接收三个参数：一个内存地址 <code>addr</code>，一个期望值 <code>expected</code>，一个新值 <code>new_val</code>。</li>
<li>如果 <code>addr</code> 处的当前值等于 <code>expected</code>，则将 <code>addr</code> 处的值更新为 <code>new_val</code>。</li>
<li>整个操作是原子的，并返回 <code>addr</code> 处操作前的值（或一个布尔值指示是否成功）。</li>
<li>Mutex 可以用 CAS 实现：尝试将锁的状态从 <code>unlocked</code> (0) 变为 <code>locked</code> (1)。如果 CAS 成功，则获取锁。</li>
</ul>
</li>
<li><p><strong>Fetch-and-Add:</strong></p>
<ul>
<li>原子地将一个值加到一个内存位置，并返回原始值。常用于实现原子计数器。</li>
</ul>
</li>
</ul>
<p>这些原子指令是构建所有高级同步原语（包括 Mutex）的基石。</p>
<h3 id="4-两种-Mutex-实现策略"><a href="#4-两种-Mutex-实现策略" class="headerlink" title="4. 两种 Mutex 实现策略"></a>4. 两种 Mutex 实现策略</h3><p>基于原子操作，Mutex 可以主要分为两种实现策略：</p>
<h4 id="4-1-自旋锁-Spinlock"><a href="#4-1-自旋锁-Spinlock" class="headerlink" title="4.1. 自旋锁 (Spinlock)"></a>4.1. 自旋锁 (Spinlock)</h4><p>自旋锁是最简单的 Mutex 实现，它完全基于原子指令。</p>
<p><strong>工作原理：</strong></p>
<ol>
<li>当一个线程尝试获取自旋锁时，它会使用原子指令（如 <code>Test-and-Set</code> 或 <code>CAS</code>）来尝试将锁的状态从“未锁定”变为“锁定”。</li>
<li>如果成功，线程获得锁，进入临界区。</li>
<li>如果失败（锁已经被其他线程持有），当前线程不会放弃 CPU，而是进入一个<strong>忙等待 (Busy-Waiting)</strong> 循环，不断地重复尝试获取锁，直到成功为止。</li>
<li>当线程释放锁时，它会原子地将锁的状态设置为“未锁定”。</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>低开销：</strong> 如果临界区很短，并且线程等待时间很短，自旋锁的开销非常小，因为它避免了上下文切换（从用户态到内核态的切换，以及保存&#x2F;恢复线程状态）。</li>
<li><strong>无上下文切换：</strong> 线程一直在运行，没有被操作系统调度出去。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>浪费 CPU 资源：</strong> 如果临界区很长，或者等待时间较长，忙等待会浪费大量的 CPU 周期，尤其是在单核处理器上，这会非常低效，甚至可能导致死锁（如果持有锁的线程无法运行）。</li>
<li><strong>不公平：</strong> 无法保证等待线程的获取顺序。</li>
</ul>
</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>主要用于操作系统内核中，保护非常短的临界区。</li>
<li>在多核处理器上，当预期锁的持有时间非常短时。</li>
</ul>
<h4 id="4-2-阻塞式互斥锁-Blocking-Mutex"><a href="#4-2-阻塞式互斥锁-Blocking-Mutex" class="headerlink" title="4.2. 阻塞式互斥锁 (Blocking Mutex)"></a>4.2. 阻塞式互斥锁 (Blocking Mutex)</h4><p><code>std::mutex</code> 属于阻塞式互斥锁，它在底层依赖于操作系统的调度机制。</p>
<p><strong>工作原理：</strong></p>
<ol>
<li><strong>尝试获取锁：</strong> 当一个线程调用 <code>lock()</code> 时，它会首先尝试使用原子指令（像自旋锁一样）快速获取锁。</li>
<li><strong>进入等待状态：</strong><ul>
<li>如果锁已经被其他线程持有，当前线程不会忙等待。</li>
<li>它会通知操作系统，表明自己无法继续执行，需要**阻塞 (Block)**。</li>
<li>操作系统会将该线程的状态从“运行”变为“等待”，并将其放入一个与该 Mutex 关联的<strong>等待队列 (Waiting Queue)</strong> 中。</li>
<li>随后，操作系统会进行**上下文切换 (Context Switch)**，将 CPU 调度给另一个准备好运行的线程。</li>
</ul>
</li>
<li><strong>释放锁与唤醒：</strong><ul>
<li>当持有锁的线程调用 <code>unlock()</code> 时，它会原子地将锁的状态设置为“未锁定”。</li>
<li>然后，它会通知操作系统，告知有线程可能在等待这个锁。</li>
<li>操作系统会从该 Mutex 的等待队列中选择一个（或多个）线程，将其状态从“等待”变为“就绪 (Ready-to-Run)”。</li>
<li>这些被唤醒的线程将有机会在未来的某个时刻被调度器选中并重新运行。</li>
</ul>
</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>优点：</strong><ul>
<li><strong>不浪费 CPU 资源：</strong> 当线程无法获取锁时，它会进入睡眠状态，释放 CPU 给其他线程使用。</li>
<li><strong>公平性（可选）：</strong> 操作系统可以实现公平的调度策略，例如先进先出 (FIFO)，确保等待时间最长的线程优先获取锁。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>上下文切换开销：</strong> 阻塞和唤醒线程涉及到用户态到内核态的切换，以及保存和恢复线程的上下文信息，这会带来显著的性能开销。</li>
</ul>
</li>
<li><strong>混合策略 (Spin-then-Block):</strong> 许多现代操作系统和库（包括 <code>std::mutex</code> 的实现）会采用一种混合策略：在尝试获取锁失败后，线程会先进行短暂的自旋（忙等待一小段时间），如果仍然无法获取，才会选择阻塞。这样可以兼顾短时间等待的低开销和长时间等待的高效率。</li>
</ul>
<h3 id="5-内存模型与内存屏障-Memory-Barriers"><a href="#5-内存模型与内存屏障-Memory-Barriers" class="headerlink" title="5. 内存模型与内存屏障 (Memory Barriers)"></a>5. 内存模型与内存屏障 (Memory Barriers)</h3><p>除了原子性，Mutex 还必须保证<strong>内存可见性 (Memory Visibility)</strong> 和**内存顺序 (Memory Ordering)**。</p>
<ul>
<li><strong>内存可见性：</strong> 当一个线程修改了共享数据，并释放了锁，另一个线程获取锁后，必须能够看到前一个线程所做的所有修改。</li>
<li><strong>内存顺序：</strong> 编译器和 CPU 为了优化性能，可能会对指令进行重排序。Mutex 必须确保在临界区内外的内存操作不会被错误地重排序，从而破坏程序的逻辑。</li>
</ul>
<p>Mutex 的 <code>lock()</code> 操作通常具有**获取语义 (Acquire Semantics)**：它确保在 <code>lock()</code> 之后的所有内存操作，都不会被重排到 <code>lock()</code> 之前。同时，它也确保能看到在之前某个线程释放锁（具有释放语义）时，所有在该释放操作之前发生的内存写入。</p>
<p>Mutex 的 <code>unlock()</code> 操作通常具有**释放语义 (Release Semantics)**：它确保在 <code>unlock()</code> 之前的所有内存操作，都不会被重排到 <code>unlock()</code> 之后。同时，它也确保这些写入操作在后续某个线程获取锁（具有获取语义）时变得可见。</p>
<p>这些语义是通过在 <code>lock()</code> 和 <code>unlock()</code> 内部插入<strong>内存屏障 (Memory Barriers)</strong> 或使用具有相应语义的原子操作来实现的。内存屏障是一种 CPU 指令，它强制 CPU 和编译器在屏障两侧的内存操作不能重排序。</p>
<h3 id="6-std-mutex-的实现概览"><a href="#6-std-mutex-的实现概览" class="headerlink" title="6. std::mutex 的实现概览"></a>6. <code>std::mutex</code> 的实现概览</h3><p><code>std::mutex</code> 通常是由操作系统提供的底层互斥量 API（如 POSIX 线程库的 <code>pthread_mutex_t</code> 或 Windows API 的 <code>CRITICAL_SECTION</code> &#x2F; <code>HANDLE</code>）封装而成的。</p>
<p><strong>在 Linux&#x2F;POSIX 系统上：</strong><br><code>std::mutex</code> 内部可能使用 <code>pthread_mutex_t</code>。<code>pthread_mutex_lock()</code> 和 <code>pthread_mutex_unlock()</code> 函数会调用内核提供的系统调用来管理线程的阻塞和唤醒。</p>
<p><strong>在 Windows 系统上：</strong><br><code>std::mutex</code> 内部可能使用 <code>CRITICAL_SECTION</code> 或 <code>HANDLE</code>（用于事件或互斥体对象）。<code>EnterCriticalSection()</code> 和 <code>LeaveCriticalSection()</code> 也是通过系统调用与内核交互。</p>
<p>这些操作系统级别的互斥量通常实现了上述的“自旋-阻塞”混合策略，以在不同场景下提供最佳性能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::mutex</code> 的底层原理是一个多层次的抽象：</p>
<ol>
<li><strong>硬件层：</strong> 依赖 CPU 提供的<strong>原子指令</strong>（如 CAS, Test-and-Set）来保证锁状态的修改是不可分割的。</li>
<li><strong>操作系统层：</strong><ul>
<li>对于阻塞式 Mutex，操作系统负责管理线程的<strong>阻塞、唤醒和调度</strong>。</li>
<li>维护等待队列，并在锁释放时选择唤醒合适的线程。</li>
<li>处理<strong>上下文切换</strong>的开销。</li>
</ul>
</li>
<li><strong>内存模型层：</strong> 通过内置的<strong>内存屏障</strong>（或具有相应语义的原子操作），保证内存操作的可见性和顺序性，防止编译器和 CPU 的重排序优化导致的问题。</li>
<li><strong>C++ 标准库层：</strong> <code>std::mutex</code> 是对这些底层操作系统原语的 C++ 封装，提供了统一、类型安全的接口供开发者使用。</li>
</ol>
<p>理解这些原理有助于你更好地使用 Mutex，避免常见的并发问题，并对并发程序的性能瓶颈有更深入的认识。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>原子操作</tag>
        <tag>锁</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中的索引</title>
    <url>/2025/06/05/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>最近有点摆烂，两门考试和六级压力有点大。没怎么更新，唉，还有就是女人（）。</p>
<p>胡乱投了简历，也约上面试了，开始女娲补天呜呜呜。公司是图数据库方面的，所以主播恶补一下mysql。</p>
<p>众所周知，数据库中的数据是按照表的形式存储的，可以想象成excel表，那么为了方便查询，我们给我们要查询的列，叫做索引，常见的索引一般是id,比如我们就查询id为1的人的姓名，年龄等，比较方便，更可以将id设置为主键（唯一且不为空）</p>
<h2 id="1-聚簇索引-Clustered-Index"><a href="#1-聚簇索引-Clustered-Index" class="headerlink" title="1. 聚簇索引 (Clustered Index)"></a>1. 聚簇索引 (Clustered Index)</h2><ul>
<li><strong>定义</strong>：聚簇索引是表数据的物理存储顺序与索引顺序一致的索引。每个表只能有一个聚簇索引，通常由主键定义。</li>
<li>就是按照索引的顺序存放数据，id从0到1000，数据就这么存放，不看其他的列</li>
<li><strong>特点</strong>：<ul>
<li>表数据按聚簇索引的键值物理排序存储。</li>
<li>数据和索引存储在同一结构中（通常是B+树）。</li>
<li>查询效率高，尤其是范围查询和主键查找。</li>
</ul>
</li>
<li><strong>用途</strong>：用于快速检索数据，适合频繁查询的列（如主键）。</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, name <span class="type">VARCHAR</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>id</code>列的索引是聚簇索引，表数据按<code>id</code>排序存储。</li>
</ul>
</li>
<li><strong>注意</strong>：InnoDB引擎默认创建聚簇索引（基于主键）；若无主键，则选择第一个非空唯一索引，或生成隐式RowID。</li>
</ul>
<hr>
<h2 id="2-主键索引-Primary-Key-Index"><a href="#2-主键索引-Primary-Key-Index" class="headerlink" title="2. 主键索引 (Primary Key Index)"></a>2. 主键索引 (Primary Key Index)</h2><ul>
<li><strong>定义</strong>：主键索引是定义在表的主键列上的特殊索引，确保每行数据的唯一性，且不能为NULL。</li>
<li>其实就是聚簇索引，不过要求索引是主键</li>
<li><strong>特点</strong>：<ul>
<li>自动创建聚簇索引（在InnoDB中）。</li>
<li>每表只能有一个主键索引。</li>
<li>强制唯一性和非空约束。</li>
</ul>
</li>
<li><strong>用途</strong>：保证数据唯一性，加速主键查询。</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, name <span class="type">VARCHAR</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>id</code>列的主键索引确保每个<code>id</code>唯一，且数据按<code>id</code>物理排序。</li>
</ul>
</li>
<li><strong>注意</strong>：主键索引是聚簇索引的子集，但术语上常分开讨论。</li>
</ul>
<hr>
<h2 id="3-二级索引-Secondary-Index"><a href="#3-二级索引-Secondary-Index" class="headerlink" title="3. 二级索引 (Secondary Index)"></a>3. 二级索引 (Secondary Index)</h2><ul>
<li><p><strong>定义</strong>：二级索引是非聚簇索引，存储索引键值和指向表数据的指针（通常是主键值）。</p>
</li>
<li><p>单独给某一列再设一个索引，方便where,group by等命令的优化，mysql自动调用</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>与聚簇索引分离，数据存储顺序与索引无关。</li>
<li>查询可能需要“回表”（通过主键查找实际数据）。</li>
<li>允许多个二级索引。</li>
</ul>
</li>
<li><p><strong>用途</strong>：优化非主键列的查询，如WHERE、JOIN条件中的列。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> users(name);</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>name</code>列上的二级索引加速<code>WHERE name = &#39;Alice&#39;</code>查询。</li>
</ul>
</li>
<li><p><strong>注意</strong>：二级索引占用额外存储空间，更新数据时需同步维护。</p>
</li>
</ul>
<hr>
<h2 id="4-普通索引-Normal-Index"><a href="#4-普通索引-Normal-Index" class="headerlink" title="4. 普通索引 (Normal Index)"></a>4. 普通索引 (Normal Index)</h2><ul>
<li><strong>定义</strong>：普通索引是基本的非唯一索引，用于加速查询，不强制唯一性或非空约束。</li>
<li><strong>特点</strong>：<ul>
<li>属于二级索引，存储键值和主键指针。</li>
<li>不限制列值重复或NULL。</li>
</ul>
</li>
<li><strong>用途</strong>：提高常用查询列的性能，如频繁出现在WHERE或ORDER BY中的列。</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> users(age);</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>age</code>列的普通索引优化<code>SELECT * FROM users WHERE age &gt; 30</code>。</li>
</ul>
</li>
<li><strong>注意</strong>：普通索引适合高选择性的列（重复值少）。</li>
</ul>
<hr>
<h2 id="5-唯一索引-Unique-Index"><a href="#5-唯一索引-Unique-Index" class="headerlink" title="5. 唯一索引 (Unique Index)"></a>5. 唯一索引 (Unique Index)</h2><ul>
<li><strong>定义</strong>：唯一索引确保索引列的值唯一，允许NULL（在InnoDB中，NULL视为不同值）。</li>
<li><strong>特点</strong>：<ul>
<li>属于二级索引，但强制唯一性约束。</li>
<li>可包含NULL，但每个NULL值视为唯一。</li>
<li>每表可有多个唯一索引。</li>
</ul>
</li>
<li><strong>用途</strong>：确保数据唯一性（如邮箱、身份证号），并加速查询。</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX idx_email <span class="keyword">ON</span> users(email);</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>email</code>列的唯一索引防止重复邮箱值。</li>
</ul>
</li>
<li><strong>注意</strong>：与主键索引不同，唯一索引允许NULL，且不一定是聚簇索引。</li>
</ul>
<hr>
<h2 id="6-Hash索引"><a href="#6-Hash索引" class="headerlink" title="6. Hash索引"></a>6. Hash索引</h2><ul>
<li><strong>定义</strong>：Hash索引基于哈希表实现，通过哈希函数将键值映射到固定位置。</li>
<li><strong>特点</strong>：<ul>
<li>仅支持等值查询（如<code>=</code>、<code>IN</code>），不支持范围查询（如<code>&gt;</code>、<code>&lt;</code>）。</li>
<li>查找速度极快（O(1)复杂度），但不适合排序或范围操作。</li>
<li>Memory引擎支持Hash索引，InnoDB仅在特定场景（如自适应哈希索引）使用。</li>
</ul>
</li>
<li><strong>用途</strong>：适合高频等值查询的场景，如内存表中的键值查找。</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mem_table (id <span class="type">INT</span>, name <span class="type">VARCHAR</span>(<span class="number">50</span>), INDEX <span class="keyword">USING</span> HASH (name))</span><br><span class="line">ENGINE <span class="operator">=</span> MEMORY;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>name</code>列使用Hash索引，优化<code>SELECT * FROM mem_table WHERE name = &#39;Alice&#39;</code>。</li>
</ul>
</li>
<li><strong>注意</strong>：Hash索引占用空间较小，但功能受限，InnoDB不默认支持。</li>
</ul>
<hr>
<h2 id="7-B-树索引"><a href="#7-B-树索引" class="headerlink" title="7. B+树索引"></a>7. B+树索引</h2><ul>
<li><strong>定义</strong>：B+树索引是MySQL中最常用的索引结构，基于B+树数据结构存储索引。</li>
<li><strong>特点</strong>：<ul>
<li>所有非叶子节点仅存储键值，叶子节点存储键值和数据指针（或数据本身）。</li>
<li>支持等值查询、范围查询、排序和分组操作。</li>
<li>InnoDB和MyISAM引擎默认使用B+树索引。</li>
<li>叶子节点通过双向链表连接，适合顺序扫描。</li>
</ul>
</li>
<li><strong>用途</strong>：广泛用于主键索引、唯一索引、普通索引和二级索引，适合大多数查询场景。</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_city <span class="keyword">ON</span> users(city);</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<code>city</code>列的B+树索引优化<code>SELECT * FROM users WHERE city = &#39;Beijing&#39; ORDER BY city</code>。</li>
</ul>
</li>
<li><strong>注意</strong>：B+树索引适合高选择性列，范围查询效率高，但插入&#x2F;更新可能导致树分裂，影响性能。</li>
</ul>
<hr>
<h2 id="8-区别与联系"><a href="#8-区别与联系" class="headerlink" title="8. 区别与联系"></a>8. 区别与联系</h2><table>
<thead>
<tr>
<th>索引类型</th>
<th>是否聚簇</th>
<th>唯一性</th>
<th>允许NULL</th>
<th>支持查询类型</th>
<th>存储结构</th>
<th>适用引擎</th>
</tr>
</thead>
<tbody><tr>
<td>聚簇索引</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>等值、范围、排序</td>
<td>B+树</td>
<td>InnoDB</td>
</tr>
<tr>
<td>主键索引</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>等值、范围、排序</td>
<td>B+树</td>
<td>InnoDB, MyISAM</td>
</tr>
<tr>
<td>二级索引</td>
<td>否</td>
<td>可选</td>
<td>是</td>
<td>等值、范围、排序</td>
<td>B+树</td>
<td>InnoDB, MyISAM</td>
</tr>
<tr>
<td>普通索引</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>等值、范围、排序</td>
<td>B+树</td>
<td>InnoDB, MyISAM</td>
</tr>
<tr>
<td>唯一索引</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>等值、范围、排序</td>
<td>B+树</td>
<td>InnoDB, MyISAM</td>
</tr>
<tr>
<td>Hash索引</td>
<td>否</td>
<td>可选</td>
<td>是</td>
<td>等值</td>
<td>哈希表</td>
<td>Memory, InnoDB*</td>
</tr>
<tr>
<td>B+树索引</td>
<td>可选</td>
<td>可选</td>
<td>可选</td>
<td>等值、范围、排序</td>
<td>B+树</td>
<td>InnoDB, MyISAM</td>
</tr>
</tbody></table>
<p>*注：InnoDB的自适应哈希索引由引擎自动管理，用户无法直接创建。</p>
<hr>
<h2 id="9-使用场景与优化建议"><a href="#9-使用场景与优化建议" class="headerlink" title="9. 使用场景与优化建议"></a>9. 使用场景与优化建议</h2><ul>
<li><strong>聚簇索引</strong>：优先用于主键或高频查询的列，保持主键递增（如自增ID）以减少分裂。</li>
<li><strong>主键索引</strong>：选择短且唯一的列（如INT型ID），避免过长字符串。</li>
<li><strong>二级索引</strong>：为WHERE、JOIN、ORDER BY中常用的列创建，注意覆盖索引优化回表。</li>
<li><strong>普通索引</strong>：适合高选择性列，避免在低选择性列（如性别）上创建。</li>
<li><strong>唯一索引</strong>：用于业务上要求唯一性的列，如用户名或邮箱。</li>
<li><strong>Hash索引</strong>：适合内存表或等值查询场景，避免范围查询。</li>
<li><strong>B+树索引</strong>：通用选择，适合大多数查询场景，定期优化索引（<code>OPTIMIZE TABLE</code>）。</li>
</ul>
<hr>
<h2 id="10-注意事项"><a href="#10-注意事项" class="headerlink" title="10. 注意事项"></a>10. 注意事项</h2><ul>
<li><strong>索引维护成本</strong>：添加索引会增加存储空间和更新开销，需权衡查询与写入性能。</li>
<li><strong>覆盖索引</strong>：通过索引直接返回所需列，避免回表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>若<code>name</code>有索引，可直接从索引获取数据。</li>
</ul>
</li>
<li><strong>索引选择性</strong>：高选择性列（重复值少）更适合建索引。</li>
<li><strong>分析性能</strong>：使用<code>EXPLAIN</code>检查索引使用情况：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;Beijing&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>碎片整理</strong>：定期运行<code>OPTIMIZE TABLE</code>清理索引碎片。</li>
</ul>
<hr>
<h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h2><p>MySQL的索引类型各有特点，聚簇索引和主键索引决定数据存储方式，二级索引和普通索引优化查询，唯一索引保证数据约束，Hash索引适合等值查询，B+树索引是默认高效结构。选择合适的索引类型需根据查询模式、数据分布和引擎特性综合考虑。</p>
<p>如果您需要更具体的索引创建示例、优化案例或对某类索引的深入分析，请告诉我！</p>
<p><strong>参考文献</strong>：  </p>
<ul>
<li>MySQL官方文档（索引部分）  </li>
<li>InnoDB存储引擎索引实现  </li>
<li>B+树与Hash索引的性能对比</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>optional</title>
    <url>/2025/09/23/optional/</url>
    <content><![CDATA[<h3 id="std-optional-C-17"><a href="#std-optional-C-17" class="headerlink" title="std::optional (C++17)"></a><code>std::optional</code> (C++17)</h3><p><code>std::optional</code> 是 C++17 标准库中引入的一个模板类，用于表示一个<strong>可能包含值，也可能不包含值</strong>的对象。它解决了在 C++ 中处理“值可能缺失”这一常见问题。</p>
<p><strong>核心思想：</strong><br>在很多情况下，一个函数可能无法返回一个有效的结果，或者一个变量可能暂时没有被初始化。传统的 C++ 做法通常有：</p>
<ol>
<li><strong>返回特殊值：</strong> 例如，返回 <code>nullptr</code>（对于指针）、<code>-1</code> 或 <code>0</code>（对于整数），但这要求调用者记住这些特殊值，并且这些特殊值可能与有效值冲突。</li>
<li><strong>抛出异常：</strong> 这会引入额外的开销，并且异常通常用于表示程序中的错误，而不是常规的“值缺失”状态。</li>
<li><strong>通过输出参数：</strong> 函数通过引用参数来返回结果，并返回一个 <code>bool</code> 值表示是否成功。这使得函数签名复杂，并且不符合函数式编程的风格。</li>
</ol>
<p><code>std::optional</code> 提供了一种类型安全、明确且惯用的方式来表达这种“可选值”的概念，类似于其他语言中的 <code>Maybe</code> 或 <code>Option</code> 类型。</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>值或无值：</strong> <code>optional</code> 对象要么包含一个 <code>T</code> 类型的值，要么不包含任何值（处于“空”状态）。</li>
<li><strong>内存开销小：</strong> <code>optional&lt;T&gt;</code> 通常只比 <code>T</code> 多占用一个 <code>bool</code> 标志位（用于指示是否有值）的内存，加上可能的对齐填充。</li>
<li><strong>类型安全：</strong> 它避免了使用特殊值或 <code>nullptr</code> 带来的类型不匹配和潜在的运行时错误。</li>
<li><strong>明确性：</strong> 通过 <code>std::optional</code>，代码的意图更加清晰，即这个值可能不存在。</li>
<li><strong>值语义：</strong> <code>std::optional</code> 是一个值类型，支持拷贝、移动、赋值等操作。</li>
</ul>
<p><strong>头文件：</strong><br><code>#include &lt;optional&gt;</code></p>
<p><strong>基本用法：</strong></p>
<ol>
<li><p><strong>创建 <code>optional</code> 对象：</strong></p>
<ul>
<li><strong>空状态：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt1; <span class="comment">// 默认构造，空状态</span></span><br><span class="line">std::optional&lt;std::string&gt; opt2 = std::<span class="literal">nullopt</span>; <span class="comment">// 使用 std::nullopt 初始化为空</span></span><br></pre></td></tr></table></figure></li>
<li><strong>包含值状态：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt3 = <span class="number">42</span>; <span class="comment">// 直接赋值</span></span><br><span class="line">std::optional&lt;std::string&gt; opt4&#123;<span class="string">&quot;hello&quot;</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line">std::optional&lt;<span class="type">double</span>&gt; opt5 = std::<span class="built_in">make_optional</span>(<span class="number">3.14</span>); <span class="comment">// 使用 std::make_optional</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>检查是否有值：</strong></p>
<ul>
<li><strong><code>has_value()</code>：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt<span class="number">3.</span><span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt3 has value.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>隐式转换为 <code>bool</code>：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt4) &#123; <span class="comment">// 等同于 opt4.has_value()</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opt4 has value.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>访问值：</strong></p>
<ul>
<li><strong><code>value()</code>：</strong> 如果 <code>optional</code> 包含值，返回值的引用；否则抛出 <code>std::bad_optional_access</code> 异常。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value of opt3: &quot;</span> &lt;&lt; opt<span class="number">3.</span><span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// std::cout &lt;&lt; &quot;Value of opt1: &quot; &lt;&lt; opt1.value() &lt;&lt; std::endl; // 运行时抛出异常</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>*</code> 解引用运算符：</strong> 如果 <code>optional</code> 包含值，返回值的引用；否则行为未定义（<strong>慎用，除非你确定有值</strong>）。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value of opt3 (dereference): &quot;</span> &lt;&lt; *opt3 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>-&gt;</code> 成员访问运算符：</strong> 如果 <code>optional</code> 包含值，用于访问其内部值的成员；否则行为未定义（<strong>慎用，除非你确定有值</strong>）。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::optional&lt;std::string&gt; name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name length: &quot;</span> &lt;&lt; name-&gt;<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>提供默认值：<code>value_or()</code></strong><br>如果 <code>optional</code> 包含值，返回该值；否则返回提供的默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; maybe_age;</span><br><span class="line"><span class="type">int</span> age = maybe_age.<span class="built_in">value_or</span>(<span class="number">30</span>); <span class="comment">// age 将是 30</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::optional&lt;<span class="type">int</span>&gt; actual_age = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> real_age = actual_age.<span class="built_in">value_or</span>(<span class="number">30</span>); <span class="comment">// real_age 将是 25</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Real Age: &quot;</span> &lt;&lt; real_age &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改 <code>optional</code> 的状态：</strong></p>
<ul>
<li><strong>赋值：</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::optional&lt;<span class="type">int</span>&gt; opt;</span><br><span class="line">opt = <span class="number">10</span>; <span class="comment">// 现在包含值 10</span></span><br><span class="line">opt = std::<span class="literal">nullopt</span>; <span class="comment">// 现在为空</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>reset()</code>：</strong> 将 <code>optional</code> 设置为空状态。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">opt = <span class="number">20</span>;</span><br><span class="line">opt.<span class="built_in">reset</span>(); <span class="comment">// 现在为空</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>emplace()</code>：</strong> 构造一个新值到 <code>optional</code> 内部，避免不必要的拷贝&#x2F;移动。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::optional&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; opt_vec;</span><br><span class="line">opt_vec.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 构造一个包含 5 个元素的 vector</span></span><br><span class="line"><span class="comment">// 等同于 opt_vec = std::vector&lt;int&gt;&#123;1, 2, 3, 4, 5&#125;; 但可能更高效</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>示例：一个查找函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找一个单词在字典中的定义</span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">find_definition</span><span class="params">(<span class="type">const</span> std::string&amp; word, <span class="type">const</span> std::map&lt;std::string, std::string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = dictionary.<span class="built_in">find</span>(word);</span><br><span class="line">    <span class="keyword">if</span> (it != dictionary.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second; <span class="comment">// 找到，返回定义</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>; <span class="comment">// 没找到，返回空 optional</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; my_dictionary = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;A greeting.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;world&quot;</span>, <span class="string">&quot;The earth, together with all of its countries and peoples.&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;c++&quot;</span>, <span class="string">&quot;A powerful programming language.&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> def1 = <span class="built_in">find_definition</span>(<span class="string">&quot;c++&quot;</span>, my_dictionary);</span><br><span class="line">    <span class="keyword">if</span> (def1) &#123; <span class="comment">// 检查是否有值</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Definition of &#x27;c++&#x27;: &quot;</span> &lt;&lt; *def1 &lt;&lt; std::endl; <span class="comment">// 使用解引用访问</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&#x27;c++&#x27; not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> def2 = <span class="built_in">find_definition</span>(<span class="string">&quot;java&quot;</span>, my_dictionary);</span><br><span class="line">    <span class="comment">// 使用 value_or 提供默认值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Definition of &#x27;java&#x27;: &quot;</span> &lt;&lt; def<span class="number">2.</span><span class="built_in">value_or</span>(<span class="string">&quot;Not found in dictionary.&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试访问一个空 optional 的值，会抛出异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::optional&lt;<span class="type">int</span>&gt; empty_opt;</span><br><span class="line">        std::cout &lt;&lt; empty_opt.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_optional_access&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与指针&#x2F;引用和特殊值的对比：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>std::optional&lt;T&gt;</code></th>
<th align="left"><code>T*</code> (指针)</th>
<th align="left">特殊值 (如 -1, “”, etc.)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>语义</strong></td>
<td align="left">明确表示“可能存在值”</td>
<td align="left">表示“可能指向一个对象”或“没有指向任何对象”</td>
<td align="left">需要约定特殊值代表“缺失”</td>
</tr>
<tr>
<td align="left"><strong>所有权</strong></td>
<td align="left">拥有其内部值 (值语义)</td>
<td align="left">通常不拥有所指对象 (引用语义)</td>
<td align="left">值本身，不涉及所有权</td>
</tr>
<tr>
<td align="left"><strong>内存开销</strong></td>
<td align="left"><code>sizeof(T) + sizeof(bool)</code> (大致)</td>
<td align="left"><code>sizeof(T*)</code></td>
<td align="left">无额外开销，但可能占用有效值范围</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">访问空值抛异常 (<code>.value()</code>) 或未定义行为 (<code>*</code>)</td>
<td align="left">解引用 <code>nullptr</code> 导致未定义行为&#x2F;崩溃</td>
<td align="left">特殊值可能与有效值冲突，易出错</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">强类型，避免类型混淆</td>
<td align="left">弱类型，指针可以指向任何类型</td>
<td align="left">依赖于约定，可能导致类型语义混淆</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">函数返回可能缺失的值，类成员可能未初始化</td>
<td align="left">动态内存管理，多态，共享&#x2F;非共享资源</td>
<td align="left">简单场景，但有局限性</td>
</tr>
<tr>
<td align="left"><strong>可读性&#x2F;意图</strong></td>
<td align="left">高，清晰表明可选性</td>
<td align="left">中，需要额外文档或约定</td>
<td align="left">低，需要查阅文档或约定</td>
</tr>
</tbody></table>
<p><strong>何时使用 <code>std::optional</code>？</strong></p>
<ul>
<li><strong>函数返回可能失败的结果：</strong> 当一个函数可能无法计算出有效结果时，返回 <code>std::optional&lt;T&gt;</code> 比返回特殊值或抛出异常更清晰和安全。</li>
<li><strong>类成员可能未初始化：</strong> 当一个类的成员变量在构造时可能没有值，但在后续操作中可能会被赋值时，可以使用 <code>std::optional</code>。</li>
<li><strong>配置参数：</strong> 当某些配置参数是可选的，并且没有默认值时。</li>
<li><strong>避免使用 <code>nullptr</code> 作为“无值”的标记：</strong> 对于非指针类型，<code>std::optional</code> 提供了更好的替代方案。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><strong>开销：</strong> 尽管 <code>std::optional</code> 的内存开销很小，但在某些对性能和内存极度敏感的场景下（例如，大量小型对象组成的容器），可能需要权衡。</li>
<li><strong>异常：</strong> <code>value()</code> 方法在访问空 <code>optional</code> 时会抛出异常。如果频繁访问且不确定是否有值，最好先用 <code>has_value()</code> 或 <code>operator bool()</code> 检查，或者使用 <code>value_or()</code> 提供默认值。</li>
<li><strong><code>T</code> 的要求：</strong> <code>T</code> 必须是可析构的。C++17 之前，<code>T</code> 还需要是可默认构造的，但 C++17 移除了这个限制。</li>
<li><strong>不要用于引用：</strong> <code>std::optional&lt;T&amp;&gt;</code> 是不允许的。如果需要可选的引用，可以使用 <code>std::optional&lt;std::reference_wrapper&lt;T&gt;&gt;</code>。</li>
</ul>
<p>总而言之，<code>std::optional</code> 是 C++17 中一个非常实用的工具，它以类型安全和明确的方式解决了“值可能缺失”的问题，使得代码更健壮、更易读。在现代 C++ 编程中，它已经成为处理可选值的主流方式。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++17</tag>
      </tags>
  </entry>
  <entry>
    <title>select,poll,epoll</title>
    <url>/2025/06/20/select-poll-epoll/</url>
    <content><![CDATA[<hr>
<h3 id="1-阻塞与非阻塞-Blocking-vs-Non-Blocking"><a href="#1-阻塞与非阻塞-Blocking-vs-Non-Blocking" class="headerlink" title="1. 阻塞与非阻塞 (Blocking vs Non-Blocking)"></a>1. 阻塞与非阻塞 (Blocking vs Non-Blocking)</h3><ul>
<li><p>**阻塞 (Blocking)**：</p>
<ul>
<li>操作在完成之前会暂停调用者的执行。例如，在阻塞I&#x2F;O中，调用<code>read()</code>或<code>write()</code>时，线程会等待直到操作完成或超时。</li>
<li>特点：简单但效率较低，适合单线程或低并发场景。</li>
<li>示例：阻塞socket的<code>recv()</code>调用会等待数据到达。</li>
</ul>
</li>
<li><p>**非阻塞 (Non-Blocking)**：</p>
<ul>
<li>操作立即返回，无论是否完成。如果数据或资源不可用，通常返回错误码（如<code>EAGAIN</code>）或部分结果。</li>
<li>特点：适合高并发场景，但需要开发者处理未完成的情况。</li>
<li>示例：非阻塞socket的<code>recv()</code>会立即返回，若无数据则返回错误码。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-异步与同步-Asynchronous-vs-Synchronous"><a href="#2-异步与同步-Asynchronous-vs-Synchronous" class="headerlink" title="2. 异步与同步 (Asynchronous vs Synchronous)"></a>2. 异步与同步 (Asynchronous vs Synchronous)</h3><ul>
<li><p>**同步 (Synchronous)**：</p>
<ul>
<li>调用者发起操作后，必须等待操作完成才能继续执行后续代码。</li>
<li>阻塞和非阻塞都可以是同步的。例如，阻塞I&#x2F;O是同步的（等待完成），非阻塞I&#x2F;O也是同步的（立即返回但需要轮询）。</li>
<li>特点：逻辑简单，但可能导致线程空闲或频繁检查。</li>
</ul>
</li>
<li><p>**异步 (Asynchronous)**：</p>
<ul>
<li>调用者发起操作后无需等待操作完成，系统通过回调、事件循环或Future&#x2F;Promise通知调用者结果。</li>
<li>通常与非阻塞结合使用，适合高并发场景。</li>
<li>示例：异步I&#x2F;O（如Linux的<code>io_uring</code>或JavaScript的<code>async/await</code>）在操作完成时触发回调。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-水平触发与边缘触发-Level-Triggered-vs-Edge-Triggered"><a href="#3-水平触发与边缘触发-Level-Triggered-vs-Edge-Triggered" class="headerlink" title="3. 水平触发与边缘触发 (Level-Triggered vs Edge-Triggered)"></a>3. 水平触发与边缘触发 (Level-Triggered vs Edge-Triggered)</h3><p>这些概念主要出现在事件驱动的I&#x2F;O多路复用机制中（如<code>select</code>、<code>poll</code>、<code>epoll</code>）。</p>
<ul>
<li><p>**水平触发 (Level-Triggered)**：</p>
<ul>
<li>事件触发条件基于状态（level）。只要文件描述符（fd）的状态满足条件（例如有数据可读），事件就会持续触发。</li>
<li>特点：需要处理所有就绪的数据，否则会反复触发。适合简单场景。</li>
<li>示例：在<code>select</code>或<code>poll</code>中，如果socket有数据未读，每次检查都会报告可读。</li>
</ul>
</li>
<li><p>**边缘触发 (Edge-Triggered)**：</p>
<ul>
<li>事件触发条件基于状态变化（edge）。仅在文件描述符状态发生变化时触发一次（如从无数据到有数据）。</li>
<li>特点：效率高，但需要开发者一次性处理所有数据，否则可能丢失事件。常用于高性能场景。</li>
<li>示例：Linux的<code>epoll</code>在<code>EPOLLET</code>模式下，仅在数据到达时触发一次。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>阻塞</th>
<th>非阻塞</th>
<th>同步</th>
<th>异步</th>
<th>水平触发</th>
<th>边缘触发</th>
</tr>
</thead>
<tbody><tr>
<td><strong>等待行为</strong></td>
<td>等待操作完成</td>
<td>立即返回</td>
<td>等待或轮询</td>
<td>不等待，回调通知</td>
<td>持续触发（状态满足）</td>
<td>仅状态变化时触发</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>低（线程阻塞）</td>
<td>高（需轮询或管理）</td>
<td>较低（需主动检查）</td>
<td>高（事件驱动）</td>
<td>较低（反复通知）</td>
<td>高（单次通知）</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单</td>
<td>较复杂</td>
<td>简单</td>
<td>较复杂</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>简单程序</td>
<td>高并发服务器</td>
<td>传统I&#x2F;O</td>
<td>事件循环（如Node.js）</td>
<td><code>select</code>&#x2F;<code>poll</code></td>
<td><code>epoll</code>&#x2F;<code>kqueue</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h3><p>假设你正在开发一个网络服务器：</p>
<ul>
<li><strong>阻塞 + 同步</strong>：每个客户端连接分配一个线程，线程调用阻塞<code>read()</code>等待数据。简单但线程开销大。</li>
<li><strong>非阻塞 + 同步</strong>：单线程使用<code>select</code>或<code>poll</code>轮询多个socket，检查哪些有数据。效率较高但需要手动管理。</li>
<li><strong>非阻塞 + 异步</strong>：使用<code>epoll</code>（边缘触发）或<code>io_uring</code>，数据到达时通过回调或事件循环处理，适合高并发。</li>
<li><strong>水平触发 vs 边缘触发</strong>：在<code>epoll</code>中，水平触发下未读完的数据会反复通知；边缘触发下只通知一次，需确保读完所有数据。</li>
</ul>
<h2 id="select-poll的缺点"><a href="#select-poll的缺点" class="headerlink" title="select,poll的缺点"></a>select,poll的缺点</h2><p>1.select采用位图进行文件描述符，能监视的连接数量有上限，一般是1024，poll采用链表存储，但都是通过轮询来访问监视连接，监视数量越大，性能越差</p>
<p>2.select和poll都需要拷贝大量句柄数据结构在用户态和内核态之间切换，产生巨大的开销</p>
<p>3.select和poll都是返回一个包含所有句柄的数组，应用程序仍需要遍历才能知道哪些句柄发生了事件</p>
<p>4.只支持水平触发，</p>
<h2 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点"></a>epoll的优点</h2><ul>
<li>支持<strong>水平触发</strong>（默认）和<strong>边缘触发</strong>（<code>EPOLLET</code> 模式）。</li>
<li>高效<ul>
<li>内核使用红黑树管理 fd，添加&#x2F;删除复杂度为 O(log n)。</li>
<li>就绪事件通过事件列表返回，仅包含就绪 fd，复杂度为 O(1)。</li>
<li>避免用户态和内核态频繁拷贝整个 fd 集合。</li>
</ul>
</li>
<li><strong>扩展性</strong>：支持大量 fd（仅受内存限制）。</li>
<li><strong>边缘触发优势</strong>：仅在状态变化时通知，适合高性能服务器，但需确保处理所有数据。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>epoll</tag>
        <tag>IO复用</tag>
      </tags>
  </entry>
  <entry>
    <title>span</title>
    <url>/2025/10/06/span/</url>
    <content><![CDATA[<p> <code>std::span</code> 是 C++20 引入的一个非常实用的特性，它提供了一个<strong>非拥有 (non-owning)</strong> 的、**连续内存区域的视图 (view)**。你可以把它理解为 <code>std::string_view</code> 的泛化版本，<code>std::string_view</code> 是 <code>char</code> 序列的非拥有视图，而 <code>std::span</code> 是任意类型 <code>T</code> 的序列的非拥有视图。</p>
<h3 id="std-span-的核心思想和解决的问题"><a href="#std-span-的核心思想和解决的问题" class="headerlink" title="std::span 的核心思想和解决的问题"></a><code>std::span</code> 的核心思想和解决的问题</h3><p>在 C++20 之前，我们经常需要处理连续内存区域，例如：</p>
<ol>
<li>C 风格数组 (<code>int arr[10];</code>)</li>
<li><code>std::vector</code></li>
<li><code>std::array</code></li>
<li>其他自定义的连续内存容器</li>
</ol>
<p>当我们需要将这些数据传递给函数时，通常有几种方式：</p>
<ul>
<li><strong>原始指针和长度：</strong> <code>void func(int* data, size_t size);</code> 这种方式容易出错，容易忘记传递长度，或者长度与实际数据不匹配，导致越界访问。</li>
<li><strong><code>const std::vector&lt;T&gt;&amp;</code>：</strong> 如果函数只读取数据，这种方式比较安全。但如果函数只需要一部分数据，或者数据来源不是 <code>std::vector</code>，就显得不那么通用。而且，它传递了整个 <code>vector</code> 对象，虽然是引用，但接口上表达的意图是“我可能需要整个 vector”，而实际上可能只需要其数据。</li>
<li><strong>迭代器对：</strong> <code>void func(Iterator begin, Iterator end);</code> 这种方式很灵活，但写起来比较冗长，且不直接表达“连续内存”的语义。</li>
</ul>
<p><code>std::span</code> 旨在解决上述问题，它提供了一个<strong>统一、安全、高效</strong>的方式来表示和传递任何连续内存区域。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>非拥有 (Non-owning)：</strong> <code>std::span</code> 不管理它所指向的内存的生命周期。它只是一个“视图”，就像一个窗口，透过它可以看到一块内存。这意味着，如果 <code>std::span</code> 所指向的原始数据被销毁了，那么 <code>std::span</code> 就会变成一个**悬空视图 (dangling span)**，访问它将是未定义行为。</li>
<li><strong>连续内存 (Contiguous memory)：</strong> <code>std::span</code> 只能指向内存中连续存储的数据。</li>
<li><strong>轻量级 (Lightweight)：</strong> <code>std::span</code> 通常只包含一个指向数据开头的指针和一个表示数据长度的 <code>size_t</code>，所以它的复制和传递成本非常低。</li>
<li><strong>类型安全 (Type-safe)：</strong> 它是一个模板类，会检查类型匹配。</li>
<li><strong>支持 <code>constexpr</code>：</strong> 可以在编译时使用。</li>
</ul>
<h3 id="std-span-的声明和初始化"><a href="#std-span-的声明和初始化" class="headerlink" title="std::span 的声明和初始化"></a><code>std::span</code> 的声明和初始化</h3><p><code>std::span</code> 是一个模板类，通常声明为 <code>std::span&lt;T&gt;</code> 或 <code>std::span&lt;T, Extent&gt;</code>。</p>
<ul>
<li><code>std::span&lt;T&gt;</code>：动态大小的 span，其长度在运行时确定。</li>
<li><code>std::span&lt;T, Extent&gt;</code>：固定大小的 span，其长度在编译时确定。<code>Extent</code> 必须是一个非负整数。</li>
</ul>
<h4 id="1-从-C-风格数组初始化"><a href="#1-从-C-风格数组初始化" class="headerlink" title="1. 从 C 风格数组初始化"></a>1. 从 C 风格数组初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span> <span class="comment">// C++20</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_span</span><span class="params">(std::span&lt;<span class="type">const</span> <span class="type">int</span>&gt; s)</span> </span>&#123; <span class="comment">// 接收 const span，表示只读</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Span size: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : s) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c_array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(c_array)</span></span>; <span class="comment">// 从 C 风格数组初始化 (动态大小)</span></span><br><span class="line">    <span class="built_in">print_span</span>(s1); <span class="comment">// 输出: Span size: 5, elements: 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>, 5&gt; <span class="title">s2</span><span class="params">(c_array)</span></span>; <span class="comment">// 从 C 风格数组初始化 (固定大小)</span></span><br><span class="line">    <span class="built_in">print_span</span>(s2); <span class="comment">// 输出: Span size: 5, elements: 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：固定大小的 span 必须与数组大小匹配，否则编译错误</span></span><br><span class="line">    <span class="comment">// std::span&lt;int, 4&gt; s3(c_array); // 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-从-std-vector-初始化"><a href="#2-从-std-vector-初始化" class="headerlink" title="2. 从 std::vector 初始化"></a>2. 从 <code>std::vector</code> 初始化</h4><p><code>std::vector</code> 可以隐式转换为 <code>std::span</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">s3</span><span class="params">(vec)</span></span>; <span class="comment">// 从 std::vector 初始化 (动态大小)</span></span><br><span class="line"><span class="built_in">print_span</span>(s3); <span class="comment">// 输出: Span size: 3, elements: 10 20 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以直接传递给接受 std::span 的函数</span></span><br><span class="line"><span class="built_in">print_span</span>(vec); <span class="comment">// 隐式转换</span></span><br></pre></td></tr></table></figure>

<h4 id="3-从-std-array-初始化"><a href="#3-从-std-array-初始化" class="headerlink" title="3. 从 std::array 初始化"></a>3. 从 <code>std::array</code> 初始化</h4><p><code>std::array</code> 也可以隐式转换为 <code>std::span</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">double</span>, 4&gt; arr = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>&#125;;</span><br><span class="line"><span class="function">std::span&lt;<span class="type">const</span> <span class="type">double</span>&gt; <span class="title">s4</span><span class="params">(arr)</span></span>; <span class="comment">// 从 std::array 初始化</span></span><br><span class="line"><span class="comment">// 注意：print_span 接受 int，这里需要一个接受 double 的函数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Span double size: &quot;</span> &lt;&lt; s<span class="number">4.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, elements: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> val : s4) &#123;</span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl; <span class="comment">// 输出: Span double size: 4, elements: 1.1 2.2 3.3 4.4</span></span><br></pre></td></tr></table></figure>

<h4 id="4-从指针和长度初始化"><a href="#4-从指针和长度初始化" class="headerlink" title="4. 从指针和长度初始化"></a>4. 从指针和长度初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>&#125;;</span><br><span class="line"><span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">s5</span><span class="params">(ptr, <span class="number">3</span>)</span></span>; <span class="comment">// 从指针和长度初始化</span></span><br><span class="line"><span class="built_in">print_span</span>(s5); <span class="comment">// 输出: Span size: 3, elements: 100 200 300</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>

<h4 id="5-从迭代器对初始化-C-23-以后更直接，C-20-可以通过-std-ranges-subrange-或-std-span-构造函数"><a href="#5-从迭代器对初始化-C-23-以后更直接，C-20-可以通过-std-ranges-subrange-或-std-span-构造函数" class="headerlink" title="5. 从迭代器对初始化 (C++23 以后更直接，C++20 可以通过 std::ranges::subrange 或 std::span 构造函数)"></a>5. 从迭代器对初始化 (C++23 以后更直接，C++20 可以通过 <code>std::ranges::subrange</code> 或 <code>std::span</code> 构造函数)</h4><p>C++20 的 <code>std::span</code> 构造函数可以直接接受一对迭代器，只要它们满足 <code>std::contiguous_iterator</code> 概念。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; another_vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">// 创建一个包含 vec 中间元素的 span</span></span><br><span class="line"><span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">s6</span><span class="params">(another_vec.begin() + <span class="number">1</span>, another_vec.begin() + <span class="number">4</span>)</span></span>; <span class="comment">// 元素 2, 3, 4</span></span><br><span class="line"><span class="built_in">print_span</span>(s6); <span class="comment">// 输出: Span size: 3, elements: 2 3 4</span></span><br></pre></td></tr></table></figure>

<h3 id="std-span-的常用成员函数"><a href="#std-span-的常用成员函数" class="headerlink" title="std::span 的常用成员函数"></a><code>std::span</code> 的常用成员函数</h3><ul>
<li><code>size()</code>: 返回 span 中的元素数量。</li>
<li><code>empty()</code>: 检查 span 是否为空。</li>
<li><code>data()</code>: 返回指向 span 第一个元素的指针。</li>
<li><code>operator[]</code>: 访问指定索引的元素（不进行边界检查）。</li>
<li><code>front()</code>: 访问第一个元素（不进行边界检查）。</li>
<li><code>back()</code>: 访问最后一个元素（不进行边界检查）。</li>
<li><code>begin()</code>, <code>end()</code>: 返回迭代器，支持范围 for 循环。</li>
<li><code>subspan(offset, count)</code>: 返回一个子 span。<ul>
<li><code>offset</code>: 子 span 起始位置的偏移量。</li>
<li><code>count</code>: 子 span 的元素数量（可选，默认为从偏移量到末尾的所有元素）。</li>
</ul>
</li>
<li><code>first(count)</code>: 返回包含前 <code>count</code> 个元素的子 span。</li>
<li><code>last(count)</code>: 返回包含后 <code>count</code> 个元素的子 span。</li>
<li><code>as_bytes()</code>: 返回一个 <code>std::span&lt;const std::byte&gt;</code>，用于查看原始字节数据。</li>
<li><code>as_writable_bytes()</code>: 返回一个 <code>std::span&lt;std::byte&gt;</code>，用于修改原始字节数据。</li>
</ul>
<h4 id="示例：成员函数使用"><a href="#示例：成员函数使用" class="headerlink" title="示例：成员函数使用"></a>示例：成员函数使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// For std::iota</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span> <span class="comment">// For std::byte</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_span</span><span class="params">(std::span&lt;<span class="type">int</span>&gt; s)</span> </span>&#123; <span class="comment">// 接收可写 span</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; val : s) &#123;</span><br><span class="line">        val *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// data: &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">full_span</span><span class="params">(data)</span></span>;</span><br><span class="line">    <span class="built_in">print_span</span>(full_span); <span class="comment">// 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; full_span.<span class="built_in">front</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 3: &quot;</span> &lt;&lt; full_span[<span class="number">3</span>] &lt;&lt; std::endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子 span</span></span><br><span class="line">    std::span&lt;<span class="type">int</span>&gt; middle_three = full_span.<span class="built_in">subspan</span>(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 从索引 3 开始，取 3 个元素</span></span><br><span class="line">    <span class="built_in">print_span</span>(middle_three); <span class="comment">// 4 5 6</span></span><br><span class="line"></span><br><span class="line">    std::span&lt;<span class="type">int</span>&gt; first_two = full_span.<span class="built_in">first</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print_span</span>(first_two); <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line">    std::span&lt;<span class="type">int</span>&gt; last_four = full_span.<span class="built_in">last</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">print_span</span>(last_four); <span class="comment">// 7 8 9 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 span 的内容 (会修改原始数据)</span></span><br><span class="line">    <span class="built_in">modify_span</span>(middle_three); <span class="comment">// 修改 &#123;4, 5, 6&#125; 为 &#123;8, 10, 12&#125;</span></span><br><span class="line">    <span class="built_in">print_span</span>(full_span); <span class="comment">// 1 2 3 8 10 12 7 8 9 10 (注意原始 data 被修改了)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// as_bytes 和 as_writable_bytes</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Raw bytes of first_two: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> std::byte b : first_two.<span class="built_in">as_bytes</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::hex &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(b) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::dec &lt;&lt; std::endl; <span class="comment">// 输出原始字节表示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个空的 span</span></span><br><span class="line">    std::span&lt;<span class="type">int</span>&gt; empty_span;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Empty span size: &quot;</span> &lt;&lt; empty_span.<span class="built_in">size</span>() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-span-的优势"><a href="#std-span-的优势" class="headerlink" title="std::span 的优势"></a><code>std::span</code> 的优势</h3><ol>
<li><strong>类型安全和边界检查 (可选)：</strong> 虽然 <code>operator[]</code> 不做边界检查，但 <code>std::span</code> 本身携带了长度信息，你可以轻松地在函数内部进行边界检查，或者使用 <code>gsl::at</code> 等工具。相比于裸指针，它提供了更多的信息。</li>
<li><strong>避免数据复制：</strong> 作为视图，它不拥有数据，因此在函数调用时避免了不必要的数据复制，提高了性能。</li>
<li><strong>统一接口：</strong> 无论是 C 风格数组、<code>std::vector</code> 还是 <code>std::array</code>，都可以通过 <code>std::span</code> 提供统一的接口。</li>
<li><strong>清晰的意图：</strong> 函数签名 <code>void func(std::span&lt;T&gt; s)</code> 明确表达了“我需要一个连续的 <code>T</code> 序列，但我不会拥有它或管理它的生命周期”。</li>
<li><strong>支持 <code>constexpr</code>：</strong> 可以在编译时进行操作，例如创建固定大小的 span。</li>
</ol>
<h3 id="std-span-的重要注意事项-悬空视图"><a href="#std-span-的重要注意事项-悬空视图" class="headerlink" title="std::span 的重要注意事项 (悬空视图)"></a><code>std::span</code> 的重要注意事项 (悬空视图)</h3><p>由于 <code>std::span</code> 是非拥有的，它不会延长其所指向数据的生命周期。这是使用 <code>std::span</code> 时最需要注意的地方。如果原始数据被销毁，而 <code>std::span</code> 仍然存在并被访问，就会导致<strong>未定义行为</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::span&lt;<span class="type">int</span>&gt; <span class="title">create_dangling_span</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp_vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// temp_vec 在函数返回时会被销毁</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">span</span>&lt;<span class="type">int</span>&gt;(temp_vec); <span class="comment">// 返回一个指向已销毁内存的 span</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::span&lt;<span class="type">int</span>&gt; s = <span class="built_in">create_dangling_span</span>();</span><br><span class="line">    <span class="comment">// 此时 s 是一个悬空视图！访问它会导致未定义行为。</span></span><br><span class="line">    <span class="comment">// 编译器通常不会警告你这种错误。</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; s[0] &lt;&lt; std::endl; // 危险！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：</strong></p>
<ul>
<li>确保 <code>std::span</code> 的生命周期<strong>短于</strong>或<strong>等于</strong>它所指向数据的生命周期。</li>
<li>通常将 <code>std::span</code> 用作函数参数，而不是作为类成员变量（除非你非常清楚其生命周期管理）。</li>
<li>对于只读访问，优先使用 <code>std::span&lt;const T&gt;</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::span</code> 是现代 C++ 中处理连续内存数据不可或缺的工具。它通过提供一个轻量级、类型安全、非拥有的视图，极大地提升了代码的安全性、可读性和性能。在 C++20 及更高版本中，你应该优先考虑在需要传递连续序列的场景中使用 <code>std::span</code> 来替代原始指针&#x2F;长度对或 <code>const std::vector&lt;T&gt;&amp;</code>。但是，务必牢记其非拥有的特性，避免创建悬空视图。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++20</tag>
      </tags>
  </entry>
  <entry>
    <title>static</title>
    <url>/2025/06/15/static/</url>
    <content><![CDATA[<h3 id="static-在-C-中的各种用法"><a href="#static-在-C-中的各种用法" class="headerlink" title="static 在 C++ 中的各种用法"></a><code>static</code> 在 C++ 中的各种用法</h3><p>以下是 <code>static</code> 的主要用法，包括静态变量、静态全局变量、静态局部变量、静态函数、静态成员函数和静态成员变量的详细说明。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

// 1. 静态全局变量（文件作用域）
static int globalCount = 0; // 仅当前文件可见

// 2. 普通全局变量（对比）
int nonStaticGlobal = 0; // 其他文件可通过 extern 访问

// 3. 静态函数（文件作用域）
static void incrementGlobalCount() &#123;
    globalCount++;
    std::cout &lt;&lt; &quot;Static globalCount: &quot; &lt;&lt; globalCount &lt;&lt; &quot;\n&quot;;
&#125;

class MyClass
&#123;
private:
    // 4. 静态成员变量
    static int staticMemberCount; // 共享于所有对象
    int instanceCount;

public:
    MyClass(int count) : instanceCount(count)
    &#123;
        staticMemberCount++;
    &#125;
    // 5. 静态成员函数
    static int getStaticMemberCount() 
    &#123;
        return staticMemberCount; // 只能访问静态成员
    &#125;

    int getInstanceCount() const &#123;
    return instanceCount;
&#125;

// 6. 静态局部变量（示例）
    void demonstrateStaticLocal()
    &#123;
        static int localStaticVar = 0; // 仅初始化一次，保留值
        localStaticVar++;
        std::cout &lt;&lt; &quot;Static local variable: &quot; &lt;&lt; localStaticVar &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;;

// 静态成员变量的定义（必须在类外定义）
int MyClass::staticMemberCount = 0;

    int main() 
&#123;
    // 测试静态全局变量
    incrementGlobalCount(); // 输出 1
    incrementGlobalCount(); // 输出 2
    // 测试静态成员变量和静态成员函数
    MyClass obj1(10);
    MyClass obj2(20);
    std::cout &lt;&lt; &quot;Static member count: &quot; &lt;&lt; MyClass::getStaticMemberCount() &lt;&lt; &quot;\n&quot;; // 输出 2
    std::cout &lt;&lt; &quot;Instance count obj1: &quot; &lt;&lt; obj1.getInstanceCount() &lt;&lt; &quot;\n&quot;; // 输出 10
    std::cout &lt;&lt; &quot;Instance count obj2: &quot; &lt;&lt; obj2.getInstanceCount() &lt;&lt; &quot;\n&quot;; // 输出 20

    // 测试静态局部变量
    obj1.demonstrateStaticLocal(); // 输出 1
    obj2.demonstrateStaticLocal(); // 输出 2

    return 0;
&#125;
</code></pre>
<hr>
<h4 id="1-静态全局变量"><a href="#1-静态全局变量" class="headerlink" title="1. 静态全局变量"></a>1. <strong>静态全局变量</strong></h4><ul>
<li><strong>定义</strong>：在文件作用域中声明的全局变量，前面加 <code>static</code>。</li>
<li><strong>作用</strong>：<ul>
<li>限制变量的链接性为内部链接（internal linkage），仅在当前翻译单元（源文件）可见。</li>
<li>其他源文件无法通过 <code>extern</code> 访问。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>初始化只发生一次，生命周期为整个程序运行期间。</li>
<li>默认初始化为 0（如果未显式初始化）。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> globalCount = <span class="number">0</span>; <span class="comment">// 仅当前文件可见</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对比普通全局变量：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nonStaticGlobal = <span class="number">0</span>; <span class="comment">// 可被其他文件通过 extern 访问</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-静态局部变量"><a href="#2-静态局部变量" class="headerlink" title="2. 静态局部变量"></a>2. <strong>静态局部变量</strong></h4><ul>
<li><strong>定义</strong>：在函数或块作用域内声明的变量，前面加 <code>static</code>。</li>
<li><strong>作用</strong>：<ul>
<li>变量只初始化一次，之后保留其值。</li>
<li>生命周期为整个程序运行期间，但作用域仅限于声明的块。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>默认初始化为 0（如果未显式初始化）。</li>
<li>C++11 及以后，静态局部变量的初始化是线程安全的</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateStaticLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> localStaticVar = <span class="number">0</span>; <span class="comment">// 仅初始化一次</span></span><br><span class="line">    localStaticVar++;</span><br><span class="line">    std::cout &lt;&lt; localStaticVar &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 每次调用递增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用两次，输出 <code>1</code> 和 <code>2</code>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-静态函数"><a href="#3-静态函数" class="headerlink" title="3. 静态函数"></a>3. <strong>静态函数</strong></h4><ul>
<li><strong>定义</strong>：在文件作用域中声明的函数，前面加 <code>static</code>。</li>
<li><strong>作用</strong>：<ul>
<li>限制函数的链接性为内部链接，仅在当前翻译单元可见。</li>
<li>防止其他源文件通过 <code>extern</code> 调用。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>用于封装文件内部的辅助函数，类似于静态全局变量的限制。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">incrementGlobalCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    globalCount++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Static globalCount: &quot;</span> &lt;&lt; globalCount &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-静态成员变量"><a href="#4-静态成员变量" class="headerlink" title="4. 静态成员变量"></a>4. <strong>静态成员变量</strong></h4><ul>
<li><strong>定义</strong>：在类中声明的成员变量，前面加 <code>static</code>。</li>
<li><strong>作用</strong>：<ul>
<li>所有类对象共享同一份静态成员变量。</li>
<li>不属于某个具体对象，而是属于类本身。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>必须在类外定义并初始化（通常在源文件中）。</li>
<li>生命周期为整个程序运行期间。</li>
<li>可通过类名直接访问（如 <code>MyClass::staticMemberCount</code>）。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticMemberCount; <span class="comment">// 声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::staticMemberCount = <span class="number">0</span>; <span class="comment">// 定义并初始化</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="5-静态成员函数"><a href="#5-静态成员函数" class="headerlink" title="5. 静态成员函数"></a>5. <strong>静态成员函数</strong></h4><ul>
<li><p><strong>定义</strong>：在类中声明的成员函数，前面加 <code>static</code>。</p>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>不依赖于类的具体对象，只能访问类的静态成员（变量或函数），无法访问非静态成员函数和成员。</li>
<li>可通过类名直接调用（如 <code>MyClass::getStaticMemberCount()</code>）。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>没有隐式的 <code>this</code> 指针，因为不绑定到任何对象。</li>
<li>常用于访问或操作静态成员变量。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getStaticMemberCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> staticMemberCount; <span class="comment">// 访问静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="6-注意事项与总结"><a href="#6-注意事项与总结" class="headerlink" title="6. 注意事项与总结"></a>6. <strong>注意事项与总结</strong></h4><ul>
<li><strong>生命周期与作用域</strong>：<ul>
<li>所有 <code>static</code> 变量（全局、局部、成员）的生命周期都是程序运行期间。</li>
<li>作用域取决于声明位置（文件、函数、类）。</li>
</ul>
</li>
<li><strong>线程安全</strong>：<ul>
<li>静态局部变量在 C++11 及以后初始化是线程安全的。</li>
<li>静态全局变量和静态成员变量的访问需开发者自行确保线程安全。</li>
</ul>
</li>
<li><strong>内存管理</strong>：<ul>
<li>静态变量存储在数据段（<code>.data</code> 或 <code>.bss</code>），非堆或栈。</li>
<li>无需手动释放，程序结束时由系统自动回收。</li>
</ul>
</li>
<li><strong>与上下文的联系</strong>：<ul>
<li>静态局部变量的线程安全特性在单例模式（如 Meyers’ Singleton）中非常有用</li>
<li>静态成员变量类似于饿汉式单例的预加载机制（程序启动时初始化）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/09/23/string-view%E4%B8%8Eformat/</url>
    <content><![CDATA[<h2 id="千秋伟业强国路，勇担重任绽芳华——社会实践报告"><a href="#千秋伟业强国路，勇担重任绽芳华——社会实践报告" class="headerlink" title="千秋伟业强国路，勇担重任绽芳华——社会实践报告"></a>千秋伟业强国路，勇担重任绽芳华——社会实践报告</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>党的二十大报告擘画了以中国式现代化全面推进中华民族伟大复兴的宏伟蓝图，强调了科技创新在国家发展中的核心地位，并对青年一代寄予厚望。在实现中华民族伟大复兴的“千秋伟业强国路”上，我们青年学子理应“勇担重任绽芳华”，将个人理想融入国家发展大局，以实际行动践行青春使命。为深入理解国家战略，将所学知识应用于基层实践，我积极参与了以“智慧赋能乡村振兴”为主题的暑期社会实践活动。本次实践旨在通过科技手段助力乡村发展，亲身体验强国建设的伟大进程，并从中汲取成长的力量。</p>
<h3 id="一、实践目的"><a href="#一、实践目的" class="headerlink" title="一、实践目的"></a>一、实践目的</h3><p>本次社会实践活动，我怀揣着多重目的与期望：</p>
<ol>
<li><strong>响应国家战略，深化理论认知：</strong> 党的十八大以来，以习近平同志为核心的党中央高度重视“三农”工作，提出乡村振兴战略。通过亲身参与，我希望能够深入了解乡村振兴的内涵、挑战与机遇，将书本上的理论知识与国家政策在实践中进行印证和深化，理解科技赋能乡村的现实意义和长远价值，从而更好地把握新时代强国建设的脉搏。</li>
<li><strong>学以致用，提升专业技能：</strong> 作为一名[请填写你的专业，例如：计算机科学与技术&#x2F;农业工程&#x2F;城乡规划等]专业的学生，我希望能够将课堂所学的数据分析、软件开发、系统集成等专业知识应用于实际场景。通过参与智慧农业、数字乡村平台建设等具体项目，锻炼解决实际问题的能力，提升项目管理、团队协作和沟通表达等多方面的综合素质。</li>
<li><strong>了解国情社情，培养家国情怀：</strong> 深入乡村一线，与基层干部和村民面对面交流，亲身体验农村的生产生活状况，了解农民的真实需求和期盼。这有助于我跳出象牙塔，增进对国情社情的理解，培养深厚的为民服务意识和家国情怀，认识到青年一代在国家发展中的责任与担当。</li>
<li><strong>磨砺意志，实现自我价值：</strong> 乡村实践往往伴随着各种挑战，如环境艰苦、条件有限、沟通障碍等。我期望通过克服这些困难，磨砺自己的意志品质，培养吃苦耐劳的精神。同时，通过自己的努力为乡村发展贡献一份力量，在服务社会中实现个人价值，让青春在奉献中焕发光彩。</li>
</ol>
<h3 id="二、实践时间"><a href="#二、实践时间" class="headerlink" title="二、实践时间"></a>二、实践时间</h3><p>本次“智慧赋能乡村振兴”社会实践活动于2024年1月进行。在这几天里，我与团队成员们全身心投入到乡村的田间地头、农户家中和村委会办公室，用汗水和智慧书写了一段难忘的青春篇章。</p>
<h3 id="三、实践地点"><a href="#三、实践地点" class="headerlink" title="三、实践地点"></a>三、实践地点</h3><p>我们的实践地点选定在<strong>山东省</strong>。星火村是一个典型的丘陵地带农业村落，地理位置相对偏远，交通条件一般。村内以传统农业种植为主，主要农作物有水稻、玉米和部分经济作物。近年来，随着青壮年劳动力外出务工，村里留守老人儿童较多，农业生产面临着劳动力短缺、技术更新缓慢、农产品销售渠道不畅等问题。然而，星火村也拥有丰富的自然资源和淳朴的民风，村党支部和村委会积极探索发展新路径，渴望借助外部力量推动乡村振兴。选择星火村作为实践地点，正是看中了其振兴的迫切需求与发展的巨大潜力，希望能通过我们的科技赋能，为这片土地注入新的活力。</p>
<h3 id="四、实践内容"><a href="#四、实践内容" class="headerlink" title="四、实践内容"></a>四、实践内容</h3><p>在星火村的一个月实践中，我们团队围绕“智慧赋能乡村振兴”的核心目标，开展了一系列富有成效的工作：</p>
<ol>
<li><p><strong>前期调研与需求分析：</strong></p>
<ul>
<li><strong>走访入户，座谈交流：</strong> 团队成员分批次深入农户家中，与村民们进行面对面交流，了解他们的生产生活状况、对科技的需求以及在农业生产中遇到的实际困难。我们还与村干部、农业技术人员举行了多场座谈会，听取他们对村情民意的介绍和对未来发展的设想。</li>
<li><strong>数据收集与分析：</strong> 收集了星火村的地理信息、气候数据、土壤状况、农作物种类、产量数据以及农产品销售渠道等一手资料。通过问卷调查和访谈，形成了详细的调研报告，明确了星火村在智慧农业和数字乡村建设方面的痛点和优先需求。主要问题集中在农业生产的精细化管理不足、信息获取不及时、农产品品牌化和电商销售滞后等方面。</li>
</ul>
</li>
<li><p><strong>“星火智慧农业”系统初步搭建与推广：</strong></p>
<ul>
<li><strong>环境监测系统部署：</strong> 针对村民对农作物生长环境监测的需求，我们团队利用所学物联网知识，在村里几块主要农田部署了小型智能监测站，包括土壤湿度、温度、PH值、空气温湿度和光照强度传感器。这些数据实时传输至我们搭建的简易云平台。</li>
<li><strong>数据可视化与预警：</strong> 开发了一个基于Web的简易数据可视化界面，村民可以通过手机或村委会的电脑查看农田的实时环境数据。同时，我们设置了异常值预警功能，当土壤湿度过低或温度异常时，系统会自动发送短信通知相关农户，指导他们及时进行灌溉或采取保护措施。</li>
<li><strong>农业知识库建设：</strong> 收集整理了当地主要农作物的种植技术、病虫害防治方法等资料，并将其数字化，集成到智慧农业系统中，方便村民随时查询。</li>
<li><strong>培训与指导：</strong> 组织村民开展了多场培训会，手把手教他们如何使用智能监测设备和智慧农业系统。针对老年村民，我们制作了图文并茂的操作手册，并进行一对一的耐心指导，确保他们能够掌握基本操作。</li>
</ul>
</li>
<li><p><strong>“星火数字乡村”信息平台建设与完善：</strong></p>
<ul>
<li><strong>村务公开模块：</strong> 协助村委会搭建了村务公开模块，将村规民约、财务收支、惠农政策等信息定期发布，增强了村务透明度，方便村民了解村内大事。</li>
<li><strong>农产品电商助销：</strong> 针对农产品销售难题，我们帮助村里几家合作社和种植大户注册了电商平台账号，并指导他们进行产品拍照、文案撰写和店铺运营。同时，我们利用社交媒体平台，为星火村的特色农产品进行宣传推广，拓宽了销售渠道。</li>
<li><strong>便民服务模块：</strong> 整合了村内便民服务信息，如医疗卫生、教育资源、交通出行等，方便村民查询。</li>
</ul>
</li>
<li><p><strong>志愿服务与文化交流（贯穿整个实践过程）：</strong></p>
<ul>
<li><strong>义务支教：</strong> 团队成员利用晚上时间，为村里的留守儿童提供义务辅导，帮助他们完成暑期作业，并开展了科普讲座、绘画手工等丰富多彩的活动，拓宽孩子们的视野。</li>
<li><strong>文化宣传：</strong> 协助村里举办了一场以“科技兴农”为主题的文艺晚会，通过歌曲、舞蹈、小品等形式，宣传智慧农业的理念和国家乡村振兴政策，激发村民参与的热情。</li>
<li><strong>环境整治：</strong> 组织村民和团队成员共同参与村容村貌整治活动，清理垃圾，美化环境，提升了村民的环保意识。</li>
</ul>
</li>
</ol>
<h3 id="五、实践感悟"><a href="#五、实践感悟" class="headerlink" title="五、实践感悟"></a>五、实践感悟</h3><p>一个月的星火村实践，是我人生中一次宝贵的精神洗礼和能力提升。它让我对“千秋伟业强国路，勇担重任绽芳华”这句话有了更深刻的理解和感悟。</p>
<p>首先，<strong>理论与实践的深度融合，让我对专业知识有了全新的认识。</strong> 过去在课堂上学习的各种编程语言、数据结构、网络通信、物联网技术等，在星火村的田间地头找到了它们的用武之地。从传感器部署到数据传输，从系统开发到用户培训，每一个环节都充满了挑战，也让我深刻体会到知识的价值和力量。当看到村民们通过手机屏幕就能实时掌握农田情况，脸上露出欣喜的笑容时，我感受到了前所未有的成就感。这种将所学应用于实际、解决实际问题的过程，远比单纯的理论学习更具启发性和意义。</p>
<p>其次，<strong>深入基层，让我真切感受到了强国路上的不易与希望。</strong> 在星火村，我看到了农村发展的巨大潜力，也体会到了基层干部和村民们为改变现状所付出的艰辛努力。他们对美好生活的向往是如此真切，对科技带来的改变是如此渴望。我亲眼目睹了国家乡村振兴战略在基层落地生根，科技创新如何一点一滴地改变着传统农业的面貌。这让我更加坚信，只要我们一代代青年人能够扎根基层、奉献青春，中国的强国之路就一定会越走越宽广，中华民族的伟大复兴就一定会实现。</p>
<p>再者，<strong>团队协作与沟通能力得到了极大提升。</strong> 实践中，我们团队成员来自不同专业，拥有不同的知识背景。在项目规划、技术攻关、村民沟通等各个环节，都需要紧密的协作和有效的沟通。我学会了如何在分工合作中发挥个人优势，如何在意见分歧时求同存异，如何在面对困难时相互支持。与村民的交流更是锻炼了我的表达能力和同理心，让我学会了如何用通俗易懂的语言解释复杂的科技概念，如何耐心倾听他们的需求和反馈。</p>
<p>最后，<strong>这次实践极大地增强了我的使命感和责任感，让青春在奉献中绽放芳华。</strong> 以前，我可能更多地关注个人学业和职业发展；而现在，我开始思考如何将个人发展与国家民族的命运紧密结合。在星火村，我看到了自己所学能够为社会带来的积极改变，体会到了“小我”融入“大我”的价值。我深刻认识到，作为新时代的中国青年，我们肩负着实现中华民族伟大复兴的历史重任。我们不仅要仰望星空，更要脚踏实地，将青春的汗水挥洒在祖国最需要的地方。我不仅贡献了自己的力量，更收获了精神上的富足和成长，让我的青春在为强国建设贡献力量的过程中，绽放出独特的芳华。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>“千秋伟业强国路，勇担重任绽芳华”，这不仅仅是一个口号，更是新时代青年学子应当秉持的信念和行动指南。通过此次“智慧赋能乡村振兴”社会实践，我不仅提升了专业技能，深化了对国情社情的理解，更坚定了投身强国伟业的决心。我将把这份宝贵的经历和感悟带回到未来的学习和生活中，继续努力学习，不断提升自我，时刻准备着为实现中华民族伟大复兴的中国梦贡献自己的青春力量。星火村的实践虽然结束了，但我的强国之路、我的青春芳华才刚刚开始绽放！</p>
]]></content>
  </entry>
  <entry>
    <title>stl中的无序关联容器底层实现</title>
    <url>/2025/06/30/stl%E4%B8%AD%E7%9A%84%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="unordered-map-时间复杂度与底层实现"><a href="#unordered-map-时间复杂度与底层实现" class="headerlink" title="unordered_map 时间复杂度与底层实现"></a><code>unordered_map</code> 时间复杂度与底层实现</h1><p>以下是对 C++ 中 <code>unordered_map</code> 时间复杂度、底层实现以及哈希冲突解决方法的详细分析。</p>
<h2 id="1-unordered-map-时间复杂度"><a href="#1-unordered-map-时间复杂度" class="headerlink" title="1. unordered_map 时间复杂度"></a>1. <strong><code>unordered_map</code> 时间复杂度</strong></h2><p><code>unordered_map</code> 是 C++ STL 中的无序关联容器，基于哈希表实现。其操作的时间复杂度如下：</p>
<ul>
<li><p><strong>平均情况</strong>：</p>
<ul>
<li>插入（<code>insert</code>）、查找（<code>find</code>）、删除（<code>erase</code>）：( O(1) )（常数时间）。</li>
<li>这是因为哈希表通过哈希函数将键映射到桶（bucket），平均情况下每个桶的元素很少，操作接近常数时间。</li>
</ul>
</li>
<li><p><strong>最坏情况</strong>：</p>
<ul>
<li>插入、查找、删除：( O(n) )，其中 ( n ) 是容器中元素数量。</li>
<li>最坏情况发生在哈希冲突严重时，例如所有键都映射到同一个桶，导致桶内元素形成长链表或类似结构。</li>
</ul>
</li>
</ul>
<h3 id="导致-O-n-的情况"><a href="#导致-O-n-的情况" class="headerlink" title="导致 ( O(n) ) 的情况"></a><strong>导致 ( O(n) ) 的情况</strong></h3><ul>
<li><strong>哈希函数质量差</strong>：如果哈希函数将大量键映射到同一桶，冲突增加，桶内查找退化为线性搜索。</li>
<li><strong>高负载因子</strong>：负载因子（<code>load_factor</code> &#x3D; 元素数 &#x2F; 桶数）过高，导致更多冲突。C++ 默认最大负载因子为 1.0，当超过时会触发 rehash（重新分配桶）。</li>
<li><strong>恶意输入</strong>：精心构造的键集可能导致哈希函数失效，造成大量冲突（常见于安全攻击场景）。</li>
<li><strong>桶内元素过多</strong>：即使哈希函数分布均匀，若桶数不足，单个桶可能存储多个元素，增加查找时间。</li>
</ul>
<h2 id="2-底层实现"><a href="#2-底层实现" class="headerlink" title="2. 底层实现"></a>2. <strong>底层实现</strong></h2><p><code>unordered_map</code> 的底层是一个<strong>哈希表</strong>，主要组成部分包括：</p>
<ul>
<li><p><strong>桶（Buckets）</strong>：</p>
<ul>
<li>哈希表由一个桶数组组成，每个桶可以存储零个或多个键值对。</li>
<li>桶的数量由 <code>bucket_count</code> 决定，可通过 <code>rehash</code> 或 <code>reserve</code> 调整。</li>
<li>键通过哈希函数映射到某个桶的索引。</li>
</ul>
</li>
<li><p><strong>哈希函数</strong>：</p>
<ul>
<li>C++ 使用 <code>std::hash</code> 模板生成哈希值（可自定义）。</li>
<li>对于内置类型（如 <code>int</code>、<code>std::string</code>），<code>std::hash</code> 有优化实现。</li>
<li>哈希函数将键映射为桶索引：<code>index = hash(key) % bucket_count</code>。</li>
</ul>
</li>
<li><p><strong>桶内结构</strong>：</p>
<ul>
<li>每个桶通常是一个链表（C++11 标准要求），存储所有映射到该桶的键值对。</li>
<li>C++17 及以后，某些实现可能使用其他结构（如红黑树）优化高冲突场景，但标准仍以链表为主。</li>
</ul>
</li>
<li><p><strong>负载因子与 rehash</strong>：</p>
<ul>
<li>负载因子 &#x3D; 元素数 &#x2F; 桶数，反映哈希表拥挤程度。</li>
<li>当负载因子超过 <code>max_load_factor</code>（默认 1.0），<code>unordered_map</code> 会重新分配更多桶（通常翻倍），重新哈希所有元素以减少冲突。</li>
</ul>
</li>
</ul>
<h2 id="3-哈希冲突的解决"><a href="#3-哈希冲突的解决" class="headerlink" title="3. 哈希冲突的解决"></a>3. <strong>哈希冲突的解决</strong></h2><p>哈希冲突指多个键映射到同一桶。C++ <code>unordered_map</code> 主要通过以下方式解决冲突：</p>
<h3 id="方法-1：分离链法（Chaining）"><a href="#方法-1：分离链法（Chaining）" class="headerlink" title="方法 1：分离链法（Chaining）"></a><strong>方法 1：分离链法（Chaining）</strong></h3><ul>
<li><strong>实现</strong>：<ul>
<li>每个桶维护一个链表，存储所有映射到该桶的键值对。</li>
<li>查找时，哈希函数确定桶索引，然后在桶内链表中线性搜索目标键。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>简单，易于实现。</li>
<li>适合小规模冲突。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>冲突多时，链表变长，查找退化为 ( O(n) )。</li>
</ul>
</li>
<li><strong>C++ 实现</strong>：<ul>
<li>标准库 <code>unordered_map</code> 默认使用分离链法，每个桶是一个链表。</li>
<li>示例：键 <code>k1</code> 和 <code>k2</code> 的哈希值相同，均映射到桶 <code>i</code>，则桶 <code>i</code> 的链表存储 <code>&#123;k1, v1&#125; -&gt; &#123;k2, v2&#125;</code>。</li>
</ul>
</li>
</ul>
<h3 id="方法-2：开放寻址法（非-C-标准，但可了解）"><a href="#方法-2：开放寻址法（非-C-标准，但可了解）" class="headerlink" title="方法 2：开放寻址法（非 C++ 标准，但可了解）"></a><strong>方法 2：开放寻址法（非 C++ 标准，但可了解）</strong></h3><ul>
<li><strong>实现</strong>：<ul>
<li>不使用链表，而是在桶数组中寻找下一个空位存储冲突的键值对（通过探测，如线性探测或二次探测）。</li>
<li>查找时按相同探测顺序搜索。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>缓存友好（数据连续存储）。</li>
<li>避免链表的额外内存开销。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>探测序列可能导致性能下降。</li>
<li>删除操作复杂。</li>
</ul>
</li>
<li><strong>C++ 实现</strong>：<ul>
<li><code>unordered_map</code> 不使用开放寻址，但某些自定义哈希表可能采用。</li>
</ul>
</li>
</ul>
<h3 id="优化冲突的策略"><a href="#优化冲突的策略" class="headerlink" title="优化冲突的策略"></a><strong>优化冲突的策略</strong></h3><ul>
<li><strong>改进哈希函数</strong>：<ul>
<li>使用高质量哈希函数（如 MurmurHash、FNV-1a）确保键均匀分布。</li>
<li>自定义 <code>std::hash</code> 模板，例如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;MyType&gt; &#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyType&amp; obj)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 自定义哈希计算</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">custom_hash</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>增加桶数</strong>：<ul>
<li>调用 <code>rehash(n)</code> 或 <code>reserve(n)</code> 预分配更多桶，降低负载因子。</li>
<li>示例：<code>um.rehash(1000);</code> 确保至少 1000 个桶。</li>
</ul>
</li>
<li><strong>调整最大负载因子</strong>：<ul>
<li>默认 <code>max_load_factor</code> 为 1.0，可降低以减少冲突：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">um.<span class="built_in">max_load_factor</span>(<span class="number">0.5</span>); <span class="comment">// 负载因子超过 0.5 时触发 rehash</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>定期 rehash</strong>：<ul>
<li>手动调用 <code>rehash</code> 或在插入大量元素前预分配空间，避免频繁重新哈希。</li>
</ul>
</li>
<li><strong>避免恶意输入</strong>：<ul>
<li>对于用户输入的键，使用随机化哈希种子（C++ 实现通常内置此功能）防止哈希攻击。</li>
</ul>
</li>
</ul>
<h2 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. <strong>代码示例</strong></h2><p>以下是一个使用 <code>unordered_map</code> 的简单示例，展示插入、查找和冲突处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; um;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    um[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">    um[<span class="string">&quot;banana&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    um[<span class="string">&quot;orange&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    <span class="keyword">auto</span> it = um.<span class="built_in">find</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != um.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看桶信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bucket count: &quot;</span> &lt;&lt; um.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Load factor: &quot;</span> &lt;&lt; um.<span class="built_in">load_factor</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max load factor: &quot;</span> &lt;&lt; um.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动调整桶数</span></span><br><span class="line">    um.<span class="built_in">rehash</span>(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;New bucket count: &quot;</span> &lt;&lt; um.<span class="built_in">bucket_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; um.<span class="built_in">bucket_count</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bucket &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = um.<span class="built_in">begin</span>(i); it != um.<span class="built_in">end</span>(i); ++it) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;&#125; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出示例（因实现而异）："><a href="#输出示例（因实现而异）：" class="headerlink" title="输出示例（因实现而异）："></a>输出示例（因实现而异）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Found: apple -&gt; 1</span><br><span class="line">Bucket count: 8</span><br><span class="line">Load factor: 0.375</span><br><span class="line">Max load factor: 1</span><br><span class="line">New bucket count: 101</span><br><span class="line">Bucket 0: &#123;banana, 2&#125;</span><br><span class="line">Bucket 23: &#123;apple, 1&#125;</span><br><span class="line">Bucket 67: &#123;orange, 3&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><ul>
<li><strong>时间复杂度</strong>：<ul>
<li>平均 ( O(1) )，最坏 ( O(n) )，取决于哈希函数质量、负载因子和冲突程度。</li>
</ul>
</li>
<li><strong>底层实现</strong>：<ul>
<li>基于哈希表，桶数组 + 链表（分离链法）。</li>
<li>哈希函数映射键到桶，冲突通过链表解决。</li>
</ul>
</li>
<li><strong>哈希冲突解决</strong>：<ul>
<li>默认使用分离链法，优化方式包括改进哈希函数、增加桶数、降低负载因子。</li>
</ul>
</li>
<li><strong>优化建议</strong>：<ul>
<li>预分配桶（<code>rehash</code>&#x2F;<code>reserve</code>）。</li>
<li>自定义高效哈希函数。</li>
<li>监控负载因子，必要时调整 <code>max_load_factor</code>。</li>
</ul>
</li>
</ul>
<p>如需更深入的哈希函数设计或特定场景优化，请提供进一步细节！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++，哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>varient与any</title>
    <url>/2025/09/19/varient%E4%B8%8Eany/</url>
    <content><![CDATA[<hr>
<h3 id="1-std-variant-变体"><a href="#1-std-variant-变体" class="headerlink" title="1. std::variant (变体)"></a>1. <code>std::variant</code> (变体)</h3><p><code>std::variant</code> 是一个<strong>类型安全的联合体 (union)<strong>。它可以在编译时定义一个固定且有限的类型集合，并在运行时</strong>精确地持有其中一个类型的值</strong>。你总是知道 <code>std::variant</code> 可能包含哪些类型。</p>
<p><strong>核心思想：</strong> “这个变量<strong>要么是</strong>一个 <code>int</code>，<strong>要么是</strong>一个 <code>double</code>，<strong>要么是</strong>一个 <code>std::string</code>，但它在任何时候都只可能是其中一个。”</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>编译时已知类型集：</strong> 在声明 <code>std::variant</code> 时，你需要明确列出它可能包含的所有类型。</li>
<li><strong>类型安全：</strong> 你不能意外地从 <code>std::variant</code> 中提取一个它当前不持有的类型的值。如果尝试这样做，会抛出 <code>std::bad_variant_access</code> 异常或返回 <code>nullptr</code>。</li>
<li><strong>空间效率：</strong> 通常会在栈上分配足够的空间来存储其所有可能类型中最大的那个，避免了动态内存分配（除非内部类型本身需要动态分配）。</li>
<li><strong>无额外开销：</strong> 相比于多态（虚函数），<code>std::variant</code> 通常没有虚函数表的开销。</li>
<li><strong>访问方式：</strong><ul>
<li><code>std::get&lt;T&gt;(variant_obj)</code>：按类型获取值，如果类型不匹配则抛出 <code>std::bad_variant_access</code>。</li>
<li><code>std::get&lt;index&gt;(variant_obj)</code>：按索引获取值，如果索引不匹配则抛出 <code>std::bad_variant_access</code>。</li>
<li><code>std::get_if&lt;T&gt;(&amp;variant_obj)</code>：按类型获取值的指针，如果类型不匹配则返回 <code>nullptr</code>。</li>
<li><code>std::visit(callable, variant_obj...)</code>：这是最强大和推荐的访问方式。它接受一个或多个 <code>callable</code> 对象（例如 lambda 表达式、函数对象）和一个或多个 <code>std::variant</code> 对象，然后根据 <code>variant</code> 当前持有的类型调用相应的 <code>callable</code> 重载。这是一种类型安全的访问模式，类似于访问者模式。</li>
</ul>
</li>
<li><strong>空状态：</strong> 默认构造的 <code>std::variant</code> 会持有其第一个模板参数类型的默认构造值。如果你想表示一个“空”或“未初始化”的状态，可以使用 <code>std::monostate</code> 作为它的第一个类型。</li>
</ul>
<p><strong>何时使用 <code>std::variant</code>：</strong></p>
<ul>
<li>当你有一个<strong>有限且已知的类型集合</strong>，并且变量在任何时候只能是其中一个。</li>
<li>实现状态机。</li>
<li>函数返回多种可能的结果类型（例如 <code>std::expected</code> 的底层实现）。</li>
<li>解析抽象语法树 (AST) 节点。</li>
<li>替代类型不安全的 C 风格联合体。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span> <span class="comment">// C++17</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个 variant，它可以是 int, double, 或 std::string</span></span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值为 int</span></span><br><span class="line">    data = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data holds int: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(data) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Index: &quot;</span> &lt;&lt; data.<span class="built_in">index</span>() &lt;&lt; std::endl; <span class="comment">// 0 (int 是第一个类型)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值为 double</span></span><br><span class="line">    data = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data holds double: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(data) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Index: &quot;</span> &lt;&lt; data.<span class="built_in">index</span>() &lt;&lt; std::endl; <span class="comment">// 1 (double 是第二个类型)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值为 std::string</span></span><br><span class="line">    data = <span class="string">&quot;Hello Variant!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data holds string: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(data) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Index: &quot;</span> &lt;&lt; data.<span class="built_in">index</span>() &lt;&lt; std::endl; <span class="comment">// 2 (std::string 是第三个类型)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取错误的类型会抛出异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(data); <span class="comment">// 当前 data 是 string，不是 int</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::visit 访问</span></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg) &#123;</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(arg)&gt;;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Visited an int: &quot;</span> &lt;&lt; arg * <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Visited a double: &quot;</span> &lt;&lt; arg * <span class="number">2.0</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::string&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Visited a string: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="string">&quot; (length: &quot;</span> &lt;&lt; arg.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, data); <span class="comment">// data 当前是 &quot;Hello Variant!&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者使用多个 variant</span></span><br><span class="line">    std::variant&lt;<span class="type">int</span>, std::string&gt; v1 = <span class="number">10</span>;</span><br><span class="line">    std::variant&lt;<span class="type">double</span>, <span class="type">bool</span>&gt; v2 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">visit</span>([](<span class="keyword">auto</span>&amp;&amp; arg1, <span class="keyword">auto</span>&amp;&amp; arg2)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Visited two variants: &quot;</span> &lt;&lt; arg1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; arg2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;, v1, v2); <span class="comment">// 输出: Visited two variants: 10, 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-std-any-任意类型"><a href="#2-std-any-任意类型" class="headerlink" title="2. std::any (任意类型)"></a>2. <code>std::any</code> (任意类型)</h3><p><code>std::any</code> 是一个<strong>类型安全的容器</strong>，它可以存储<strong>任何单个值</strong>，只要该类型是<strong>可复制构造 (CopyConstructible)</strong> 的。你不需要在编译时知道它可能包含哪些类型，它在运行时处理类型信息。</p>
<p><strong>核心思想：</strong> “这个变量可以包含<strong>任何东西</strong>，但它在任何时候都只包含一个东西。我需要在使用时猜测并验证它里面是什么。”</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>运行时未知类型：</strong> 你不需要在声明 <code>std::any</code> 时指定它可能包含的类型。它可以在运行时存储任何可复制构造的类型。</li>
<li><strong>类型擦除 (Type Erasure)：</strong> <code>std::any</code> 通过类型擦除技术来存储任意类型的数据。它内部维护了存储值的副本以及其类型信息。</li>
<li><strong>动态内存分配：</strong> 通常会涉及动态内存分配来存储其内部的值，尤其当存储的对象大小超过某个阈值时（小对象优化可能会在栈上）。</li>
<li><strong>运行时类型检查：</strong> 访问 <code>std::any</code> 中的值需要进行运行时类型检查。</li>
<li><strong>访问方式：</strong><ul>
<li><code>std::any_cast&lt;T&gt;(any_obj)</code>：尝试将 <code>any_obj</code> 中的值转换为类型 <code>T</code>。如果 <code>any_obj</code> 为空或存储的类型不是 <code>T</code>，则抛出 <code>std::bad_any_cast</code> 异常。</li>
<li><code>std::any_cast&lt;T&gt;(&amp;any_obj)</code>：尝试将 <code>any_obj</code> 中的值转换为类型 <code>T</code> 的指针。如果 <code>any_obj</code> 为空或存储的类型不是 <code>T</code>，则返回 <code>nullptr</code>。</li>
<li><code>any_obj.has_value()</code>：检查 <code>any_obj</code> 是否包含值。</li>
<li><code>any_obj.type()</code>：返回 <code>std::type_info</code> 对象，提供关于存储类型的信息（通常用于调试或更复杂的类型检查）。</li>
</ul>
</li>
</ul>
<p><strong>何时使用 <code>std::any</code>：</strong></p>
<ul>
<li>当你需要存储<strong>真正任意的类型</strong>，并且在编译时无法预知所有可能的类型。</li>
<li>实现插件系统，插件可以返回任意类型的数据。</li>
<li>配置系统，配置项的值可以是各种类型。</li>
<li>事件系统，事件携带的数据可以是任意类型。</li>
<li>需要传递任意上下文数据到通用函数中。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span> <span class="comment">// C++17</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个 std::any</span></span><br><span class="line">    std::any value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值为 int</span></span><br><span class="line">    value = <span class="number">42</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value holds int: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type name: &quot;</span> &lt;&lt; value.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// 输出类似 &quot;i&quot; 或 &quot;int&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值为 std::string</span></span><br><span class="line">    value = std::<span class="built_in">string</span>(<span class="string">&quot;Hello Any!&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value holds string: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(value) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Type name: &quot;</span> &lt;&lt; value.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// 输出类似 </span></span><br><span class="line">    <span class="comment">// 赋值为自定义类型 (必须是 CopyConstructible)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        std::string name;</span><br><span class="line">        <span class="built_in">MyStruct</span>(<span class="type">int</span> i, std::string n) : <span class="built_in">id</span>(i), <span class="built_in">name</span>(std::<span class="built_in">move</span>(n)) &#123;&#125;</span><br><span class="line">        <span class="built_in">MyStruct</span>(<span class="type">const</span> MyStruct&amp;) = <span class="keyword">default</span>; <span class="comment">// 必须是可复制构造的</span></span><br><span class="line">        MyStruct&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyStruct&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = MyStruct&#123;<span class="number">1</span>, <span class="string">&quot;Test&quot;</span>&#125;;</span><br><span class="line">    MyStruct s = std::<span class="built_in">any_cast</span>&lt;MyStruct&gt;(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value holds MyStruct: &quot;</span> &lt;&lt; s.id &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s.name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取错误的类型会抛出异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::<span class="built_in">any_cast</span>&lt;<span class="type">double</span>&gt;(value); <span class="comment">// 当前 value 是 MyStruct</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_any_cast&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指针版本进行安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span>* p_int = std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(&amp;value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It&#x27;s an int: &quot;</span> &lt;&lt; *p_int &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MyStruct* p_struct = std::<span class="built_in">any_cast</span>&lt;MyStruct&gt;(&amp;value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It&#x27;s a MyStruct: &quot;</span> &lt;&lt; p_struct-&gt;id &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;It&#x27;s something else or empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value.<span class="built_in">reset</span>(); <span class="comment">// 清空 any</span></span><br><span class="line">    <span class="keyword">if</span> (!value.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="std-variant-vs-std-any-总结对比"><a href="#std-variant-vs-std-any-总结对比" class="headerlink" title="std::variant vs std::any 总结对比"></a><code>std::variant</code> vs <code>std::any</code> 总结对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>std::variant</code></th>
<th align="left"><code>std::any</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型集合</strong></td>
<td align="left"><strong>编译时已知，固定，有限</strong></td>
<td align="left"><strong>运行时未知，任意</strong> (任何 CopyConstructible 类型)</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>编译时安全</strong> (通过 <code>std::visit</code> 和类型列表)</td>
<td align="left"><strong>运行时安全</strong> (通过 <code>std::any_cast</code> 检查)</td>
</tr>
<tr>
<td align="left"><strong>性能&#x2F;开销</strong></td>
<td align="left">通常<strong>更高</strong>，无动态分配（除非内部类型大），无类型擦除开销</td>
<td align="left">通常<strong>较低</strong>，涉及动态分配和类型擦除开销</td>
</tr>
<tr>
<td align="left"><strong>内存分配</strong></td>
<td align="left">通常在栈上，大小为最大成员类型的大小</td>
<td align="left">通常在堆上（对于大对象），涉及动态内存管理</td>
</tr>
<tr>
<td align="left"><strong>访问方式</strong></td>
<td align="left"><code>std::get</code>, <code>std::get_if</code>, <strong><code>std::visit</code> (推荐)</strong></td>
<td align="left"><code>std::any_cast</code> (可能抛异常或返回 <code>nullptr</code>)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>有限的、已知的、固定的</strong>几种类型选择</td>
<td align="left"><strong>任意的、未知的</strong>类型，需要极致的灵活性</td>
</tr>
<tr>
<td align="left"><strong>空状态</strong></td>
<td align="left">默认持有第一个类型的值，可使用 <code>std::monostate</code></td>
<td align="left"><code>has_value()</code> 为 <code>false</code> 时为空，或调用 <code>reset()</code> 清空</td>
</tr>
</tbody></table>
<p><strong>简单来说：</strong></p>
<ul>
<li>如果你知道所有可能的类型，并且这个集合是固定的，使用 <code>std::variant</code>。它提供了更好的编译时安全性和性能。</li>
<li>如果你需要存储任何类型的数据，并且在编译时无法预知所有可能性，使用 <code>std::any</code>。它提供了最大的灵活性，但代价是运行时开销和更多的运行时类型检查。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>varient</tag>
        <tag>any</tag>
        <tag>异构容器</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Concurrency in Action》第二章</title>
    <url>/2025/10/29/%E3%80%8AC-Concurrency-in-Action%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<p>这本书主要讲的是c++多线程编程相关的内容，第二章主要讲的是std:thread的使用注意事项</p>
<h3 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h3><p>在使用std:thread时，我们要注意的一点是c++中的语法解析，原文是(c++’s most vexing parse).</p>
<p>函数对象（Functors）即任何重载了 <code>operator()</code> 的类的实例。Lambda 表达式是匿名函数对象的语法糖</p>
<p>如果将函数对象作为thread的构造函数参数而不是普通的函数对象，就注意不要使用临时变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fun &#123;</span><br><span class="line">    void operator()() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;MyFunctor is running in a thread!&quot; &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">        std::cout &lt;&lt; &quot;MyFunctor finished.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::thread my_thread(fun());</span><br><span class="line">这样的写法，很不幸会被识别为，thread类型返回值的函数声明</span><br></pre></td></tr></table></figure>

<p>解决这样的情况，可以用{}进行初始化，或者用额外的括号，以及使用命名变量而不是临时变量。</p>
<p>同样的，lambda函数也是解决这样的情况的一个不错的方法</p>
<h2 id="线程的等待"><a href="#线程的等待" class="headerlink" title="线程的等待"></a>线程的等待</h2><p>众所周知，线程有两种结束的方法，detach和join，join会阻塞主线程，直到线程运行完毕，detach则会将资源交给操作系统，不再关心被detach的线程如何结束。这里就会出现访问已释放的资源的风险。</p>
<p>这里要注意子线程的参数如果是函数对象的话，不能访问主线程中的变量的引用（如果要访问，一定要注意生命周期），因为detach之后主线程可能先于子线程结束，这样就会出现未定义行为。举个例子，就是lambda函数[&amp;]{}捕获引用后又作为函数对象传递给thread</p>
<p>特殊情况下的等待：这里主要是提醒在使用try catch的时候，如果在try catch之后有t.join()那么在catch的地方throw之前一定也要t.join()</p>
<h2 id="线程中的参数传递（重要）"><a href="#线程中的参数传递（重要）" class="headerlink" title="线程中的参数传递（重要）"></a>线程中的参数传递（重要）</h2><p>thread有一个毛病，就是当你传递参数给thread的构造函数时，thread会触发拷贝构造函数，将参数拷贝到新线程的内存空间中（如果使用一个可调用的对象（也就是函数对象）作为线程函数的参数也会先复制到新线程的存储空间中，然后在新线程中调用执行函数对象）</p>
<p>即使你的thread的函数的参数要求是引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void func(int&amp; x) &#123;</span><br><span class="line">    x += 10;</span><br><span class="line">    std::cout &lt;&lt; &quot;In thread, x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5;</span><br><span class="line"></span><br><span class="line">    std::thread t(func, a); // 👈 看似传了引用，实际是复制！</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;After thread, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实在想要穿引用，就要用std::ref();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void func(int&amp; x) &#123;</span><br><span class="line">    x += 10;</span><br><span class="line">    std::cout &lt;&lt; &quot;In thread, x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5;</span><br><span class="line"></span><br><span class="line">    std::thread t(func, std::ref(a)); // ✅ 使用 std::ref 显式传引用</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;After thread, a = &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="为什么要默认复制？"><a href="#为什么要默认复制？" class="headerlink" title="为什么要默认复制？"></a>为什么要默认复制？</h3><p>这是 <strong>出于安全和生命周期管理的考虑</strong>：</p>
<ul>
<li>新线程可能会比调用线程<strong>存活更久</strong>。<br>如果直接引用主线程的局部变量，而主线程结束了，那么引用就悬空了（dangling reference），会造成未定义行为。</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 可能访问已销毁的变量！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func, std::ref(<span class="number">42</span>))</span></span>; <span class="comment">// ❌ 错误！引用临时对象</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止这种情况，C++ 设计 <code>std::thread</code> 时 <strong>默认复制所有参数</strong>，以确保新线程使用自己的独立副本，不会引用无效内存。</p>
<p>传递参数时，容易出现一些错误行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(int i,std::string const&amp; s);</span><br><span class="line">void oops(int param)</span><br><span class="line">&#123;</span><br><span class="line">	char buffer[1024];</span><br><span class="line">	std::thread(f,3,buffer);//为避免悬空指针，应使用std::string显式转换</span><br><span class="line">	t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会出现一个问题，函数f需要一个string类型的参数，我们提供的是buffer,事实上是一个指针，正常情况下编译器会将其隐式转换为string，但是thread的拷贝构造函数也会将参数复制一份，如果此时还没有进行隐式转换，而thread已经完成了复制，那么隐式转换完毕的buffer也不再有机会传递到新的线程中，从而导致f函数接收到错误的参数类型。</p>
<p>为了避免这样的情况，我们需要使用std::thread(f,3,std::string(buffer);</p>
<p>接下来的部分，原文我个人感觉有一定错误，暂且跳过去</p>
<p>如果我们想要将类的成员函数作为thread的参数函数，具体做法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">do_soming</span><span class="params">(<span class="type">int</span> s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="type">int</span> num =<span class="number">0</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(&amp;X::do_soming,&amp;my_x,num)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里传入实例的指针起到this指针的作用</p>
<p>同时，thread对于参数的传递也有一部分优化</p>
<p>对于参数，如果是左值，会默认调用拷贝构造函数，如果是右值，就默认调用移动构造函数</p>
<h2 id="转移所有权"><a href="#转移所有权" class="headerlink" title="转移所有权"></a>转移所有权</h2><p>thread和线程本身是分离的，类似指针和资源的关系，而thread和unique_ptr一样都是可移动但不可复制的</p>
<p>但我们不能通过赋新值的方式来丢弃一个线程</p>
<p>同时可以用move的形式将thread作为参数进行传递</p>
<p>接下来笔者补充介绍一下c++20中引入的jthread，而本书出来时c++标准只更新到c++17,jthread还只存在于构想中</p>
<p> **<code>std::jthread</code>**（”joining thread”）是 <strong>C++20</strong> 新增的线程类，是对 <code>std::thread</code> 的一种 <strong>改进版</strong>。  </p>
<p>它在易用性、安全性和可中断性方面都比 <code>std::thread</code> 更优雅、更安全。<br>我们可以把它理解为：  </p>
<blockquote>
<p><strong><code>std::jthread = std::thread + 自动 join + 可中断机制（stop token）</code></strong></p>
</blockquote>
<hr>
<h2 id="🚀-一、std-jthread-的核心特点"><a href="#🚀-一、std-jthread-的核心特点" class="headerlink" title="🚀 一、std::jthread 的核心特点"></a>🚀 一、<code>std::jthread</code> 的核心特点</h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>std::thread</code></th>
<th><code>std::jthread</code></th>
</tr>
</thead>
<tbody><tr>
<td>是否自动 <code>join</code></td>
<td>❌ 需要手动调用 <code>.join()</code> 或 <code>.detach()</code></td>
<td>✅ 析构时自动 <code>join</code></td>
</tr>
<tr>
<td>可否被复制</td>
<td>❌ 不可复制（只能 move）</td>
<td>❌ 不可复制（只能 move）</td>
</tr>
<tr>
<td>是否支持中断（停止请求）</td>
<td>❌ 不支持</td>
<td>✅ 支持（<code>stop_token</code>）</td>
</tr>
<tr>
<td>安全性</td>
<td>需要手动管理生命周期</td>
<td>自动管理，防止“悬空线程”</td>
</tr>
<tr>
<td>标准版本</td>
<td>C++11</td>
<td>C++20</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧠-二、为什么要有-std-jthread"><a href="#🧠-二、为什么要有-std-jthread" class="headerlink" title="🧠 二、为什么要有 std::jthread"></a>🧠 二、为什么要有 <code>std::jthread</code></h2><p>在 <code>std::thread</code> 中，如果你忘记在对象销毁前调用 <code>.join()</code> 或 <code>.detach()</code>，程序会直接调用 <code>std::terminate()</code> 崩溃。<br>这在大型程序或异常路径中非常危险。</p>
<p><code>std::jthread</code> 的设计目标就是：</p>
<ol>
<li>自动管理线程生命周期（RAII）</li>
<li>简化中断（stop）机制</li>
<li>提高可读性和安全性</li>
</ol>
<hr>
<h2 id="⚙️-三、基本用法示例"><a href="#⚙️-三、基本用法示例" class="headerlink" title="⚙️ 三、基本用法示例"></a>⚙️ 三、基本用法示例</h2><h3 id="✅-自动-join-的线程"><a href="#✅-自动-join-的线程" class="headerlink" title="✅ 自动 join 的线程"></a>✅ 自动 join 的线程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread running\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">(work)</span></span>;  <span class="comment">// 创建并启动线程</span></span><br><span class="line">    <span class="comment">// 不需要显式调用 t.join()</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread exiting\n&quot;</span>;</span><br><span class="line">&#125;  <span class="comment">// 离开作用域时，jthread 自动 join</span></span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Worker thread running</span><br><span class="line">Main thread exiting</span><br></pre></td></tr></table></figure>

<p>🔹 当 <code>t</code> 离开作用域时，它的析构函数会自动调用 <code>.join()</code>，确保线程结束后再销毁。<br>这就彻底解决了 <code>std::thread</code> 常见的忘记 <code>join()</code> 导致崩溃的问题。</p>
<hr>
<h2 id="🧩-四、可中断的线程（Stop-Token-机制）"><a href="#🧩-四、可中断的线程（Stop-Token-机制）" class="headerlink" title="🧩 四、可中断的线程（Stop Token 机制）"></a>🧩 四、可中断的线程（Stop Token 机制）</h2><p><code>std::jthread</code> 新增了一个 <strong>中断机制（stop token）</strong>，可以让你优雅地通知线程“停止工作”。</p>
<h3 id="1️⃣-基本示例"><a href="#1️⃣-基本示例" class="headerlink" title="1️⃣ 基本示例"></a>1️⃣ 基本示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;  <span class="comment">// 检查是否收到停止请求</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker stopped.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">(worker)</span></span>;  <span class="comment">// worker 会自动接收 stop_token</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    t.<span class="built_in">request_stop</span>();  <span class="comment">// 请求停止线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Working...</span><br><span class="line">Working...</span><br><span class="line">Working...</span><br><span class="line">Worker stopped.</span><br></pre></td></tr></table></figure>

<p>🔹 <code>std::jthread</code> 在启动时会自动为线程提供一个 <code>std::stop_token</code> 参数，<br>只要你的线程函数声明第一个参数为 <code>std::stop_token</code>，<code>std::jthread</code> 会自动传入。</p>
<p>🔹 当你调用 <code>t.request_stop()</code> 时，</p>
<ul>
<li>线程中的 <code>stop_token</code> 会变为已请求状态；</li>
<li>线程循环中可以通过 <code>st.stop_requested()</code> 检查并退出。</li>
</ul>
<hr>
<h3 id="2️⃣-Stop-Token-工作原理"><a href="#2️⃣-Stop-Token-工作原理" class="headerlink" title="2️⃣ Stop Token 工作原理"></a>2️⃣ Stop Token 工作原理</h3><p><code>std::jthread</code> 内部持有一个 <strong><code>std::stop_source</code></strong> 对象，线程函数通过 <code>std::stop_token</code> 获取状态。</p>
<p>它们的关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────────────┐</span><br><span class="line">│     jthread t       │</span><br><span class="line">│  ├─ stop_source     │◀─────────────┐</span><br><span class="line">│  └─ thread handle   │              │</span><br><span class="line">└─────────────────────┘              │</span><br><span class="line">                                     │</span><br><span class="line">                      ┌──────────────┘</span><br><span class="line">                      ▼</span><br><span class="line">                stop_token（传给线程函数）</span><br></pre></td></tr></table></figure>

<p>当 <code>t.request_stop()</code> 被调用时：</p>
<ul>
<li><code>stop_source</code> 标记为已停止；</li>
<li>所有通过该 token 获取的线程都能检测到 <code>stop_requested()</code> 返回 <code>true</code>；</li>
<li>从而线程函数可以优雅地结束。</li>
</ul>
<hr>
<h3 id="3️⃣-Stop-Callback（注册回调函数）"><a href="#3️⃣-Stop-Callback（注册回调函数）" class="headerlink" title="3️⃣ Stop Callback（注册回调函数）"></a>3️⃣ Stop Callback（注册回调函数）</h3><p>你还可以注册一个回调，当停止请求发生时自动执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::stop_callback <span class="title">cb</span><span class="params">(st, [] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Stop requested! Cleaning up...\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Running...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">300</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">t</span><span class="params">(worker)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    t.<span class="built_in">request_stop</span>();  <span class="comment">// 会触发回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Running...</span><br><span class="line">Running...</span><br><span class="line">Running...</span><br><span class="line">Stop requested! Cleaning up...</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧮-五、构造和移动"><a href="#🧮-五、构造和移动" class="headerlink" title="🧮 五、构造和移动"></a>🧮 五、构造和移动</h2><p><code>std::jthread</code> 和 <code>std::thread</code> 一样：</p>
<ul>
<li>不可复制（<code>=delete</code>）</li>
<li>但可以移动</li>
</ul>
<h3 id="✅-移动示例"><a href="#✅-移动示例" class="headerlink" title="✅ 移动示例"></a>✅ 移动示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::jthread <span class="title">t1</span><span class="params">([] &#123; std::cout &lt;&lt; <span class="string">&quot;Thread 1\n&quot;</span>; &#125;)</span></span>;</span><br><span class="line">std::jthread t2 = std::<span class="built_in">move</span>(t1);  <span class="comment">// 所有权转移</span></span><br></pre></td></tr></table></figure>

<p>移动后：</p>
<ul>
<li><code>t1</code> 变为空线程；</li>
<li><code>t2</code> 接管原先的执行任务。</li>
</ul>
<hr>
<h2 id="🔧-六、典型应用场景"><a href="#🔧-六、典型应用场景" class="headerlink" title="🔧 六、典型应用场景"></a>🔧 六、典型应用场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th><code>std::thread</code></th>
<th><code>std::jthread</code> 优势</th>
</tr>
</thead>
<tbody><tr>
<td>启动线程执行任务</td>
<td>✅</td>
<td>✅ 自动 join，安全性更高</td>
</tr>
<tr>
<td>周期性工作线程</td>
<td>✅</td>
<td>✅ 支持 stop_token，易于终止</td>
</tr>
<tr>
<td>线程池或任务调度</td>
<td>⚠️ 需自管停止标志</td>
<td>✅ 内置可中断机制</td>
</tr>
<tr>
<td>异常路径安全退出</td>
<td>❌ 需显式 join&#x2F;detach</td>
<td>✅ RAII 自动清理</td>
</tr>
</tbody></table>
<hr>
<h2 id="⚠️-七、注意事项"><a href="#⚠️-七、注意事项" class="headerlink" title="⚠️ 七、注意事项"></a>⚠️ 七、注意事项</h2><ol>
<li><p><code>std::jthread</code> 析构时 <strong>自动 join</strong>（阻塞等待线程结束），<br>如果线程还在执行，主线程会阻塞，直到线程退出。</p>
</li>
<li><p>如果你不希望阻塞，可以：</p>
<ul>
<li>调用 <code>t.detach()</code>；</li>
<li>或提前调用 <code>t.request_stop()</code> 并等待线程结束。</li>
</ul>
</li>
<li><p><code>std::jthread</code> 的中断机制是 <strong>协作式的</strong>，<br>它不会强制中止线程，只能通知线程 <strong>“该停了”</strong>，<br>线程函数需要自己定期检查 <code>stop_token</code>。</p>
</li>
</ol>
<hr>
<h2 id="🧩-八、完整示例：优雅停止的后台任务"><a href="#🧩-八、完整示例：优雅停止的后台任务" class="headerlink" title="🧩 八、完整示例：优雅停止的后台任务"></a>🧩 八、完整示例：优雅停止的后台任务</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">background_task</span><span class="params">(std::stop_token st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">stop_requested</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing background work...\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Gracefully stopping background work.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::jthread <span class="title">worker</span><span class="params">(background_task)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Requesting stop...\n&quot;</span>;</span><br><span class="line">    worker.<span class="built_in">request_stop</span>();  <span class="comment">// 优雅地请求停止</span></span><br><span class="line">&#125;  <span class="comment">// 离开作用域自动 join</span></span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Doing background work...</span><br><span class="line">Doing background work...</span><br><span class="line">Doing background work...</span><br><span class="line">Requesting stop...</span><br><span class="line">Gracefully stopping background work.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-九、总结对比表"><a href="#✅-九、总结对比表" class="headerlink" title="✅ 九、总结对比表"></a>✅ 九、总结对比表</h2><table>
<thead>
<tr>
<th>功能</th>
<th><code>std::thread</code></th>
<th><code>std::jthread</code></th>
</tr>
</thead>
<tbody><tr>
<td>析构时自动 join</td>
<td>❌ 否</td>
<td>✅ 是</td>
</tr>
<tr>
<td>可请求停止</td>
<td>❌ 否</td>
<td>✅ 是（stop_token）</td>
</tr>
<tr>
<td>RAII 管理</td>
<td>⚠️ 手动 join&#x2F;detach</td>
<td>✅ 自动</td>
</tr>
<tr>
<td>安全性</td>
<td>需谨慎管理</td>
<td>安全，不易出错</td>
</tr>
<tr>
<td>中断控制</td>
<td>外部变量标志</td>
<td>内建 stop 机制</td>
</tr>
<tr>
<td>推荐场景</td>
<td>性能极端要求时</td>
<td>绝大多数实际应用</td>
</tr>
</tbody></table>
<p>虽然 detach 后还能调用 <code>request_stop()</code>，但要理解一些<strong>边界行为</strong>：</p>
<h3 id="1️⃣-如果线程已经退出，request-stop-只是无效操作"><a href="#1️⃣-如果线程已经退出，request-stop-只是无效操作" class="headerlink" title="1️⃣ 如果线程已经退出，request_stop() 只是无效操作"></a>1️⃣ 如果线程已经退出，<code>request_stop()</code> 只是无效操作</h3><ul>
<li><code>std::stop_source::request_stop()</code> 是幂等的；</li>
<li>如果线程已经结束，它什么也不会做；</li>
<li>不会抛异常，不会报错。</li>
</ul>
<p>也就是说，你可以安全地在任何时候调用 <code>request_stop()</code>，只不过可能不会再影响任何线程。</p>
<p>虽然这里jthread有点像协程，但是完全不一样，jthread stop之后就再也无法恢复了</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>vector与array</title>
    <url>/2025/06/30/vector%E4%B8%8Earray/</url>
    <content><![CDATA[<h1 id="vector-与-array-的区别"><a href="#vector-与-array-的区别" class="headerlink" title="vector 与 array 的区别"></a><code>vector</code> 与 <code>array</code> 的区别</h1><p>以下是 C++ 中 <code>std::vector</code> 和 <code>std::array</code> 的区别，涵盖定义、特点、性能和使用场景等方面。</p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h2><ul>
<li>**<code>std::vector</code>**：<ul>
<li>动态数组，来自 <code>&lt;vector&gt;</code> 头文件。</li>
<li>可以在运行时动态调整大小，支持插入、删除元素。</li>
<li>基于堆内存分配，容量不足时自动扩容。</li>
</ul>
</li>
<li>**<code>std::array</code>**：<ul>
<li>固定大小数组，来自 <code>&lt;array&gt;</code> 头文件（C++11 引入）。</li>
<li>封装了 C 风格数组，长度在编译时确定，无法动态改变。</li>
<li>通常分配在栈上（或静态存储区）。</li>
</ul>
</li>
</ul>
<h2 id="2-主要区别"><a href="#2-主要区别" class="headerlink" title="2. 主要区别"></a>2. <strong>主要区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>std::vector</code></th>
<th><code>std::array</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>大小</strong></td>
<td>动态大小，可通过 <code>resize</code>、<code>push_back</code> 等调整</td>
<td>固定大小，编译时确定</td>
</tr>
<tr>
<td><strong>内存分配</strong></td>
<td>堆内存，动态分配</td>
<td>栈内存（通常）或静态存储区</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>访问速度快，但扩容&#x2F;重新分配有开销</td>
<td>访问速度快，无动态分配开销</td>
</tr>
<tr>
<td><strong>容量管理</strong></td>
<td>支持 <code>capacity</code> 和 <code>reserve</code>，可预分配空间</td>
<td>无容量概念，大小固定</td>
</tr>
<tr>
<td><strong>接口</strong></td>
<td>丰富（如 <code>push_back</code>、<code>pop_back</code>、<code>insert</code>）</td>
<td>简单（如 <code>at</code>、<code>size</code>、迭代器支持）</td>
</tr>
<tr>
<td><strong>边界检查</strong></td>
<td><code>at</code> 方法提供边界检查，<code>[]</code> 不检查</td>
<td><code>at</code> 方法提供边界检查，<code>[]</code> 不检查</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>额外存储大小、容量等元数据</td>
<td>无额外开销，仅存储元素</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>支持默认构造、初始化列表、填充等</td>
<td>支持初始化列表，需指定大小</td>
</tr>
</tbody></table>
<h2 id="3-详细对比"><a href="#3-详细对比" class="headerlink" title="3. 详细对比"></a>3. <strong>详细对比</strong></h2><ul>
<li><strong>大小与容量</strong>：<ul>
<li><code>vector</code>：大小（<code>size</code>）和容量（<code>capacity</code>）分离，容量不足时自动扩容（通常翻倍），可能触发内存重新分配。</li>
<li><code>array</code>：大小固定，编译时由模板参数指定（如 <code>std::array&lt;int, 5&gt;</code>），无法改变。</li>
</ul>
</li>
<li><strong>内存管理</strong>：<ul>
<li><code>vector</code>：动态分配在堆上，扩容可能导致数据拷贝，适合动态场景。</li>
<li><code>array</code>：固定分配在栈上（或静态存储区），内存效率高，适合小规模固定数据。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li>两者访问元素（<code>[]</code> 或 <code>at</code>）时间复杂度为 ( O(1) )。</li>
<li><code>vector</code> 的 <code>push_back</code> 为平摊 ( O(1) )，但扩容时为 ( O(n) )。</li>
<li><code>array</code> 无动态操作，性能更可预测。</li>
</ul>
</li>
<li><strong>灵活性</strong>：<ul>
<li><code>vector</code> 提供动态操作（如插入、删除），适合大小不确定的场景。</li>
<li><code>array</code> 适合大小固定的场景，提供更严格的类型安全和固定内存布局。</li>
</ul>
</li>
<li><strong>安全性</strong>：<ul>
<li>两者均支持 <code>at</code> 方法进行边界检查，抛出 <code>std::out_of_range</code> 异常。</li>
<li><code>[]</code> 操作符不检查边界，可能导致未定义行为。</li>
</ul>
</li>
<li><strong>初始化</strong>：<ul>
<li><code>vector</code>：支持多种初始化方式，如 <code>std::vector&lt;int&gt; v = &#123;1, 2, 3&#125;;</code> 或 <code>v.resize(5, 0);</code>。</li>
<li><code>array</code>：需指定大小，如 <code>std::array&lt;int, 3&gt; a = &#123;1, 2, 3&#125;;</code>，不足部分自动填充默认值（通常为 0）。</li>
</ul>
</li>
</ul>
<h2 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. <strong>代码示例</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector 示例</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">4</span>); <span class="comment">// 动态添加元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;, capacity: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vec) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 3 4</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array 示例</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// arr.push_back(4); // 错误：array 大小固定</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array size: &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : arr) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: 1 2 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界检查</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">10</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vector out of range\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. <strong>使用场景</strong></h2><ul>
<li>**<code>vector</code>**：<ul>
<li>需要动态调整大小（如列表、缓冲区）。</li>
<li>数据量不确定或可能增长。</li>
<li>典型场景：动态列表、堆栈、队列的底层实现。</li>
</ul>
</li>
<li>**<code>array</code>**：<ul>
<li>大小固定且已知（如矩阵、配置文件）。</li>
<li>追求性能和内存效率。</li>
<li>典型场景：小型固定数据集、替换 C 风格数组。</li>
</ul>
</li>
</ul>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h2><ul>
<li>**<code>vector</code>**：动态、灵活，适合大小可变场景，但有内存管理开销。</li>
<li>**<code>array</code>**：固定、轻量，适合大小确定且追求效率的场景。</li>
<li>选择时需权衡灵活性与性能，<code>vector</code> 更通用，<code>array</code> 更高效且安全。</li>
</ul>
<p>如需更具体的使用场景或优化建议，请提供进一步细节！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手与四次挥手</title>
    <url>/2025/06/09/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p>三次握手和四次挥手是计算机网络中鼎鼎大名的面试题，今天主播也来回答下</p>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>首先是握手的过程</p>
<p>1.客户端随机生成序列号，然后把序列号seq&#x3D;x放进SYN报文，发送给服务端，客户端进入syn_sent阶段</p>
<p>2.服务端接收到SYN报文之后，确认ack&#x3D;x+1，以及自己的seq&#x3D;y，发送syn+ack报文，服务端进入syn_rcvd阶段</p>
<p>3.客户端收到syn+ack报文之后，将ack&#x3D;y+1，发送ack报文，自身进入established阶段</p>
<p>4.服务端收到ack报文，也进入established阶段</p>
<p>tips:第三次握手是可以携带数据的，前两次不可以（因为通信能力和连接还未确定可靠，而第三次携带一些数据可以减少RTT次数，比如发送http请求）</p>
<h2 id="那么为什么需要三次握手呢？"><a href="#那么为什么需要三次握手呢？" class="headerlink" title="那么为什么需要三次握手呢？"></a>那么为什么需要三次握手呢？</h2><h3 id="1-确保双向通信能力"><a href="#1-确保双向通信能力" class="headerlink" title="1. 确保双向通信能力"></a>1. 确保双向通信能力</h3><p>TCP 是全双工协议，允许数据在客户端和服务器之间双向传输。三次握手通过以下步骤验证双方的发送和接收能力：</p>
<ul>
<li><strong>第一次（SYN）</strong>：客户端发送 SYN 包（seq&#x3D;x），证明客户端能发送数据，服务器能接收。</li>
<li><strong>第二次（SYN-ACK）</strong>：服务器响应 SYN-ACK 包（seq&#x3D;y, ack&#x3D;x+1），证明服务器能接收客户端的包（通过 ack&#x3D;x+1 确认），也能发送数据（通过 SYN 和 seq&#x3D;y）。</li>
<li><strong>第三次（ACK）</strong>：客户端发送 ACK 包（ack&#x3D;y+1），证明客户端能接收服务器的包，并确认服务器的发送能力。</li>
</ul>
<p>三次交互确保双方都能发送和接收数据，建立可靠的双向通信通道。如果只有两次握手（SYN 和 SYN-ACK），客户端无法确认服务器是否正确接收了自己的确认，导致单向通信可能未完全验证。</p>
<h3 id="2-同步序列号"><a href="#2-同步序列号" class="headerlink" title="2. 同步序列号"></a>2. 同步序列号</h3><p>TCP 使用序列号（Sequence Number）和确认号（Acknowledgment Number）来跟踪数据段的顺序，确保数据不丢失、不重复、不乱序。三次握手用于同步双方的初始序列号（ISN，Initial Sequence Number）：</p>
<ul>
<li>客户端发送 seq&#x3D;x（其初始序列号）。</li>
<li>服务器确认 ack&#x3D;x+1，并发送自己的 seq&#x3D;y。</li>
<li>客户端确认 ack&#x3D;y+1。</li>
</ul>
<p>通过三次交互，双方明确对方的初始序列号，并为后续数据传输建立基准。这防止数据错序或重复，尤其在网络不稳定时（如包丢失或延迟）。</p>
<p><strong>为什么需要同步？</strong><br>序列号是 TCP 可靠性的核心。例如，若客户端发送数据段 seq&#x3D;1000，服务器需通过 ack&#x3D;1001 确认收到。若序列号未同步，服务器可能误解数据位置，导致传输错误。</p>
<h3 id="3-防止旧连接的干扰"><a href="#3-防止旧连接的干扰" class="headerlink" title="3.防止旧连接的干扰"></a>3.防止旧连接的干扰</h3><p>由于拥塞问题，网络中可能存在延迟或者重复的旧连接，三次握手可以通过序列号和状态机管理防止建立重复建立连接</p>
<p>比如客户端向服务端发送syn报文由于延迟得不到ack回应，就多次发送syn报文</p>
<p>服务端可能率先接收到旧报文，就会发送syn+ack报文作为响应。ack&#x3D;old_x,seq&#x3D;y</p>
<p>客户端收到后发现这是旧连接，就发送rst报文表示中止这次连接。服务端就释放此次连接，等待新的syn报文送达</p>
<p><strong>如果这里是两次握手，客户端无法向服务端说明这是旧连接，服务端每接受到一个syn报文，就得发送一个syn+ack报文，导致建立多个冗余无效链接，造成资源浪费</strong></p>
<h4 id="半连接队列（SYN队列"><a href="#半连接队列（SYN队列" class="headerlink" title="半连接队列（SYN队列)"></a>半连接队列（SYN队列)</h4><p>服务端对于客户端发送的SYN报文，会建立一个连接，但因为没有完全建立，就存储在这个队列，方便后续可能的连接释放或者移入全连接队列（accept 队列）。也有针对syn队列的攻击</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>在挥手之前，双方都处于established状态，而且我们假设主动关闭方是客户端，被动关闭方是服务端</p>
<p>1.第一次挥手：客户端发送FIN报文，seq&#x3D;x，表示无数据发送，通知服务端可以关闭了，客户端变为final_wait_1状态</p>
<p>2.第二次挥手：服务端接收到FIN报文，发送ack报文，ack&#x3D;x+1,seq&#x3D;y，服务端变为close_wait状态，继续进行最后的发送，客户端接收后变为final_wait_2状态</p>
<p>3.第三次挥手：服务端发送FIN报文，seq&#x3D;y,ack&#x3D;x+1，表示自己也没有数据发送，变为last_ack状态</p>
<p>4.第四次挥手：客户端接受到FIN报文后，发送ack报文，ack&#x3D;y+1，客户端进入TIME_WAIT状态，并开始等待。服务端接收到ack报文后变为close状态。</p>
<p>客户端在等待2MSL之后，也进入close状态。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>双向关闭</strong>：每个方向的关闭需单独确认，确保数据传输完成。</li>
<li><strong>TIME_WAIT</strong>：主动关闭方发送最后 ACK 后进入 TIME_WAIT 状态（通常 2MSL，约 2-4 分钟），防止旧包干扰。</li>
<li><strong>可靠终止</strong>：确保双方都完成数据发送，避免数据丢失。</li>
</ul>
<h2 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h2><p>客户端处于final_wait_1&#x2F;2时，只是不发送数据了，但是依然能接收到来自服务端的最后的数据，而服务端的关闭不是一蹴而就的，需要把手头上最后的事务处理完之后，才能休息。所以比起握手，挥手要多一次</p>
<h2 id="为什么要有TIME-WAIT状态？"><a href="#为什么要有TIME-WAIT状态？" class="headerlink" title="为什么要有TIME_WAIT状态？"></a>为什么要有TIME_WAIT状态？</h2><p>主动发起关闭的一方，才会有TIME_WAIT状态。</p>
<p>之所以主动关闭的一方，发送完ack报文之后不直接进入close状态，而是在TIME_WAIT状态等待2个WSL，有两个原因：</p>
<p>第一，防止历史连接中的数据，被后面相同四元组的连接错误的接收</p>
<p>如果发生了网络拥塞或者延迟，来自服务端的数据包可能在网络中滞留，如果直接关闭，没有客户端接收，这个数据包就会发给新连接，导致新连接被旧连接干扰。</p>
<p>第二，保证服务端能正确的接收到最后的ack报文。</p>
<p>如果客户端直接进入close状态，而最后的ack报文丢失，服务器一直等待，最后超时，就会重发FIN报文。而已经close的客户端，接受到这个FIN报文，就会发送RST报文，服务端接收到这个RST报文，就会把其解释为一个错误。为了避免这个情况，客户端就必须等待足够长的时间，确保服务端接收到，如果没有接收到，就重新发送FIN和ACK报文，一来一回的时间正好是2个MSL(即客户端到服务端的时间，指客户端第一次发送给服务端的ack加上服务端重传的FIN一共两个msl)</p>
<h2 id="为什么是两个MSL"><a href="#为什么是两个MSL" class="headerlink" title="为什么是两个MSL?"></a>为什么是两个MSL?</h2><p>MSL是报文最大生存时间，超过这个时间任何报文均会被丢弃</p>
<ol>
<li><p><strong>覆盖一个往返时间</strong>：</p>
<ul>
<li>2MSL 等于一个数据包从发送到接收的最大时间（MSL）加上返回确认的最大时间（MSL）。这确保最后一次 ACK 有足够时间到达被动关闭方，且任何延迟的 FIN 重传都能被处理。当客户端在TIME_WAIT状态接收到重传的FIN报文后，会重置2MSL时间</li>
</ul>
</li>
<li><p><strong>清理网络中的旧包</strong>：</p>
<ul>
<li>TCP 数据包可能因网络路由延迟而滞留。2MSL 确保旧连接的所有数据包（包括 FIN 或其他延迟包）在网络中超时失效，避免干扰新连接。</li>
</ul>
</li>
<li><h5 id="如果比2MSL更长就会占用内存资源和端口，造成资源的浪费"><a href="#如果比2MSL更长就会占用内存资源和端口，造成资源的浪费" class="headerlink" title="如果比2MSL更长就会占用内存资源和端口，造成资源的浪费"></a>如果比2MSL更长就会占用内存资源和端口，造成资源的浪费</h5></li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历访问的实现</title>
    <url>/2024/09/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我们从小学二年级开始，就学过二叉树了（bushi）</p>
<p>那么，如何用编程实现二叉树的遍历呢？</p>
<p>（这里使用c艹）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二叉树的每个结点都是如此定义的</p>
<h1 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h1><h5 id="分为前序，中序，后序三种遍历方法。"><a href="#分为前序，中序，后序三种遍历方法。" class="headerlink" title="分为前序，中序，后序三种遍历方法。"></a>分为前序，中序，后序三种遍历方法。</h5><p>前序是从根结点开始，访问到最左侧第一个叶子结点后，访问右侧叶子，然后返回上一级（不访问），访问同级右侧结点，然后往下按照先左后右的顺序访问，等左子树访问完毕后，访问右子树。</p>
<p>中序是从左侧第一个叶子结点开始，返回上一级（访问），下一级右侧，返回上上级，右侧最下方左侧结点，然后返回上一级（访问），以此类推。</p>
<p>后序是按从左到右的顺序，左侧第一个叶子结点开始，访问完上一级结点左侧后，去右侧，然后返回上一级。</p>
<h5 id="每种遍历方法又分为递归和非递归两种"><a href="#每种遍历方法又分为递归和非递归两种" class="headerlink" title="每种遍历方法又分为递归和非递归两种"></a>每种遍历方法又分为递归和非递归两种</h5><h2 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h2><h3 id="1-前序遍历（非递归）"><a href="#1-前序遍历（非递归）" class="headerlink" title="1. 前序遍历（非递归）"></a>1. 前序遍历（非递归）</h3><p>前序遍历的顺序是：根节点 -&gt; 左子树 -&gt; 右子树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; result; // 存储遍历结果</span><br><span class="line">    if (!root) return result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk; // 辅助栈</span><br><span class="line">    stk.push(root);       // 首先将根节点入栈</span><br><span class="line"></span><br><span class="line">    while (!stk.empty()) &#123;</span><br><span class="line">        TreeNode* node = stk.top();  // 获取栈顶元素</span><br><span class="line">        stk.pop();                   // 弹出栈顶元素</span><br><span class="line">        result.push_back(node-&gt;val); // 访问节点（加入结果）</span><br><span class="line"></span><br><span class="line">        // 先压右子节点，再压左子节点，保证左子节点先处理</span><br><span class="line">        if (node-&gt;right) stk.push(node-&gt;right);</span><br><span class="line">        if (node-&gt;left) stk.push(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历（非递归）"><a href="#2-中序遍历（非递归）" class="headerlink" title="2. 中序遍历（非递归）"></a>2. 中序遍历（非递归）</h3><p>中序遍历的顺序是：左子树 -&gt; 根节点 -&gt; 右子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 遍历到最左节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        current = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">// 转向右子树</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong>：创建一个栈来存储节点，并将当前节点指向根节点。</p>
<p><strong>遍历左子树</strong>：使用一个 <code>while</code> 循环，持续将当前节点的左子节点压入栈中，直到当前节点为 <code>NULL</code>。这一步实际上是在找到最左侧的节点。</p>
<p><strong>处理节点</strong>：当当前节点为 <code>NULL</code> 且栈不为空时，弹出栈顶节点，输出该节点的值。这就是中序遍历的核心步骤。</p>
<p><strong>转向右子树</strong>：将当前节点更新为弹出的节点的右子节点，继续上述过程。</p>
<p><strong>结束条件</strong>：当当前节点为 <code>NULL</code> 且栈为空时，遍历结束。</p>
<h3 id="3-后序遍历（非递归）"><a href="#3-后序遍历（非递归）" class="headerlink" title="3. 后序遍历（非递归）"></a>3. 后序遍历（非递归）</h3><p>后序遍历的顺序是：左子树 -&gt; 右子树 -&gt; 根节点。</p>
<p>后序遍历的非递归实现较复杂，可以使用两个栈来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">    stk<span class="number">1.</span><span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个栈，stk1用于遍历，stk2用于存储结果</span></span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = stk<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">        stk<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        stk<span class="number">2.</span><span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子节点和右子节点按顺序压入stk1</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) stk<span class="number">1.</span><span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) stk<span class="number">1.</span><span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将stk2中的节点依次弹出到结果中</span></span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(stk<span class="number">2.</span><span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        stk<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三种非递归遍历方法使用栈来模拟递归调用的过程，顺序不同是由于每种遍历访问节点的顺序不同。</p>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>递归算法是一种非常常见且简单的二叉树遍历实现方式，它依赖函数调用栈的隐式机制来完成节点的访问。在二叉树的递归遍历中，递归函数会按照特定的顺序调用自身来遍历树的各个节点。</p>
<h3 id="1-前序遍历（递归）"><a href="#1-前序遍历（递归）" class="headerlink" title="1. 前序遍历（递归）"></a>1. 前序遍历（递归）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>前序遍历的顺序是：<strong>先访问根节点</strong>，再访问左子树，最后访问右子树。</p>
<p>前序遍历顺序：</p>
<ul>
<li>根节点 -&gt; 左子树 -&gt; 右子树。</li>
</ul>
<h4 id="递归算法步骤"><a href="#递归算法步骤" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>先访问当前节点（根节点）。</li>
<li>递归访问左子树。</li>
<li>递归访问右子树。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                  <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);         <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">preorderTraversal</span>(root-&gt;left, result); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">preorderTraversal</span>(root-&gt;right, result); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明"><a href="#过程说明" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先访问根节点 <code>1</code>，然后递归访问它的右子节点 <code>2</code>。</li>
<li>访问 <code>2</code> 后，递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问 <code>3</code> 后，没有更多节点，递归结束。</li>
</ul>
<p>最终前序遍历的结果为 <code>[1, 2, 3]</code>。</p>
<hr>
<h3 id="2-中序遍历（递归）"><a href="#2-中序遍历（递归）" class="headerlink" title="2. 中序遍历（递归）"></a>2. 中序遍历（递归）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>中序遍历的顺序是：<strong>先访问左子树</strong>，然后访问根节点，最后访问右子树。</p>
<p>中序遍历顺序：</p>
<ul>
<li>左子树 -&gt; 根节点 -&gt; 右子树。</li>
</ul>
<h4 id="递归算法步骤-1"><a href="#递归算法步骤-1" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>递归访问左子树。</li>
<li>访问当前节点（根节点）。</li>
<li>递归访问右子树。</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                    <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;left, result);   <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);            <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;right, result);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明-1"><a href="#过程说明-1" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先递归访问 <code>1</code> 的左子树，但为空，直接访问根节点 <code>1</code>。</li>
<li>然后递归访问右子树，从 <code>2</code> 开始，递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问完 <code>3</code>，回到 <code>2</code>，访问 <code>2</code>。</li>
</ul>
<p>最终中序遍历的结果为 <code>[1, 3, 2]</code>。</p>
<hr>
<h3 id="3-后序遍历（递归）"><a href="#3-后序遍历（递归）" class="headerlink" title="3. 后序遍历（递归）"></a>3. 后序遍历（递归）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>后序遍历的顺序是：<strong>先访问左子树</strong>，再访问右子树，最后访问根节点。</p>
<p>后序遍历顺序：</p>
<ul>
<li>左子树 -&gt; 右子树 -&gt; 根节点。</li>
</ul>
<h4 id="递归算法步骤-2"><a href="#递归算法步骤-2" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>递归访问左子树。</li>
<li>递归访问右子树。</li>
<li>访问当前节点（根节点）。</li>
</ol>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                    <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left, result);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;right, result); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);             <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明-2"><a href="#过程说明-2" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先递归访问 <code>1</code> 的左子树，空节点返回。</li>
<li>然后递归访问 <code>1</code> 的右子节点 <code>2</code>，继续递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问 <code>3</code> 后返回，访问 <code>2</code> 后返回，最后访问根节点 <code>1</code>。</li>
</ul>
<p>最终后序遍历的结果为 <code>[3, 2, 1]</code>。</p>
<hr>
<h3 id="递归遍历的工作原理"><a href="#递归遍历的工作原理" class="headerlink" title="递归遍历的工作原理"></a>递归遍历的工作原理</h3><p>递归遍历的核心思想是利用系统调用栈隐式地保存当前节点的状态，并通过函数的自我调用完成对二叉树各个节点的遍历。在每一次递归调用时，栈帧会记录当前函数的上下文（包括参数和本地变量），当递归返回时，栈帧会恢复之前的状态。因此，递归算法中不需要显式地使用栈结构来保存节点状态，递归的函数调用本身就是栈的模拟。</p>
<h1 id="通过遍历确定二叉树"><a href="#通过遍历确定二叉树" class="headerlink" title="通过遍历确定二叉树"></a>通过遍历确定二叉树</h1><p>首先，一种遍历是肯定不能的</p>
<p>前序遍历＋后序也不能</p>
<p>但中序＋任意就可以</p>
<p>下面是后序和中序的一个例子</p>
<p>给定二叉树的<strong>后序遍历</strong>和<strong>中序遍历</strong>，可以确定这棵二叉树的结构。</p>
<ul>
<li><strong>后序遍历</strong>：<code>dabec</code></li>
<li><strong>中序遍历</strong>：<code>debac</code></li>
</ul>
<h3 id="重建二叉树的步骤"><a href="#重建二叉树的步骤" class="headerlink" title="重建二叉树的步骤"></a>重建二叉树的步骤</h3><ol>
<li><p><strong>后序遍历的特点</strong>：后序遍历的最后一个节点是根节点。因此，通过后序遍历可以找到二叉树的根节点。</p>
<ul>
<li>在后序遍历 <code>dabec</code> 中，最后一个元素 <code>c</code> 是二叉树的根节点。</li>
</ul>
</li>
<li><p><strong>在中序遍历中找到根节点</strong>：通过中序遍历，可以将二叉树分为左子树和右子树。</p>
<ul>
<li>中序遍历是 <code>debac</code>，根节点 <code>c</code> 在中序遍历中的位置是最后一位，因此 <code>deba</code> 是左子树，右子树为空。</li>
</ul>
</li>
<li><p><strong>递归构建左子树</strong>：</p>
<ul>
<li>左子树的中序遍历是 <code>deba</code>，左子树的后序遍历是 <code>dabe</code>（从后序遍历中取去掉根节点的部分）。</li>
<li>继续对 <code>dabe</code> 和 <code>deba</code> 递归构建。</li>
</ul>
</li>
<li><p><strong>对左子树进行递归构建</strong>：</p>
<ul>
<li>在后序遍历 <code>dabe</code> 中，最后一个元素 <code>e</code> 是左子树的根节点。</li>
<li>在中序遍历 <code>deba</code> 中，根节点 <code>e</code> 的位置将 <code>d</code> 和 <code>ba</code> 分为左右子树，左子树为 <code>d</code>，右子树为 <code>ba</code>。</li>
</ul>
</li>
<li><p><strong>递归构建左子树和右子树</strong>：</p>
<ul>
<li>对左子树 <code>d</code>，中序遍历和后序遍历均为 <code>d</code>，因此它是叶子节点。</li>
<li>对右子树 <code>ba</code>：<ul>
<li>在后序遍历 <code>ba</code> 中，根节点是 <code>a</code>，剩下的 <code>b</code> 是它的左子树。</li>
<li>对左子树 <code>b</code>，中序遍历和后序遍历均为 <code>b</code>，因此它是叶子节点。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="最终二叉树的结构"><a href="#最终二叉树的结构" class="headerlink" title="最终二叉树的结构"></a>最终二叉树的结构</h3><p>将上述步骤的结果组合在一起，二叉树的形状如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    c</span><br><span class="line">   /</span><br><span class="line">  e</span><br><span class="line"> / \</span><br><span class="line">d   a</span><br><span class="line">   /</span><br><span class="line">  b</span><br></pre></td></tr></table></figure>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul>
<li>根节点是 <code>c</code>，它的左子树是 <code>e</code>。</li>
<li>节点 <code>e</code> 的左子树是 <code>d</code>，右子树是 <code>a</code>。</li>
<li>节点 <code>a</code> 有一个左子树 <code>b</code>，而 <code>b</code> 和 <code>d</code> 都是叶子节点。</li>
</ul>
<p>通过后序遍历和中序遍历，我们成功地重建了这棵二叉树。</p>
<hr>
<h1 id="递归-vs-非递归"><a href="#递归-vs-非递归" class="headerlink" title="递归 vs. 非递归"></a>递归 vs. 非递归</h1><ol>
<li><p><strong>递归遍历</strong>：</p>
<ul>
<li>简洁且符合思维逻辑。</li>
<li>利用系统调用栈来管理递归状态，不需要手动维护栈。</li>
<li>如果树的深度较深，递归深度过大会导致栈溢出。</li>
</ul>
</li>
<li><p><strong>非递归遍历</strong>：</p>
<ul>
<li>使用显式栈来模拟递归，避免了函数调用的开销。</li>
<li>更加适合处理非常深的树，避免了递归栈溢出的问题。</li>
<li>实现较为复杂，尤其是后序遍历，需要用到两个栈。</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>递归遍历是通过系统调用栈隐式地实现节点状态的保存与恢复，而非递归遍历则通过显式的栈来模拟递归过程。选择递归或非递归方法通常取决于具体应用场景以及对性能和栈深度的要求。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>tls/ssl握手</title>
    <url>/2025/06/24/tls-ssl%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h3 id="HTTPS-详细介绍"><a href="#HTTPS-详细介绍" class="headerlink" title="HTTPS 详细介绍"></a>HTTPS 详细介绍</h3><p>HTTPS（超文本传输协议安全版，Hypertext Transfer Protocol Secure）是HTTP的加密版本，通过在HTTP和传输层之间引入SSL&#x2F;TLS（安全套接字层&#x2F;传输层安全协议）提供安全性。HTTPS旨在确保数据传输的<strong>保密性</strong>、<strong>完整性</strong>和<strong>身份验证</strong>，广泛应用于需要保护用户数据的场景，如在线银行、电子商务和敏感信息传输。</p>
<hr>
<h3 id="HTTPS-与-HTTP-的不同"><a href="#HTTPS-与-HTTP-的不同" class="headerlink" title="HTTPS 与 HTTP 的不同"></a><strong>HTTPS 与 HTTP 的不同</strong></h3><ol>
<li><strong>加密</strong>：<ul>
<li><strong>HTTP</strong>：数据以明文传输，容易被拦截和篡改。</li>
<li><strong>HTTPS</strong>：通过SSL&#x2F;TLS加密数据，保护通信内容，防止窃听和中间人攻击。</li>
</ul>
</li>
<li><strong>安全性</strong>：<ul>
<li><strong>HTTP</strong>：无身份验证，客户端无法确认服务器身份，易受DNS劫持或伪造服务器攻击。</li>
<li><strong>HTTPS</strong>：通过SSL&#x2F;TLS证书验证服务器身份，确保通信对象可信。</li>
</ul>
</li>
<li><strong>默认端口</strong>：<ul>
<li><strong>HTTP</strong>：默认使用80端口。</li>
<li><strong>HTTPS</strong>：默认使用443端口。</li>
</ul>
</li>
<li><strong>协议栈</strong>：<ul>
<li><strong>HTTP</strong>：直接运行在TCP之上。</li>
<li><strong>HTTPS</strong>：在HTTP和TCP之间加入SSL&#x2F;TLS层，HTTP消息通过SSL&#x2F;TLS加密后在TCP上传输。</li>
</ul>
</li>
<li><strong>性能开销</strong>：<ul>
<li><strong>HTTP</strong>：无加密，传输速度较快，但不安全。</li>
<li><strong>HTTPS</strong>：加密和解密需要计算资源，握手过程增加延迟，但现代优化（如TLS 1.3、会话复用）已显著降低开销。</li>
</ul>
</li>
<li><strong>SEO 和浏览器支持</strong>：<ul>
<li><strong>HTTP</strong>：现代浏览器可能标记为“不安全”，影响用户信任和搜索引擎排名。</li>
<li><strong>HTTPS</strong>：被搜索引擎（如Google）优先排名，浏览器显示安全锁图标，增强用户信任。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="SSL-TLS-握手过程"><a href="#SSL-TLS-握手过程" class="headerlink" title="SSL&#x2F;TLS 握手过程"></a><strong>SSL&#x2F;TLS 握手过程</strong></h3><p>SSL&#x2F;TLS握手是建立HTTPS连接的核心步骤，用于协商加密算法、交换密钥并验证身份。以下是TLS 1.2和TLS 1.3的握手过程对比，重点介绍TLS 1.3（现代标准，性能更优）。</p>
<h4 id="TLS-1-3-握手过程"><a href="#TLS-1-3-握手过程" class="headerlink" title="TLS 1.3 握手过程"></a><strong>TLS 1.3 握手过程</strong></h4><p>TLS 1.3简化了握手流程，减少了往返时间（RTT），通常在1-RTT内完成（支持0-RTT的场景更高效）。以下是详细步骤：</p>
<ol>
<li><strong>Client Hello</strong>：<ul>
<li>客户端发送消息，包含：<ul>
<li>支持的TLS版本（例如TLS 1.3）。</li>
<li>支持的加密套件（如TLS_AES_256_GCM_SHA384）。</li>
<li>客户端生成的随机数（Client Random）。</li>
<li>密钥共享信息（通常是Diffie-Hellman参数或椭圆曲线参数，用于生成共享密钥）。</li>
<li>可选的会话ID或会话票据（用于会话复用）。</li>
<li>扩展字段（如SNI，服务器名称指示，用于虚拟主机）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Server Hello</strong>：<ul>
<li>服务器响应，包含：<ul>
<li>选定的TLS版本和加密套件。</li>
<li>服务器生成的随机数（Server Random）。</li>
<li>服务器的密钥共享信息（完成Diffie-Hellman密钥交换）。</li>
<li>服务器证书（包含公钥和身份信息，由受信任的CA签名）。</li>
<li>可选的会话票据（用于未来会话复用）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>密钥计算与验证</strong>：<ul>
<li>客户端和服务器使用交换的密钥共享信息计算共享密钥（通过Diffie-Hellman或椭圆曲线算法）。</li>
<li>客户端验证服务器证书（检查CA签名、证书链、域名匹配等）。</li>
<li>双方生成会话密钥，用于加密后续通信。</li>
</ul>
</li>
<li><strong>Finished 消息</strong>：<ul>
<li>客户端和服务器分别发送Finished消息，包含基于共享密钥的校验值，确认握手完整性。</li>
<li>握手完成后，双方开始加密通信。</li>
</ul>
</li>
<li><strong>0-RTT（可选）</strong>：<ul>
<li>如果客户端之前与服务器建立了会话（通过会话票据），可在Client Hello中直接发送加密数据（0-RTT模式）。</li>
<li>服务器使用存储的会话密钥解密数据，减少握手时间。</li>
<li>注意：0-RTT数据可能面临重放攻击风险，需谨慎使用。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是多态？</title>
    <url>/2025/06/16/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="编译时多态与运行时多态"><a href="#编译时多态与运行时多态" class="headerlink" title="编译时多态与运行时多态"></a>编译时多态与运行时多态</h2><hr>
<h3 id="1-编译时多态"><a href="#1-编译时多态" class="headerlink" title="1. 编译时多态"></a>1. 编译时多态</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><ul>
<li><strong>编译时多态</strong>（Static Polymorphism）是在<strong>编译阶段</strong>通过函数或操作的重载、模板等机制实现的多样化行为。</li>
<li>也称为<strong>静态多态</strong>，因为函数调用在编译时就绑定（静态绑定）。</li>
</ul>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li><strong>函数重载</strong>：根据参数类型或数量选择不同函数。</li>
<li><strong>运算符重载</strong>：自定义运算符行为。</li>
<li><strong>模板</strong>：通过模板参数生成不同类型的函数或类（模板特化）。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>效率高</strong>：编译时解析，无运行时开销。</li>
<li><strong>类型固定</strong>：需要在编译时确定调用类型。</li>
<li><strong>无虚函数</strong>：不涉及虚函数表（vtable，参考上下文）。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>);        <span class="comment">// 调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5.5</span>);      <span class="comment">// 调用 print(double)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;     <span class="comment">// 输出: 7 (int)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">4.5</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出: 8.0 (double)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-运行时多态"><a href="#2-运行时多态" class="headerlink" title="2. 运行时多态"></a>2. 运行时多态</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><ul>
<li><strong>运行时多态</strong>（Dynamic Polymorphism）是在<strong>运行阶段</strong>通过虚函数和继承实现的动态行为。</li>
<li>也称为<strong>动态多态</strong>，因为函数调用在运行时根据对象实际类型绑定（动态绑定）。</li>
</ul>
<h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li><strong>虚函数</strong>：通过 <code>virtual</code> 关键字声明，派生类重写基类虚函数（参考上下文）。</li>
<li><strong>基类指针或引用</strong>：指向派生类对象，动态调用对应函数。</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>灵活性高</strong>：支持动态类型，运行时决定行为。</li>
<li><strong>性能开销</strong>：涉及虚函数表（vtable）和虚函数表指针（vptr，参考上下文），增加内存和运行时查找成本。</li>
<li><strong>依赖继承</strong>：需通过类层次结构实现。</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func</span>(); <span class="comment">// 输出: Derived::func（运行时决定）</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-对比总结"><a href="#3-对比总结" class="headerlink" title="3. 对比总结"></a>3. 对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th>编译时多态</th>
<th>运行时多态</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现方式</strong></td>
<td>函数重载、模板、运算符重载</td>
<td>虚函数、继承</td>
</tr>
<tr>
<td><strong>绑定时间</strong></td>
<td>编译时（静态绑定）</td>
<td>运行时（动态绑定）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>无运行时开销，高效</td>
<td>有 vtable&#x2F;vptr 开销</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>类型需编译时确定</td>
<td>支持运行时动态类型</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>通用编程、模板库</td>
<td>多态对象、插件系统</td>
</tr>
</tbody></table>
<h4 id="与上下文联系"><a href="#与上下文联系" class="headerlink" title="与上下文联系"></a>与上下文联系</h4><ul>
<li><strong>虚函数</strong>（参考上下文）：运行时多态的核心，依赖 vtable 和 vptr（参考上下文）。</li>
<li><strong>虚继承</strong>（参考上下文）：与运行时多态无关，但可能在多态类层次中出现，需注意虚析构函数（参考上下文）。</li>
<li><strong>内存对齐</strong>（参考上下文）：运行时多态的 vptr 可能影响对象大小和对齐，编译时多态无此问题。</li>
</ul>
<hr>
<h3 id="4-综合示例"><a href="#4-综合示例" class="headerlink" title="4. 综合示例"></a>4. 综合示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时多态：模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Template: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时多态：虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译时多态</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>);     <span class="comment">// 输出: Template: 5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5.5</span>);   <span class="comment">// 输出: Template: 5.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行时多态</span></span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func</span>();  <span class="comment">// 输出: Derived::func</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是placement_new？</title>
    <url>/2025/06/07/%E4%BB%80%E4%B9%88%E6%98%AFplacement-new%EF%BC%9F/</url>
    <content><![CDATA[<p>昨天面试完,感觉自己有好多不足啊,亡羊补牢，女娲补天,哈哈哈</p>
<p>在 C++ 中，<strong>placement new</strong> 是一种特殊的 <code>new</code> 运算符变体，允许在预分配的内存地址上构造对象，而不分配新的内存。与标准 <code>new</code> 不同，placement new 仅负责调用构造函数，不负责分配内存。这使得它在需要精确控制内存分配的场景（如内存池、自定义容器或嵌入式系统）中非常有用。</p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h2><p>Placement new 是 <code>new</code> 运算符的一种重载形式，其核心思想是将对象的构造与内存分配分离。标准 <code>new</code> 运算符的工作流程是：</p>
<ol>
<li>通过 <code>operator new</code> 分配内存。</li>
<li>调用对象的构造函数初始化内存。</li>
</ol>
<p>而 placement new 跳过第一步，直接在用户提供的内存地址上调用构造函数。其标准语法定义在 <code>&lt;new&gt;</code> 头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code>：要构造的对象大小（通常由编译器自动传递）。</li>
<li><code>ptr</code>：用户提供的内存地址，用于构造对象。</li>
</ul>
<h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. <strong>语法</strong></h2><p>Placement new 的基本语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> (address) <span class="built_in">Type</span>(constructor_args)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>address</code>：指向预分配内存的指针，必须有足够大小且正确对齐。</li>
<li><code>Type</code>：要构造的类型。</li>
<li><code>constructor_args</code>：传递给构造函数的参数（可选）。</li>
</ul>
<h3 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3. 工作原理"></a>3. <strong>工作原理</strong></h3><ul>
<li><strong>内存分配</strong>：用户必须提供一块足够大小且正确对齐的内存（通常通过 <code>new</code>、<code>malloc</code> 或静态分配）。</li>
<li><strong>对象构造</strong>：Placement new 调用指定类型的构造函数，在提供的内存地址上构造对象。</li>
<li><strong>内存管理</strong>：Placement new 不负责分配或释放内存，内存的分配和释放由用户管理。</li>
<li><strong>析构</strong>：Placement new 不自动调用析构函数，用户需要手动调用 <code>obj-&gt;~Type()</code> 来销毁对象。</li>
</ul>
<h2 id="4-关键特性"><a href="#4-关键特性" class="headerlink" title="4. 关键特性"></a>4. <strong>关键特性</strong></h2><ul>
<li><strong>不分配内存</strong>：仅调用构造函数，内存必须预先分配。</li>
<li><strong>灵活性</strong>：允许在任意内存位置构造对象（如栈、堆或自定义内存池）。</li>
<li><strong>性能优化</strong>：避免动态内存分配的开销，适用于高性能场景。</li>
<li><strong>手动管理</strong>：用户负责内存分配、释放和对象析构，增加了代码复杂性。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. <strong>使用场景</strong></h2><p>Placement new 在以下场景中特别有用：</p>
<ol>
<li>内存池<ul>
<li>在预分配的内存池中构造对象，避免频繁的动态内存分配，减少内存碎片。</li>
<li>示例：游戏引擎或实时系统中使用内存池管理对象。</li>
</ul>
</li>
<li>自定义容器<ul>
<li>标准库容器（如 <code>std::vector</code>）使用 placement new 在预分配的缓冲区上构造元素。</li>
<li>示例：<code>std::vector</code> 的 <code>push_back</code> 可能在预分配的数组上使用 placement new 构造新元素。</li>
</ul>
</li>
</ol>
<h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. <strong>注意事项</strong></h2><p>使用 placement new 时需格外小心，以下是关键注意点：</p>
<ul>
<li><p><strong>内存大小</strong>：提供的内存必须足够容纳对象（<code>sizeof(Type)</code>）。</p>
</li>
<li><p>内存对齐</p>
<ul>
<li><p>内存地址必须满足类型的对齐要求（<code>alignof(Type)</code>）。</p>
</li>
<li><p>C++11 引入的 <code>std::aligned_alloc</code> 或 <code>std::align</code> 可帮助对齐内存。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* raw = std::<span class="built_in">aligned_alloc</span>(<span class="built_in">alignof</span>(MyClass), <span class="built_in">sizeof</span>(MyClass));</span><br><span class="line">MyClass* obj = <span class="built_in">new</span>(raw) <span class="built_in">MyClass</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>析构函数</strong>：Placement new 不自动调用析构函数，必须手动调用 <code>obj-&gt;~Type()</code>。</p>
</li>
<li><p><strong>内存释放</strong>：用户负责释放原始内存，需确保在对象析构后正确释放。</p>
</li>
<li><p>异常安全</p>
<ul>
<li>如果构造函数抛出异常，需确保内存不会泄漏。</li>
<li>使用智能指针或 RAII 机制管理内存可提高安全性。</li>
</ul>
</li>
<li><p><strong>不可重复构造</strong>：在同一内存地址上重复调用 placement new（未先析构）会导致未定义行为。</p>
</li>
</ul>
<h2 id="7-高级示例：实现简单内存池"><a href="#7-高级示例：实现简单内存池" class="headerlink" title="7. 高级示例：实现简单内存池"></a>7. <strong>高级示例：实现简单内存池</strong></h2><p>以下是一个使用 placement new 实现简单内存池的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemoryPool</span>(<span class="type">size_t</span> size) : <span class="built_in">buffer_</span>(<span class="keyword">new</span> <span class="type">char</span>[size * <span class="built_in">sizeof</span>(MyClass)]), <span class="built_in">capacity_</span>(size) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MemoryPool</span>() &#123; <span class="keyword">delete</span>[] buffer_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass* <span class="title">allocate</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (used_ &gt;= capacity_) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 在 buffer_ 上构造对象</span></span><br><span class="line">        MyClass* obj = <span class="built_in">new</span>(buffer_ + used_ * <span class="built_in">sizeof</span>(MyClass)) <span class="built_in">MyClass</span>(value);</span><br><span class="line">        used_++;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(MyClass* obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj) obj-&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 手动调用析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* buffer_;</span><br><span class="line">    <span class="type">size_t</span> capacity_;</span><br><span class="line">    <span class="type">size_t</span> used_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">value_</span>(value) &#123; std::cout &lt;&lt; <span class="string">&quot;Constructed with &quot;</span> &lt;&lt; value_ &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MemoryPool <span class="title">pool</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// 可容纳 2 个 MyClass 对象</span></span><br><span class="line">    MyClass* obj1 = pool.<span class="built_in">allocate</span>(<span class="number">10</span>);</span><br><span class="line">    MyClass* obj2 = pool.<span class="built_in">allocate</span>(<span class="number">20</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1 value: &quot;</span> &lt;&lt; obj1-&gt;value_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    pool.<span class="built_in">deallocate</span>(obj1);</span><br><span class="line">    pool.<span class="built_in">deallocate</span>(obj2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Constructed <span class="keyword">with</span> <span class="number">10</span></span><br><span class="line">Constructed <span class="keyword">with</span> <span class="number">20</span></span><br><span class="line">obj1 <span class="keyword">value</span>: <span class="number">10</span></span><br><span class="line">Destructed</span><br><span class="line">Destructed</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>内存池</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器输入url并按下回车之后...</title>
    <url>/2025/06/24/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<h3 id="浏览器输入URL后发生了什么"><a href="#浏览器输入URL后发生了什么" class="headerlink" title="浏览器输入URL后发生了什么"></a>浏览器输入URL后发生了什么</h3><p>当在浏览器中输入一个URL（如 <code>https://www.example.com</code>）并按下回车后，浏览器会执行一系列复杂的过程，将用户请求的资源加载并呈现在屏幕上。以下是详细步骤，使用Markdown格式，结合上下文确保清晰且技术准确。</p>
<hr>
<h4 id="1-解析URL"><a href="#1-解析URL" class="headerlink" title="1. 解析URL"></a>1. <strong>解析URL</strong></h4><ul>
<li><strong>URL结构</strong>：URL（Uniform Resource Locator）由协议（如 <code>https</code>）、域名（如 <code>www.example.com</code>）、端口（默认 HTTPS 为 443）、路径（如 <code>/path</code>）、查询参数（如 <code>?key=value</code>）等组成。</li>
<li><strong>浏览器行为</strong>：<ul>
<li>解析输入的URL，检查合法性。</li>
<li>若无协议前缀（如输入 <code>example.com</code>），浏览器可能自动补全为 <code>https://example.com</code> 或尝试搜索。</li>
<li>清理URL（如去除多余空格，规范化编码）。</li>
</ul>
</li>
<li><strong>示例</strong>：输入 <code>example.com</code> → 解析为 <code>https://example.com/</code>。</li>
</ul>
<hr>
<h4 id="2-检查缓存"><a href="#2-检查缓存" class="headerlink" title="2. 检查缓存"></a>2. <strong>检查缓存</strong></h4><ul>
<li><strong>浏览器缓存</strong>：<ul>
<li>浏览器检查本地缓存（内存缓存、磁盘缓存）是否有请求资源的有效副本。</li>
<li>缓存策略（如 <code>Cache-Control</code>、<code>ETag</code>、<code>Last-Modified</code>）决定是否使用缓存。</li>
<li>若缓存有效，直接加载缓存资源，跳过后续网络请求。</li>
</ul>
</li>
<li><strong>示例</strong>：若 <code>https://www.example.com/index.html</code> 的缓存未过期，浏览器直接渲染缓存内容。</li>
</ul>
<hr>
<h4 id="3-DNS解析"><a href="#3-DNS解析" class="headerlink" title="3. DNS解析"></a>3. <strong>DNS解析</strong></h4><ul>
<li><strong>目的</strong>：将域名（如 <code>www.example.com</code>）转换为服务器的IP地址。</li>
<li><strong>过程</strong>：<ol>
<li><strong>检查本地缓存</strong>：<ul>
<li>浏览器检查本地DNS缓存（浏览器、操作系统）。</li>
<li>若命中，直接获取IP。</li>
</ul>
</li>
<li><strong>查询本地DNS服务器</strong>：<ul>
<li>若无缓存，浏览器向操作系统配置的DNS服务器发送查询请求。</li>
<li>操作系统可能查询 <code>/etc/hosts</code> 文件。</li>
</ul>
</li>
<li><strong>递归&#x2F;迭代查询</strong>：<ul>
<li>本地DNS服务器通过根域名服务器（<code>.</code>）、顶级域名服务器（如 <code>.com</code>）、权威域名服务器（如 <code>example.com</code>）逐级解析。</li>
<li>最终返回IP地址（如 <code>93.184.216.34</code>）。</li>
</ul>
</li>
</ol>
</li>
<li><strong>优化</strong>：<ul>
<li>DNS预解析（<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>）。</li>
<li>使用CDN可能返回就近服务器IP。</li>
</ul>
</li>
<li><strong>示例</strong>：<code>www.example.com</code> 解析为 <code>93.184.216.34</code>。</li>
</ul>
<hr>
<h4 id="4-建立TCP连接"><a href="#4-建立TCP连接" class="headerlink" title="4. 建立TCP连接"></a>4. <strong>建立TCP连接</strong></h4><ul>
<li><strong>协议</strong>：HTTP&#x2F;HTTPS基于TCP，需先建立TCP连接。</li>
<li><strong>过程</strong>：<ol>
<li><strong>三次握手</strong>：<ul>
<li>客户端发送 SYN 包。</li>
<li>服务器响应 SYN+ACK。</li>
<li>客户端发送 ACK，连接建立。</li>
<li>[<br>\text{Client: SYN} \rightarrow \text{Server: SYN+ACK} \rightarrow \text{Client: ACK}<br>]</li>
</ul>
</li>
<li><strong>拥塞控制</strong>（结合上下文）：<ul>
<li>TCP使用慢启动，初始拥塞窗口（cwnd）较小。</li>
<li>若发生拥塞，ssthresh设为当前未确认数据量的一半（如上下文所述）。</li>
</ul>
</li>
</ol>
</li>
<li><strong>端口</strong>：HTTP 默认 80，HTTPS 默认 443。</li>
</ul>
<hr>
<h4 id="5-TLS-SSL握手（若为HTTPS）"><a href="#5-TLS-SSL握手（若为HTTPS）" class="headerlink" title="5. TLS&#x2F;SSL握手（若为HTTPS）"></a>5. <strong>TLS&#x2F;SSL握手（若为HTTPS）</strong></h4><ul>
<li><strong>目的</strong>：为HTTPS建立加密通道。</li>
<li><strong>过程</strong>：<ol>
<li><strong>客户端Hello</strong>：发送支持的加密协议、算法、随机数。</li>
<li><strong>服务器Hello</strong>：响应选定的加密算法、证书、随机数。</li>
<li><strong>证书验证</strong>：客户端验证服务器证书（由CA签发）。</li>
<li><strong>密钥交换</strong>：通过算法（如RSA或ECDHE）协商会话密钥。</li>
<li><strong>完成握手</strong>：双方确认加密通道建立。</li>
</ol>
</li>
<li><strong>优化</strong>：<ul>
<li>TLS 1.3 减少握手往返。</li>
<li>会话恢复（如Session ID或Session Ticket）加速后续连接。</li>
</ul>
</li>
<li><strong>示例</strong>：<code>https://www.example.com</code> 触发TLS握手，确保数据加密。</li>
</ul>
<hr>
<h4 id="6-发送HTTP请求"><a href="#6-发送HTTP请求" class="headerlink" title="6. 发送HTTP请求"></a>6. <strong>发送HTTP请求</strong></h4><ul>
<li><strong>请求格式</strong>：<ul>
<li>浏览器构造HTTP请求（GET、POST等），包括：<ul>
<li>请求行：<code>GET / HTTP/1.1</code></li>
<li>头部：<code>Host: www.example.com</code>, <code>User-Agent</code>, <code>Accept</code> 等。</li>
<li>可选的请求体（如POST数据）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>HTTP版本</strong>：<ul>
<li>HTTP&#x2F;1.1：逐个请求-响应，需等待响应完成。</li>
<li>HTTP&#x2F;2：支持多路复用，多个请求并行。</li>
<li>HTTP&#x2F;3：基于UDP（QUIC），进一步优化。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept: text/html</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="7-服务器处理请求"><a href="#7-服务器处理请求" class="headerlink" title="7. 服务器处理请求"></a>7. <strong>服务器处理请求</strong></h4><ul>
<li><strong>服务器行为</strong>：<ul>
<li>Web服务器（如Nginx、Apache）接收请求，解析路径和参数。</li>
<li>若为动态内容，交给后端（如Node.js、PHP）。</li>
<li>返回响应，包括状态码（如 <code>200 OK</code>）、头部（如 <code>Content-Type</code>）、响应体（如HTML）。</li>
</ul>
</li>
<li><strong>示例响应</strong>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1234</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="8-接收和解析响应"><a href="#8-接收和解析响应" class="headerlink" title="8. 接收和解析响应"></a>8. <strong>接收和解析响应</strong></h4><ul>
<li><strong>接收数据</strong>：<ul>
<li>浏览器通过TCP接收响应数据。</li>
<li>若数据量大，可能分段传输（结合上下文，可能涉及<strong>粘包</strong>问题）。</li>
<li>应用层需解析数据包边界（如使用固定长度头部，参考上下文）。</li>
</ul>
</li>
<li><strong>解析HTML</strong>：<ul>
<li>浏览器解析HTML，构建DOM（Document Object Model）树。</li>
<li>解析CSS，构建CSSOM（CSS Object Model）树。</li>
<li>合并DOM和CSSOM，生成渲染树（Render Tree）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="9-加载子资源"><a href="#9-加载子资源" class="headerlink" title="9. 加载子资源"></a>9. <strong>加载子资源</strong></h4><ul>
<li><strong>子资源</strong>：HTML中引用的CSS、JavaScript、图片等。</li>
<li><strong>过程</strong>：<ul>
<li>浏览器识别 <code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code> 等标签，发起新请求。</li>
<li>重复DNS解析、TCP连接、HTTP请求等步骤。</li>
<li>优化：<ul>
<li>并行加载（HTTP&#x2F;2多路复用）。</li>
<li>预加载（<code>&lt;link rel=&quot;preload&quot;&gt;</code>）。</li>
<li>延迟加载非关键资源。</li>
</ul>
</li>
</ul>
</li>
<li><strong>示例</strong>：<code>&lt;img src=&quot;/image.jpg&quot;&gt;</code> 触发新请求。</li>
</ul>
<hr>
<h4 id="10-渲染页面"><a href="#10-渲染页面" class="headerlink" title="10. 渲染页面"></a>10. <strong>渲染页面</strong></h4><ul>
<li><strong>渲染过程</strong>：<ol>
<li><strong>布局（Layout）</strong>：计算元素位置和大小。</li>
<li><strong>绘制（Painting）</strong>：将渲染树转换为像素。</li>
<li><strong>合成（Compositing）</strong>：将图层合并，显示在屏幕上。</li>
</ol>
</li>
<li><strong>JavaScript执行</strong>：<ul>
<li>执行 <code>&lt;script&gt;</code> 标签中的代码，操作DOM或CSSOM。</li>
<li>异步脚本（<code>async</code>、<code>defer</code>）优化加载。</li>
</ul>
</li>
<li><strong>优化</strong>：<ul>
<li>减少重排（Reflow）和重绘（Repaint）。</li>
<li>使用GPU加速（如CSS transform）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="11-处理交互"><a href="#11-处理交互" class="headerlink" title="11. 处理交互"></a>11. <strong>处理交互</strong></h4><ul>
<li><strong>事件监听</strong>：<ul>
<li>浏览器绑定JavaScript事件（如点击、滚动）。</li>
<li>用户交互触发回调，动态更新页面。</li>
</ul>
</li>
<li><strong>示例</strong>：点击 <code>&lt;button onclick=&quot;myFunction()&quot;&gt;</code> 调用JavaScript函数。</li>
</ul>
<hr>
<h4 id="12-连接关闭或保持"><a href="#12-连接关闭或保持" class="headerlink" title="12. 连接关闭或保持"></a>12. <strong>连接关闭或保持</strong></h4><ul>
<li><strong>HTTP&#x2F;1.1</strong>：支持 <code>Keep-Alive</code>，连接复用，避免重复TCP握手。</li>
<li><strong>HTTP&#x2F;2及以上</strong>：多路复用，单个连接处理多个请求。</li>
<li><strong>关闭</strong>：若无 <code>Keep-Alive</code>，TCP连接通过四次挥手关闭：</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>从源文件到可执行文件(编译之路)</title>
    <url>/2025/06/08/%E4%BB%8E%E6%BA%90%E6%96%87%E4%BB%B6%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="从源文件到可执行文件-编译之路"><a href="#从源文件到可执行文件-编译之路" class="headerlink" title="从源文件到可执行文件(编译之路)"></a>从源文件到可执行文件(编译之路)</h1><p>被面试官狠狠拷打的亡羊补牢罢了</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>C++程序从源代码到可执行文件需要经过四个主要阶段：</p>
<ol>
<li>预处理（Preprocess)</li>
<li>编译(Compilation)</li>
<li>汇编(Assembly)</li>
<li>链接(Linking)</li>
</ol>
<h2 id="预处理（Preprocess）"><a href="#预处理（Preprocess）" class="headerlink" title="预处理（Preprocess）"></a>预处理（Preprocess）</h2><p>这一步由预处理器完成，对源程序中的伪指令（以#开头的指令）和特殊符号进行处理。主要工作包括：</p>
<ul>
<li>将所有的<code>#define</code>删除，并进行宏展开</li>
<li>处理所有条件编译指令，如<code>#if</code>、<code>#ifdef</code>、<code>#ifndef</code>、<code>#else</code>、<code>#elif</code>、<code>#endif</code>等</li>
<li>处理<code>#include</code>预编译指令，将被包含的头文件内容插入该位置，递归处理多重包含</li>
<li>处理其他宏指令，包括<code>#error</code>、<code>#warning</code>、<code>#line</code>、<code>#pragma</code></li>
<li>删除所有注释（C++的<code>//</code>，C语言的<code>/**/</code>），通常用空格替代</li>
<li>添加行号和文件标识，便于调试和错误定位</li>
<li>保留所有的<code>#pragma</code>编译器指令</li>
<li>处理预定义的宏：如<code>__DATE__</code>、<code>__FILE__</code>等</li>
</ul>
<p>预处理后的文件通常有<code>.i</code>或<code>.ii</code>(C++)扩展名，可以通过<code>g++ -E source.cpp -o source.i</code>命令查看预处理结果。</p>
<h2 id="编译（Compilation）"><a href="#编译（Compilation）" class="headerlink" title="编译（Compilation）"></a>编译（Compilation）</h2><p>这一步由编译器完成，对预处理后的文件进行分析并生成汇编代码：</p>
<ul>
<li><p><strong>语法分析</strong>：在词法分析的基础上将单词序列组合成各类语法短语，如”程序”、”语句”、”表达式”等，判断源程序在结构上是否正确。</p>
</li>
<li><p><strong>语义分析：对结构正确的源程序进行上下文相关性质的审查，进行类型检查并报告错误。</strong></p>
</li>
<li><p><strong>中间代码生成</strong>：编译器生成平台无关的中间表示(IR)，如LLVM IR或GCC的GIMPLE。</p>
</li>
<li><p><strong>代码优化：对中间代码进行优化，如常量折叠、死代码消除、循环优化、内联函数、尾递归优化等。</strong></p>
</li>
<li><p><strong>目标代码生成</strong>：将优化后的中间代码转换为特定平台的汇编代码。</p>
</li>
</ul>
<p>编译后生成的汇编文件通常有<code>.s</code>扩展名，可以使用<code>g++ -S source.cpp -o source.s</code>命令生成。</p>
<h2 id="汇编（Assembly）"><a href="#汇编（Assembly）" class="headerlink" title="汇编（Assembly）"></a>汇编（Assembly）</h2><p>由汇编器完成，将汇编代码转变成机器可执行的二进制代码，并生成目标文件。汇编器执行的具体工作包括：</p>
<ul>
<li>将汇编指令的助记符转换为操作码</li>
<li>将标签转换为地址</li>
<li>生成符号表和重定位信息</li>
<li>为各段分配空间</li>
</ul>
<p>目标文件通常采用ELF格式(Linux)或PE格式(Windows)，包含：</p>
<ul>
<li>代码段(<code>.text</code>)：存放程序指令</li>
<li>数据段(<code>.data</code>)：存放已初始化的全局变量和静态变量</li>
<li>BSS段(<code>.bss</code>)：存放未初始化的全局变量和静态变量</li>
</ul>
<p>可以使用<code>g++ -c source.cpp -o source.o</code>命令生成目标文件，目标文件是二进制格式，可以用<code>objdump -d source.o</code>查看反汇编内容。</p>
<h2 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h2><p>由链接器完成，主要解决多个文件之间符号引用的问题。编译时编译器只对单个文件进行处理，如果该文件引用了其他文件中的符号（如全局变量或库函数），这些符号的地址无法确定，需要链接器将所有目标文件链接在一起才能确定最终地址。</p>
<p>链接器执行的具体工作：</p>
<ul>
<li>**符号解析(Symbol Resolution)**：将每个符号引用与其定义匹配</li>
<li>**重定位(Relocation)**：调整代码中的地址引用，使其指向正确的最终位置</li>
<li><strong>处理弱符号和强符号</strong></li>
<li><strong>合并各个段</strong>：将所有目标文件的相同段合并</li>
</ul>
<p>链接分为两种方式：</p>
<ul>
<li><strong>静态链接</strong>：库代码直接复制到可执行文件中，生成独立但较大的可执行文件</li>
<li><strong>动态链接</strong>：可执行文件仅包含对共享库的引用，运行时加载库，节省空间但依赖库文件</li>
</ul>
<p>常见链接错误：</p>
<ul>
<li>未定义引用(Undefined reference)</li>
<li>重复定义(Multiple definition)</li>
<li>符号版本不匹配</li>
</ul>
<h2 id="实用命令示例"><a href="#实用命令示例" class="headerlink" title="实用命令示例"></a>实用命令示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一步完成所有阶段</span></span><br><span class="line">g++ source.cpp -o program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分步执行每个阶段</span></span><br><span class="line">g++ -E source.cpp -o source.i    <span class="comment"># 预处理</span></span><br><span class="line">g++ -S source.i -o source.s      <span class="comment"># 编译</span></span><br><span class="line">g++ -c source.s -o source.o      <span class="comment"># 汇编</span></span><br><span class="line">g++ source.o -o program          <span class="comment"># 链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译优化选项</span></span><br><span class="line">g++ -O0 source.cpp -o program    <span class="comment"># 无优化(调试用)</span></span><br><span class="line">g++ -O2 source.cpp -o program    <span class="comment"># 常用优化级别</span></span><br><span class="line">g++ -O3 source.cpp -o program    <span class="comment"># 最高优化级别</span></span><br></pre></td></tr></table></figure>

<p>之所以要经过预处理、编译、汇编这么一系列步骤才生成目标文件，是因为在每一阶段都有相应的优化技术，只有在各个阶段分别优化才能生成最高效的机器指令。如果直接从源程序生成目标文件，可能会失去很多代码优化的机会。</p>
<p>无论采用静态链接还是动态链接，最终都会生成一个可以在计算机上执行的可执行程序。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>仿函数</title>
    <url>/2025/01/12/%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>仿函数（Function Object 或 Functor）</strong> 是一种行为类似于函数的对象。仿函数是通过重载 <code>operator()</code> 运算符来实现的，这样一个对象就可以像函数一样调用。</p>
<p>仿函数的核心思想是：<strong>对象可以具有类似函数的行为，并且可以携带状态</strong>。这为设计灵活的函数调用方式提供了可能性，尤其是在 STL（标准模板库）中，仿函数被广泛应用于算法、容器操作等场景。</p>
<hr>
<h2 id="1-仿函数的基本概念"><a href="#1-仿函数的基本概念" class="headerlink" title="1. 仿函数的基本概念"></a><strong>1. 仿函数的基本概念</strong></h2><p>仿函数是通过在一个类中重载 <code>operator()</code> 运算符来实现的。这样，类的对象就可以被调用（表现得像一个函数）。</p>
<h3 id="仿函数的基本语法"><a href="#仿函数的基本语法" class="headerlink" title="仿函数的基本语法"></a><strong>仿函数的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载 operator()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Called with: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyFunctor functor; <span class="comment">// 创建仿函数对象</span></span><br><span class="line">    <span class="built_in">functor</span>(<span class="number">10</span>);       <span class="comment">// 像函数一样调用对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called with: 10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>functor(10)</code> 的调用会自动调用 <code>MyFunctor</code> 类的 <code>operator()</code> 函数。这样，<code>functor</code> 对象就表现得像一个函数。</p>
<hr>
<h2 id="2-仿函数的优点"><a href="#2-仿函数的优点" class="headerlink" title="2. 仿函数的优点"></a><strong>2. 仿函数的优点</strong></h2><ol>
<li><p><strong>携带状态：</strong><br>仿函数可以包含成员变量，用于保存状态，而普通函数无法做到这一点。</p>
</li>
<li><p><strong>灵活性和可扩展性：</strong><br>仿函数是一个类，可以拥有额外的功能，如构造函数、成员函数等，提供比普通函数更多的功能和灵活性。</p>
</li>
<li><p><strong>STL 算法支持：</strong><br>仿函数与 STL 算法（如 <code>std::sort</code>、<code>std::for_each</code>）配合得非常好，用于定义自定义的行为。</p>
</li>
</ol>
<hr>
<h2 id="3-仿函数的应用"><a href="#3-仿函数的应用" class="headerlink" title="3. 仿函数的应用"></a><strong>3. 仿函数的应用</strong></h2><h3 id="3-1-仿函数与-STL-算法结合"><a href="#3-1-仿函数与-STL-算法结合" class="headerlink" title="3.1 仿函数与 STL 算法结合"></a><strong>3.1 仿函数与 STL 算法结合</strong></h3><p>仿函数可以作为参数传递给 STL 算法，例如 <code>std::sort</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数作为自定义排序规则</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vec) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5 3 2 1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>仿函数 <code>Compare</code> 定义了一个自定义排序规则：返回 <code>true</code> 时表示 <code>a</code> 应该排在 <code>b</code> 的前面。</li>
<li><code>std::sort</code> 接受仿函数作为第三个参数，用于对容器中的元素进行排序。</li>
</ul>
<hr>
<h3 id="3-2-状态保存的仿函数"><a href="#3-2-状态保存的仿函数" class="headerlink" title="3.2 状态保存的仿函数"></a><strong>3.2 状态保存的仿函数</strong></h3><p>仿函数可以保存状态，普通函数无法做到这一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 保存状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + value; <span class="comment">// 返回加上状态值后的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">add5</span><span class="params">(<span class="number">5</span>)</span></span>;   <span class="comment">// 创建一个仿函数对象，保存状态值 5</span></span><br><span class="line">    <span class="function">Adder <span class="title">add10</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建另一个仿函数对象，保存状态值 10</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add5</span>(<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 输出 8（3 + 5）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add10</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 输出 13（3 + 10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>仿函数 <code>Adder</code> 内部保存了一个状态 <code>value</code>，通过构造函数进行初始化。</li>
<li>调用仿函数时，可以使用该状态进行计算，类似于闭包（closure）的效果。</li>
</ul>
<hr>
<h3 id="3-3-使用-STL-的-std-for-each"><a href="#3-3-使用-STL-的-std-for-each" class="headerlink" title="3.3 使用 STL 的 std::for_each"></a><strong>3.3 使用 STL 的 <code>std::for_each</code></strong></h3><p>仿函数可以用于 STL 算法 <code>std::for_each</code>，实现对容器中每个元素的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数，用于打印元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数与 for_each</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>Print</code> 仿函数定义了如何处理每个元素。</li>
<li><code>std::for_each</code> 将容器中的每个元素依次传递给仿函数。</li>
</ul>
<hr>
<h3 id="3-4-Lambda-表达式的替代"><a href="#3-4-Lambda-表达式的替代" class="headerlink" title="3.4 Lambda 表达式的替代"></a><strong>3.4 Lambda 表达式的替代</strong></h3><p>在现代 C++（C++11 及以上）中，仿函数可以被 <strong>Lambda 表达式</strong> 替代。Lambda 表达式更简洁，但仿函数在某些复杂场景下依然有优势。</p>
<p>等价于上面的 <code>std::for_each</code> 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式替代仿函数</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-STL-中常见的仿函数"><a href="#4-STL-中常见的仿函数" class="headerlink" title="4. STL 中常见的仿函数"></a><strong>4. STL 中常见的仿函数</strong></h2><p>C++ STL 提供了一些常用的内置仿函数，主要定义在头文件 <code>&lt;functional&gt;</code> 中：</p>
<h3 id="4-1-算术仿函数"><a href="#4-1-算术仿函数" class="headerlink" title="4.1 算术仿函数"></a><strong>4.1 算术仿函数</strong></h3><ul>
<li><code>std::plus</code>：加法。</li>
<li><code>std::minus</code>：减法。</li>
<li><code>std::multiplies</code>：乘法。</li>
<li><code>std::divides</code>：除法。</li>
<li><code>std::modulus</code>：取模。</li>
<li><code>std::negate</code>：取负。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="type">int</span>&gt; add;           <span class="comment">// 加法仿函数</span></span><br><span class="line">    multiplies&lt;<span class="type">int</span>&gt; multiply; <span class="comment">// 乘法仿函数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;        <span class="comment">// 输出 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;  <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-逻辑仿函数"><a href="#4-2-逻辑仿函数" class="headerlink" title="4.2 逻辑仿函数"></a><strong>4.2 逻辑仿函数</strong></h3><ul>
<li><code>std::equal_to</code>：等于。</li>
<li><code>std::not_equal_to</code>：不等于。</li>
<li><code>std::greater</code>：大于。</li>
<li><code>std::less</code>：小于。</li>
<li><code>std::greater_equal</code>：大于等于。</li>
<li><code>std::less_equal</code>：小于等于。</li>
</ul>
<h3 id="4-3-逻辑操作仿函数"><a href="#4-3-逻辑操作仿函数" class="headerlink" title="4.3 逻辑操作仿函数"></a><strong>4.3 逻辑操作仿函数</strong></h3><ul>
<li><code>std::logical_and</code>：逻辑与。</li>
<li><code>std::logical_or</code>：逻辑或。</li>
<li><code>std::logical_not</code>：逻辑非。</li>
</ul>
<hr>
<h2 id="5-仿函数与-Lambda-的对比"><a href="#5-仿函数与-Lambda-的对比" class="headerlink" title="5. 仿函数与 Lambda 的对比"></a><strong>5. 仿函数与 Lambda 的对比</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>仿函数</strong></th>
<th><strong>Lambda 表达式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态管理</strong></td>
<td>通过类的成员变量保存状态</td>
<td>捕获变量（自动或手动捕获）</td>
</tr>
<tr>
<td><strong>代码长度</strong></td>
<td>需要定义一个类，代码较长</td>
<td>简洁（C++11 及以上）</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>灵活，可定义复杂行为</td>
<td>简单场景更适用</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>C++98 开始支持</td>
<td>C++11 及以上支持</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li>仿函数是通过重载 <code>operator()</code> 实现的对象，可以像函数一样调用。</li>
<li>仿函数能够保存状态，并灵活应用于 STL 算法。</li>
<li>在现代 C++ 中，仿函数仍然有其独特的作用，尤其是在复杂的场景中，而简单场景更推荐使用 Lambda 表达式。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>共享内存</title>
    <url>/2025/06/24/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p> 在 C++ 中，<strong>共享内存</strong>（Shared Memory）是一种进程间通信（IPC）机制，允许多个进程访问同一块内存区域，从而实现高效的数据共享。以下是共享内存的用法、使用场景及相关注意事项，格式为 Markdown：</p>
<hr>
<h3 id="共享内存的用法"><a href="#共享内存的用法" class="headerlink" title="共享内存的用法"></a>共享内存的用法</h3><p>C++ 中使用共享内存通常依赖操作系统提供的 API（如 POSIX 的 <code>shm_open</code> 和 <code>mmap</code>，或 Windows 的 <code>CreateFileMapping</code> 和 <code>MapViewOfFile</code>）。C++11 及以上版本没有直接提供标准库支持，但可以通过系统调用或第三方库（如 Boost.Interprocess）实现。以下以 POSIX 系统为例说明用法：</p>
<h4 id="1-创建-打开共享内存"><a href="#1-创建-打开共享内存" class="headerlink" title="1. 创建&#x2F;打开共享内存"></a>1. 创建&#x2F;打开共享内存</h4><p>使用 <code>shm_open</code> 创建或打开一个共享内存对象，并通过 <code>mmap</code> 将其映射到进程地址空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开或创建共享内存对象</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* shm_name = <span class="string">&quot;/my_shared_memory&quot;</span>;</span><br><span class="line">    <span class="type">int</span> shm_fd = <span class="built_in">shm_open</span>(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shm_open failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置共享内存大小</span></span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">4096</span>; <span class="comment">// 4KB</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ftruncate</span>(shm_fd, size) == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;ftruncate failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射共享内存到进程地址空间</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">mmap</span>(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;mmap failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr), <span class="string">&quot;Hello, Shared Memory!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="built_in">munmap</span>(ptr, size); <span class="comment">// 解除映射</span></span><br><span class="line">    <span class="built_in">close</span>(shm_fd);     <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">shm_unlink</span>(shm_name); <span class="comment">// 删除共享内存对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-读取共享内存"><a href="#2-读取共享内存" class="headerlink" title="2. 读取共享内存"></a>2. 读取共享内存</h4><p>另一个进程可以通过相同的共享内存名称（<code>shm_name</code>）打开并映射内存，读取或修改数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* shm_name = <span class="string">&quot;/my_shared_memory&quot;</span>;</span><br><span class="line">    <span class="type">int</span> shm_fd = <span class="built_in">shm_open</span>(shm_name, O_RDONLY, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;shm_open failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">mmap</span>(<span class="number">0</span>, size, PROT_READ, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;mmap failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared Memory Content: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(ptr) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="built_in">munmap</span>(ptr, size);</span><br><span class="line">    <span class="built_in">close</span>(shm_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-同步机制"><a href="#3-同步机制" class="headerlink" title="3. 同步机制"></a>3. 同步机制</h4><p>共享内存本身不提供同步机制，多进程并发访问可能导致数据竞争。需要使用信号量（<code>sem_t</code>）、互斥锁或原子操作确保线程安全。例如，使用 POSIX 信号量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="type">sem_t</span>* sem = <span class="built_in">sem_open</span>(<span class="string">&quot;/my_semaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 等待信号量</span></span><br><span class="line"><span class="built_in">sem_wait</span>(sem);</span><br><span class="line"><span class="comment">// 访问共享内存...</span></span><br><span class="line"><span class="comment">// 释放信号量</span></span><br><span class="line"><span class="built_in">sem_post</span>(sem);</span><br><span class="line"><span class="comment">// 清理</span></span><br><span class="line"><span class="built_in">sem_close</span>(sem);</span><br><span class="line"><span class="built_in">sem_unlink</span>(<span class="string">&quot;/my_semaphore&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4-使用-Boost-Interprocess（跨平台）"><a href="#4-使用-Boost-Interprocess（跨平台）" class="headerlink" title="4. 使用 Boost.Interprocess（跨平台）"></a>4. 使用 Boost.Interprocess（跨平台）</h4><p>Boost 提供高级接口，简化共享内存管理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/interprocess/shared_memory_object.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/interprocess/mapped_region.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::interprocess;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建共享内存</span></span><br><span class="line">    <span class="function">shared_memory_object <span class="title">shm</span><span class="params">(create_only, <span class="string">&quot;MySharedMemory&quot;</span>, read_write)</span></span>;</span><br><span class="line">    shm.<span class="built_in">truncate</span>(<span class="number">4096</span>); <span class="comment">// 设置大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射</span></span><br><span class="line">    <span class="function">mapped_region <span class="title">region</span><span class="params">(shm, read_write)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    std::string message = <span class="string">&quot;Hello, Boost Shared Memory!&quot;</span>;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(region.<span class="built_in">get_address</span>(), message.<span class="built_in">c_str</span>(), message.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理（自动解除映射）</span></span><br><span class="line">    shared_memory_object::<span class="built_in">remove</span>(<span class="string">&quot;MySharedMemory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p><strong>高性能数据共享</strong>：</p>
<ul>
<li>多个进程需要快速交换大量数据（如图像、日志、配置）。</li>
<li>例：实时视频处理，共享帧缓冲区。</li>
</ul>
</li>
<li><p><strong>进程间通信</strong>：</p>
<ul>
<li>服务器与客户端共享状态或缓存（如数据库连接池）。</li>
<li>例：Web 服务器与工作进程共享会话数据。</li>
</ul>
</li>
<li><p><strong>并行计算</strong>：</p>
<ul>
<li>多进程并行处理大数据集，共享输入&#x2F;输出缓冲区。</li>
<li>例：科学计算中，多个进程处理同一矩阵。</li>
</ul>
</li>
<li><p><strong>低延迟通信</strong>：</p>
<ul>
<li>相比管道或消息队列，共享内存避免数据拷贝，适合低延迟场景。</li>
<li>例：高频交易系统中的订单簿共享。</li>
</ul>
</li>
<li><p><strong>跨语言&#x2F;跨进程交互</strong>：</p>
<ul>
<li>不同语言编写的进程（如 C++ 和 Python）通过共享内存交换数据。</li>
<li>例：机器学习模型推理，C++ 预处理数据后供 Python 使用。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>同步问题</strong>：</p>
<ul>
<li>必须使用同步机制（如信号量、互斥锁）避免数据竞争。</li>
<li>推荐 Boost.Interprocess 提供的同步工具。</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：</p>
<ul>
<li>确保所有进程正确解除映射（<code>munmap</code>）并删除共享内存（<code>shm_unlink</code>）。</li>
<li>避免内存泄漏或悬空指针。</li>
</ul>
</li>
<li><p><strong>跨平台兼容性</strong>：</p>
<ul>
<li>POSIX API（如 <code>shm_open</code>）适用于 Linux&#x2F;Unix，Windows 使用 <code>CreateFileMapping</code>。</li>
<li>使用 Boost.Interprocess 可提高代码可移植性。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>设置适当权限（如 <code>0666</code>）以控制访问。</li>
<li>避免未初始化的共享内存导致未定义行为。</li>
</ul>
</li>
<li><p><strong>性能开销</strong>：</p>
<ul>
<li>共享内存创建和映射有初始开销，适合长期使用。</li>
<li>频繁创建&#x2F;销毁共享内存可能不如其他 IPC 机制（如管道）高效。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h3><ul>
<li><strong>内存访问时间</strong>：共享内存的访问时间接近本地内存，为 ( O(1) )，无数据拷贝开销。</li>
<li><strong>同步开销</strong>：信号量或锁的加锁&#x2F;解锁时间通常为 ( O(1) )，但竞争激烈时可能退化为 ( O(n) )，其中 ( n ) 为竞争进程数。</li>
<li><strong>空间复杂度</strong>：共享内存大小为 ( S )，由 <code>ftruncate</code> 或 <code>truncate</code> 设定，额外同步机制（如信号量）占用 ( O(1) ) 空间。</li>
</ul>
<hr>
<h3 id="适用场景与替代方案"><a href="#适用场景与替代方案" class="headerlink" title="适用场景与替代方案"></a>适用场景与替代方案</h3><ul>
<li><strong>适用场景</strong>：需要高效、大量数据共享的进程间通信。</li>
<li><strong>替代方案</strong>：<ul>
<li><strong>管道&#x2F;消息队列</strong>：适合小数据量或流式传输。</li>
<li><strong>套接字</strong>：适合网络通信或跨主机场景。</li>
<li><strong>文件映射</strong>：适合持久化数据共享。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>进程通信</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄漏</title>
    <url>/2025/06/17/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h3 id="内存泄漏是什么？"><a href="#内存泄漏是什么？" class="headerlink" title="内存泄漏是什么？"></a>内存泄漏是什么？</h3><p>内存泄漏（Memory Leak）是指程序在分配内存后，由于某些原因未能正确释放，导致这部分内存无法被再次使用，直到程序结束或操作系统回收。内存泄漏会逐渐消耗系统资源，可能导致程序性能下降甚至崩溃。</p>
<hr>
<h3 id="如何避免内存泄漏？"><a href="#如何避免内存泄漏？" class="headerlink" title="如何避免内存泄漏？"></a>如何避免内存泄漏？</h3><p>以下是一些常见的避免内存泄漏的方法：</p>
<ol>
<li><p><strong>使用 RAII（资源获取即初始化）</strong>：</p>
<ul>
<li>RAII 是 C++ 中一种重要的资源管理技术，通过将资源（如动态分配的内存）绑定到对象的生命周期，确保资源在对象销毁时自动释放。</li>
<li>使用智能指针（如 <code>std::unique_ptr</code>、<code>std::shared_ptr</code>）管理动态内存，避免手动调用 <code>delete</code>。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 自动释放</span></span><br><span class="line">    <span class="comment">// 无需手动 delete，ptr 离开作用域时自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>规范内存管理</strong>：</p>
<ul>
<li>确保每个 <code>new</code> 都有对应的 <code>delete</code>，每个 <code>malloc</code> 都有对应的 <code>free</code>。</li>
<li>使用容器类（如 <code>std::vector</code>、<code>std::string</code>）代替手动管理的数组，自动管理内存。</li>
<li>避免在复杂逻辑中手动分配和释放内存，减少遗漏的可能性。</li>
</ul>
</li>
<li><p><strong>异常安全设计</strong>：</p>
<ul>
<li>在可能抛出异常的代码中，确保内存释放不被跳过。例如，使用 RAII 或 <code>try-catch</code> 块：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">risky_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的操作</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr; <span class="comment">// 确保释放</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// 继续抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用 RAII 可简化上述代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>); <span class="comment">// ptr 自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>避免循环引用</strong>：</p>
<ul>
<li>在使用 <code>std::shared_ptr</code> 时，注意避免循环引用（如对象 A 持有 B 的 <code>shared_ptr</code>，B 持有 A 的 <code>shared_ptr</code>），可用 <code>std::weak_ptr</code> 打破循环。</li>
</ul>
</li>
<li><p><strong>编写清晰的析构函数</strong>：</p>
<ul>
<li>在类设计中，确保析构函数正确释放所有动态分配的资源。</li>
<li>如果类中有指针成员，检查是否需要深拷贝（或使用智能指针）。</li>
</ul>
</li>
<li><p><strong>最小化动态内存分配</strong>：</p>
<ul>
<li>尽量使用栈内存或静态分配，避免不必要的动态分配，减少泄漏风险。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何检查内存泄漏？"><a href="#如何检查内存泄漏？" class="headerlink" title="如何检查内存泄漏？"></a>如何检查内存泄漏？</h3><ol>
<li><p><strong>静态分析工具</strong>：</p>
<ul>
<li>使用静态代码分析工具（如 Clang Static Analyzer、Coverity）检查代码中潜在的内存泄漏问题。</li>
</ul>
</li>
<li><p><strong>动态分析工具</strong>：</p>
<ul>
<li><strong>Valgrind</strong>：一个强大的内存调试工具，可检测内存泄漏、非法访问等问题。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --leak-check=full ./my_program</span><br></pre></td></tr></table></figure>
Valgrind 的 Memcheck 工具会报告未释放的内存块及其分配位置。</li>
<li>**AddressSanitizer (ASan)**：编译器支持的工具（如 GCC、Clang 的 <code>-fsanitize=address</code>），运行时检测内存泄漏和越界访问。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -fsanitize=address -g my_program.cpp</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>调试器和日志</strong>：</p>
<ul>
<li>在代码中添加日志，跟踪内存分配和释放。</li>
<li>使用调试器（如 GDB）检查程序状态，定位未释放的内存。</li>
</ul>
</li>
<li><p><strong>单元测试</strong>：</p>
<ul>
<li>编写针对内存管理的单元测试，验证资源分配和释放的正确性。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何解决内存泄漏？"><a href="#如何解决内存泄漏？" class="headerlink" title="如何解决内存泄漏？"></a>如何解决内存泄漏？</h3><ol>
<li><p><strong>定位泄漏点</strong>：</p>
<ul>
<li>使用 Valgrind 或 ASan 提供的堆栈跟踪，找到分配但未释放的内存位置。</li>
<li>检查代码逻辑，尤其是异常路径、循环、条件分支等可能跳过 <code>delete</code> 的地方。</li>
</ul>
</li>
<li><p><strong>修复析构函数中的问题</strong>：</p>
<ul>
<li>如果程序在析构函数调用前异常退出导致内存泄漏，使用 RAII 或智能指针确保资源自动释放。</li>
<li>示例：析构函数未被调用导致泄漏：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span>[] data; &#125; <span class="comment">// 可能因异常未调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
改进为：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">data</span>(std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">100</span>)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 无需显式析构，data 自动释放</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>重构复杂代码</strong>：</p>
<ul>
<li>将手动内存管理替换为智能指针或标准库容器。</li>
<li>简化资源管理逻辑，减少手动 <code>new</code> 和 <code>delete</code> 的使用。</li>
</ul>
</li>
<li><p><strong>处理特殊场景</strong>：</p>
<ul>
<li><strong>多线程环境</strong>：确保线程安全，避免在多线程中重复释放或遗漏释放。</li>
<li><strong>外部库资源</strong>：检查第三方库分配的资源，调用其提供的释放函数。</li>
</ul>
</li>
<li><p><strong>验证修复</strong>：</p>
<ul>
<li>使用 Valgrind 或 ASan 重新运行程序，确认泄漏已修复。</li>
<li>增加测试覆盖率，确保修复不引入新问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存泄漏是动态内存未被正确释放导致的资源浪费，可能由异常、逻辑错误或不当设计引发。避免泄漏的关键是使用 RAII 和智能指针，规范内存管理，设计异常安全的代码。检查泄漏可使用 Valgrind、ASan 等工具，解决泄漏需定位问题、修复代码并验证结果。结合工具和良好的编码实践，可有效减少内存泄漏风险。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>再探智能指针</title>
    <url>/2025/02/27/%E5%86%8D%E6%8E%A2%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>又是许久未见的一期非人机博客，哈哈哈，感觉事好多（才不是寒假偷懒）</p>
<p>写完cc_muduo网络库之后，深感c++基础有待加深学习，于是重新看了一遍智能指针</p>
<p>众所周知，智能指针包括三种shared_ptr,weak_ptr,unique_ptr,我们一个个来</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>智能指针，作为c++独有的方式，相比malloc,free,以及new delete这两对需要手动释放的情侣，智能指针总算学会了自动释放内存</p>
<p>但是很不幸的是，他学艺不精，依然容易存在双重释放等问题，但依然是巨大的进步</p>
<p>智能指针的自动释放依赖于RAII机制，即在栈上，依赖析构函数实现的自动释放方法</p>
<p>毕竟栈上的内存，在离开作用域之后，会自动释放，便借用这个机制，在析构函数中加入delete，从而实现</p>
<p>shared_ptr，强调的是共享所有权，可以通过裸指针构造，也可以通过另一个智能指针构造</p>
<p>每个shared_ptr的引用计数都会指向该对象的数量，当引用计数为0（最后一个shared_ptr析构时，会自动删除对象和引用计数）</p>
<p>这里强调两点构造时要注意的：</p>
<p><strong>（1）不要用同一个裸指针创建多个shared_ptr</strong></p>
<p><strong>（2）避免用this指针创建shared_ptr</strong></p>
<p>原因都类似，在用裸指针创建shared_ptr时，会创建一个计数对象，如果用同一个裸指针创建两个shared_ptr,那么一个计数对象是2，新的那个却是1.而用一个shared_ptr初始化（赋值）另一个shared_ptr就没问题，只会在已有的计数对象上++</p>
<p>在必须用this指针创建shared_ptr时，我们一般使用shared_from_this()函数，可以安全的获得指针，但是要求this指针指向的该类已被shared_ptr指向</p>
<p>shared_ptr实际上包括两个指针，一个是指向管理对象的指针，另一个是指向控制块的指针</p>
<p>控制块中有引用计数，弱计数，和其他一些东西</p>
<p>而引用计数的内存是动态分配的，递增和递减是原子操作</p>
<p>一般来说，我们创建一个shared_ptr有两种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过一个裸指针构造</span><br><span class="line">test* p = new test(1);</span><br><span class="line">std::shared_ptr&lt;test&gt; sp(p);</span><br><span class="line">//使用make_shared实现</span><br><span class="line">std::shared_ptr&lt;test&gt; sp = std::make_shared&lt;test&gt;(1);</span><br></pre></td></tr></table></figure>

<p>相比先创建对象，然后再创建shared_ptr,make_shared不但更安全，而且只会产生一次内存分配，将对象和计数对象共用一块区域，效率更高</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr表示临时所有权，是弱引用，不会增加引用计数，需要配合shared_ptr使用，追踪判断shared_ptr的对象是否有效，当需要临时所有权时，也可以将weak_ptr转换成shared_ptr，使引用计数++</p>
<p>weak_ptr的构造可以用一个weak_ptr也可以用shared_ptr</p>
<p>在多线程操作中，管理共享对象是一个令人头疼的事情，最大的困难就是保证共享对象的有效性和共享对象的有效性检测</p>
<p>在这里我们一般使用weak_ptr和shared_ptr的结合使用来完成</p>
<p>正常情况下，在将弱引用转换为强引用的过程中我们很容易出现以下状况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weak_ptr&lt;int&gt; wp1(sp1);//弱引用不增加引用计数  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sp1.use_count() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//在多线程环境下，可能在初始化sp2和wp1.expired()之间，sp1的引用计数减为0，从而导致未定义操作（并非原子操作）</span><br><span class="line">if (!wp1.expired())//检测shared_ptr对象是否已经释放</span><br><span class="line">&#123;</span><br><span class="line">//sp1,wp1指向的被释放</span><br><span class="line">	shared_ptr&lt;int&gt;sp2(wp1);</span><br><span class="line">	cout &lt;&lt; sp2.use_count() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们选择原子操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp3 = wp1.lock();//通过weak_ptr对象获取shared_ptr对象(原子操作，将弱引用转换为强引用)</span><br></pre></td></tr></table></figure>

<p>这样的话，如果wp1指向的对象仍存在，就一定能成功初始化sp3，如果不存在，就返回0，不会出现未定义操作</p>
<p>如此，我们便可以根据sp3的状况，判断是否对象有效</p>
<h3 id="这里插播一条提醒：不要出现循环引用"><a href="#这里插播一条提醒：不要出现循环引用" class="headerlink" title="这里插播一条提醒：不要出现循环引用"></a>这里插播一条提醒：不要出现循环引用</h3><p>比如，分别创建类A，B的shared_ptr，然后再用该指针，在类内创建shared_ptr分别指向另一个，这样的话，就表示两者互有所有权。这种是不正确的，应该在其中一方使用weak_ptr</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr代表的是独占所有权，没有拷贝语义，只能通过移动操作来转移所有权，有三个核心接口：release()，reset()，swap()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;test&gt;up1(new test(1));</span><br><span class="line">std::unique_ptr&lt;test&gt;up2(new test(2));</span><br><span class="line">up1=std::move(up2);//test(2)会销毁，up1指向test(2),up2为空</span><br><span class="line"></span><br><span class="line">up1.reset(up2.release());//up2不再指向test(2),up1指向test(2)，同时将test(1)销毁，up2变为空</span><br></pre></td></tr></table></figure>

<p>reset的参数是一个裸指针（或者为空），将原unique_ptr指向的对象销毁后指向参数的指针指向的对象</p>
<p>release的返回值是裸指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;test&gt;&gt;v1;</span><br><span class="line">v1.emplace_back(move(up1));//在容器中要使用move转移所有权</span><br></pre></td></tr></table></figure>



<h2 id="智能指针在多线程中的强大作用"><a href="#智能指针在多线程中的强大作用" class="headerlink" title="智能指针在多线程中的强大作用"></a>智能指针在多线程中的强大作用</h2><h3 id="1-一个-shared-ptr-对象可以被多个线程同时读"><a href="#1-一个-shared-ptr-对象可以被多个线程同时读" class="headerlink" title="1. 一个 shared_ptr 对象可以被多个线程同时读"></a>1. <strong>一个 <code>shared_ptr</code> 对象可以被多个线程同时读</strong></h3><p><strong>✓ 正确</strong><br>多个线程可以同时读取同一个 <code>shared_ptr</code> 对象而不会产生问题。<code>std::shared_ptr</code> 的读操作是线程安全的，包括：</p>
<ul>
<li>获取原始指针 (get())</li>
<li>检查引用计数 (use_count())</li>
<li>检查指针是否为空 (operator bool)</li>
</ul>
<h3 id="2-两个-shared-ptr-对象实体可以被两个线程同时读写，即使他们管理的是同一个对象"><a href="#2-两个-shared-ptr-对象实体可以被两个线程同时读写，即使他们管理的是同一个对象" class="headerlink" title="2. 两个 shared_ptr 对象实体可以被两个线程同时读写，即使他们管理的是同一个对象"></a>2. <strong>两个 <code>shared_ptr</code> 对象实体可以被两个线程同时读写，即使他们管理的是同一个对象</strong></h3><p><strong>✓ 正确，但有重要注意事项</strong><br>从 <code>shared_ptr</code> 本身的角度看，两个不同的 <code>shared_ptr</code> 实例可以分别被不同线程安全地修改（比如赋值、重置等），即使它们指向同一个底层对象。这是因为你在修改的是两个不同的智能指针实例。</p>
<p><strong>然而，重要注意事项</strong>：虽然修改两个不同的 <code>shared_ptr</code> 实例是安全的，但如果通过这两个智能指针同时修改它们指向的同一个对象，则会产生数据竞争，这是不安全的，需要额外的同步机制。</p>
<h3 id="3-多个线程读写同一个-shared-ptr-对象实体，需要加锁"><a href="#3-多个线程读写同一个-shared-ptr-对象实体，需要加锁" class="headerlink" title="3. 多个线程读写同一个 shared_ptr 对象实体，需要加锁"></a>3. <strong>多个线程读写同一个 <code>shared_ptr</code> 对象实体，需要加锁</strong></h3><p><strong>✓ 正确</strong><br>如果多个线程需要修改同一个 <code>shared_ptr</code> 实例（例如对同一个 <code>shared_ptr</code> 变量进行赋值或重置操作），则需要同步机制（如互斥锁）来保护这些操作。<code>shared_ptr</code> 的引用计数机制是线程安全的，但智能指针实例本身的修改操作不是线程安全的。</p>
<h3 id="总结与补充说明"><a href="#总结与补充说明" class="headerlink" title="总结与补充说明"></a>总结与补充说明</h3><ul>
<li><strong><code>shared_ptr</code> 的引用计数</strong>：内部引用计数的增减是原子的、线程安全的</li>
<li><strong><code>shared_ptr</code> 实例的修改</strong>：对同一个 <code>shared_ptr</code> 变量的修改需要同步</li>
<li><strong><code>shared_ptr</code> 指向的对象</strong>：对指向对象的并发访问需要用户自行提供同步机制</li>
</ul>
<h4 id="第二点需要明确区分”修改-shared-ptr-实例本身”和”修改-shared-ptr-所指向的对象”这两种不同的操作。"><a href="#第二点需要明确区分”修改-shared-ptr-实例本身”和”修改-shared-ptr-所指向的对象”这两种不同的操作。" class="headerlink" title="第二点需要明确区分”修改 shared_ptr 实例本身”和”修改 shared_ptr 所指向的对象”这两种不同的操作。"></a>第二点需要明确区分”修改 <code>shared_ptr</code> 实例本身”和”修改 <code>shared_ptr</code> 所指向的对象”这两种不同的操作。</h4><p>在下一节中，我们将详细介绍写时复制</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>几种排序</title>
    <url>/2025/06/20/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="常见排序算法的时间复杂度和空间复杂度"><a href="#常见排序算法的时间复杂度和空间复杂度" class="headerlink" title="常见排序算法的时间复杂度和空间复杂度"></a>常见排序算法的时间复杂度和空间复杂度</h3><p>以下是常见排序算法的时间复杂度和空间复杂度的总结，列出了最佳、平均和最坏情况下的时间复杂度，以及空间复杂度。所有复杂度以大 O 表示法表示。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>最佳时间复杂度</th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody><tr>
<td><strong>冒泡排序</strong></td>
<td>( O(n) )</td>
<td>( O(n^2) )</td>
<td>( O(n^2) )</td>
<td>( O(1) )</td>
<td>是</td>
</tr>
<tr>
<td><strong>选择排序</strong></td>
<td>( O(n^2) )</td>
<td>( O(n^2) )</td>
<td>( O(n^2) )</td>
<td>( O(1) )</td>
<td>否</td>
</tr>
<tr>
<td><strong>插入排序</strong></td>
<td>( O(n) )</td>
<td>( O(n^2) )</td>
<td>( O(n^2) )</td>
<td>( O(1) )</td>
<td>是</td>
</tr>
<tr>
<td><strong>希尔排序</strong></td>
<td>( O(n \log n) )</td>
<td>取决于步长序列（如 ( O(n^{1.3}) )）</td>
<td>( O(n^2) )</td>
<td>( O(1) )</td>
<td>否</td>
</tr>
<tr>
<td><strong>归并排序</strong></td>
<td>( O(n \log n) )</td>
<td>( O(n \log n) )</td>
<td>( O(n \log n) )</td>
<td>( O(n) )</td>
<td>是</td>
</tr>
<tr>
<td><strong>快速排序</strong></td>
<td>( O(n \log n) )</td>
<td>( O(n \log n) )</td>
<td>( O(n^2) )</td>
<td>( O(\log n) )（递归栈）</td>
<td>否</td>
</tr>
<tr>
<td><strong>堆排序</strong></td>
<td>( O(n \log n) )</td>
<td>( O(n \log n) )</td>
<td>( O(n \log n) )</td>
<td>( O(1) )</td>
<td>否</td>
</tr>
<tr>
<td><strong>计数排序</strong></td>
<td>( O(n + k) )</td>
<td>( O(n + k) )</td>
<td>( O(n + k) )</td>
<td>( O(k) )</td>
<td>是</td>
</tr>
<tr>
<td><strong>桶排序</strong></td>
<td>( O(n + k) )</td>
<td>( O(n + k) )</td>
<td>( O(n^2) )</td>
<td>( O(n + k) )</td>
<td>是</td>
</tr>
<tr>
<td><strong>基数排序</strong></td>
<td>( O(n \cdot k) )</td>
<td>( O(n \cdot k) )</td>
<td>( O(n \cdot k) )</td>
<td>( O(n + k) )</td>
<td>是</td>
</tr>
</tbody></table>
<hr>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>最佳情况</strong>：输入数据已经接近有序（如冒泡排序、插入排序）或特定条件（如快速排序选择好的枢轴）。</li>
<li><strong>平均情况</strong>：基于随机输入数据的期望复杂度。</li>
<li><strong>最坏情况</strong>：输入数据完全逆序或最不利情况（如快速排序的枢轴选择不佳）。</li>
<li>( n ) 表示输入元素数量，( k ) 表示计数排序或基数排序中的范围或位数。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>( O(1) )：原地排序算法（如冒泡、选择、插入、堆排序）。</li>
<li>( O(n) )：需要额外数组（如归并排序）。</li>
<li>( O(\log n) )：快速排序的递归调用栈平均情况。</li>
<li>( O(k) ) 或 ( O(n + k) )：计数排序、桶排序、基数排序依赖于辅助数据结构。</li>
</ul>
</li>
<li><p><strong>稳定性</strong>：</p>
<ul>
<li>稳定排序：相同值的元素在排序后保持相对顺序（如冒泡、插入、归并、计数、桶、基数排序）。</li>
<li>非稳定排序：可能改变相同值元素的相对顺序（如选择、希尔、快速、堆排序）。</li>
</ul>
</li>
<li><p><strong>特殊说明</strong>：</p>
<ul>
<li><strong>希尔排序</strong>：时间复杂度取决于步长序列（如增量为 ( 2^k ) 或 Sedgewick 序列）。</li>
<li><strong>快速排序</strong>：最坏情况 ( O(n^2) ) 通常可通过随机化枢轴或三路划分优化到接近 ( O(n \log n) )。</li>
<li><strong>计数排序、桶排序、基数排序</strong>：适用于特定数据范围（如整数或有限范围值），( k ) 表示范围或位数。</li>
</ul>
</li>
</ol>
<p>如果需要某算法的详细代码示例或进一步分析，请告诉我！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>函数后面的const与noexcept</title>
    <url>/2025/06/16/%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E7%9A%84const%E4%B8%8Enoexcept/</url>
    <content><![CDATA[<h2 id="C-中函数后面的-const-和-noexcept-的含义"><a href="#C-中函数后面的-const-和-noexcept-的含义" class="headerlink" title="C++ 中函数后面的 const 和 noexcept 的含义"></a>C++ 中函数后面的 <code>const</code> 和 <code>noexcept</code> 的含义</h2><p>在 C++ 中，函数声明或定义后添加的 <code>const</code> 和 <code>noexcept</code> 是函数修饰符，用于指定函数的行为和属性。</p>
<hr>
<h3 id="1-函数后面的-const"><a href="#1-函数后面的-const" class="headerlink" title="1. 函数后面的 const"></a>1. 函数后面的 <code>const</code></h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><ul>
<li><strong>成员函数限定符</strong>：<code>const</code> 出现在类成员函数的声明或定义后，表示该函数不会修改对象的非 <code>mutable</code> 成员变量。</li>
<li><strong>承诺</strong>：调用该函数时，对象的状态（除 <code>mutable</code> 成员外）保持不变。</li>
<li><strong>语义</strong>：用于声明“只读”成员函数，增强代码安全性。</li>
</ul>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>编译器将 <code>const</code> 成员函数的 <code>this</code> 指针视为 <code>const T*</code>（而非 <code>T*</code>），禁止修改非 <code>mutable</code> 成员。</li>
<li>可被 <code>const</code> 对象、引用或指针调用，而非 <code>const</code> 成员函数只能被非 <code>const</code> 对象调用。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> y = <span class="number">0</span>; <span class="comment">// mutable 允许在 const 函数中修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; x = val; &#125; <span class="comment">// 非 const 函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">// const 函数</span></span><br><span class="line">        <span class="comment">// x = 42; // 错误：不能修改非 mutable 成员</span></span><br><span class="line">        y = <span class="number">42</span>; <span class="comment">// 正确：mutable 成员可修改</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> MyClass obj;</span><br><span class="line">    <span class="comment">// obj.setX(10); // 错误：const 对象不能调用非 const 函数</span></span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 正确：调用 const 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>只读访问</strong>：用于访问对象状态而不修改（如 getter 函数）。</li>
<li><strong>const 正确性</strong>：确保 <code>const</code> 对象或引用能安全调用函数。</li>
<li><strong>接口设计</strong>：提高类接口的语义清晰性和安全性。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>mutable</code> 成员可在 <code>const</code> 函数中修改，需谨慎使用。</li>
<li>重载时，<code>const</code> 和非 <code>const</code> 版本可共存，编译器根据调用对象的 <code>const</code> 属性选择。</li>
</ul>
<hr>
<h3 id="2-函数后面的-noexcept"><a href="#2-函数后面的-noexcept" class="headerlink" title="2. 函数后面的 noexcept"></a>2. 函数后面的 <code>noexcept</code></h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><ul>
<li><strong>异常规范</strong>：<code>noexcept</code> 表示函数承诺不抛出异常（或有条件不抛出）。</li>
<li><strong>性能优化</strong>：编译器可优化不抛异常的函数（如减少异常处理开销）。</li>
<li><strong>C++11 引入</strong>：位于 <code>&lt;exception&gt;</code>，用于增强异常安全性和性能。</li>
</ul>
<h4 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li><code>noexcept</code> 分为两种：<ul>
<li>**无条件 <code>noexcept</code>**：<code>noexcept</code> 或 <code>noexcept(true)</code>，保证不抛异常。</li>
<li>**条件 <code>noexcept</code>**：<code>noexcept(expression)</code>，根据表达式决定是否抛异常。</li>
</ul>
</li>
<li>若 <code>noexcept</code> 函数抛出异常，程序调用 <code>std::terminate()</code> 终止。</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// 无条件不抛异常</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func1 called\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123; <span class="comment">// 可能抛异常</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> x)</span> <span class="title">noexcept</span><span class="params">(x &gt; <span class="number">0</span>)</span> </span>&#123; <span class="comment">// 条件 noexcept</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func3 called with x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>(); <span class="comment">// 安全调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func2</span>(); <span class="comment">// 可能抛异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">func3</span>(<span class="number">1</span>); <span class="comment">// 不抛异常</span></span><br><span class="line">    <span class="built_in">func3</span>(<span class="number">-1</span>); <span class="comment">// 可能抛异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>性能优化</strong>：在标准库容器（如 <code>std::vector</code>）的移动操作中，<code>noexcept</code> 函数可启用更高效的实现（强异常保证）。</li>
<li><strong>异常安全性</strong>：明确函数的异常行为，方便调用者处理。</li>
<li><strong>模板编程</strong>：配合 <code>noexcept</code> 运算符（如 <code>std::is_nothrow_move_constructible</code>）优化代码。</li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>错误使用 <code>noexcept</code>（抛出异常）会导致程序终止，需确保函数逻辑符合承诺。</li>
<li>使用 <code>noexcept</code> 运算符检查函数是否为 <code>noexcept</code>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">noexcept</span>(<span class="built_in">func1</span>()), <span class="string">&quot;func1 should be noexcept&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-结合使用-const-和-noexcept"><a href="#3-结合使用-const-和-noexcept" class="headerlink" title="3. 结合使用 const 和 noexcept"></a>3. 结合使用 <code>const</code> 和 <code>noexcept</code></h3><ul>
<li><code>const</code> 和 <code>noexcept</code> 可同时用于成员函数，互不冲突。</li>
<li>语法：<code>ReturnType func() const noexcept;</code></li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125; <span class="comment">// 只读且不抛异常</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>高性能只读函数</strong>：如标准库中的访问器函数，需高效且安全。</li>
<li><strong>严格接口</strong>：在要求高可靠性的系统中，明确函数行为。</li>
</ul>
<hr>
<h3 id="4-对比总结"><a href="#4-对比总结" class="headerlink" title="4. 对比总结"></a>4. 对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>const</code></th>
<th><code>noexcept</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>禁止修改对象状态</td>
<td>承诺不抛异常</td>
</tr>
<tr>
<td><strong>适用范围</strong></td>
<td>成员函数</td>
<td>任何函数（成员或非成员）</td>
</tr>
<tr>
<td><strong>编译器行为</strong></td>
<td>限制 <code>this</code> 为 <code>const</code></td>
<td>优化代码，异常抛出调用 <code>terminate</code></td>
</tr>
<tr>
<td><strong>性能影响</strong></td>
<td>无直接影响</td>
<td>减少异常处理开销</td>
</tr>
<tr>
<td><strong>语义</strong></td>
<td>保证状态不变</td>
<td>保证异常安全</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul>
<li><strong>误用后果</strong>：<ul>
<li><code>const</code> 函数修改非 <code>mutable</code> 成员会导致编译错误。</li>
<li><code>noexcept</code> 函数抛出异常会导致程序终止。</li>
</ul>
</li>
<li><strong>与智能指针结合</strong>（结合上下文）：<ul>
<li>智能指针（如 <code>unique_ptr</code>、<code>shared_ptr</code>）的析构函数通常是 <code>noexcept</code>，确保异常安全。</li>
<li>成员函数操作智能指针时，<code>const</code> 保证不修改指针状态，<code>noexcept</code> 优化析构或移动操作。</li>
</ul>
</li>
<li><strong>C++ 标准演进</strong>：<ul>
<li>C++11 引入 <code>noexcept</code> 和 <code>alignof</code>，C++17 增强 <code>noexcept</code> 推导。</li>
<li>优先使用 <code>std::make_unique</code>&#x2F;<code>make_shared</code>（如上下文所述），它们通常是 <code>noexcept</code> 的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li>**<code>const</code>**：用于成员函数，保证不修改对象状态，适合只读操作。</li>
<li>**<code>noexcept</code>**：承诺函数不抛异常，提升性能和异常安全性，适合移动操作或关键路径。</li>
<li><strong>结合使用</strong>：在高性能、强安全场景中，<code>const noexcept</code> 提供清晰语义和优化。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2025/06/29/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h3 id="分布式锁是什么？"><a href="#分布式锁是什么？" class="headerlink" title="分布式锁是什么？"></a>分布式锁是什么？</h3><p>分布式锁是一种在分布式系统中用于协调多个节点访问共享资源或执行互斥操作的机制。它的核心目标是确保在分布式环境中，同一时间只有一个节点（或进程）能够访问某个共享资源，避免数据不一致或竞争条件。类似于单机系统中的锁（如 Java 的 <code>synchronized</code> 或 <code>ReentrantLock</code>），但分布式锁需要解决多节点间的同步问题，因此更复杂。</p>
<p>通俗来说，分布式锁就像一个“共享钥匙”：多个节点（或服务）想要操作某个资源时，必须先拿到这把钥匙。一次只能有一个节点持有钥匙，用完后释放，别的节点才能抢到。</p>
<hr>
<h3 id="分布式锁的机制"><a href="#分布式锁的机制" class="headerlink" title="分布式锁的机制"></a>分布式锁的机制</h3><p>分布式锁通常依赖一个<strong>中心化的协调服务</strong>（如 ZooKeeper、Redis、etcd）或某种一致性协议来实现。以下是分布式锁的典型工作流程：</p>
<ol>
<li><p><strong>获取锁</strong>：</p>
<ul>
<li>节点 A 尝试向协调服务（如 Redis）请求锁，比如通过 <code>SETNX</code>（set if not exists）命令在 Redis 中设置一个键（如 <code>lock:resource1</code>），并带上过期时间（防止死锁）。</li>
<li>如果键设置成功，节点 A 获得锁；如果键已存在，说明其他节点持有锁，节点 A 需要等待或重试。</li>
</ul>
</li>
<li><p><strong>执行操作</strong>：</p>
<ul>
<li>节点 A 持有锁后，安全地访问共享资源（比如修改数据库中的某条记录）。</li>
<li>其他节点（如 B、C）尝试获取锁时会失败，只能等待。</li>
</ul>
</li>
<li><p><strong>释放锁</strong>：</p>
<ul>
<li>节点 A 完成操作后，主动释放锁（比如删除 Redis 中的键）。</li>
<li>其他节点检测到锁被释放后，重新竞争锁。</li>
</ul>
</li>
<li><p><strong>防止死锁</strong>：</p>
<ul>
<li>为了避免节点崩溃导致锁无法释放，分布式锁通常会设置<strong>过期时间</strong>（TTL）。如果节点 A 持有锁但崩溃，锁会在过期后自动释放。</li>
<li>为了确保安全，锁还会绑定节点标识（如 UUID），释放锁时检查是否是自己持有的锁。</li>
</ul>
</li>
<li><p><strong>重试机制</strong>：</p>
<ul>
<li>如果节点 B 没抢到锁，可以通过轮询、订阅通知（如 ZooKeeper 的 Watch 机制）或阻塞等待来重试获取锁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="分布式锁的常见实现"><a href="#分布式锁的常见实现" class="headerlink" title="分布式锁的常见实现"></a>分布式锁的常见实现</h3><ol>
<li><p><strong>基于 Redis</strong>：</p>
<ul>
<li>使用 <code>SETNX</code> 命令设置锁，结合 <code>EXPIRE</code> 设置过期时间。</li>
<li>释放锁时使用 Lua 脚本确保只有锁的持有者能删除键。</li>
<li>优点：高性能、简单易用。</li>
<li>缺点：单点故障风险（需用 Redis 集群缓解），锁过期时间难以设置（过短可能导致锁提前失效，过长可能影响效率）。</li>
</ul>
</li>
<li><p><strong>基于 ZooKeeper</strong>：</p>
<ul>
<li>使用临时顺序节点（如 <code>/lock/resource1</code>）实现锁。</li>
<li>节点竞争创建顺序节点，序号最小的节点获得锁，其他节点监听前一个节点的状态。</li>
<li>优点：强一致性，适合高可靠性场景；支持 Watch 机制，效率高。</li>
<li>缺点：部署和维护较复杂，性能略低于 Redis。</li>
</ul>
</li>
<li><p><strong>基于 etcd</strong>：</p>
<ul>
<li>利用 etcd 的租约（Lease）和键值存储实现锁。</li>
<li>节点通过租约创建键，获取锁；租约到期自动释放。</li>
<li>优点：强一致性，支持分布式事务。</li>
<li>缺点：性能和复杂度与 ZooKeeper 类似。</li>
</ul>
</li>
<li><p><strong>基于数据库</strong>：</p>
<ul>
<li>通过数据库的唯一约束（如插入唯一记录）或事务实现锁。</li>
<li>优点：简单，适合已有数据库的场景。</li>
<li>缺点：性能较低，数据库压力大。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="与-Raft-的关系和对比"><a href="#与-Raft-的关系和对比" class="headerlink" title="与 Raft 的关系和对比"></a>与 Raft 的关系和对比</h3><p>你提到实现过 Raft 集群，Raft 是一种分布式一致性协议，主要用于保证数据复制和状态机的一致性（比如在分布式数据库或配置中心中）。分布式锁和 Raft 的目标不同，但有一定联系：</p>
<ul>
<li><p><strong>共同点</strong>：</p>
<ul>
<li>两者都用于分布式系统，解决多节点协作问题。</li>
<li>Raft 也可以用来实现分布式锁（比如基于 Raft 构建的键值存储，类似 etcd 的方式）。</li>
<li>都需要处理节点故障、脑裂等问题。</li>
</ul>
</li>
<li><p><strong>不同点</strong>：</p>
<ul>
<li>Raft 关注的是<strong>数据一致性</strong>（如日志复制），而分布式锁关注的是<strong>互斥访问</strong>（如控制谁能修改资源）。</li>
<li>Raft 通常用于状态机复制场景（如分布式数据库），而分布式锁更常用于短暂的资源访问控制（如秒杀系统）。</li>
<li>Raft 的实现复杂度较高（需要选举 Leader、复制日志等），而分布式锁的实现可以更轻量（比如 Redis 实现只需几个命令）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="分布式锁的优势"><a href="#分布式锁的优势" class="headerlink" title="分布式锁的优势"></a>分布式锁的优势</h3><ol>
<li><p><strong>互斥性</strong>：</p>
<ul>
<li>保证分布式环境中同一时间只有一个节点能操作共享资源，避免数据竞争和不一致。</li>
</ul>
</li>
<li><p><strong>高可用性</strong>：</p>
<ul>
<li>通过协调服务（如 Redis 集群、ZooKeeper 集群），分布式锁可以在节点故障时继续工作。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li>分布式锁可以用于多种场景，如分布式任务调度、秒杀系统、分布式事务等。</li>
</ul>
</li>
<li><p><strong>防止死锁</strong>：</p>
<ul>
<li>自动过期机制和节点标识检查可以有效避免死锁问题。</li>
</ul>
</li>
<li><p><strong>可扩展性</strong>：</p>
<ul>
<li>分布式锁支持动态扩展，新增节点不会破坏锁的机制。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="分布式锁的典型应用场景"><a href="#分布式锁的典型应用场景" class="headerlink" title="分布式锁的典型应用场景"></a>分布式锁的典型应用场景</h3><ol>
<li><p><strong>秒杀系统</strong>：</p>
<ul>
<li>确保库存扣减操作是线程安全的，避免超卖。</li>
<li>比如用 Redis 分布式锁控制对库存键的访问。</li>
</ul>
</li>
<li><p><strong>分布式任务调度</strong>：</p>
<ul>
<li>在多个节点运行的任务中，确保某个任务只被一个节点执行（如 Quartz 集群中的任务调度）。</li>
</ul>
</li>
<li><p><strong>分布式事务</strong>：</p>
<ul>
<li>在分布式系统中协调多个服务的事务操作，确保一致性。</li>
</ul>
</li>
<li><p><strong>配置管理</strong>：</p>
<ul>
<li>确保配置更新时只有一个节点能修改配置（如 ZooKeeper 的分布式配置管理）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="通俗比喻"><a href="#通俗比喻" class="headerlink" title="通俗比喻"></a>通俗比喻</h3><p>想象一个图书馆，只有一本珍贵书籍（共享资源）。图书馆有很多读者（分布式节点），但一次只能有一个读者借阅这本书。为了避免争抢，图书馆用一个登记本（分布式锁服务）记录谁在借书：</p>
<ul>
<li>读者 A 去登记本上写下自己的名字（获取锁），其他读者（B、C）看到名字已存在，只能等待。</li>
<li>读者 A 读完书后擦掉自己的名字（释放锁），其他人再去抢着登记。</li>
<li>如果读者 A 忘了还书，登记本会自动清除名字（锁过期），让其他人有机会借书。</li>
</ul>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>锁的粒度</strong>：</p>
<ul>
<li>锁的范围要尽量小，避免锁住过多资源，影响并发性能。</li>
</ul>
</li>
<li><p><strong>过期时间设置</strong>：</p>
<ul>
<li>过期时间要合理，过短可能导致锁提前失效，过长可能导致其他节点等待过久。</li>
</ul>
</li>
<li><p><strong>性能瓶颈</strong>：</p>
<ul>
<li>分布式锁依赖协调服务（如 Redis、ZooKeeper），其性能和可靠性会影响锁的效率。</li>
</ul>
</li>
<li><p><strong>一致性要求</strong>：</p>
<ul>
<li>如果需要强一致性，推荐 ZooKeeper 或 etcd；如果追求高性能，Redis 是更好的选择。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分布式锁是分布式系统中实现互斥访问的利器，通过协调服务（如 Redis、ZooKeeper、etcd）确保多节点间的同步。相比你熟悉的 Raft，分布式锁更专注于资源访问控制，机制更轻量，应用场景更灵活。它的优势在于互斥性、高可用性和防止死锁，广泛用于秒杀、任务调度等场景。如果你想尝试实现，可以从 Redis 的 <code>SETNX</code> 开始，结合 Raft 的经验，理解起来会更轻松</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀表与KMP算法</title>
    <url>/2024/11/02/%E5%89%8D%E7%BC%80%E8%A1%A8%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p> KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配的高效算法，它能够在文本串中查找模式串出现的位置。KMP算法的核心在于避免重复比较字符，从而提高匹配效率。</p>
<h3 id="KMP算法的基本思路"><a href="#KMP算法的基本思路" class="headerlink" title="KMP算法的基本思路"></a>KMP算法的基本思路</h3><ol>
<li><strong>预处理模式串</strong>：通过构建一个“部分匹配表”（或称为“失配表”），在模式串中记录每个位置的最长可匹配前缀长度。</li>
<li><strong>匹配过程</strong>：利用部分匹配表，在匹配失败时，根据前缀信息跳过不必要的比较，从而加速匹配过程。</li>
</ol>
<h3 id="部分匹配表（LPS数组）"><a href="#部分匹配表（LPS数组）" class="headerlink" title="部分匹配表（LPS数组）"></a>部分匹配表（LPS数组）</h3><p>LPS（Longest Prefix Suffix）数组用于存储模式串的每个前缀的最长相等前后缀的长度。具体构建方式如下：</p>
<ul>
<li>**LPS[i]**：表示模式串的前缀（<code>pattern[0]</code> 到 <code>pattern[i]</code>）的最长相等前后缀的长度。</li>
</ul>
<h3 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h3><p>下面是KMP算法的完整实现，包括LPS数组的构建和匹配过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于构建LPS数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">computeLPS</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lps</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// 上一个最长前缀后缀的长度</span></span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;     <span class="comment">// LPS[0]始终为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (length &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[length]) &#123;</span><br><span class="line">            length = lps[length - <span class="number">1</span>]; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[length]) &#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        lps[i] = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP搜索算法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">KMPSearch</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; lps = <span class="built_in">computeLPS</span>(pattern);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; positions; <span class="comment">// 存储匹配的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 文本指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == text[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配</span></span><br><span class="line">            positions.<span class="built_in">push_back</span>(i - j);</span><br><span class="line">            j = lps[j - <span class="number">1</span>]; <span class="comment">// 继续查找下一个匹配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; pattern[j] != text[i]) &#123; <span class="comment">// 匹配失败</span></span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = lps[j - <span class="number">1</span>]; <span class="comment">// 根据LPS表跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++; <span class="comment">// 否则向前移动文本指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">KMPSearch</span>(text, pattern);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pos : result) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pattern found at index: &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol>
<li><strong>computeLPS函数</strong>：构建LPS数组，遍历模式串并填充LPS数组，使用回溯逻辑。</li>
<li><strong>KMPSearch函数</strong>：使用LPS数组进行模式匹配：<ul>
<li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向文本和模式串。</li>
<li>如果字符匹配，两个指针同时移动。</li>
<li>如果模式串匹配完成，将起始位置保存。</li>
<li>如果不匹配，根据LPS数组调整模式指针。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n + m)，其中 n 是文本串的长度，m 是模式串的长度。</li>
<li><strong>空间复杂度</strong>：O(m)，用于存储LPS数组。</li>
</ul>
<p>KMP算法是一个非常高效的字符串匹配算法，适用于大规模文本搜索。希望这个解释和示例代码对你理解KMP算法有帮助！如果你有任何问题或需要进一步的解释，请告诉我！</p>
<p> 当然可以！让我们通过一个具体的实例来演示KMP算法的工作过程。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有以下文本串和模式串：</p>
<ul>
<li><strong>文本串</strong>：<code>text = &quot;ABABDABACDABABCABAB&quot;</code></li>
<li><strong>模式串</strong>：<code>pattern = &quot;ABABCABAB&quot;</code></li>
</ul>
<p>我们要找到模式串在文本串中的所有出现位置。</p>
<h3 id="步骤-1：构建LPS数组"><a href="#步骤-1：构建LPS数组" class="headerlink" title="步骤 1：构建LPS数组"></a>步骤 1：构建LPS数组</h3><p>首先，我们需要构建模式串的LPS数组。</p>
<h4 id="模式串：ABABCABAB"><a href="#模式串：ABABCABAB" class="headerlink" title="模式串：ABABCABAB"></a>模式串：<code>ABABCABAB</code></h4><ul>
<li>计算LPS数组：<ul>
<li><code>lps[0] = 0</code>（第一个字符没有前缀和后缀）</li>
<li><code>lps[1] = 0</code>（<code>A</code>没有相等的前后缀）</li>
<li><code>lps[2] = 1</code>（<code>AB</code>的前缀<code>A</code>和后缀<code>A</code>相等）</li>
<li><code>lps[3] = 2</code>（<code>ABA</code>的前缀<code>AB</code>和后缀<code>AB</code>相等）</li>
<li><code>lps[4] = 0</code>（<code>ABAB</code>没有相等的前后缀）</li>
<li><code>lps[5] = 1</code>（<code>ABABC</code>的前缀<code>A</code>和后缀<code>A</code>相等）</li>
<li><code>lps[6] = 2</code>（<code>ABABCA</code>的前缀<code>AB</code>和后缀<code>AB</code>相等）</li>
<li><code>lps[7] = 3</code>（<code>ABABCAB</code>的前缀<code>ABA</code>和后缀<code>ABA</code>相等）</li>
<li><code>lps[8] = 4</code>（<code>ABABCABA</code>的前缀<code>ABAB</code>和后缀<code>ABAB</code>相等）</li>
</ul>
</li>
</ul>
<p>最终的LPS数组为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lps = [0, 0, 1, 2, 0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="步骤-2：进行KMP搜索"><a href="#步骤-2：进行KMP搜索" class="headerlink" title="步骤 2：进行KMP搜索"></a>步骤 2：进行KMP搜索</h3><p>接下来我们使用KMP算法进行匹配。</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>i = 0</code>（文本指针）</li>
<li><code>j = 0</code>（模式指针）</li>
<li><code>positions = []</code>（存储匹配位置）</li>
</ul>
</li>
<li><p><strong>开始匹配</strong>：</p>
<ul>
<li><strong>第 1 次比较</strong>：<code>text[0] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 1</code>, <code>j = 1</code></li>
<li><strong>第 2 次比较</strong>：<code>text[1] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 2</code>, <code>j = 2</code></li>
<li><strong>第 3 次比较</strong>：<code>text[2] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 3</code>, <code>j = 3</code></li>
<li> Constructed with 10Constructed with 20obj1 value: 10DestructedDestructedcsharp</li>
<li><strong>第 5 次比较</strong>：<code>text[4] = &#39;D&#39;</code>, <code>pattern[4] = &#39;C&#39;</code> → 不匹配。根据LPS数组，<code>j = lps[3] = 2</code>，回溯到<code>pattern[2]</code>。</li>
<li><strong>继续比较</strong>：<code>text[4] = &#39;D&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 不匹配，<code>j = lps[1] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 5</code>。</li>
</ul>
</li>
<li><p><strong>继续匹配</strong>：</p>
<ul>
<li><strong>第 6 次比较</strong>：<code>text[5] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 6</code>, <code>j = 1</code></li>
<li><strong>第 7 次比较</strong>：<code>text[6] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 7</code>, <code>j = 2</code></li>
<li><strong>第 8 次比较</strong>：<code>text[7] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 8</code>, <code>j = 3</code></li>
<li><strong>第 9 次比较</strong>：<code>text[8] = &#39;C&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 不匹配。根据LPS，<code>j = lps[2] = 1</code>，回溯到<code>pattern[1]</code>。</li>
<li><strong>继续比较</strong>：<code>text[8] = &#39;C&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 不匹配，<code>j = lps[0] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 9</code>。</li>
</ul>
</li>
<li><p><strong>再次匹配</strong>：</p>
<ul>
<li><strong>第 10 次比较</strong>：<code>text[9] = &#39;D&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 不匹配，<code>i++</code> → <code>i = 10</code>。</li>
<li><strong>第 11 次比较</strong>：<code>text[10] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 11</code>, <code>j = 1</code></li>
<li><strong>第 12 次比较</strong>：<code>text[11] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 12</code>, <code>j = 2</code></li>
<li><strong>第 13 次比较</strong>：<code>text[12] = &#39;C&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 不匹配，<code>j = lps[1] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 13</code>。</li>
<li><strong>第 14 次比较</strong>：<code>text[13] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 14</code>, <code>j = 1</code></li>
<li><strong>第 15 次比较</strong>：<code>text[14] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 15</code>, <code>j = 2</code></li>
<li><strong>第 16 次比较</strong>：<code>text[15] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 16</code>, <code>j = 3</code></li>
<li><strong>第 17 次比较</strong>：<code>text[16] = &#39;B&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 17</code>, <code>j = 4</code></li>
<li><strong>第 18 次比较</strong>：<code>text[17] = &#39;C&#39;</code>, <code>pattern[4] = &#39;C&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 18</code>, <code>j = 5</code></li>
<li><strong>第 19 次比较</strong>：<code>text[18] = &#39;A&#39;</code>, <code>pattern[5] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 19</code>, <code>j = 6</code></li>
<li><strong>第 20 次比较</strong>：<code>text[19] = &#39;B&#39;</code>, <code>pattern[6] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 20</code>, <code>j = 7</code></li>
<li><strong>第 21 次比较</strong>：<code>i = 20</code>，超出文本长度，停止匹配。</li>
</ul>
</li>
</ol>
<h3 id="匹配结果"><a href="#匹配结果" class="headerlink" title="匹配结果"></a>匹配结果</h3><p>在整个过程中，我们找到了模式串在文本串中的匹配起始位置：</p>
<ul>
<li><strong>匹配位置</strong>：<code>positions = [10]</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>模式串 <code>&quot;ABABCABAB&quot;</code> 在文本串 <code>&quot;ABABDABACDABABCABAB&quot;</code> 中的匹配位置是 <code>10</code>。</li>
</ul>
<p>这种通过LPS数组的预处理，使得算法能够避免重复比较，提高了效率，特别是在文本较长和模式较短的情况下尤为明显。如果你有其他问题或需要更深入的解释，请随时问我！</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>kmp</tag>
        <tag>前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>分支预测</title>
    <url>/2025/09/23/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<p>说实话，我是怎么也没想到这玩意可以被放到面试题合集里面，但是凯读的笔试考了，真服了</p>
<hr>
<h3 id="一、-分支预测-Branch-Prediction"><a href="#一、-分支预测-Branch-Prediction" class="headerlink" title="一、 分支预测 (Branch Prediction)"></a>一、 分支预测 (Branch Prediction)</h3><h4 id="1-什么是分支预测？"><a href="#1-什么是分支预测？" class="headerlink" title="1. 什么是分支预测？"></a>1. 什么是分支预测？</h4><p>分支预测是现代微处理器（CPU）中的一项关键技术，用于<strong>优化指令流水线（Instruction Pipeline）的效率</strong>。简单来说，当CPU遇到一个条件分支（例如 <code>if-else</code> 语句、<code>switch</code> 语句、循环等）时，它需要决定接下来执行哪条路径的指令。然而，CPU无法立即知道条件判断的结果，如果等待判断结果出来再取下一条指令，就会导致流水线停顿，浪费大量时间。</p>
<p>为了避免这种停顿，CPU会<strong>猜测</strong>哪个分支会被执行，并提前获取并处理该分支上的指令。这就是分支预测。</p>
<h4 id="2-为什么需要分支预测？"><a href="#2-为什么需要分支预测？" class="headerlink" title="2. 为什么需要分支预测？"></a>2. 为什么需要分支预测？</h4><p>现代CPU采用<strong>指令流水线</strong>技术，将指令的执行过程分解为多个阶段（如取指、译码、执行、访存、写回），并让多个指令在不同阶段并行执行，就像工厂的流水线一样。这大大提高了CPU的吞吐量。</p>
<p>然而，当遇到条件分支时，流水线的执行会遇到挑战：</p>
<ul>
<li><strong>取指阶段</strong>需要知道下一条指令的地址。</li>
<li>如果下一条指令的地址取决于一个尚未计算出的条件（例如 <code>if (x &gt; y)</code>），那么流水线就必须等待 <code>x &gt; y</code> 的结果。</li>
<li>这种等待会导致流水线**停顿 (Stall)**，所有后续阶段的指令都无法继续，大大降低了流水线的效率。</li>
</ul>
<p>分支预测就是为了解决这个问题而生。</p>
<h4 id="3-分支预测的工作原理"><a href="#3-分支预测的工作原理" class="headerlink" title="3. 分支预测的工作原理"></a>3. 分支预测的工作原理</h4><p>CPU内部有一个**分支预测器 (Branch Predictor)**，它会根据历史信息和启发式算法来预测分支的走向。</p>
<ul>
<li><strong>预测正确 (Prediction Hit)：</strong> 如果CPU的猜测是正确的，那么它提前加载和处理的指令就是正确的，流水线可以顺畅地继续执行，没有任何停顿。这是我们希望看到的最佳情况。</li>
<li><strong>预测错误 (Prediction Miss &#x2F; Misprediction)：</strong> 如果CPU的猜测是错误的，那么它提前加载和处理的指令就都是无用的。此时，CPU必须：<ol>
<li><strong>清空 (Flush)</strong> 流水线中所有错误路径上的指令。</li>
<li><strong>回滚 (Rollback)</strong> CPU的状态到分支点之前的状态。</li>
<li>从正确的分支路径重新**取指 (Fetch)**。<br>这个过程会带来巨大的性能开销，通常会导致几十甚至上百个CPU周期的浪费。</li>
</ol>
</li>
</ul>
<h4 id="4-分支预测的策略-简述"><a href="#4-分支预测的策略-简述" class="headerlink" title="4. 分支预测的策略 (简述)"></a>4. 分支预测的策略 (简述)</h4><p>分支预测器会使用各种复杂的策略来提高预测准确率：</p>
<ul>
<li><strong>静态预测：</strong> 基于指令的类型或方向（例如，循环的向后跳转通常被预测为“Taken”）。</li>
<li><strong>动态预测：</strong> 基于分支的历史行为。<ul>
<li><strong>1-bit 预测器：</strong> 记住上次分支是否被执行。</li>
<li><strong>2-bit 预测器 (饱和计数器)：</strong> 用一个两位计数器来记录分支的历史。只有连续两次预测错误才会改变预测方向，这使得预测器对偶尔的异常行为更具鲁棒性。</li>
<li><strong>全局历史预测器：</strong> 结合多个分支的历史信息进行预测。</li>
<li><strong>间接分支预测器：</strong> 预测通过函数指针或虚函数调用实现的间接跳转的目标地址。</li>
</ul>
</li>
</ul>
<h4 id="5-分支预测对性能的影响"><a href="#5-分支预测对性能的影响" class="headerlink" title="5. 分支预测对性能的影响"></a>5. 分支预测对性能的影响</h4><ul>
<li><strong>可预测的分支 (Predictable Branches)：</strong> 如果一个分支的走向是规律的（例如，循环大部分时间都会执行，直到最后一次退出），分支预测器就能很好地预测，性能影响很小。</li>
<li><strong>不可预测的分支 (Unpredictable Branches)：</strong> 如果一个分支的走向是随机的，或者频繁地在“Taken”和“Not Taken”之间切换，分支预测器就很难准确预测，导致大量的预测错误，从而严重拖慢程序执行速度。</li>
</ul>
<hr>
<h3 id="二、-函数数组-Function-Arrays-及其优越性"><a href="#二、-函数数组-Function-Arrays-及其优越性" class="headerlink" title="二、 函数数组 (Function Arrays) 及其优越性"></a>二、 函数数组 (Function Arrays) 及其优越性</h3><p>函数数组（更准确地说，是<strong>函数指针数组</strong>）是一种存储函数指针的数组。它的每个元素都是一个指向特定函数的指针。</p>
<h4 id="1-传统的分支密集型代码-Switch-If-Else-If"><a href="#1-传统的分支密集型代码-Switch-If-Else-If" class="headerlink" title="1. 传统的分支密集型代码 (Switch&#x2F;If-Else If)"></a>1. 传统的分支密集型代码 (Switch&#x2F;If-Else If)</h4><p>考虑一个常见的场景：根据一个枚举值或整数值来执行不同的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operation</span> &#123; ADD, SUB, MUL, DIV &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; std::cout &lt;&lt; a + b &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; std::cout &lt;&lt; a - b &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; std::cout &lt;&lt; a * b &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">div_op</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">if</span> (b != <span class="number">0</span>) std::cout &lt;&lt; a / b &lt;&lt; std::endl; <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;Error: Divide by zero&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perform_operation_switch</span><span class="params">(Operation op, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> ADD: <span class="built_in">add</span>(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUB: <span class="built_in">sub</span>(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MUL: <span class="built_in">mul</span>(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DIV: <span class="built_in">div_op</span>(x, y); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: std::cout &lt;&lt; <span class="string">&quot;Unknown operation&quot;</span> &lt;&lt; std::endl; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>if-else if</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">perform_operation_if_else</span><span class="params">(Operation op, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == ADD) &#123;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SUB) &#123;</span><br><span class="line">        <span class="built_in">sub</span>(x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == MUL) &#123;</span><br><span class="line">        <span class="built_in">mul</span>(x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == DIV) &#123;</span><br><span class="line">        <span class="built_in">div_op</span>(x, y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unknown operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些情况下，<code>switch</code> 语句或 <code>if-else if</code> 链会产生一系列的条件分支。如果 <code>op</code> 的值是随机的，或者在不同的调用之间频繁变化，那么分支预测器就很难准确预测下一个要执行的 <code>case</code> 或 <code>else if</code> 分支，从而导致大量的<strong>分支预测错误</strong>，严重影响性能。</p>
<h4 id="2-使用函数数组"><a href="#2-使用函数数组" class="headerlink" title="2. 使用函数数组"></a>2. 使用函数数组</h4><p>我们可以用函数指针数组来替代上述的分支密集型代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// For std::function</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数签名</span></span><br><span class="line"><span class="keyword">using</span> OperationFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这些函数已经定义</span></span><br><span class="line"><span class="comment">// void add(int a, int b) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// void sub(int a, int b) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// void mul(int a, int b) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// void div_op(int a, int b) &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针数组</span></span><br><span class="line"><span class="comment">// 注意：std::function 允许存储 lambda、函数指针、函数对象等</span></span><br><span class="line"><span class="comment">// 如果只存储普通函数指针，可以用：void (*operations_ptr[])(int, int) = &#123;&amp;add, &amp;sub, ...&#125;;</span></span><br><span class="line">std::vector&lt;OperationFunc&gt; operations_array = &#123;</span><br><span class="line">    add,    <span class="comment">// 对应 ADD = 0</span></span><br><span class="line">    sub,    <span class="comment">// 对应 SUB = 1</span></span><br><span class="line">    mul,    <span class="comment">// 对应 MUL = 2</span></span><br><span class="line">    div_op  <span class="comment">// 对应 DIV = 3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perform_operation_array</span><span class="params">(Operation op, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op &gt;= <span class="number">0</span> &amp;&amp; op &lt; operations_array.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        operations_array[op](x, y); <span class="comment">// 直接通过索引调用函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unknown operation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例调用</span></span><br><span class="line">    <span class="built_in">perform_operation_switch</span>(ADD, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">perform_operation_array</span>(SUB, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">perform_operation_if_else</span>(MUL, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">perform_operation_array</span>(DIV, <span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 演示错误处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-函数数组的优越性-在分支预测上下文"><a href="#3-函数数组的优越性-在分支预测上下文" class="headerlink" title="3. 函数数组的优越性 (在分支预测上下文)"></a>3. 函数数组的优越性 (在分支预测上下文)</h4><p>使用函数数组的主要优越性在于它能够<strong>减少分支预测错误的开销</strong>，尤其是在处理大量随机或不可预测的分支时：</p>
<ol>
<li><p><strong>消除多重条件分支：</strong></p>
<ul>
<li><code>if-else if</code> 和 <code>switch</code> 语句会生成一系列的条件跳转指令。CPU需要对每个条件进行预测。如果 <code>op</code> 的值是随机的，每次都需要预测，且预测错误的概率高，就会导致大量流水线清空。</li>
<li>函数数组通过 <code>operations_array[op](x, y);</code> 实现了**间接跳转 (Indirect Jump)**。虽然间接跳转本身也是一个分支，但它只有一个目标，并且目标地址通常可以通过简单的内存查找（数组索引）直接计算出来。</li>
<li>对于这种<strong>基于索引的间接跳转</strong>，现代CPU的间接分支预测器（如 BTB - Branch Target Buffer）通常能够更有效地预测目标地址，尤其是在目标地址集较小且稳定时。即使预测失败，也只是一次预测失败，而不是一系列潜在的预测失败。</li>
</ul>
</li>
<li><p><strong>常数时间复杂度 (O(1)) 的分派：</strong></p>
<ul>
<li>访问数组元素是 O(1) 操作。这意味着无论有多少个操作，查找并调用正确函数的开销都是恒定的。</li>
<li>虽然编译器通常会将 <code>switch</code> 语句优化为**跳转表 (Jump Table)**，使其在大多数情况下也达到 O(1) 的分派效率，但跳转表仍然涉及到分支预测的问题。函数数组在底层实现上与跳转表类似，但它在源代码层面更直接地表达了这种“直接跳转”的意图，有时能更好地帮助编译器和CPU优化。</li>
</ul>
</li>
<li><p><strong>代码更简洁和可扩展：</strong></p>
<ul>
<li>对于大量操作，函数数组比冗长的 <code>if-else if</code> 链或 <code>switch</code> 语句更简洁、易读。</li>
<li>添加新的操作只需在数组中添加新的函数指针，而无需修改现有的 <code>switch</code> 结构，降低了维护成本和引入错误的风险。</li>
</ul>
</li>
<li><p><strong>避免数据依赖造成的流水线停顿：</strong></p>
<ul>
<li>在 <code>if-else if</code> 链中，每个条件判断都可能依赖于前一个判断的结果，这可能会在流水线中引入数据依赖，导致停顿。</li>
<li>函数数组直接通过索引访问，索引本身通常是独立的，减少了这种依赖。</li>
</ul>
</li>
</ol>
<h4 id="4-适用场景和注意事项"><a href="#4-适用场景和注意事项" class="headerlink" title="4. 适用场景和注意事项"></a>4. 适用场景和注意事项</h4><p><strong>适用场景：</strong></p>
<ul>
<li>当你需要根据一个整数或枚举值来执行多个不同的、具有相同签名的函数时。</li>
<li>当这些操作的调用模式是随机的，导致 <code>switch</code> 或 <code>if-else if</code> 产生大量分支预测错误时。</li>
<li>需要高性能、低延迟的事件分发系统（如游戏引擎、网络服务器）。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><strong>函数签名必须一致：</strong> 数组中的所有函数指针必须指向具有相同参数类型和返回类型的函数。如果函数签名不同，你需要使用 <code>std::variant&lt;std::function&lt;...&gt;&gt;</code> 或其他更复杂的机制。</li>
<li><strong>索引必须连续且合理：</strong> 如果你的枚举值或整数索引是稀疏的（例如 0, 1, 100, 1000），那么创建一个巨大的数组来填充中间的空洞将是内存浪费。在这种情况下，<code>std::map&lt;int, OperationFunc&gt;</code> 可能更合适，但会牺牲一部分性能（因为 <code>map</code> 查找本身也有分支和缓存问题）。</li>
<li><strong>安全性：</strong> 直接通过外部输入索引函数数组可能存在安全风险（例如，索引越界可能导致执行任意内存地址的代码）。务必进行严格的边界检查。</li>
<li><strong>小规模场景：</strong> 对于只有少数几个分支的情况，<code>switch</code> 语句通常会被编译器优化得非常好，并且代码可能更直观，此时函数数组的性能优势不明显。</li>
</ul>
<p>总之，函数数组是一种强大的优化技术，它通过将运行时决策转化为直接的内存查找和间接跳转，有效地规避了分支预测失败带来的性能惩罚，尤其适用于需要高效分发大量随机操作的场景。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>协程</title>
    <url>/2025/06/29/%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="协程（Coroutine）介绍及其分类"><a href="#协程（Coroutine）介绍及其分类" class="headerlink" title="协程（Coroutine）介绍及其分类"></a>协程（Coroutine）介绍及其分类</h1><h2 id="1-什么是协程？"><a href="#1-什么是协程？" class="headerlink" title="1. 什么是协程？"></a>1. <strong>什么是协程？</strong></h2><p><strong>协程也可以叫做”轻量级的线程，用户线程“。</strong><br>    简单的理解协程，协程一种执行过程中能够yield(暂停)和resume(恢复)的子程序，也可以说是协程就是函数和函数运行状态的组合，怎么理解？正常的函数在执行中是直接就执行完成了中间不会有多余的步骤，更不会说我这个函数执行到一半就去执行其他函数了，但是协程不一样，我们使用协程首先要绑定一个入口函数，并且可以在函数的任意位置暂停去执行其他其他的函数，再回来执行暂停的函数，所以说协程是函数和函数运行状态的组合(协程需要绑定入口函数，协程记录了函数的运行状态)。<br><strong>那么协程是如何做到让函数暂停和让函数的恢复呢？</strong><br>这个是因为协程的记录会有协程上下文，协程执行yield的时候，协程上下文记录了协程暂停的位置。当resume的时候就是从暂停的地方恢复。协程上下文包含了函数在当前状态的全部cpu寄存器的值，这些寄存器记录函数的栈帧、代码执行的位置等信息，如果把这些值交给cpu去执行，那么就会实现从函数暂停的地方去恢复执行。</p>
<p><strong>需要注意单线程的情况下，协程的resume和yield一定是同步的，</strong>一个协程进行yield暂停，必然对应另一个协程的resume恢复，因为线程不能没用执行主体。并且协程的yield和resume是应用程序控制的，这点和线程不一样。</p>
<p>线程的运行和调度是操作系统来完成的，协程的运行和调用是由应用程序来完成的，所以协程也叫做“用户态线程”。</p>
<p><strong>核心特点</strong>：</p>
<ul>
<li><strong>协作式调度</strong>：协程在特定点（yield 或 await）主动挂起，交出控制权。</li>
<li><strong>上下文切换</strong>：保存当前执行状态（如栈帧、寄存器），恢复时继续执行。</li>
<li><strong>轻量级</strong>：比线程更低的内存和切换开销。</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li>异步 I&#x2F;O（如网络请求、文件操作）。</li>
<li>事件驱动系统（如游戏循环、Web 服务器）。</li>
<li>并发任务处理（如协程池替代线程池）。</li>
</ul>
<h2 id="2-协程的分类"><a href="#2-协程的分类" class="headerlink" title="2. 协程的分类"></a>2. <strong>协程的分类</strong></h2><p>协程可以根据调度方式、栈管理方式等分为以下几类：</p>
<h3 id="2-1-对称协程-vs-非对称协程"><a href="#2-1-对称协程-vs-非对称协程" class="headerlink" title="2.1 对称协程 vs 非对称协程"></a><strong>2.1 对称协程 vs 非对称协程</strong></h3><h4 id="对称协程（Symmetric-Coroutine）"><a href="#对称协程（Symmetric-Coroutine）" class="headerlink" title="对称协程（Symmetric Coroutine）"></a><strong>对称协程（Symmetric Coroutine）</strong></h4><ul>
<li><strong>定义</strong>：协程之间可以直接切换，调用者和被调用者的地位平等，控制权可任意传递给另一个协程。</li>
<li><strong>机制</strong>：通过类似 <code>yield to</code> 的操作，协程直接指定下一个执行的协程。</li>
<li><strong>示例</strong>：Lua 的协程（<code>coroutine.resume</code> 和 <code>coroutine.yield</code>）。</li>
<li><strong>优点</strong>：<ul>
<li><strong>灵活性高</strong>：协程可以自由切换，适合复杂控制流。</li>
<li><strong>通用性</strong>：可实现多种并发模型。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>调度复杂</strong>：需要程序员显式管理协程切换，易出错。</li>
<li><strong>调试困难</strong>：控制流分散，难以跟踪状态。</li>
</ul>
</li>
</ul>
<h4 id="非对称协程（Asymmetric-Coroutine）"><a href="#非对称协程（Asymmetric-Coroutine）" class="headerlink" title="非对称协程（Asymmetric Coroutine）"></a><strong>非对称协程（Asymmetric Coroutine）</strong></h4><ul>
<li><strong>定义</strong>：协程分为调用者和被调用者，控制权只能在调用者和被调用者之间传递（通常通过 <code>yield</code> 返回调用者，<code>resume</code> 恢复协程）。</li>
<li><strong>机制</strong>：协程只能挂起回调用者，无法直接切换到其他协程。</li>
<li><strong>示例</strong>：C++20 的 <code>co_await</code> 和 <code>co_yield</code>，Python 的 <code>async/await</code>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>简单易用</strong>：控制流清晰，调用者管理协程生命周期。</li>
<li><strong>易于调试</strong>：挂起和恢复的点明确，适合异步编程。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>灵活性较低</strong>：无法直接在协程间切换，限制了某些并发模型。</li>
<li><strong>依赖调用者</strong>：协程的执行依赖调用者的调度。</li>
</ul>
</li>
</ul>
<h4 id="对称-vs-非对称对比"><a href="#对称-vs-非对称对比" class="headerlink" title="对称 vs 非对称对比"></a><strong>对称 vs 非对称对比</strong></h4><ul>
<li>对称协程适合需要复杂控制流的场景，如状态机或协作式多任务。</li>
<li>非对称协程更适合异步编程，结构清晰，常用于现代语言（如 C++、Python）。</li>
</ul>
<h3 id="2-2-有栈协程-vs-无栈协程"><a href="#2-2-有栈协程-vs-无栈协程" class="headerlink" title="2.2 有栈协程 vs 无栈协程"></a><strong>2.2 有栈协程 vs 无栈协程</strong></h3><h4 id="有栈协程（Stackful-Coroutine）"><a href="#有栈协程（Stackful-Coroutine）" class="headerlink" title="有栈协程（Stackful Coroutine）"></a><strong>有栈协程（Stackful Coroutine）</strong></h4><ul>
<li><strong>定义</strong>：每个协程拥有独立的调用栈，保存完整的上下文（函数调用链、局部变量等）。</li>
<li><strong>机制</strong>：协程暂停时，栈帧完整保存，恢复时直接继续执行。</li>
<li><strong>示例</strong>：Boost.Coroutine（C++）、Lua 协程。</li>
<li><strong>优点</strong>：<ul>
<li><strong>灵活性高</strong>：可在任意函数调用深度挂起，支持复杂逻辑。</li>
<li><strong>语言无关</strong>：无需语言级支持，可在库中实现。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>内存开销大</strong>：每个协程需要独立的栈（通常 KB 级别）。</li>
<li><strong>实现复杂</strong>：需要管理栈分配和切换，可能涉及汇编或系统调用。</li>
<li><strong>性能开销</strong>：上下文切换成本高于无栈协程。</li>
</ul>
</li>
</ul>
<h4 id="无栈协程（Stackless-Coroutine）"><a href="#无栈协程（Stackless-Coroutine）" class="headerlink" title="无栈协程（Stackless Coroutine）"></a><strong>无栈协程（Stackless Coroutine）</strong></h4><ul>
<li><strong>定义</strong>：协程不维护完整调用栈，仅保存挂起点的最小上下文（如局部变量、状态机）。</li>
<li><strong>机制</strong>：编译器将协程转换为状态机，挂起时保存状态，恢复时跳转到对应状态。</li>
<li><strong>示例</strong>：C++20 的 <code>co_await</code>&#x2F;<code>co_yield</code>、Python 的 <code>async/await</code>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>内存开销低</strong>：仅存储必要状态，适合高并发（如百万级协程）。</li>
<li><strong>高效切换</strong>：上下文切换成本低，接近函数调用。</li>
<li><strong>编译器优化</strong>：编译器生成状态机，代码高效。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>灵活性有限</strong>：只能在协程函数内挂起，无法在任意函数调用深度暂停。</li>
<li><strong>语言依赖</strong>：需要语言支持（如 C++20 的 <code>co_await</code> 关键字）。</li>
<li><strong>复杂实现</strong>：用户代码简单，但编译器生成的状态机可能难以调试。</li>
</ul>
</li>
</ul>
<h4 id="有栈-vs-无栈对比"><a href="#有栈-vs-无栈对比" class="headerlink" title="有栈 vs 无栈对比"></a><strong>有栈 vs 无栈对比</strong></h4><ul>
<li>有栈协程适合需要深度调用栈的场景（如复杂递归），但内存占用高。</li>
<li>无栈协程适合高并发、异步 I&#x2F;O 场景，内存效率高，但受限于语言支持。</li>
</ul>
<h3 id="2-3-独立栈-vs-共享栈"><a href="#2-3-独立栈-vs-共享栈" class="headerlink" title="2.3 独立栈 vs 共享栈"></a><strong>2.3 独立栈 vs 共享栈</strong></h3><h4 id="独立栈（Separate-Stack）"><a href="#独立栈（Separate-Stack）" class="headerlink" title="独立栈（Separate Stack）"></a><strong>独立栈（Separate Stack）</strong></h4><ul>
<li><strong>定义</strong>：每个协程拥有独立的栈空间，互不干扰。</li>
<li><strong>机制</strong>：每个协程分配固定或动态大小的栈，上下文切换时保存&#x2F;恢复栈。</li>
<li><strong>示例</strong>：Boost.Coroutine、ucontext（Linux）。</li>
<li><strong>优点</strong>：<ul>
<li><strong>隔离性强</strong>：协程间栈独立，互不影响，适合复杂任务。</li>
<li><strong>支持深递归</strong>：栈大小可动态调整，适应复杂调用链。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>内存开销大</strong>：每个协程需要 KB 级别的栈空间。</li>
<li><strong>切换开销</strong>：栈复制或切换成本较高。</li>
<li><strong>资源管理复杂</strong>：需要显式分配和回收栈。</li>
</ul>
</li>
</ul>
<h4 id="共享栈（Shared-Stack）"><a href="#共享栈（Shared-Stack）" class="headerlink" title="共享栈（Shared Stack）"></a><strong>共享栈（Shared Stack）</strong></h4><ul>
<li><strong>定义</strong>：多个协程共享一个栈空间，挂起时保存上下文，恢复时重用栈。</li>
<li><strong>机制</strong>：通过状态机或最小上下文保存，栈空间在协程间复用。</li>
<li><strong>示例</strong>：C++20 协程（通过编译器优化实现共享栈效果）。</li>
<li><strong>优点</strong>：<ul>
<li><strong>内存效率高</strong>：无需为每个协程分配独立栈，适合高并发。</li>
<li><strong>切换快速</strong>：上下文切换仅涉及状态恢复，无需复制栈。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>实现复杂</strong>：需要编译器或运行时支持栈管理。</li>
<li><strong>限制较多</strong>：不支持深递归或复杂调用链，挂起点受限。</li>
<li><strong>调试困难</strong>：共享栈可能导致状态管理复杂化。</li>
</ul>
</li>
</ul>
<h4 id="独立栈-vs-共享栈对比"><a href="#独立栈-vs-共享栈对比" class="headerlink" title="独立栈 vs 共享栈对比"></a><strong>独立栈 vs 共享栈对比</strong></h4><ul>
<li>独立栈适合需要隔离和复杂控制流的场景，但内存和性能开销大。</li>
<li>共享栈适合高并发、轻量级任务，内存效率高，但灵活性较低。</li>
</ul>
<h2 id="3-C-中的协程支持"><a href="#3-C-中的协程支持" class="headerlink" title="3. C++ 中的协程支持"></a>3. <strong>C++ 中的协程支持</strong></h2><p>C++20 引入了协程支持（<code>co_await</code>、<code>co_yield</code>、<code>co_return</code>），主要实现<strong>非对称、无栈、共享栈</strong>协程。以下是一个简单的 C++20 协程示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">coroutine_example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start coroutine\n&quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;; <span class="comment">// 挂起</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Resume coroutine\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> task = <span class="built_in">coroutine_example</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: before resume\n&quot;</span>;</span><br><span class="line">    task.handle.<span class="built_in">resume</span>(); <span class="comment">// 恢复协程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: after resume\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Start coroutine</span><br><span class="line">Main: before resume</span><br><span class="line">Resume coroutine</span><br><span class="line">Main: after resume</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li>C++20 协程是<strong>非对称</strong>的（只能挂起回调用者）。</li>
<li><strong>无栈</strong>实现：编译器将协程转换为状态机，上下文存储在堆上。</li>
<li><strong>共享栈</strong>：协程不维护独立栈，状态机共享调用者的栈空间。</li>
</ul>
<h2 id="4-总结与对比"><a href="#4-总结与对比" class="headerlink" title="4. 总结与对比"></a>4. <strong>总结与对比</strong></h2><table>
<thead>
<tr>
<th>分类</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对称协程</strong></td>
<td>灵活，支持任意协程切换</td>
<td>调度复杂，调试困难</td>
<td>复杂控制流、状态机</td>
</tr>
<tr>
<td><strong>非对称协程</strong></td>
<td>简单易用，控制流清晰</td>
<td>灵活性低，依赖调用者</td>
<td>异步 I&#x2F;O、事件驱动</td>
</tr>
<tr>
<td><strong>有栈协程</strong></td>
<td>支持深递归，语言无关</td>
<td>内存开销大，切换慢</td>
<td>复杂任务、深调用链</td>
</tr>
<tr>
<td><strong>无栈协程</strong></td>
<td>内存效率高，切换快</td>
<td>挂起点受限，语言依赖</td>
<td>高并发、异步任务</td>
</tr>
<tr>
<td><strong>独立栈</strong></td>
<td>隔离性强，支持复杂逻辑</td>
<td>内存和切换开销大</td>
<td>复杂任务、深递归</td>
</tr>
<tr>
<td><strong>共享栈</strong></td>
<td>内存效率高，切换快</td>
<td>实现复杂，限制多</td>
<td>高并发、轻量任务</td>
</tr>
</tbody></table>
<h2 id="5-与线程池的联系"><a href="#5-与线程池的联系" class="headerlink" title="5. 与线程池的联系"></a>5. <strong>与线程池的联系</strong></h2><p>结合之前的线程池讨论，协程和线程池可以互补：</p>
<ul>
<li><strong>线程池</strong>：适合 CPU 密集型任务，线程数量受限于核心数。</li>
<li><strong>协程</strong>：适合 I&#x2F;O 密集型任务，可支持百万级并发。</li>
<li><strong>结合方式</strong>：在线程池中运行协程，线程处理计算密集任务，协程处理异步 I&#x2F;O（如 Boost.Asio 结合协程）。</li>
</ul>
<p>如需 C++ 协程的更详细实现（如与线程池结合、异步 I&#x2F;O 示例）或特定分类的深入分析，请提供进一步要求！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2025/06/15/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p> 单例模式（Singleton Pattern）是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。</p>
<p>在C++中，单例模式常用于需要全局唯一实例的场景，例如日志系统、配置管理器或数据库连接池。下面详细介绍其实现方法和作用。</p>
<hr>
<h3 id="单例模式的实现方法"><a href="#单例模式的实现方法" class="headerlink" title="单例模式的实现方法"></a>单例模式的实现方法</h3><p>以下是几种常见的C++单例模式实现方式：</p>
<h4 id="1-懒汉式（Lazy-Initialization）"><a href="#1-懒汉式（Lazy-Initialization）" class="headerlink" title="1. 懒汉式（Lazy Initialization）"></a>1. <strong>懒汉式（Lazy Initialization）</strong></h4><p>延迟初始化，在第一次使用时创建实例。需要注意线程安全问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123; <span class="comment">// 双重检查锁</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton* s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    s1-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    s2-&gt;<span class="built_in">doSomething</span>(); <span class="comment">// 地址相同，说明是同一个实例</span></span><br><span class="line">    <span class="keyword">delete</span> Singleton::instance;<span class="comment">//要delete</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>使用双重检查锁（Double-Checked Locking）确保线程安全。</li>
<li>延迟加载，节省资源，但首次访问可能有性能开销。</li>
<li>需要手动管理内存（<code>delete instance</code>），否则可能导致内存泄漏。</li>
</ul>
<hr>
<h4 id="2-饿汉式（Eager-Initialization）"><a href="#2-饿汉式（Eager-Initialization）" class="headerlink" title="2. 饿汉式（Eager Initialization）"></a>2. <strong>饿汉式（Eager Initialization）</strong></h4><p>程序启动时立即创建实例，避免线程安全问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="type">static</span> Singleton instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line">Singleton Singleton::instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton&amp; s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton&amp; s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">doSomething</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">doSomething</span>(); <span class="comment">// 地址相同，说明是同一个实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>程序启动时创建实例，线程安全。使用static使得运行时就创建，对比懒汉式使用静态的类的指针类型，他直接使用静态的类初始化</li>
<li>占用资源较早，可能在未使用时就分配内存。</li>
<li>实现简单，无需额外同步机制。</li>
</ul>
<hr>
<h4 id="3-Meyers’-Singleton（C-11及以上推荐）"><a href="#3-Meyers’-Singleton（C-11及以上推荐）" class="headerlink" title="3. Meyers’ Singleton（C++11及以上推荐）"></a>3. <strong>Meyers’ Singleton（C++11及以上推荐）</strong></h4><p>利用C++11的静态局部变量特性，实现线程安全的懒汉式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 局部静态变量，C++11保证线程安全</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton&amp; s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    Singleton&amp; s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">doSomething</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">doSomething</span>(); <span class="comment">// 地址相同，说明是同一个实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>利用C++11静态局部变量的初始化是线程安全的特性。</li>
<li>延迟加载，仅在首次调用<code>getInstance</code>时创建。</li>
<li>自动管理内存（静态变量生命周期由程序控制）。</li>
<li>实现简洁，推荐使用。</li>
</ul>
<hr>
<h4 id="4-使用智能指针"><a href="#4-使用智能指针" class="headerlink" title="4. 使用智能指针"></a>4. <strong>使用智能指针</strong></h4><p>结合智能指针（如<code>std::shared_ptr</code>）管理单例实例的生命周期。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;Singleton&gt; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = std::<span class="built_in">make_shared</span>&lt;Singleton&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝和赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Singleton instance: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;Singleton&gt; instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员初始化</span></span><br><span class="line">std::shared_ptr&lt;Singleton&gt; Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">auto</span> s2 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    s1-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    s2-&gt;<span class="built_in">doSomething</span>(); <span class="comment">// 地址相同，说明是同一个实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>使用<code>std::shared_ptr</code>自动管理内存，避免手动释放。</li>
<li>仍需线程同步机制（如<code>std::mutex</code>）来保护初始化。</li>
<li>适合需要动态管理资源的场景。</li>
</ul>
<hr>
<h3 id="单例模式的作用"><a href="#单例模式的作用" class="headerlink" title="单例模式的作用"></a>单例模式的作用</h3><ol>
<li><p><strong>全局唯一实例</strong>：</p>
<ul>
<li>确保某个类只有一个实例，适合需要全局访问的资源，如配置管理器、日志记录器、线程池等。</li>
</ul>
</li>
<li><p><strong>资源共享</strong>：</p>
<ul>
<li>避免重复创建开销大的对象（如数据库连接），提高资源利用率。</li>
</ul>
</li>
<li><p><strong>全局访问点</strong>：</p>
<ul>
<li>提供统一的访问接口，方便在程序的任何地方使用同一实例。</li>
</ul>
</li>
<li><p><strong>控制资源访问</strong>：</p>
<ul>
<li>通过单例控制对共享资源的访问（如文件系统或硬件设备），避免冲突。</li>
</ul>
</li>
<li><p><strong>延迟初始化（懒汉式）</strong>：</p>
<ul>
<li>推迟实例创建到首次使用，优化启动性能。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>线程安全</strong>：</p>
<ul>
<li>懒汉式需要显式加锁或使用C++11静态局部变量来保证线程安全。</li>
<li>饿汉式和Meyers’ Singleton天生线程安全。</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：</p>
<ul>
<li>懒汉式需手动释放内存，或使用智能指针&#x2F;静态变量自动管理。</li>
</ul>
</li>
<li><p><strong>单例的缺点</strong>：</p>
<ul>
<li>可能导致全局状态，增加代码耦合性，难以测试。</li>
<li>单例的滥用可能违反单一职责原则，需谨慎使用。</li>
</ul>
</li>
<li><p><strong>析构问题</strong>：</p>
<ul>
<li>单例的销毁顺序可能引发问题，尤其在静态变量依赖其他全局对象时。</li>
</ul>
</li>
</ol>
<h3 id="为什么局部静态变量能保证线程安全？"><a href="#为什么局部静态变量能保证线程安全？" class="headerlink" title="为什么局部静态变量能保证线程安全？"></a>为什么局部静态变量能保证线程安全？</h3><p>Meyers’ Singleton利用C++11及以上标准的局部静态变量特性，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Singleton instance; <span class="comment">// 局部静态变量</span></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程安全原因</p>
<p>：C++11标准（ISO&#x2F;IEC 14882:2011, §6.7）规定，局部静态变量的初始化是线程安全的。具体来说：</p>
<ul>
<li>编译器和运行时确保<code>instance</code>的初始化只发生一次，即使多个线程同时调用<code>getInstance</code>。</li>
<li>初始化过程由内部的同步机制（实现依赖，通常是编译器生成的锁）保护，避免竞争条件。</li>
<li>初始化完成后，后续访问直接返回已初始化的对象，无需额外同步开销。</li>
</ul>
</li>
<li><p><strong>优势</strong>：无需显式加锁，代码简洁，性能高效，且静态变量的生命周期由程序自动管理（程序结束时销毁）。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>推荐实现</strong>：Meyers’ Singleton（C++11及以上），因其简洁、线程安全且自动管理内存。</li>
<li><strong>适用场景</strong>：需要全局唯一实例且访问频繁的场景，如日志、配置管理。</li>
<li><strong>注意事项</strong>：权衡单例的便利性和潜在问题（如耦合性、测试难度），避免滥用。</li>
</ul>
<p>如果有更多具体问题或需要代码调试，请随时告知！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>static</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单源最短路径问题与Dijkstra算法</title>
    <url>/2024/10/23/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%B8%8EDijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="单源最短路径问题（Single-Source-Shortest-Path-SSSP）"><a href="#单源最短路径问题（Single-Source-Shortest-Path-SSSP）" class="headerlink" title="单源最短路径问题（Single Source Shortest Path, SSSP）"></a><strong>单源最短路径问题</strong>（Single Source Shortest Path, SSSP）</h2><h5 id="是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。"><a href="#是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。" class="headerlink" title="是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。"></a>是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的<strong>起点</strong>（源点）到图中<strong>所有其他节点</strong>的最短路径。</h5><h3 id="问题定义："><a href="#问题定义：" class="headerlink" title="问题定义："></a>问题定义：</h3><ul>
<li><strong>图</strong>：图可以是有向图或无向图，通常包含若干个节点和边，每条边都有一个非负权重（即从一个节点到另一个节点的代价或距离）。</li>
<li><strong>起点（源点）</strong>：单源最短路径问题会指定一个起始节点，称为源节点，问题要求从这个源节点出发，计算它到图中其他所有节点的最短路径。</li>
<li><strong>最短路径</strong>：最短路径是指从源节点到目标节点经过的路径中，总边权重之和最小的路径。</li>
</ul>
<h3 id="具体目标："><a href="#具体目标：" class="headerlink" title="具体目标："></a>具体目标：</h3><p>对于给定的源节点s，你需要找到从s到每个其他节点v的最短路径长度，并且路径上的权重和最小。</p>
<h3 id="常见的算法："><a href="#常见的算法：" class="headerlink" title="常见的算法："></a>常见的算法：</h3><ol>
<li><strong>Dijkstra算法</strong>：<ul>
<li>解决<strong>边权非负</strong>的单源最短路径问题，时间复杂度为$O((V + E) \log V)$，适合稀疏图。</li>
</ul>
</li>
<li><strong>Bellman-Ford算法</strong>：<ul>
<li>可以处理<strong>负权边</strong>的情况，且能够检测负权环，时间复杂度为$O(V \times E)$。</li>
</ul>
</li>
<li><strong>Floyd-Warshall算法</strong>：<ul>
<li>这是一个<strong>多源最短路径</strong>算法，可以计算图中任意两个节点之间的最短路径，时间复杂度为O(V^3)。</li>
</ul>
</li>
<li><strong>SPFA算法</strong>（Shortest Path Faster Algorithm）：<ul>
<li>Bellman-Ford的优化版本，通常在图较稀疏时运行更快。</li>
</ul>
</li>
</ol>
<h2 id="Dijkstra算法："><a href="#Dijkstra算法：" class="headerlink" title="Dijkstra算法："></a><strong>Dijkstra算法</strong>：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个结构体来表示边</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to;     // 边的目标节点</span><br><span class="line">    int weight; // 边的权重</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个pair来表示优先队列中的元素，first为当前距离，second为当前节点</span><br><span class="line">using pii = pair&lt;int, int&gt;;</span><br><span class="line"></span><br><span class="line">// Dijkstra算法函数，参数为起点和图的邻接表</span><br><span class="line">vector&lt;int&gt; dijkstra(int start, const vector&lt;vector&lt;Edge&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    int n = graph.size();  // 获取图中节点的数量</span><br><span class="line">    vector&lt;int&gt; dist(n, INT_MAX);  // 初始化每个节点的距离为无穷大</span><br><span class="line">    dist[start] = 0;  // 起点到自身的距离为0</span><br><span class="line"></span><br><span class="line">    // 定义优先队列，按照距离升序排列，pair的格式是&#123;距离, 节点&#125;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123;0, start&#125;);  // 将起点放入优先队列</span><br><span class="line"></span><br><span class="line">    // 当优先队列不为空时，执行以下操作</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        int curr_dist = pq.top().first;  // 获取当前节点的距离</span><br><span class="line">        int curr_node = pq.top().second;  // 获取当前节点</span><br><span class="line">        pq.pop();  // 弹出队首元素</span><br><span class="line"></span><br><span class="line">        // 如果当前距离已经大于记录的最短距离，跳过（优化）</span><br><span class="line">        if (curr_dist &gt; dist[curr_node]) continue;</span><br><span class="line"></span><br><span class="line">        // 遍历当前节点的邻居</span><br><span class="line">        for (const Edge&amp; edge : graph[curr_node]) &#123;</span><br><span class="line">            int next_node = edge.to;        // 邻居节点</span><br><span class="line">            int weight = edge.weight;       // 边的权重</span><br><span class="line"></span><br><span class="line">            // 计算从当前节点到邻居节点的距离</span><br><span class="line">            if (dist[curr_node] + weight &lt; dist[next_node]) &#123;</span><br><span class="line">                dist[next_node] = dist[curr_node] + weight;  // 更新邻居节点的最短距离</span><br><span class="line">                pq.push(&#123;dist[next_node], next_node&#125;);  // 将邻居节点加入优先队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dist;  // 返回从起点到其他所有节点的最短距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;  // n为节点数，m为边数</span><br><span class="line">    cout &lt;&lt; &quot;输入图的节点数和边数：&quot;;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    // 定义图的邻接表</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; graph(n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;输入每条边（格式：起点 终点 权重）：\n&quot;;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int u, v, w;  // u为起点，v为终点，w为权重</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        graph[u].push_back(&#123;v, w&#125;);  // 添加从u到v的边，权重为w</span><br><span class="line">        // 如果是无向图，需要加上这行代码：</span><br><span class="line">        // graph[v].push_back(&#123;u, w&#125;);  // 添加从v到u的边</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int start;  // 起点</span><br><span class="line">    cout &lt;&lt; &quot;输入起点：&quot;;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line"></span><br><span class="line">    // 执行Dijkstra算法</span><br><span class="line">    vector&lt;int&gt; dist = dijkstra(start, graph);</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    cout &lt;&lt; &quot;从起点到其他节点的最短距离：&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (dist[i] == INT_MAX)</span><br><span class="line">            cout &lt;&lt; &quot;节点 &quot; &lt;&lt; i &lt;&lt; &quot; 不可达&quot; &lt;&lt; endl;  // 如果距离为无穷大，说明不可达</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;到节点 &quot; &lt;&lt; i &lt;&lt; &quot; 的最短距离为： &quot; &lt;&lt; dist[i] &lt;&lt; endl;  // 输出最短距离</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="图的描述"><a href="#图的描述" class="headerlink" title="图的描述"></a>图的描述</h3><ul>
<li>节点: 0, 1, 2, 3, 4</li>
<li>边及其权重：<ul>
<li>0 → 1 (权重 1)</li>
<li>0 → 2 (权重 4)</li>
<li>1 → 2 (权重 2)</li>
<li>1 → 3 (权重 5)</li>
<li>2 → 3 (权重 3)</li>
<li>3 → 4 (权重 1)</li>
</ul>
</li>
</ul>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们将从节点 <code>0</code> 开始，使用Dijkstra算法计算到其他节点的最短路径。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p><strong>距离数组</strong> <code>dist[]</code>：初始化为无穷大，源节点的距离为0。</p>
<ul>
<li><code>dist[0] = 0</code></li>
<li><code>dist[1] = ∞</code></li>
<li><code>dist[2] = ∞</code></li>
<li><code>dist[3] = ∞</code></li>
<li><code>dist[4] = ∞</code></li>
</ul>
</li>
<li><p><strong>优先队列</strong>：将源节点加入优先队列。</p>
<ul>
<li><code>pq = [(0, 0)]</code>（表示距离为0，节点为0）</li>
</ul>
</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol>
<li><p><strong>处理节点 0</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(0, 0)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>1</code>，更新距离：<ul>
<li><code>dist[1] = min(∞, 0 + 1) = 1</code></li>
<li>加入优先队列：<code>pq = [(1, 1)]</code></li>
</ul>
</li>
<li>对于 <code>2</code>，更新距离：<ul>
<li><code>dist[2] = min(∞, 0 + 4) = 4</code></li>
<li>加入优先队列：<code>pq = [(1, 1), (4, 2)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 1</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(1, 1)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>2</code>，更新距离：<ul>
<li><code>dist[2] = min(4, 1 + 2) = 3</code></li>
<li>更新优先队列：<code>pq = [(3, 2), (4, 2)]</code>（会自动调整优先队列顺序）</li>
</ul>
</li>
<li>对于 <code>3</code>，更新距离：<ul>
<li><code>dist[3] = min(∞, 1 + 5) = 6</code></li>
<li>加入优先队列：<code>pq = [(3, 2), (4, 2), (6, 3)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 2</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(3, 2)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>3</code>，更新距离：<ul>
<li><code>dist[3] = min(6, 3 + 3) = 6</code>（不变）</li>
</ul>
</li>
<li>这个节点不更新，不加入队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 3</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(6, 3)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>4</code>，更新距离：<ul>
<li><code>dist[4] = min(∞, 6 + 1) = 7</code></li>
<li>加入优先队列：<code>pq = [(7, 4)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 4</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(7, 4)</code>。</li>
<li>节点 <code>4</code> 没有邻居节点，不再更新。</li>
</ul>
</li>
</ol>
<h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><ul>
<li><code>dist[0] = 0</code> (到自身)</li>
<li><code>dist[1] = 1</code> (通过边 <code>0 → 1</code>)</li>
<li><code>dist[2] = 3</code> (通过边 <code>0 → 1 → 2</code>)</li>
<li><code>dist[3] = 6</code> (通过边 <code>0 → 1 → 2 → 3</code>)</li>
<li><code>dist[4] = 7</code> (通过边 <code>0 → 1 → 2 → 3 → 4</code>)</li>
</ul>
<h2 id="对于一次性获得所有路径间的最小路径（包括负权）-可以用floyd算法"><a href="#对于一次性获得所有路径间的最小路径（包括负权）-可以用floyd算法" class="headerlink" title="对于一次性获得所有路径间的最小路径（包括负权）,可以用floyd算法"></a>对于一次性获得所有路径间的最小路径（包括负权）,可以用floyd算法</h2><p>下面是Floyd-Warshall算法的C++实现。该实现使用一个二维数组来表示图的邻接矩阵，并通过三重循环来更新所有节点对之间的最短路径。</p>
<h3 id="Floyd-Warshall-C-实现"><a href="#Floyd-Warshall-C-实现" class="headerlink" title="Floyd-Warshall C++ 实现"></a>Floyd-Warshall C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义无穷大，表示节点之间不可达</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Floyd-Warshall算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floydWarshall</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化距离矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist = graph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三重循环，逐个更新通过每个中间节点的路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">// 更新dist[i][j]，如果通过k节点可以缩短路径</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] &lt; INF &amp;&amp; dist[k][j] &lt; INF) &#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终的最短路径矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The following matrix shows the shortest distances between every pair of vertices:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == INF)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;INF&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">        &#123;INF, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, INF&#125;,</span><br><span class="line">        &#123;INF, INF, <span class="number">0</span>, <span class="number">3</span>, INF&#125;,</span><br><span class="line">        &#123;INF, INF, INF, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;INF, INF, INF, INF, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Floyd-Warshall算法</span></span><br><span class="line">    <span class="built_in">floydWarshall</span>(graph, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>INF</code> 定义为一个非常大的数，用于表示节点之间不可达。这里用 <code>1e9</code> (即 $10^9$) 来表示。</li>
<li><code>graph</code> 是一个二维数组，表示图的邻接矩阵。</li>
</ul>
</li>
<li><p><strong>核心算法</strong>：</p>
<ul>
<li>三重循环遍历所有节点 <code>k</code>，<code>i</code> 和 <code>j</code>，其中 <code>k</code> 是中间节点。检查是否通过 <code>k</code> 作为中间节点可以使 <code>i</code> 到 <code>j</code> 的路径更短。</li>
<li>如果通过节点 <code>k</code> 可以使 <code>dist[i][j]</code> 更短，那么就更新 <code>dist[i][j]</code>。</li>
<li><code>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);</code> 这就是动态规划的更新公式。</li>
</ul>
</li>
<li><p><strong>输出结果</strong>：</p>
<ul>
<li>最终 <code>dist</code> 数组中保存了所有节点对之间的最短距离。</li>
<li>如果节点对不可达，显示 <code>INF</code>。</li>
</ul>
</li>
</ol>
<h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h3><p>对于上面的代码，输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following matrix shows the shortest distances between every pair of vertices:</span><br><span class="line">0   1   3   6   7   </span><br><span class="line">INF 0   2   5   6   </span><br><span class="line">INF INF 0   3   4   </span><br><span class="line">INF INF INF 0   1   </span><br><span class="line">INF INF INF INF 0   </span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>时间复杂度：$O(n^3)$，其中 $n$ 是图的节点数。</li>
<li>空间复杂度：$O(n^2)$，因为使用了二维数组存储距离矩阵。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>单源最短路径问题</tag>
      </tags>
  </entry>
  <entry>
    <title>友元与友元函数</title>
    <url>/2025/05/02/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="友元与友元函数"><a href="#友元与友元函数" class="headerlink" title="友元与友元函数"></a>友元与友元函数</h3><p>在 C++ 中，<strong>友元</strong>（friend）是一种机制，允许特定的非成员函数或类访问某个类的私有（private）和保护（protected）成员，从而在一定程度上绕过封装限制。友元函数和友元类是友元机制的两种主要形式。以下是详细说明。</p>
<hr>
<h3 id="1-友元函数"><a href="#1-友元函数" class="headerlink" title="1. 友元函数"></a>1. 友元函数</h3><p><strong>友元函数</strong>是一个非成员函数，但通过在类中用 <code>friend</code> 关键字声明，获得访问该类私有和保护成员的权限。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>非成员函数</strong>：友元函数不属于类的成员，不能通过类的对象直接调用（如 <code>obj.func()</code>），而是像普通全局函数一样调用。</li>
<li><strong>访问权限</strong>：可以直接访问类的私有和保护成员，通常需要通过对象参数传递。</li>
<li><strong>声明位置</strong>：在类中用 <code>friend</code> 关键字声明，可位于 <code>public</code>、<code>private</code> 或 <code>protected</code> 区域（位置不影响功能）。</li>
<li><strong>调用方式</strong>：通过函数名直接调用，通常传递类对象作为参数。</li>
</ul>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>; <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(obj); <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="典型用途"><a href="#典型用途" class="headerlink" title="典型用途"></a>典型用途</h4><ol>
<li><strong>运算符重载</strong>：如前文讨论的，流运算符（<code>&lt;&lt;</code>、<code>&gt;&gt;</code>）通常定义为友元函数，因为左侧操作数（如 <code>std::ostream</code>）不是类对象。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    os &lt;&lt; obj.value;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>多类交互</strong>：当一个函数需要访问多个类的私有成员时，可声明为所有相关类的友元。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numA;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">int</span> n) : <span class="built_in">numA</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> ClassA&amp;, <span class="type">const</span> ClassB&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numB;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>(<span class="type">int</span> n) : <span class="built_in">numB</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> ClassA&amp;, <span class="type">const</span> ClassB&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span> ClassA&amp; a, <span class="type">const</span> ClassB&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.numA + b.numB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-友元类"><a href="#2-友元类" class="headerlink" title="2. 友元类"></a>2. 友元类</h3><p><strong>友元类</strong>是指一个类被声明为另一个类的友元，从而该类的所有成员函数都可以访问另一个类的私有和保护成员。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>全类访问</strong>：友元类的所有成员函数自动成为友元函数，拥有对目标类的私有和保护成员的访问权限。</li>
<li><strong>单向关系</strong>：如果类 A 声明类 B 为友元，B 可以访问 A 的私有成员，但 A 不能访问 B 的私有成员，除非 B 也声明 A 为友元。</li>
<li><strong>非继承</strong>：友元关系不会被继承，派生类无法自动获得友元权限。</li>
</ul>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>; <span class="comment">// 声明友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    FriendClass f;</span><br><span class="line">    f.<span class="built_in">show</span>(obj); <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="典型用途-1"><a href="#典型用途-1" class="headerlink" title="典型用途"></a>典型用途</h4><ul>
<li><strong>紧密耦合的类</strong>：如数据库表和索引类，索引类需要直接访问表类的私有数据。</li>
<li><strong>模块化设计</strong>：在硬件接口开发（如 OpenBMC 风扇管理）中，一个控制器类可能需要访问硬件设备类的内部状态。</li>
</ul>
<hr>
<h3 id="3-友元的使用场景与你的项目相关性"><a href="#3-友元的使用场景与你的项目相关性" class="headerlink" title="3. 友元的使用场景与你的项目相关性"></a>3. 友元的使用场景与你的项目相关性</h3><p>结合你提到的 C++ 项目（如 OpenBMC 风扇管理、硬件接口或数据分析工具）：</p>
<ul>
<li><strong>运算符重载</strong>：如前文所述，友元函数常用于流运算符或对称运算符（如 <code>+</code>），在硬件接口中可用于格式化输出设备状态（如 <code>std::cout &lt;&lt; fanController</code>）。</li>
<li><strong>硬件模块交互</strong>：友元类可用于模块化设计。例如，一个 <code>FanController</code> 类可能声明 <code>SystemMonitor</code> 为友元，以便后者直接访问风扇的私有状态（如转速、温度），无需暴露公共接口。</li>
<li><strong>调试与 Valgrind</strong>：友元函数可用于调试工具，访问类的私有成员以打印详细状态，结合 Valgrind 确保无内存泄漏。</li>
<li><strong>多态性</strong>：在多态设计中，友元函数可以通过基类接口访问派生类的私有数据，但需谨慎使用以避免破坏封装。</li>
</ul>
<hr>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><strong>封装性</strong>：友元会部分打破封装，过多使用可能导致代码维护困难。优先考虑通过公共接口（如 getter）访问数据，除非友元显著简化设计。</li>
<li><strong>耦合性</strong>：友元函数或类增加类之间的耦合，需谨慎设计，避免过度依赖。</li>
<li><strong>声明顺序</strong>：友元类或函数涉及多类交互时，需使用前向声明（如 <code>class ClassB;</code>）以解决编译器依赖问题。</li>
<li><strong>非对称性</strong>：友元关系是单向的，A 是 B 的友元不意味着 B 是 A 的友元。</li>
<li><strong>性能</strong>：友元函数通常内联（<code>inline</code>），性能开销低，但复杂逻辑可能导致临时对象开销，需注意资源管理。</li>
</ul>
<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li><strong>友元函数</strong>：通过 <code>friend</code> 关键字声明的非成员函数，可访问类的私有和保护成员，常用于运算符重载或多类交互。</li>
<li><strong>友元类</strong>：一个类被声明为另一个类的友元，其所有成员函数可访问目标类的私有和保护成员，适合紧密耦合的模块。</li>
<li><strong>适用场景</strong>：运算符重载、调试、硬件接口交互、紧密耦合的类设计。</li>
<li><strong>注意事项</strong>：谨慎使用友元以保护封装，优先考虑公共接口，注意耦合性和声明顺序。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>友元</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针与滑动窗口</title>
    <url>/2024/09/24/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h1><p>题目：给定一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要<strong>原地</strong>移除所有数值等于 <code>val</code> 的元素.元素的顺序可以改变.然后返回数组中与 <code>val</code> 不同的元素的数量.</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，你需要执行以下操作：</p>
<ul>
<li>修改 <code>nums</code> 数组，使得 <code>nums</code> 的前 <code>k</code> 个元素包含所有不等于 <code>val</code> 的元素.</li>
<li>返回 <code>k</code> 的值.<code>nums</code> 中的其他元素和数组大小不重要.</li>
</ul>
<h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="思路及算法："><a href="#思路及算法：" class="headerlink" title="思路及算法："></a>思路及算法：</h2><p>由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上.可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置.</p>
<p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>
<p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位.</p>
<p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val.当左右指针遍历完输入数组以后，left 的值就是输出数组的长度.</p>
<p>这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        for (int right = 0; right &lt; n; right++) &#123;</span><br><span class="line">            if (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 为序列的长度.我们只需要遍历该序列至多两次.</p>
<p>空间复杂度：O(1).我们只需要常数的空间保存若干变量.</p>
<h1 id="方法二：双指针优化"><a href="#方法二：双指针优化" class="headerlink" title="方法二：双指针优化"></a>方法二：双指针优化</h1><h2 id="思路与算法："><a href="#思路与算法：" class="headerlink" title="思路与算法："></a>思路与算法：</h2><p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位.注意到题目中说：「元素的顺序可以改变」.实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求.这个优化在序列中 val 元素的数量较少时非常有效.</p>
<p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列.</p>
<p>如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位.如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止.</p>
<p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素.</p>
<p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次.与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int left = 0, right = nums.size();</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right - 1];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n)，其中 n 为序列的长度.我们只需要遍历该序列至多一次.</p>
<p>空间复杂度：O(1).我们只需要常数的空间保存若干变量.</p>
<h1 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h1><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>.</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**.**如果不存在符合条件的子数组，返回 <code>0</code> .</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组.</span><br></pre></td></tr></table></figure>

<h1 id="方法一：暴力解法（会超时）"><a href="#方法一：暴力解法（会超时）" class="headerlink" title="方法一：暴力解法（会超时）"></a>方法一：暴力解法（会超时）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                if (sum &gt;= s) &#123;</span><br><span class="line">                    ans = min(ans, j - i + 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n的平方），其中 n 是数组的长度.需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组.</p>
<p>空间复杂度：O(1).</p>
<h1 id="方法二：前缀和-二分查找"><a href="#方法二：前缀和-二分查找" class="headerlink" title="方法二：前缀和 + 二分查找"></a>方法二：前缀和 + 二分查找</h1><p>方法一的时间复杂度是 O(n的平方)，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要 O(n) 的时间.如果使用二分查找，则可以将时间优化到 O(logn).</p>
<p>为了使用二分查找，需要额外创建一个数组 sums 用于存储数组 nums 的前缀和，其中 sums[i] 表示从 nums[0] 到 nums[i−1] 的元素和.得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标 bound，使得 sums[bound]−sums[i−1]≥s，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）.</p>
<p>因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性.如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了.</p>
<p>在很多语言中，都有现成的库和函数来为我们实现这里二分查找大于等于某个数的第一个位置的功能，比如 C++ 的 lower_bound.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        vector&lt;int&gt; sums(n + 1, 0); </span><br><span class="line">        // 为了方便计算，令 size = n + 1 </span><br><span class="line">        // sums[0] = 0 意味着前 0 个元素的前缀和为 0</span><br><span class="line">        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span><br><span class="line">        // 以此类推</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - 1] + nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int target = s + sums[i - 1];</span><br><span class="line">            auto bound = lower_bound(sums.begin(), sums.end(), target);</span><br><span class="line">            if (bound != sums.end()) &#123;</span><br><span class="line">                ans = min(ans, static_cast&lt;int&gt;((bound - sums.begin()) - (i - 1)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="方法三：滑动窗口"><a href="#方法三：滑动窗口" class="headerlink" title="方法三：滑动窗口"></a>方法三：滑动窗口</h1><p>在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高.为了降低时间复杂度，可以使用滑动窗口的方法.</p>
<p>定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）.</p>
<p>初始状态下，start 和 end 都指向下标 0，sum 的值为 0.</p>
<p>每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum&lt;s，在此过程中同样更新子数组的最小长度.在每一轮迭代的最后，将 end 右移.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int result=100001;</span><br><span class="line">        int sum=0;</span><br><span class="line">        int i=0;</span><br><span class="line">        int subLength=0;</span><br><span class="line">        for(int j=0;j&lt;nums.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            while(sum&gt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">                subLength=j-i+1;</span><br><span class="line">                result=result&lt;subLength?result:subLength;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result==100001?0:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>thread_local的作用</title>
    <url>/2025/01/27/thread-local%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>thread_local修饰的变量，可以理解为每个线程独有的静态变量</p>
<h3 id="thread-local-的作用"><a href="#thread-local-的作用" class="headerlink" title="thread_local 的作用"></a><strong><code>thread_local</code> 的作用</strong></h3><p><code>thread_local</code> 是 C++11 引入的一个关键字，它用于声明线程局部存储（TLS）。<strong>线程局部存储</strong>指的是每个线程都有自己的变量副本，而这些副本在不同线程之间互不干扰。每个线程访问 <code>thread_local</code> 变量时，都会得到该变量的独立副本。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p><code>thread_local</code> 的主要作用是确保每个线程都有该变量的独立副本，避免不同线程之间对该变量的竞争和冲突。这在多线程程序中非常重要，特别是当不同线程需要独立的状态或数据时。</p>
<hr>
<h3 id="如何使用-thread-local"><a href="#如何使用-thread-local" class="headerlink" title="如何使用 thread_local"></a><strong>如何使用 <code>thread_local</code></strong></h3><p><code>thread_local</code> 可以修饰普通的变量、静态变量、类成员变量等。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法</strong>：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> type variable_name;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;  <span class="comment">// 每个线程都有自己的独立 counter 变量</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a><strong>1. 基本用法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_counter = <span class="number">0</span>;  <span class="comment">// 每个线程都有自己的 thread_counter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++thread_counter;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() </span><br><span class="line">              &lt;&lt; <span class="string">&quot;, Counter: &quot;</span> &lt;&lt; thread_counter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程也可以访问</span></span><br><span class="line">    <span class="built_in">increment_counter</span>();  <span class="comment">// 主线程也有自己的 thread_counter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出（可能的）："><a href="#输出（可能的）：" class="headerlink" title="输出（可能的）："></a><strong>输出（可能的）</strong>：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread ID: 140306947039680, Counter: 1</span><br><span class="line">Thread ID: 140306938646976, Counter: 1</span><br><span class="line">Thread ID: 140306941834368, Counter: 1</span><br></pre></td></tr></table></figure>

<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a><strong>说明</strong>：</h4><ul>
<li>这个例子展示了 <code>thread_local</code> 变量 <code>thread_counter</code> 的用法。每个线程都拥有 <code>thread_counter</code> 的独立副本，所以主线程和两个子线程中的 <code>thread_counter</code> 是不同的。</li>
<li><code>thread_counter</code> 是线程局部变量，每个线程的修改不会影响其他线程的副本。</li>
</ul>
<hr>
<h3 id="thread-local-的重要特点"><a href="#thread-local-的重要特点" class="headerlink" title="thread_local 的重要特点"></a><strong><code>thread_local</code> 的重要特点</strong></h3><ol>
<li><p><strong>每个线程拥有独立副本</strong>：</p>
<ul>
<li>每个线程都有变量的独立副本，线程之间互不影响。</li>
<li>即使是静态或全局变量，加上 <code>thread_local</code> 修饰后，也会变成每个线程的局部变量。</li>
</ul>
</li>
<li><p><strong>线程生命周期管理</strong>：</p>
<ul>
<li>当线程启动时，<code>thread_local</code> 变量会被初始化。</li>
<li>当线程结束时，<code>thread_local</code> 变量的析构函数会被调用，执行必要的清理操作。</li>
</ul>
</li>
<li><p><strong>不适用于所有类型的变量</strong>：</p>
<ul>
<li><code>thread_local</code> 变量不能是动态分配的（比如通过 <code>new</code> 创建的对象）和指向虚拟基类的指针等。</li>
<li>对象的构造和析构是自动处理的，且 <code>thread_local</code> 变量必须具有静态或线程存储期。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="thread-local-的适用场景"><a href="#thread-local-的适用场景" class="headerlink" title="thread_local 的适用场景"></a><strong><code>thread_local</code> 的适用场景</strong></h3><ol>
<li><p><strong>每个线程都有独立状态</strong>：</p>
<ul>
<li>例如，记录每个线程的执行状态、计数器、缓存等。</li>
</ul>
</li>
<li><p><strong>避免锁竞争</strong>：</p>
<ul>
<li>在多线程环境中，通过将数据声明为 <code>thread_local</code>，每个线程有独立的数据副本，避免了锁的竞争，提高并发效率。</li>
</ul>
</li>
<li><p><strong>优化线程性能</strong>：</p>
<ul>
<li>当线程需要维护一些状态信息时，使用 <code>thread_local</code> 可以减少不必要的同步开销。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="与静态局部变量的对比"><a href="#与静态局部变量的对比" class="headerlink" title="与静态局部变量的对比"></a><strong>与静态局部变量的对比</strong></h3><p><strong>普通静态局部变量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ++count;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static</code> 变量在多个函数调用之间保持其值，但它在所有线程之间是共享的，不适合多线程环境。</li>
</ul>
<p><strong><code>thread_local</code> 变量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 每个线程有自己的独立副本</span></span><br><span class="line">    ++count;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>thread_local</code> 变量会确保每个线程有自己的副本，避免多线程共享问题。</li>
</ul>
<hr>
<h3 id="限制与注意事项"><a href="#限制与注意事项" class="headerlink" title="限制与注意事项"></a><strong>限制与注意事项</strong></h3><ol>
<li><p><strong>线程销毁时的清理</strong>：</p>
<ul>
<li><code>thread_local</code> 变量的生命周期是与线程绑定的，线程结束时，这些变量会自动销毁，但它们的析构函数只会在对应线程结束时执行。</li>
</ul>
</li>
<li><p><strong>初始化顺序</strong>：</p>
<ul>
<li><code>thread_local</code> 变量的初始化顺序不如常规静态变量的初始化顺序明确，因此在使用时需要确保其线程安全初始化。</li>
</ul>
</li>
<li><p><strong>性能影响</strong>：</p>
<ul>
<li>由于每个线程都有自己的副本，可能会带来内存的开销。特别是在多线程数目较大的情况下，可能需要管理的副本会变得比较多。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>thread_local</code> 关键字允许每个线程都有变量的独立副本，这对于多线程程序中的线程独立数据存储非常有用。</li>
<li>使用 <code>thread_local</code> 可以避免多线程之间的竞争，提高程序性能和线程安全。</li>
<li><code>thread_local</code> 变量的生命周期与线程绑定，在该线程结束时，自动析构。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>线程</tag>
        <tag>多线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>可调用对象的绑定器和包装器</title>
    <url>/2025/01/12/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%E5%8C%85%E8%A3%85%E5%99%A8/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>可调用对象的绑定器和包装器</strong>是用来简化或增强对函数（包括普通函数、成员函数、函数对象、Lambda 表达式等）的调用操作的工具。它们广泛用于泛型编程和 STL 算法中，以便将函数灵活地传递给算法或动态控制其行为。</p>
<hr>
<h2 id="1-可调用对象的绑定器"><a href="#1-可调用对象的绑定器" class="headerlink" title="1. 可调用对象的绑定器"></a><strong>1. 可调用对象的绑定器</strong></h2><p>绑定器的作用是<strong>将一个可调用对象的一部分参数提前绑定</strong>，从而生成一个新的可调用对象。</p>
<p>C++11 起引入了 <code>std::bind</code>，用于创建一个可调用对象并绑定部分参数；在现代 C++（C++20）中，更推荐使用 <strong>Lambda 表达式</strong> 替代 <code>std::bind</code>。</p>
<h3 id="1-1-std-bind"><a href="#1-1-std-bind" class="headerlink" title="1.1 std::bind"></a><strong>1.1 std::bind</strong></h3><p><code>std::bind</code> 是一个函数模板，它可以接受一个可调用对象（如普通函数、成员函数、函数对象等）及部分参数，并返回一个新的可调用对象，该对象可以像函数一样调用。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind 所在的头文件</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">bind</span>(callable, arg1, arg2, ..., argN);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>callable</code>：要绑定的可调用对象。</li>
<li><code>arg1, arg2, ..., argN</code>：可调用对象的参数，其中可以使用占位符 <code>_1</code>, <code>_2</code>, … 来延迟绑定。</li>
</ul>
<p>占位符 <code>_1</code>, <code>_2</code>, … 来自头文件 <code>&lt;functional&gt;</code>，表示绑定时保留的参数位置。</p>
<hr>
<h4 id="例子-1：绑定普通函数"><a href="#例子-1：绑定普通函数" class="headerlink" title="例子 1：绑定普通函数"></a><strong>例子 1：绑定普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind, std::placeholders</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; <span class="comment">// 使用占位符 _1, _2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add_five = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, _1); <span class="comment">// 绑定第一个参数为 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_five</span>(<span class="number">10</span>) &lt;&lt; endl;          <span class="comment">// 输出 15（5 + 10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::bind(add, 5, _1)</code> 创建了一个新函数对象 <code>add_five</code>，它将 <code>add</code> 的第一个参数固定为 <code>5</code>，第二个参数保留动态输入。</li>
<li>调用 <code>add_five(10)</code> 等价于调用 <code>add(5, 10)</code>。</li>
</ul>
<hr>
<h4 id="例子-2：绑定成员函数"><a href="#例子-2：绑定成员函数" class="headerlink" title="例子 2：绑定成员函数"></a><strong>例子 2：绑定成员函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> bound_fn = std::<span class="built_in">bind</span>(&amp;MyClass::display, &amp;obj, _1); <span class="comment">// 绑定成员函数</span></span><br><span class="line">    <span class="built_in">bound_fn</span>(<span class="number">42</span>); <span class="comment">// 输出 Value: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>成员函数绑定时，需要提供对象指针（如 <code>&amp;obj</code>）作为隐式的 <code>this</code> 参数。</li>
<li><code>std::bind(&amp;MyClass::display, &amp;obj, _1)</code> 将成员函数的调用与对象绑定。</li>
</ul>
<hr>
<h3 id="1-2-替代-std-bind-的-Lambda-表达式"><a href="#1-2-替代-std-bind-的-Lambda-表达式" class="headerlink" title="1.2 替代 std::bind 的 Lambda 表达式"></a><strong>1.2 替代 std::bind 的 Lambda 表达式</strong></h3><p>在现代 C++ 中，Lambda 表达式更简洁，功能更强，因此可以用 Lambda 替代 <code>std::bind</code>。</p>
<p>以上绑定普通函数的例子，用 Lambda 表达式可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_five = [](<span class="type">int</span> b) &#123; <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">5</span>, b); &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add_five</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>

<p>绑定成员函数的例子，用 Lambda 表达式可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_fn = [&amp;obj](<span class="type">int</span> x) &#123; obj.<span class="built_in">display</span>(x); &#125;;</span><br><span class="line"><span class="built_in">bound_fn</span>(<span class="number">42</span>); <span class="comment">// 输出 Value: 42</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-可调用对象的包装器"><a href="#2-可调用对象的包装器" class="headerlink" title="2. 可调用对象的包装器"></a><strong>2. 可调用对象的包装器</strong></h2><p>包装器的作用是<strong>将一个可调用对象封装起来，允许在运行时管理其调用行为</strong>。</p>
<h3 id="2-1-std-function"><a href="#2-1-std-function" class="headerlink" title="2.1 std::function"></a><strong>2.1 std::function</strong></h3><p><code>std::function</code> 是一个通用的函数包装器，用来存储和调用任何符合特定签名的可调用对象。<br>它可以存储：</p>
<ul>
<li>普通函数</li>
<li>函数指针</li>
<li>成员函数指针</li>
<li>Lambda 表达式</li>
<li>仿函数</li>
</ul>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::function 所在的头文件</span></span></span><br><span class="line"></span><br><span class="line">std::function&lt;R(Args...)&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>R</code>：函数的返回类型。</li>
<li><code>Args...</code>：函数的参数类型列表。</li>
</ul>
<hr>
<h4 id="例子-1：包装普通函数"><a href="#例子-1：包装普通函数" class="headerlink" title="例子 1：包装普通函数"></a><strong>例子 1：包装普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::function</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add; <span class="comment">// 包装普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;              <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="例子-2：包装-Lambda-表达式"><a href="#例子-2：包装-Lambda-表达式" class="headerlink" title="例子 2：包装 Lambda 表达式"></a><strong>例子 2：包装 Lambda 表达式</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;; <span class="comment">// 包装 Lambda</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;                                            <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="例子-3：包装仿函数"><a href="#例子-3：包装仿函数" class="headerlink" title="例子 3：包装仿函数"></a><strong>例子 3：包装仿函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = <span class="built_in">Multiply</span>(); <span class="comment">// 包装仿函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">6</span>, <span class="number">7</span>) &lt;&lt; endl;                    <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-std-function-与-std-bind-配合使用"><a href="#2-2-std-function-与-std-bind-配合使用" class="headerlink" title="2.2 std::function 与 std::bind 配合使用"></a><strong>2.2 std::function 与 std::bind 配合使用</strong></h3><p><code>std::function</code> 可以与 <code>std::bind</code> 结合使用，将部分参数绑定后存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, _1); <span class="comment">// 绑定第一个参数为 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; endl;                             <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-std-function-的灵活性"><a href="#2-3-std-function-的灵活性" class="headerlink" title="2.3 std::function 的灵活性"></a><strong>2.3 std::function 的灵活性</strong></h3><p><code>std::function</code> 允许运行时动态更改存储的可调用对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func;</span><br><span class="line"></span><br><span class="line">    func = add; <span class="comment">// 动态存储 add</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    func = subtract; <span class="comment">// 动态存储 subtract</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-区别与应用场景"><a href="#3-区别与应用场景" class="headerlink" title="3. 区别与应用场景"></a><strong>3. 区别与应用场景</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>std::bind</strong></th>
<th><strong>std::function</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>用于绑定函数的部分参数，生成新的可调用对象</td>
<td>用于包装函数，统一管理所有可调用对象</td>
</tr>
<tr>
<td><strong>参数绑定</strong></td>
<td>支持占位符 <code>_1</code>, <code>_2</code> 等</td>
<td>不支持参数绑定</td>
</tr>
<tr>
<td><strong>运行时动态性</strong></td>
<td>固定绑定时传入的函数和参数</td>
<td>可以运行时动态更改存储的可调用对象</td>
</tr>
<tr>
<td><strong>替代方案</strong></td>
<td>Lambda 表达式可以完全替代</td>
<td>无明显替代方案（功能独特）</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li>**<code>std::bind</code>**：用于将函数的部分参数提前绑定生成一个新的可调用对象，但在现代 C++ 中，通常使用更直观的 <strong>Lambda 表达式</strong> 代替。</li>
<li>**<code>std::function</code>**：是一个灵活的函数包装器，可以统一存储和调用各种可调用对象（普通函数、Lambda、仿函数等），适用于需要动态改变函数行为的场景。</li>
</ul>
<p>结合 <code>std::bind</code> 和 <code>std::function</code>（如 <code>ThreadFunc</code>），我们可以更灵活地创建回调函数或者线程入口函数。<code>std::bind</code> 允许你将某些函数的参数预先绑定，生成一个新的可调用对象。这个新的可调用对象可以通过 <code>std::function</code> 传递，作为回调或者线程的入口函数。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h3 id="结合-std-bind-和-ThreadFunc-的用法"><a href="#结合-std-bind-和-ThreadFunc-的用法" class="headerlink" title="结合 std::bind 和 ThreadFunc 的用法"></a><strong>结合 <code>std::bind</code> 和 <code>ThreadFunc</code> 的用法</strong></h3><p>假设你需要通过 <code>std::bind</code> 绑定函数的某些参数，然后将其传递给一个线程或其他需要可调用对象的地方。使用 <code>std::function</code> 和 <code>std::bind</code> 可以非常方便地处理这种情况。</p>
<h3 id="示例：使用-std-bind-和-ThreadFunc-传递绑定参数"><a href="#示例：使用-std-bind-和-ThreadFunc-传递绑定参数" class="headerlink" title="示例：使用 std::bind 和 ThreadFunc 传递绑定参数"></a><strong>示例：使用 <code>std::bind</code> 和 <code>ThreadFunc</code> 传递绑定参数</strong></h3><p>在这个例子中，我们将创建一个 <code>ThreadFunc</code> 类型的对象，使用 <code>std::bind</code> 绑定一个函数的部分参数，然后将绑定后的函数作为线程的入口函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程函数类型别名</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例线程函数，接受两个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定 print_sum 的两个参数</span></span><br><span class="line">    <span class="comment">// 绑定参数 a = 10，b = 20</span></span><br><span class="line">    ThreadFunc func = std::<span class="built_in">bind</span>(print_sum, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程并传递绑定后的函数作为入口函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a><strong>解释：</strong></h3><ol>
<li><strong><code>ThreadFunc</code> 类型别名</strong>：<code>using ThreadFunc = std::function&lt;void()&gt;;</code> 定义了一个新的类型 <code>ThreadFunc</code>，表示一个无参数且返回 <code>void</code> 的可调用对象。</li>
<li><strong><code>std::bind</code> 的使用</strong>：<code>std::bind(print_sum, 10, 20)</code> 创建了一个新的函数对象，它绑定了 <code>print_sum</code> 函数的两个参数 <code>a</code> 和 <code>b</code>，分别为 10 和 20。返回的是一个新的可调用对象，它没有参数，可以通过 <code>ThreadFunc</code> 来表示。</li>
<li><strong>传递给线程</strong>：<code>std::thread t(func);</code> 创建了一个新的线程 <code>t</code>，并将 <code>func</code>（一个经过 <code>std::bind</code> 绑定的函数对象）作为线程的入口函数。</li>
<li><strong>等待线程执行</strong>：<code>t.join();</code> 等待线程执行完毕。</li>
</ol>
<h3 id="示例：结合-std-bind-和-lambda"><a href="#示例：结合-std-bind-和-lambda" class="headerlink" title="示例：结合 std::bind 和 lambda"></a><strong>示例：结合 <code>std::bind</code> 和 lambda</strong></h3><p>你也可以将 <code>std::bind</code> 与 lambda 表达式结合，动态地传递参数。在这种情况下，lambda 表达式可以充当回调函数的一部分，<code>std::bind</code> 则允许你预先绑定一些参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线程函数类型别名</span></span><br><span class="line"><span class="keyword">using</span> ThreadFunc = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例线程函数，接受两个参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定一个函数，并结合 lambda 来处理参数</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    ThreadFunc func = std::<span class="built_in">bind</span>([](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">print_sum</span>(a, b);  <span class="comment">// 使用 lambda 来调用 print_sum</span></span><br><span class="line">    &#125;, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程并传递绑定后的函数作为入口函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li><strong><code>std::bind</code> 和 <code>ThreadFunc</code></strong> 结合使用时，<code>std::bind</code> 可以为函数创建一个新的可调用对象，绑定部分参数，生成一个无参数的函数对象。这个对象可以通过 <code>ThreadFunc</code> 类型来表示。</li>
<li><strong>灵活性</strong>：<code>std::bind</code> 使得我们可以预先绑定一些参数，创建更灵活的回调函数或线程入口函数。结合 <code>std::function</code> 类型别名后，代码会更加简洁和清晰。</li>
<li><strong>代码简化</strong>：在多线程和回调编程中，使用 <code>std::bind</code> 和 <code>ThreadFunc</code> 可以极大地简化参数传递和回调逻辑，尤其是当你需要传递复杂的函数或绑定多个参数时。</li>
</ul>
<p>这种方式常用于多线程编程和事件驱动编程中，使得代码更加模块化、灵活。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>各种各样的锁~</title>
    <url>/2025/06/29/%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h1 id="各种锁的介绍"><a href="#各种锁的介绍" class="headerlink" title="各种锁的介绍"></a>各种锁的介绍</h1><p>在并发编程中，锁是用于保护共享资源、防止数据竞争和确保线程安全的机制。以下是对你提到的各种锁（<code>mutex</code>、<code>lock_guard</code>、<code>shared_lock</code>、<code>unique_lock</code>、分布式锁、自旋锁、悲观锁、乐观锁）的详细介绍，涵盖定义、用途、实现原理、优缺点及适用场景。由于你提到自旋锁两次，我会将其合并处理，并结合 C++ 上下文（基于之前的线程池讨论）进行讲解。</p>
<hr>
<h2 id="1-互斥锁（std-mutex）"><a href="#1-互斥锁（std-mutex）" class="headerlink" title="1. 互斥锁（std::mutex）"></a>1. <strong>互斥锁（<code>std::mutex</code>）</strong></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p><code>std::mutex</code> 是 C++11 提供的互斥锁（Mutual Exclusion Lock），用于保护共享资源，确保同一时间只有一个线程可以访问临界区。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>防止多个线程同时访问共享资源（如线程池中的任务队列）。</li>
<li>实现线程同步，确保数据一致性。</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><ul>
<li><code>std::mutex</code> 提供 <code>lock()</code> 和 <code>unlock()</code> 方法，锁定和释放互斥量。</li>
<li>线程尝试获取锁时，若锁已被占用，线程会阻塞（进入休眠）直到锁可用。</li>
<li>操作系统底层通常通过原子操作和内核调度实现。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        ++shared_data;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl; <span class="comment">// 应输出 2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>简单易用，适合保护临界区。</li>
<li>提供强一致性保证。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>手动调用 <code>lock</code>&#x2F;<code>unlock</code> 易出错（忘记解锁会导致死锁）。</li>
<li>阻塞线程可能导致性能开销（上下文切换）。</li>
</ul>
</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>保护共享数据（如计数器、队列）。</li>
<li>需要简单、强一致性的同步场景。</li>
</ul>
<hr>
<h2 id="2-std-lock-guard"><a href="#2-std-lock-guard" class="headerlink" title="2. std::lock_guard"></a>2. <strong><code>std::lock_guard</code></strong></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h3><p><code>std::lock_guard</code> 是 C++11 提供的 RAII（资源获取即初始化）类模板，用于自动管理 <code>std::mutex</code> 的锁定和解锁，防止忘记解锁导致死锁。</p>
<h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>简化 <code>std::mutex</code> 的使用，确保锁在作用域结束时自动释放。</li>
<li>用于短生命周期的临界区保护。</li>
</ul>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><ul>
<li>构造时调用 <code>mutex.lock()</code>，析构时调用 <code>mutex.unlock()</code>。</li>
<li>使用 RAII 机制，绑定锁的生命周期到作用域。</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">        ++shared_data;</span><br><span class="line">    &#125; <span class="comment">// 离开作用域，自动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>自动管理锁，防止忘记解锁。</li>
<li>代码简洁，安全性高。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>不支持灵活的锁管理（如中途解锁或条件变量）。</li>
<li>仅适用于简单场景。</li>
</ul>
</li>
</ul>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>需要简单、自动化的互斥锁管理。</li>
<li>保护短临界区（如单次数据操作）。</li>
</ul>
<hr>
<h2 id="3-std-shared-mutex-shared-lock"><a href="#3-std-shared-mutex-shared-lock" class="headerlink" title="3. std::shared_mutex/shared_lock"></a>3. <strong><code>std::shared_mutex/shared_lock</code></strong></h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a><strong>定义</strong></h3><p><code>std::shared_lock</code> 是 C++14 引入的 RAII 类模板，用于管理共享锁（<code>std::shared_mutex</code> 或 <code>std::shared_timed_mutex</code>），支持读写锁模式（多读单写）。</p>
<h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>允许多个线程同时读取共享资源（共享锁），但写操作独占（独占锁）。</li>
<li>用于读多写少的场景，提高并发性能。</li>
</ul>
<h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><p><code>std::shared_mutex</code> 支持两种锁模式：</p>
<ul>
<li><ul>
<li><strong>共享锁</strong>（<code>lock_shared()</code>）：多个线程可同时获取，适合读操作。</li>
<li><strong>独占锁</strong>（<code>lock()</code>）：仅一个线程可获取，适合写操作。</li>
</ul>
</li>
<li><code>std::shared_lock</code> 在构造时调用 <code>lock_shared()</code>，析构时调用 <code>unlock_shared()</code>。</li>
</ul>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_mutex smtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_data</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(smtx)</span></span>; <span class="comment">// 共享锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reader &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; reads: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(smtx)</span></span>; <span class="comment">// 独占锁</span></span><br><span class="line">    ++shared_data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writer updated data to: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread readers[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        readers[i] = std::<span class="built_in">thread</span>(read_data, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::thread <span class="title">writer</span><span class="params">(write_data)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : readers) r.<span class="built_in">join</span>();</span><br><span class="line">    writer.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>支持读写分离，提高读操作并发性。</li>
<li>RAII 机制，自动管理锁。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>实现复杂度高于 <code>std::mutex</code>。</li>
<li>写操作可能饥饿（读操作过多时）。</li>
</ul>
</li>
</ul>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>读多写少的场景（如数据库查询、缓存访问）。</li>
<li>需要高并发读操作的系统。</li>
</ul>
<hr>
<h2 id="4-std-unique-lock"><a href="#4-std-unique-lock" class="headerlink" title="4. std::unique_lock"></a>4. <strong><code>std::unique_lock</code></strong></h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a><strong>定义</strong></h3><p><code>std::unique_lock</code> 是 C++11 提供的 RAII 类模板，用于管理 <code>std::mutex</code>（或类似互斥量），比 <code>std::lock_guard</code> 更灵活，支持延迟加锁、条件变量等。</p>
<h3 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>提供灵活的锁管理（如手动加锁&#x2F;解锁、与条件变量配合）。</li>
<li>用于复杂同步场景（如线程池中的任务等待）。</li>
</ul>
<h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><ul>
<li>类似 <code>std::lock_guard</code>，但支持：<ul>
<li>延迟加锁（<code>std::unique_lock(mutex, std::defer_lock)</code>）。</li>
<li>手动解锁（<code>unlock()</code>）。</li>
<li>转移锁所有权（<code>std::move</code>）。</li>
</ul>
</li>
<li>与 <code>std::condition_variable</code> 配合，<code>wait</code> 时自动释放锁，唤醒时重新加锁。</li>
</ul>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><p>结合线程池中的条件变量（参考之前的线程池代码）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mutex_;</span><br><span class="line">std::condition_variable condition_;</span><br><span class="line">std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line"><span class="type">bool</span> stop;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">            <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">            task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">            tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="comment">// 锁自动释放</span></span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>灵活性高，支持条件变量、延迟加锁等。</li>
<li>RAII 机制，自动管理锁。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>比 <code>std::lock_guard</code> 略高开销（因功能更复杂）。</li>
<li>使用复杂，需小心管理锁状态。</li>
</ul>
</li>
</ul>
<h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>需要条件变量的场景（如线程池的任务等待）。</li>
<li>复杂同步逻辑（如动态加锁&#x2F;解锁）。</li>
</ul>
<hr>
<h2 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5. 分布式锁"></a>5. <strong>分布式锁</strong></h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>分布式锁是跨多个进程或节点（通常在分布式系统中）的锁机制，用于协调不同机器上的共享资源访问。</p>
<h3 id="用途-4"><a href="#用途-4" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>在分布式系统中保护共享资源（如数据库、文件系统）。</li>
<li>实现分布式任务调度、分布式事务等。</li>
</ul>
<h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><ul>
<li>通常基于分布式协调服务（如 ZooKeeper、Redis、etcd）实现。</li>
<li><strong>Redis 实现</strong>：<ul>
<li>使用 <code>SETNX</code>（set if not exists）命令创建锁。</li>
<li>设置锁的过期时间（防止死锁）。</li>
<li>释放锁通过删除键。</li>
</ul>
</li>
<li><strong>ZooKeeper 实现</strong>：<ul>
<li>使用临时节点和顺序节点创建锁。</li>
<li>节点删除或断开连接自动释放锁。</li>
</ul>
</li>
</ul>
<h3 id="代码示例（Redis-分布式锁）"><a href="#代码示例（Redis-分布式锁）" class="headerlink" title="代码示例（Redis 分布式锁）"></a><strong>代码示例（Redis 分布式锁）</strong></h3><p>使用 C++ Redis 客户端（如 <code>cpp_redis</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cpp_redis/cpp_redis&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">cpp_redis::client redis_client;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">acquire_lock</span><span class="params">(<span class="type">const</span> std::string&amp; lock_key, <span class="type">int</span> timeout_ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> expire = std::chrono::<span class="built_in">milliseconds</span>(timeout_ms).<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">return</span> redis_client.<span class="built_in">setnx</span>(lock_key, <span class="string">&quot;locked&quot;</span>) &amp;&amp; redis_client.<span class="built_in">pexpire</span>(lock_key, expire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release_lock</span><span class="params">(<span class="type">const</span> std::string&amp; lock_key)</span> </span>&#123;</span><br><span class="line">    redis_client.<span class="built_in">del</span>(&#123;lock_key&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>支持跨节点同步，适用于分布式系统。</li>
<li>可实现高可用性（如 Redis 集群）。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>依赖外部服务，增加系统复杂性。</li>
<li>网络延迟可能影响性能。</li>
<li>实现复杂，需处理锁超时、脑裂等问题。</li>
</ul>
</li>
</ul>
<h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>分布式系统中的资源协调（如分布式任务调度）。</li>
<li>跨节点的共享资源访问（如分布式数据库）。</li>
</ul>
<hr>
<h2 id="6-自旋锁（Spinlock）"><a href="#6-自旋锁（Spinlock）" class="headerlink" title="6. 自旋锁（Spinlock）"></a>6. <strong>自旋锁（Spinlock）</strong></h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>自旋锁是一种非阻塞锁，线程在获取锁失败时不会休眠，而是通过循环（“自旋”）不断尝试获取锁，直到成功。</p>
<h3 id="用途-5"><a href="#用途-5" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>适合临界区非常短的场景，减少上下文切换开销。</li>
<li>高性能场景（如实时系统、内核编程）。</li>
</ul>
<h3 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><ul>
<li>使用原子操作（如 <code>std::atomic_flag</code>）检查锁状态。</li>
<li>如果锁被占用，线程循环检查，直到锁可用。</li>
</ul>
<h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spinlock</span> &#123;</span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Spinlock spinlock;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        spinlock.<span class="built_in">lock</span>();</span><br><span class="line">        ++shared_data;</span><br><span class="line">        spinlock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>避免上下文切换，适合短临界区。</li>
<li>实现简单，适用于低延迟场景。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>自旋浪费 CPU 资源，长时间等待效率低。</li>
<li>不适合长临界区或高争用场景。</li>
</ul>
</li>
</ul>
<h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>短临界区（如内存分配、计数器更新）。</li>
<li>实时系统或高性能计算。</li>
</ul>
<hr>
<h2 id="7-悲观锁（Pessimistic-Lock）"><a href="#7-悲观锁（Pessimistic-Lock）" class="headerlink" title="7. 悲观锁（Pessimistic Lock）"></a>7. <strong>悲观锁（Pessimistic Lock）</strong></h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>悲观锁假设并发操作会发生冲突，因此在访问共享资源前总是先加锁，确保独占访问。</p>
<h3 id="用途-6"><a href="#用途-6" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>确保数据一致性，适合写多读少的场景。</li>
<li>防止数据竞争或冲突。</li>
</ul>
<h3 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><ul>
<li>使用互斥锁（如 <code>std::mutex</code>）、读写锁等实现。</li>
<li>线程获取锁后独占资源，其他线程阻塞等待。</li>
</ul>
<h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><p><code>std::mutex</code> 和 <code>std::lock_guard</code> 就是典型的悲观锁实现（见上述示例）。</p>
<h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>强一致性，适合高冲突场景。</li>
<li>简单可靠，易于实现。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>阻塞线程，降低并发性能。</li>
<li>不适合读多写少的场景。</li>
</ul>
</li>
</ul>
<h3 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>写操作频繁的场景（如数据库事务）。</li>
<li>需要强一致性的系统（如金融系统）。</li>
</ul>
<hr>
<h2 id="8-乐观锁（Optimistic-Lock）"><a href="#8-乐观锁（Optimistic-Lock）" class="headerlink" title="8. 乐观锁（Optimistic Lock）"></a>8. <strong>乐观锁（Optimistic Lock）</strong></h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>乐观锁假设冲突较少，允许线程先操作共享资源，提交时检查是否发生冲突，若有冲突则回滚重试。</p>
<h3 id="用途-7"><a href="#用途-7" class="headerlink" title="用途"></a><strong>用途</strong></h3><ul>
<li>适合读多写少的场景，提高并发性能。</li>
<li>用于数据库（如 MVCC）、版本控制等。</li>
</ul>
<h3 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><ul>
<li>通常基于版本号或比较交换（CAS，Compare-And-Swap）机制。</li>
<li>线程读取数据时记录版本号，更新时检查版本号是否改变。</li>
</ul>
<h3 id="代码示例（基于-CAS）"><a href="#代码示例（基于-CAS）" class="headerlink" title="代码示例（基于 CAS）"></a><strong>代码示例（基于 CAS）</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">shared_data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> expected = shared_data.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (!shared_data.<span class="built_in">compare_exchange_strong</span>(expected, expected + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// CAS 失败，重试</span></span><br><span class="line">            expected = shared_data.<span class="built_in">load</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul>
<li><strong>优点</strong>：<ul>
<li>非阻塞，高并发性能。</li>
<li>适合读多写少的场景。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>冲突多时，重试开销大。</li>
<li>实现复杂，需处理版本控制或 CAS。</li>
</ul>
</li>
</ul>
<h3 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul>
<li>读多写少的场景（如数据库 MVCC）。</li>
<li>高并发系统（如缓存更新）。</li>
</ul>
<hr>
<h2 id="9-总结与对比"><a href="#9-总结与对比" class="headerlink" title="9. 总结与对比"></a>9. <strong>总结与对比</strong></h2><table>
<thead>
<tr>
<th>锁类型</th>
<th>阻塞&#x2F;非阻塞</th>
<th>适用场景</th>
<th>C++ 实现</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::mutex</code></td>
<td>阻塞</td>
<td>简单共享资源保护</td>
<td><code>lock</code>&#x2F;<code>unlock</code></td>
<td>简单但需手动管理，易死锁</td>
</tr>
<tr>
<td><code>std::lock_guard</code></td>
<td>阻塞</td>
<td>短临界区，自动管理锁</td>
<td>RAII 管理 <code>mutex</code></td>
<td>安全简单，但不灵活</td>
</tr>
<tr>
<td><code>std::shared_lock</code></td>
<td>阻塞</td>
<td>读多写少</td>
<td>配合 <code>std::shared_mutex</code></td>
<td>高并发读，写可能饥饿</td>
</tr>
<tr>
<td><code>std::unique_lock</code></td>
<td>阻塞</td>
<td>复杂同步（如条件变量）</td>
<td>配合 <code>std::mutex</code></td>
<td>灵活但稍复杂</td>
</tr>
<tr>
<td>分布式锁</td>
<td>阻塞&#x2F;非阻塞</td>
<td>分布式系统资源协调</td>
<td>Redis&#x2F;ZooKeeper</td>
<td>跨节点同步，依赖外部服务</td>
</tr>
<tr>
<td>自旋锁</td>
<td>非阻塞</td>
<td>短临界区，高性能</td>
<td><code>std::atomic_flag</code></td>
<td>低延迟但浪费 CPU</td>
</tr>
<tr>
<td>悲观锁</td>
<td>阻塞</td>
<td>写多读少，强一致性</td>
<td><code>std::mutex</code> 等</td>
<td>简单可靠但并发性低</td>
</tr>
<tr>
<td>乐观锁</td>
<td>非阻塞</td>
<td>读多写少，高并发</td>
<td><code>std::atomic</code> CAS</td>
<td>高并发但冲突多时效率低</td>
</tr>
</tbody></table>
<hr>
<h2 id="10-结合线程池的上下文"><a href="#10-结合线程池的上下文" class="headerlink" title="10. 结合线程池的上下文"></a>10. <strong>结合线程池的上下文</strong></h2><p>在之前的线程池实现中：</p>
<ul>
<li>**<code>std::mutex</code> 和 <code>std::unique_lock</code>**：用于保护任务队列，<code>unique_lock</code> 与 <code>std::condition_variable</code> 配合实现线程等待&#x2F;通知。</li>
<li><strong>适用性</strong>：线程池中任务队列的访问是典型悲观锁场景，<code>unique_lock</code> 提供灵活性支持条件变量。</li>
<li><strong>扩展建议</strong>：<ul>
<li>若任务队列访问时间极短，可尝试自旋锁优化。</li>
<li>若线程池扩展到分布式系统，可引入分布式锁管理跨节点任务。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="11-注意事项"><a href="#11-注意事项" class="headerlink" title="11. 注意事项"></a>11. <strong>注意事项</strong></h2><ul>
<li><strong>选择锁类型</strong>：根据临界区长度、读写比例、并发需求选择合适的锁。</li>
<li><strong>死锁风险</strong>：避免多锁嵌套，使用 <code>std::lock</code> 或 RAII 工具。</li>
<li><strong>性能权衡</strong>：阻塞锁适合长临界区，非阻塞锁（如自旋锁、乐观锁）适合短临界区或高并发。</li>
</ul>
<p>如果你对某类锁的实现细节（如分布式锁的 Redis 配置、自旋锁的优化）或在特定场景（如线程池）的应用有进一步疑问，请告诉我，我可以提供更深入的代码或分析！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>宏与inline函数</title>
    <url>/2025/06/08/%E5%AE%8F%E4%B8%8Einline%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="宏定义-vs-内联函数"><a href="#宏定义-vs-内联函数" class="headerlink" title="宏定义 vs 内联函数"></a>宏定义 vs 内联函数</h1><p>宏定义（Macro）和内联函数（Inline Function）是 C&#x2F;C++ 中用于代码复用和性能优化的两种机制，但它们的实现方式、行为和适用场景有显著差异。以下是详细对比，结合 C++ STL 容器（如 <code>std::vector</code>）的上下文，分析两者的定义、原理、优缺点及应用场景。</p>
<hr>
<h2 id="1-宏定义-Macro-Definition"><a href="#1-宏定义-Macro-Definition" class="headerlink" title="1. 宏定义 (Macro Definition)"></a>1. 宏定义 (Macro Definition)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>宏定义是使用预处理器指令 <code>#define</code> 定义的代码片段，由预处理器在编译前进行文本替换。宏可以是简单的常量、表达式或函数式宏。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><strong>预处理器操作</strong>：在编译前，预处理器将宏调用替换为宏定义的内容，类似于文本“复制粘贴”。</li>
<li><strong>无类型检查</strong>：宏是纯文本替换，不涉及语法或类型检查，编译器直接处理替换后的代码。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">SQUARE</span>(<span class="number">5</span>); <span class="comment">// 替换为 ((5) * (5))</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>灵活性高</strong>：宏支持任意代码片段替换，适用于复杂场景（如条件编译、字符串化）。</li>
<li><strong>无函数调用开销</strong>：宏直接展开为代码，消除函数调用的栈操作和参数传递。</li>
<li><strong>类型无关</strong>：宏不依赖类型，可用于多种数据类型（如 <code>int</code>、<code>double</code>）。</li>
<li><strong>适合简单 STL 操作</strong>：如定义 <code>std::vector</code> 的快捷操作（如 <code>#define VEC_SIZE(vec) vec.size()</code>）。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p><strong>无类型安全</strong>：宏不检查参数类型，易导致错误。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">MAX</span>(<span class="number">5</span>, <span class="string">&quot;10&quot;</span>); <span class="comment">// 编译错误，类型不匹配</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>副作用问题</strong>：参数可能被多次求值，导致意外行为。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="built_in">SQUARE</span>(++y); <span class="comment">// 替换为 ((++y) * (++y))，y 被递增两次</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>调试困难</strong>：宏展开后，调试器无法直接跟踪宏定义，错误定位复杂。</p>
</li>
<li><p><strong>代码膨胀</strong>：宏多次展开可能导致二进制文件变大。</p>
</li>
<li><p><strong>不具备作用域</strong>：宏无法访问类成员（如 <code>std::vector</code> 的私有成员）。</p>
</li>
</ul>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li>宏定义以 <code>#define</code> 开头，新行结束（无需分号）。</li>
<li>函数式宏使用括号避免运算符优先级问题（如 <code>(x) * (x)</code>）。</li>
<li>常用场景：常量定义（如 <code>#define PI 3.14</code>）、条件编译（如 <code>#ifdef</code>）、简单表达式。</li>
</ul>
<hr>
<h2 id="2-内联函数-Inline-Function"><a href="#2-内联函数-Inline-Function" class="headerlink" title="2. 内联函数 (Inline Function)"></a>2. 内联函数 (Inline Function)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>内联函数是使用 <code>inline</code> 关键字定义的 C&#x2F;C++ 函数，<strong>建议</strong>编译器将函数调用替换为函数体代码，以减少函数调用开销。内联函数是真正的函数，遵循语言的类型检查和作用域规则。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li><strong>编译器优化</strong>：编译器在调用处将内联函数的代码嵌入，类似宏的展开，但由编译器而非预处理器处理。</li>
<li><strong>类型安全</strong>：参数和返回值类型由编译器检查，遵循函数语义。</li>
<li><strong>非强制性</strong>：<code>inline</code> 是建议，编译器可能忽略（如函数过大或包含复杂控制流）。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">square</span>(<span class="number">5</span>); <span class="comment">// 可能被替换为 5 * 5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>类型安全</strong>：编译器检查参数和返回值类型，避免类型错误。</li>
<li><strong>单次求值</strong>：参数只求值一次，避免宏的副作用问题。例如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="built_in">square</span>(++y); <span class="comment">// y 仅递增一次，z = 36</span></span><br></pre></td></tr></table></figure></li>
<li><strong>调试友好</strong>：内联函数保留函数语义，调试器可跟踪调用。</li>
<li><strong>作用域支持</strong>：可访问类成员，适合 STL 操作。例如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> vec.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>优化机会</strong>：编译器可结合上下文优化内联代码（如常量折叠）。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>非强制内联</strong>：编译器可能忽略 <code>inline</code>，导致函数调用开销。</li>
<li><strong>代码膨胀</strong>：多次内联可能增加二进制大小，类似宏。</li>
<li><strong>复杂函数不适用</strong>：内联函数若包含循环、递归或静态变量，编译器可能拒绝内联。</li>
<li><strong>头文件依赖</strong>：内联函数定义通常需放在头文件中，增加编译依赖。</li>
</ul>
<h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><ul>
<li>使用 <code>inline</code> 关键字，通常定义在头文件中以确保多文件可见。</li>
<li>编译器根据函数大小、调用频率和优化级别决定是否内联。</li>
<li>强制内联（GCC）：使用 <code>__attribute__((always_inline))</code>。</li>
<li>示例命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -O2 main.cpp -o program  <span class="comment"># 优化级别 O2 提高内联概率</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-对比表格"><a href="#3-对比表格" class="headerlink" title="3. 对比表格"></a>3. 对比表格</h2><table>
<thead>
<tr>
<th>特性</th>
<th>宏定义</th>
<th>内联函数</th>
</tr>
</thead>
<tbody><tr>
<td><strong>处理阶段</strong></td>
<td>预处理器（编译前）</td>
<td>编译器（编译时）</td>
</tr>
<tr>
<td><strong>类型检查</strong></td>
<td>无，文本替换</td>
<td>有，遵循函数语义</td>
</tr>
<tr>
<td><strong>参数求值</strong></td>
<td>多次求值，可能有副作用</td>
<td>单次求值，无副作用</td>
</tr>
<tr>
<td><strong>调试</strong></td>
<td>困难，展开后无函数信息</td>
<td>友好，可跟踪函数调用</td>
</tr>
<tr>
<td><strong>作用域</strong></td>
<td>无，无法访问类成员</td>
<td>有，可访问类成员</td>
</tr>
<tr>
<td><strong>代码膨胀</strong></td>
<td>多次展开增加二进制大小</td>
<td>编译器控制，膨胀可控</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>高，任意代码替换</td>
<td>受函数语义限制</td>
</tr>
<tr>
<td><strong>关键字</strong></td>
<td><code>#define</code></td>
<td><code>inline</code></td>
</tr>
<tr>
<td><strong>STL 适用性</strong></td>
<td>简单操作（如 <code>vec.size()</code>）</td>
<td>复杂逻辑（如 <code>std::vector</code> 方法）</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-与-C-STL-容器的关联"><a href="#4-与-C-STL-容器的关联" class="headerlink" title="4. 与 C++ STL 容器的关联"></a>4. 与 C++ STL 容器的关联</h2><ul>
<li><strong>宏定义</strong>：<ul>
<li>适合简单、类型无关的 STL 操作，如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VEC_CLEAR(vec) vec.clear()</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">VEC_CLEAR</span>(v); <span class="comment">// 替换为 v.clear()</span></span><br></pre></td></tr></table></figure></li>
<li>缺点：无法访问 <code>std::vector</code> 的私有成员，且易引入副作用（如 <code>VEC_CLEAR(++vec)</code>）。</li>
<li>适用场景：快速定义重复的 STL 操作（如 <code>std::vector::size</code> 的别名）。</li>
</ul>
</li>
<li><strong>内联函数</strong>：<ul>
<li>适合封装 STL 容器的复杂逻辑，如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">safe_size</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vec.<span class="built_in">empty</span>() ? <span class="number">0</span> : vec.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>优点：类型安全，支持类成员访问，适合 <code>std::map</code>、<code>std::unordered_set</code> 等复杂操作。</li>
<li>适用场景：性能敏感的 STL 操作（如 <code>std::vector::push_back</code> 的包装）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><ul>
<li><strong>宏定义</strong>：<ul>
<li>常量定义：如 <code>#define MAX_SIZE 100</code>。</li>
<li>条件编译：如 <code>#ifdef DEBUG</code>。</li>
<li>简单表达式：如 <code>#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))</code>。</li>
<li>快速 STL 别名：如 <code>#define VEC_PUSH(vec, x) vec.push_back(x)</code>。</li>
</ul>
</li>
<li><strong>内联函数</strong>：<ul>
<li>小型函数：如计算 <code>std::vector</code> 元素和的函数。</li>
<li>类成员函数：如 <code>std::vector</code> 的包装方法。</li>
<li>性能敏感代码：如游戏引擎中频繁调用的 STL 操作。</li>
<li>类型安全场景：如 <code>std::map</code> 的键值访问。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="6-性能考量"><a href="#6-性能考量" class="headerlink" title="6. 性能考量"></a>6. 性能考量</h2><ul>
<li><strong>宏定义</strong>：无函数调用开销，但多次展开可能增加指令缓存压力。适合简单 STL 操作（如 <code>std::vector::size</code>）。</li>
<li><strong>内联函数</strong>：若成功内联，性能接近宏；若未内联，有函数调用开销。编译器优化（如内联 <code>std::vector::push_back</code>）可提升性能。</li>
<li><strong>STL 容器性能</strong>：容器操作（如 <code>std::map::insert</code> 的 O(log n)）不受宏或内联影响，但内联函数的类型安全和优化更适合复杂逻辑。</li>
</ul>
<hr>
<h2 id="7-建议"><a href="#7-建议" class="headerlink" title="7. 建议"></a>7. 建议</h2><ul>
<li><strong>选择依据</strong>：<ul>
<li><strong>宏定义</strong>：用于简单、类型无关的代码片段或条件编译，避免复杂逻辑（如 STL 容器操作）。</li>
<li><strong>内联函数</strong>：优先用于类型安全、调试友好或涉及类成员的场景（如 <code>std::vector</code> 的方法）。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li><strong>宏定义需加括号避免优先级问题（如 <code>((x) * (x))</code>）。</strong></li>
<li>内联函数应保持简短，避免复杂逻辑以确保内联成功。</li>
<li>避免宏的副作用，使用内联函数或模板替代（如 C++ 模板函数）。</li>
</ul>
</li>
<li><strong>实践</strong>：<ul>
<li>测试宏与内联的性能：编写 <code>std::vector</code> 操作的宏和内联函数，比较编译后二进制大小和运行时间。</li>
<li>调试宏问题：使用 <code>gcc -E</code> 查看宏展开结果，定位错误。</li>
<li>阅读 STL 实现：查看 <code>libstdc++</code> 中 <code>std::vector</code> 的内联函数（如 <code>push_back</code>）。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>inline</tag>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>完美转发</title>
    <url>/2025/05/11/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h2 id="C-中的“完美转发”（Perfect-Forwarding）。"><a href="#C-中的“完美转发”（Perfect-Forwarding）。" class="headerlink" title="C++ 中的“完美转发”（Perfect Forwarding）。"></a>C++ 中的“完美转发”（Perfect Forwarding）。</h2><p><strong>核心含义：</strong></p>
<p>完美转发是指在函数模板中，将接收到的参数<strong>以其原本的值类别（左值或右值）和 <code>const</code>&#x2F;<code>volatile</code> 属性</strong>转发给另一个函数。</p>
<p>简单来说，就是让一个“中间”函数（通常是模板函数）能够透明地将参数传递给它调用的“目标”函数，就好像参数是直接传递给目标函数一样，不会因为经过中间函数而改变参数的左值&#x2F;右值属性或 <code>const</code>&#x2F;<code>volatile</code> 属性。</p>
<p><strong>为什么需要完美转发？</strong></p>
<p>考虑一个常见的场景：你有一个泛型函数（比如一个包装器、一个工厂函数、一个日志记录函数），它接收任意类型的参数，然后将这些参数传递给另一个实际执行操作的函数。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with lvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with const lvalue/rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的包装器函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T arg)</span> </span>&#123; <span class="comment">// 按值传递</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside wrapper (by value)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">target_function</span>(arg); <span class="comment">// 问题在这里！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper_ref</span><span class="params">(T&amp; arg)</span> </span>&#123; <span class="comment">// 按左值引用传递</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside wrapper (by lvalue ref)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">target_function</span>(arg); <span class="comment">// 问题在这里！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper_const_ref</span><span class="params">(<span class="type">const</span> T&amp; arg)</span> </span>&#123; <span class="comment">// 按 const 左值引用传递</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside wrapper (by const lvalue ref)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">target_function</span>(arg); <span class="comment">// 问题在这里！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x); <span class="comment">// 传入左值 x</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">20</span>); <span class="comment">// 传入右值 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">wrapper_ref</span>(x); <span class="comment">// 传入左值 x</span></span><br><span class="line">    <span class="comment">// wrapper_ref(20); // 错误：不能将右值绑定到左值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">wrapper_const_ref</span>(x); <span class="comment">// 传入左值 x</span></span><br><span class="line">    <span class="built_in">wrapper_const_ref</span>(<span class="number">20</span>); <span class="comment">// 传入右值 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中：</p>
<ol>
<li><code>wrapper(T arg)</code>：参数 <code>arg</code> 是按值传递的，这意味着传入的实参会被复制一份。无论你传入左值还是右值，<code>arg</code> 在 <code>wrapper</code> 函数内部都是一个独立的局部变量（一个左值）。当你将 <code>arg</code> 传递给 <code>target_function</code> 时，它会匹配 <code>target_function(int&amp;)</code> 或 <code>target_function(const int&amp;)</code>（取决于 <code>T</code> 是否被推导为 const），而永远不会匹配 <code>target_function(int&amp;&amp;)</code>。原始实参的右值属性丢失了。</li>
<li><code>wrapper_ref(T&amp; arg)</code>：这个包装器只能接收左值。如果你传入右值，会编译错误。即使传入左值，<code>arg</code> 在内部是左值引用，传递给 <code>target_function</code> 时也是作为左值引用传递。</li>
<li><code>wrapper_const_ref(const T&amp; arg)</code>：这个包装器可以接收左值和右值（因为 <code>const T&amp;</code> 可以绑定到右值）。但无论传入什么，<code>arg</code> 在内部都是一个 <code>const</code> 左值引用。传递给 <code>target_function</code> 时，它会匹配 <code>target_function(const int&amp;)</code>。原始实参的右值属性丢失了，并且增加了 <code>const</code> 属性。</li>
</ol>
<p>这些传统的传递方式都无法实现“完美转发”，即无法让 <code>target_function</code> 像直接接收原始实参那样，根据实参是左值还是右值来选择对应的重载版本。这在需要利用移动语义（当传入右值时）的场景下尤其成问题。</p>
<p><strong>如何实现完美转发？</strong></p>
<p>完美转发依赖于两个关键的 C++11 特性：</p>
<ol>
<li><strong>万能引用 (Universal Reference &#x2F; Forwarding Reference)：</strong> 在函数模板参数中使用 <code>T&amp;&amp;</code>（其中 <code>T</code> 是模板参数）或 <code>auto&amp;&amp;</code>。这使得参数可以绑定到左值或右值，并通过引用折叠规则保留了原始实参的值类别信息。</li>
<li><strong><code>std::forward&lt;T&gt;()</code>：</strong> 这是一个标准库工具，用于在转发参数时<strong>有条件地</strong>将其转换为右值引用。如果原始实参是左值，<code>std::forward</code> 会将其转发为左值引用；如果原始实参是右值，<code>std::forward</code> 会将其转发为右值引用。</li>
</ol>
<p><strong>使用完美转发的例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// 需要包含 &lt;utility&gt; 来使用 std::forward</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with lvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">int</span>&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">target_function</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; arg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Called with const lvalue/rvalue: &quot;</span> &lt;&lt; arg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用完美转发的包装器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perfect_forwarding_wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; <span class="comment">// T&amp;&amp; 是万能引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside perfect_forwarding_wrapper&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 使用 std::forward&lt;T&gt; 转发参数</span></span><br><span class="line">    <span class="built_in">target_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cx = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(x);     <span class="comment">// 传入左值 x -&gt; T 被推导为 int&amp; -&gt; std::forward&lt;int&amp;&gt;(arg) 返回 int&amp; -&gt; 匹配 target_function(int&amp;)</span></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(<span class="number">20</span>);    <span class="comment">// 传入右值 20 -&gt; T 被推导为 int -&gt; std::forward&lt;int&gt;(arg) 返回 int&amp;&amp; -&gt; 匹配 target_function(int&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(cx);    <span class="comment">// 传入 const 左值 cx -&gt; T 被推导为 const int&amp; -&gt; std::forward&lt;const int&amp;&gt;(arg) 返回 const int&amp; -&gt; 匹配 target_function(const int&amp;)</span></span><br><span class="line">    <span class="built_in">perfect_forwarding_wrapper</span>(std::<span class="built_in">move</span>(x)); <span class="comment">// 传入右值 std::move(x) -&gt; T 被推导为 int -&gt; std::forward&lt;int&gt;(arg) 返回 int&amp;&amp; -&gt; 匹配 target_function(int&amp;&amp;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with lvalue: 10</span><br><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with rvalue: 20</span><br><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with const lvalue/rvalue: 30</span><br><span class="line">Inside perfect_forwarding_wrapper</span><br><span class="line">Called with rvalue: 10</span><br></pre></td></tr></table></figure>

<p>可以看到，通过使用 <code>T&amp;&amp;</code> 万能引用和 <code>std::forward&lt;T&gt;(arg)</code>，<code>perfect_forwarding_wrapper</code> 成功地将实参的原始值类别和 <code>const</code> 属性传递给了 <code>target_function</code>，使得 <code>target_function</code> 能够根据传入的实参类型选择正确的重载版本。</p>
<p><strong>总结：</strong></p>
<p>完美转发是一种技术，用于在泛型编程（特别是模板函数）中，将参数以其原始的左值&#x2F;右值属性和 <code>const</code>&#x2F;<code>volatile</code> 属性转发给另一个函数。它通过结合<strong>万能引用（或称转发引用）</strong>和 <strong><code>std::forward</code></strong> 工具来实现，解决了传统参数传递方式在转发过程中丢失参数原始属性的问题，这对于实现通用的、高效的包装器函数和利用移动语义至关重要。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++11</tag>
        <tag>完美转发</tag>
        <tag>万能引用</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树的调整(左旋与右旋)</title>
    <url>/2024/10/30/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4-%E5%B7%A6%E6%97%8B%E4%B8%8E%E5%8F%B3%E6%97%8B/</url>
    <content><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，它在结构上保持一定的平衡，以确保在最坏情况下依然具有较好的查找、插入和删除性能。</p>
<h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><p><strong>平衡</strong>的具体定义可以根据不同类型的平衡树略有不同。一般来说，一个二叉树是平衡的，当其任意节点的左右子树高度差的绝对值不超过某个特定值（通常是1）时。</p>
<h3 id="常见类型的平衡二叉树"><a href="#常见类型的平衡二叉树" class="headerlink" title="常见类型的平衡二叉树"></a>常见类型的平衡二叉树</h3><ol>
<li><p><strong>AVL树</strong>：</p>
<ul>
<li><p>每个节点的左右子树高度差（平衡因子）只允许为 -1、0 或 1。</p>
</li>
<li><p>在插入或删除节点后，如果导致不平衡，会通过旋转操作来恢复平衡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt; // 用于 std::max</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 节点结构</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;       // 节点值</span><br><span class="line">    Node* left;    // 左子节点</span><br><span class="line">    Node* right;   // 右子节点</span><br><span class="line">    int height;    // 节点高度</span><br><span class="line"></span><br><span class="line">    Node(int k) : key(k), left(nullptr), right(nullptr), height(1) &#123;&#125; // 初始化节点</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 获取节点的高度</span><br><span class="line">int getHeight(Node* node) &#123;</span><br><span class="line">    return node ? node-&gt;height : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取平衡因子</span><br><span class="line">int getBalanceFactor(Node* node) &#123;</span><br><span class="line">    return node ? getHeight(node-&gt;left) - getHeight(node-&gt;right) : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新节点的高度</span><br><span class="line">void updateHeight(Node* node) &#123;</span><br><span class="line">    node-&gt;height = max(getHeight(node-&gt;left), getHeight(node-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 右旋操作</span><br><span class="line">Node* rightRotate(Node* y) &#123;</span><br><span class="line">    Node* x = y-&gt;left;</span><br><span class="line">    Node* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">    // 右旋转</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    // 更新高度</span><br><span class="line">    updateHeight(y);</span><br><span class="line">    updateHeight(x);</span><br><span class="line"></span><br><span class="line">    // 返回新的根节点</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 左旋操作</span><br><span class="line">Node* leftRotate(Node* x) &#123;</span><br><span class="line">    Node* y = x-&gt;right;</span><br><span class="line">    Node* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    // 左旋转</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    // 更新高度</span><br><span class="line">    updateHeight(x);</span><br><span class="line">    updateHeight(y);</span><br><span class="line"></span><br><span class="line">    // 返回新的根节点</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点并保持平衡</span><br><span class="line">Node* insert(Node* node, int key) &#123;</span><br><span class="line">    // 1. 标准的二叉搜索树插入</span><br><span class="line">    if (!node) return new Node(key);</span><br><span class="line"></span><br><span class="line">    if (key &lt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    &#125; else if (key &gt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 不允许插入重复值</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 更新当前节点的高度</span><br><span class="line">    updateHeight(node);</span><br><span class="line"></span><br><span class="line">    // 3. 计算平衡因子</span><br><span class="line">    int balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">    // 4. 根据平衡因子进行相应的旋转操作</span><br><span class="line">    // 左左情况</span><br><span class="line">    if (balanceFactor &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        return rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右右情况</span><br><span class="line">    if (balanceFactor &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        return leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 左右情况</span><br><span class="line">    if (balanceFactor &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">        return rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右左情况</span><br><span class="line">    if (balanceFactor &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">        return leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回不变的节点指针</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中序遍历树以显示结果</span><br><span class="line">void inOrder(Node* root) &#123;</span><br><span class="line">    if (root) &#123;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; root-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数测试AVL树</span><br><span class="line">int main() &#123;</span><br><span class="line">    Node* root = nullptr;</span><br><span class="line"></span><br><span class="line">    // 插入一些节点</span><br><span class="line">    root = insert(root, 10);</span><br><span class="line">    root = insert(root, 20);</span><br><span class="line">    root = insert(root, 30);</span><br><span class="line">    root = insert(root, 40);</span><br><span class="line">    root = insert(root, 50);</span><br><span class="line">    root = insert(root, 25);</span><br><span class="line"></span><br><span class="line">    // 中序遍历 AVL 树</span><br><span class="line">    cout &lt;&lt; &quot;中序遍历 AVL 树: &quot;;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>红黑树</strong>：</p>
<ul>
<li>是一种自平衡的二叉搜索树，每个节点都有一个颜色属性（红色或黑色），并遵循特定的颜色规则。</li>
<li>保证从根到叶的路径上的黑色节点数量相同，从而保持树的平衡性。</li>
</ul>
</li>
</ol>
<h3 id="平衡二叉树的特点"><a href="#平衡二叉树的特点" class="headerlink" title="平衡二叉树的特点"></a>平衡二叉树的特点</h3><ul>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li>查找、插入和删除操作的时间复杂度通常为 O(\log n)，这使得平衡二叉树非常高效，特别是在大量数据的情况下。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>平衡二叉树的空间复杂度为 O(n)，与普通的二叉树相同。</li>
</ul>
</li>
<li><p><strong>自我平衡</strong>：</p>
<ul>
<li>在插入或删除节点时，通过旋转和调整树的结构，保持树的平衡，从而避免退化成链表。</li>
</ul>
</li>
</ul>
<p> 旋转操作是平衡二叉树（如 AVL 树和红黑树）中的重要技术，用于在插入或删除节点后恢复树的平衡。旋转操作可以分为两种类型：左旋（Left Rotation）和右旋（Right Rotation）。以下是这两种旋转的详细介绍及其实现。</p>
<h1 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h1><p>首先注意，右旋（L）实际上是将树向左旋转，左旋则是将树向右旋转</p>
<h3 id="1-右旋（Right-Rotation）"><a href="#1-右旋（Right-Rotation）" class="headerlink" title="1. 右旋（Right Rotation）"></a>1. 右旋（Right Rotation）</h3><p>右旋操作是将某个节点（称为“失衡节点”）的左子节点提升为新的根节点，同时将失衡节点降为新根节点的右子节点。</p>
<h4 id="右旋的步骤"><a href="#右旋的步骤" class="headerlink" title="右旋的步骤"></a>右旋的步骤</h4><ol>
<li>设失衡节点为 <code>y</code>，其左子节点为 <code>x</code>。</li>
<li>将 <code>x</code> 的右子节点（如果存在）连接到 <code>y</code> 的左子节点。</li>
<li>将 <code>x</code> 提升为新的根节点。</li>
<li>将 <code>y</code> 设为 <code>x</code> 的右子节点。</li>
</ol>
<h4 id="右旋的伪代码"><a href="#右旋的伪代码" class="headerlink" title="右旋的伪代码"></a>右旋的伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="type">int</span> height; <span class="comment">// 用于 AVL 树的高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* y)</span> </span>&#123;</span><br><span class="line">    TreeNode* x = y-&gt;left;           <span class="comment">// 让 x 指向 y 的左子节点</span></span><br><span class="line">    TreeNode* T2 = x-&gt;right;         <span class="comment">// 保存 x 的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    x-&gt;right = y;                    <span class="comment">// 将 y 设置为 x 的右子节点</span></span><br><span class="line">    y-&gt;left = T2;                    <span class="comment">// 将 T2 设置为 y 的左子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度（如果需要）</span></span><br><span class="line">    y-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-左旋（Left-Rotation）"><a href="#2-左旋（Left-Rotation）" class="headerlink" title="2. 左旋（Left Rotation）"></a>2. 左旋（Left Rotation）</h3><p>左旋操作是将某个节点的右子节点提升为新的根节点，同时将失衡节点降为新根节点的左子节点。</p>
<h4 id="左旋的步骤"><a href="#左旋的步骤" class="headerlink" title="左旋的步骤"></a>左旋的步骤</h4><ol>
<li>设失衡节点为 <code>x</code>，其右子节点为 <code>y</code>。</li>
<li>将 <code>y</code> 的左子节点（如果存在）连接到 <code>x</code> 的右子节点。</li>
<li>将 <code>y</code> 提升为新的根节点。</li>
<li>将 <code>x</code> 设为 <code>y</code> 的左子节点。</li>
</ol>
<h4 id="左旋的伪代码"><a href="#左旋的伪代码" class="headerlink" title="左旋的伪代码"></a>左旋的伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* x)</span> </span>&#123;</span><br><span class="line">    TreeNode* y = x-&gt;right;         <span class="comment">// 让 y 指向 x 的右子节点</span></span><br><span class="line">    TreeNode* T2 = y-&gt;left;         <span class="comment">// 保存 y 的左子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    y-&gt;left = x;                    <span class="comment">// 将 x 设置为 y 的左子节点</span></span><br><span class="line">    x-&gt;right = T2;                  <span class="comment">// 将 T2 设置为 x 的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度（如果需要）</span></span><br><span class="line">    x-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    y-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-组合旋转"><a href="#3-组合旋转" class="headerlink" title="3. 组合旋转"></a>3. 组合旋转</h3><h4 id="AVL有且只有的四种情况（LL-LR-RL-RR）"><a href="#AVL有且只有的四种情况（LL-LR-RL-RR）" class="headerlink" title="AVL有且只有的四种情况（LL,LR,RL,RR）"></a>AVL有且只有的四种情况（LL,LR,RL,RR）</h4><p>图片来自<a href="https://blog.csdn.net/a6892255/article/details/117001282?ops_request_misc=%7B%22request_id%22:%22EBCFF1FE-F5C1-4776-B879-A508C09E98D5%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=EBCFF1FE-F5C1-4776-B879-A508C09E98D5&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117001282-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B&spm=1018.2226.3001.4187">数据结构之AVL树(平衡二叉树)的理解_avl左右旋-CSDN博客</a></p>
<h4 id="1-LL"><a href="#1-LL" class="headerlink" title="1.LL"></a>1.LL</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/edea4edc378247e01a490437e164a51f.png" alt="LL"></p>
<h4 id="2-LR"><a href="#2-LR" class="headerlink" title="2.LR"></a>2.LR</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dc372fd873d281a3bb0b8a92eaae54fa.png" alt="LR(1)"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/30204ce4046bd0a9c2316159496d1886.png" alt="LR(2)"></p>
<h4 id="3-RL"><a href="#3-RL" class="headerlink" title="3.RL"></a>3.RL</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d60980e235068364f15691ef822690de.png" alt="RL(1)"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/084bc177d55d0797ab75c3caf6963405.png" alt="RL(2)"></p>
<h4 id="4-RR"><a href="#4-RR" class="headerlink" title="4.RR"></a>4.RR</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/60bb25e94471951b5602f0507a5b232c.png" alt="RR2"></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>懒加载</title>
    <url>/2025/01/22/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p><strong>懒加载</strong>（Lazy Initialization 或 Lazy Loading）是一种设计模式或编程技巧，它的核心思想是：<strong>延迟初始化资源，只有在真正需要的时候才创建或加载这些资源</strong>。</p>
<hr>
<h3 id="懒加载的特点"><a href="#懒加载的特点" class="headerlink" title="懒加载的特点"></a><strong>懒加载的特点</strong></h3><ol>
<li><strong>避免不必要的开销</strong><ul>
<li>如果资源加载非常耗时或占用大量内存，懒加载可以减少程序启动时的资源占用。</li>
</ul>
</li>
<li><strong>提升性能</strong><ul>
<li>只有在资源被真正需要时才加载，减少了程序的启动时间。</li>
</ul>
</li>
<li><strong>按需加载</strong><ul>
<li>资源是否加载取决于程序运行时的实际需求，可能避免加载某些资源。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="懒加载的使用场景"><a href="#懒加载的使用场景" class="headerlink" title="懒加载的使用场景"></a><strong>懒加载的使用场景</strong></h3><ol>
<li><p><strong>单例模式</strong></p>
<ul>
<li>在单例模式中，实例对象通常会在第一次访问时才创建。</li>
<li>例如，你的 <code>Logger</code> 类的实现：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Logger &amp;<span class="title">Logger::instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger; <span class="comment">// 静态变量只在第一次调用时初始化</span></span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Logger</code> 对象只有在调用 <code>Logger::instance()</code> 时才会被创建，而不是程序启动时。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件或资源加载</strong></p>
<ul>
<li>某些大文件、图像、数据库连接等，只有当它们真正被使用时才加载：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    std::string filePath;</span><br><span class="line">    <span class="type">bool</span> loaded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!loaded) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Loading image from: &quot;</span> &lt;&lt; filePath &lt;&lt; std::endl;</span><br><span class="line">            loaded = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这里，<code>load()</code> 方法只会在需要时加载图像。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Web开发</strong></p>
<ul>
<li>某些页面的资源（如图片、视频等）可能只有当用户滚动到相关区域时才加载，减少初始页面加载时间。</li>
</ul>
</li>
<li><p><strong>数据库连接或远程服务</strong></p>
<ul>
<li>某些昂贵的资源，比如数据库连接或远程 API 的初始化，可以延迟到第一次调用时：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;Connection&gt; conn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Connection* <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">            conn = std::<span class="built_in">make_unique</span>&lt;Connection&gt;(<span class="string">&quot;database_url&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="懒加载的优缺点"><a href="#懒加载的优缺点" class="headerlink" title="懒加载的优缺点"></a><strong>懒加载的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><strong>节约资源</strong><ul>
<li>如果某些资源没有被使用，那么它们就不会被初始化，节省内存和 CPU 开销。</li>
</ul>
</li>
<li><strong>提升性能</strong><ul>
<li>程序启动时不需要一次性加载所有资源，减少启动时间。</li>
</ul>
</li>
<li><strong>动态性</strong><ul>
<li>根据实际需要按需加载，增加程序的灵活性。</li>
</ul>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><strong>可能导致延迟</strong><ul>
<li>当资源在运行时第一次被访问时，懒加载会增加一定的初始化开销，可能导致短暂的延迟。</li>
</ul>
</li>
<li><strong>线程安全问题</strong><ul>
<li>在多线程环境中，如果多个线程同时访问未初始化的资源，可能会导致竞争条件或重复初始化。需要通过加锁或使用线程安全的机制（如 C++11 的静态局部变量）解决。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="懒加载与饿加载对比"><a href="#懒加载与饿加载对比" class="headerlink" title="懒加载与饿加载对比"></a><strong>懒加载与饿加载对比</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>懒加载</strong></th>
<th><strong>饿加载（Eager Loading）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>加载时机</strong></td>
<td>只有在需要时才加载资源</td>
<td>程序启动时立即加载资源</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>程序启动时较快，首次使用时可能有延迟</td>
<td>程序启动时较慢，但运行时无需等待</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>只有用到的资源才会加载，节约内存</td>
<td>所有资源都被加载，可能造成浪费</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>需要确保初始化过程的线程安全</td>
<td>初始化时线程安全问题相对较少</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>资源加载成本高，且不一定被全部使用</td>
<td>资源较少，或所有资源都会被使用</td>
</tr>
</tbody></table>
<hr>
<h3 id="懒加载的实现方式"><a href="#懒加载的实现方式" class="headerlink" title="懒加载的实现方式"></a><strong>懒加载的实现方式</strong></h3><h4 id="1-静态局部变量"><a href="#1-静态局部变量" class="headerlink" title="1. 静态局部变量"></a><strong>1. 静态局部变量</strong></h4><ul>
<li>C++ 中常用懒加载方式，利用静态局部变量的特性：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Logger &amp;<span class="title">Logger::instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;  <span class="comment">// 只有第一次调用时，logger 才会被初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-延迟初始化变量"><a href="#2-延迟初始化变量" class="headerlink" title="2. 延迟初始化变量"></a><strong>2. 延迟初始化变量</strong></h4><ul>
<li>用一个标志位来判断是否已加载资源：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyObject</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;Resource&gt; resource;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Resource* <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!resource) &#123;</span><br><span class="line">            resource = std::<span class="built_in">make_unique</span>&lt;Resource&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-双重检查锁（用于多线程）"><a href="#3-双重检查锁（用于多线程）" class="headerlink" title="3. 双重检查锁（用于多线程）"></a><strong>3. 双重检查锁（用于多线程）</strong></h4><ul>
<li>多线程情况下的懒加载，可以用双重检查锁：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>懒加载是一种高效的设计模式，适合那些<strong>资源初始化开销大但并非总是需要</strong>的场景。在你的 <code>Logger</code> 单例模式中，懒加载的使用保证了资源的按需加载和全局唯一性，同时避免了程序启动时不必要的性能消耗。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕vector</title>
    <url>/2025/05/02/%E6%89%8B%E6%92%95vector/</url>
    <content><![CDATA[<p>手撕不了一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;cstddef&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;new&gt;</span><br><span class="line"></span><br><span class="line">// 简单的内存池分配器，用于高效内存管理</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class PoolAllocator &#123;</span><br><span class="line">private:</span><br><span class="line">    struct Block &#123;</span><br><span class="line">        Block* next; // 指向下一个空闲块的指针</span><br><span class="line">    &#125;;</span><br><span class="line">    static constexpr size_t POOL_SIZE = 1024 * sizeof(T); // 内存池总大小</span><br><span class="line">    static constexpr size_t BLOCK_SIZE = sizeof(T) &gt; sizeof(Block) ? sizeof(T) : sizeof(Block); // 每个块的大小</span><br><span class="line">    unsigned char* pool_;  // 原始内存池</span><br><span class="line">    Block* free_list_;     // 空闲块链表头</span><br><span class="line">    size_t pool_size_;     // 内存池总大小</span><br><span class="line"></span><br><span class="line">// 初始化空闲块链表，将内存池分割为链接的块</span><br><span class="line">void init_pool() &#123;</span><br><span class="line">    free_list_ = reinterpret_cast&lt;Block*&gt;(pool_);</span><br><span class="line">    Block* current = free_list_;</span><br><span class="line">    size_t block_count = pool_size_ / BLOCK_SIZE;</span><br><span class="line">    for (size_t i = 0; i &lt; block_count - 1; ++i) &#123;</span><br><span class="line">        current-&gt;next = reinterpret_cast&lt;Block*&gt;(reinterpret_cast&lt;unsigned char*&gt;(current) + BLOCK_SIZE);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    using value_type = T;</span><br><span class="line"></span><br><span class="line">// 构造函数：分配内存池并初始化空闲链表</span><br><span class="line">PoolAllocator() : pool_(new unsigned char[POOL_SIZE]), free_list_(nullptr), pool_size_(POOL_SIZE) &#123;</span><br><span class="line">    init_pool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 析构函数：释放内存池</span><br><span class="line">~PoolAllocator() &#123; delete[] pool_; &#125;</span><br><span class="line"></span><br><span class="line">// 从内存池分配单个块</span><br><span class="line">T* allocate(size_t n) &#123;</span><br><span class="line">    if (n != 1) throw std::bad_alloc(); // 仅支持单对象分配</span><br><span class="line">    if (!free_list_) throw std::bad_alloc(); // 内存池已耗尽</span><br><span class="line">    Block* block = free_list_;</span><br><span class="line">    free_list_ = free_list_-&gt;next;</span><br><span class="line">    return reinterpret_cast&lt;T*&gt;(block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将块归还到内存池</span><br><span class="line">void deallocate(T* p, size_t n) noexcept &#123;</span><br><span class="line">    if (n != 1) return;</span><br><span class="line">    Block* block = reinterpret_cast&lt;Block*&gt;(p);</span><br><span class="line">    block-&gt;next = free_list_;</span><br><span class="line">    free_list_ = block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 支持不同类型的重绑定</span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line">struct rebind &#123;</span><br><span class="line">    using other = PoolAllocator&lt;U&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 向量实现，支持自定义分配器</span><br><span class="line">template &lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;</span><br><span class="line">class MyVector &#123;</span><br><span class="line">private:</span><br><span class="line">    using AllocTraits = std::allocator_traits&lt;Alloc&gt;;</span><br><span class="line">    T* data_;         // 动态数组指针</span><br><span class="line">    size_t size_;     // 元素数量</span><br><span class="line">    size_t capacity_; // 当前容量</span><br><span class="line">    Alloc alloc_;     // 分配器实例</span><br><span class="line"></span><br><span class="line">// 重新分配到新容量，移动现有元素</span><br><span class="line">void reallocate(size_t new_capacity) &#123;</span><br><span class="line">    T* new_data = AllocTraits::allocate(alloc_, new_capacity);</span><br><span class="line">    for (size_t i = 0; i &lt; size_; ++i) &#123;</span><br><span class="line">        AllocTraits::construct(alloc_, new_data + i, std::move(data_[i]));</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + i);</span><br><span class="line">    &#125;</span><br><span class="line">    if (data_) AllocTraits::deallocate(alloc_, data_, capacity_);</span><br><span class="line">    data_ = new_data;</span><br><span class="line">    capacity_ = new_capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁指定范围内的元素</span><br><span class="line">void destroy_range(T* first, T* last) &#123;</span><br><span class="line">    while (first != last) &#123;</span><br><span class="line">        AllocTraits::destroy(alloc_, first);</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数：空向量</span><br><span class="line">    MyVector() : data_(nullptr), size_(0), capacity_(0), alloc_() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 初始化列表构造函数</span><br><span class="line">MyVector(std::initializer_list&lt;T&gt; init, const Alloc&amp; alloc = Alloc())</span><br><span class="line">    : data_(nullptr), size_(0), capacity_(0), alloc_(alloc) &#123;</span><br><span class="line">    reserve(init.size());</span><br><span class="line">    for (const T&amp; value : init) &#123;</span><br><span class="line">        push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝构造函数</span><br><span class="line">MyVector(const MyVector&amp; other)</span><br><span class="line">    : data_(nullptr), size_(0), capacity_(0), alloc_(AllocTraits::select_on_container_copy_construction(other.alloc_)) &#123;</span><br><span class="line">    reserve(other.size_);</span><br><span class="line">    for (size_t i = 0; i &lt; other.size_; ++i) &#123;</span><br><span class="line">        push_back(other.data_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动构造函数</span><br><span class="line">MyVector(MyVector&amp;&amp; other) noexcept</span><br><span class="line">    : data_(other.data_), size_(other.size_), capacity_(other.capacity_), alloc_(std::move(other.alloc_)) &#123;</span><br><span class="line">    other.data_ = nullptr;</span><br><span class="line">    other.size_ = 0;</span><br><span class="line">    other.capacity_ = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 析构函数：清理元素和内存</span><br><span class="line">~MyVector() &#123;</span><br><span class="line">    destroy_range(data_, data_ + size_);</span><br><span class="line">    if (data_) AllocTraits::deallocate(alloc_, data_, capacity_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝赋值运算符</span><br><span class="line">MyVector&amp; operator=(const MyVector&amp; other) &#123;</span><br><span class="line">    if (this != &amp;other) &#123;</span><br><span class="line">        MyVector temp(other);</span><br><span class="line">        std::swap(data_, temp.data_);</span><br><span class="line">        std::swap(size_, temp.size_);</span><br><span class="line">        std::swap(capacity_, temp.capacity_);</span><br><span class="line">        std::swap(alloc_, temp.alloc_);</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动赋值运算符</span><br><span class="line">MyVector&amp; operator=(MyVector&amp;&amp; other) noexcept &#123;</span><br><span class="line">    if (this != &amp;other) &#123;</span><br><span class="line">        destroy_range(data_, data_ + size_);</span><br><span class="line">        if (data_) AllocTraits::deallocate(alloc_, data_, capacity_);</span><br><span class="line">        data_ = other.data_;</span><br><span class="line">        size_ = other.size_;</span><br><span class="line">        capacity_ = other.capacity_;</span><br><span class="line">        alloc_ = std::move(other.alloc_);</span><br><span class="line">        other.data_ = nullptr;</span><br><span class="line">        other.size_ = 0;</span><br><span class="line">        other.capacity_ = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素访问</span><br><span class="line">T&amp; operator[](size_t index) &#123; return data_[index]; &#125;</span><br><span class="line">const T&amp; operator[](size_t index) const &#123; return data_[index]; &#125;</span><br><span class="line"></span><br><span class="line">// 安全元素访问，带边界检查</span><br><span class="line">T&amp; at(size_t index) &#123;</span><br><span class="line">    if (index &gt;= size_) throw std::out_of_range(&quot;索引越界&quot;);</span><br><span class="line">    return data_[index];</span><br><span class="line">&#125;</span><br><span class="line">const T&amp; at(size_t index) const &#123;</span><br><span class="line">    if (index &gt;= size_) throw std::out_of_range(&quot;索引越界&quot;);</span><br><span class="line">    return data_[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 容量操作</span><br><span class="line">size_t size() const &#123; return size_; &#125;</span><br><span class="line">size_t capacity() const &#123; return capacity_; &#125;</span><br><span class="line">bool empty() const &#123; return size_ == 0; &#125;</span><br><span class="line"></span><br><span class="line">// 预留容量，必要时重新分配</span><br><span class="line">void reserve(size_t new_capacity) &#123;</span><br><span class="line">    if (new_capacity &gt; capacity_) &#123;</span><br><span class="line">        reallocate(new_capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整大小，添加默认元素或裁剪</span><br><span class="line">void resize(size_t new_size) &#123;</span><br><span class="line">    if (new_size &gt; size_) &#123;</span><br><span class="line">        reserve(new_size);</span><br><span class="line">        while (size_ &lt; new_size) &#123;</span><br><span class="line">            AllocTraits::construct(alloc_, data_ + size_, T());</span><br><span class="line">            ++size_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        destroy_range(data_ + new_size, data_ + size_);</span><br><span class="line">        size_ = new_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素操作</span><br><span class="line">// 在末尾追加元素</span><br><span class="line">void push_back(const T&amp; value) &#123;</span><br><span class="line">    if (size_ == capacity_) &#123;</span><br><span class="line">        reserve(capacity_ == 0 ? 1 : capacity_ * 2);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::construct(alloc_, data_ + size_, value);</span><br><span class="line">    ++size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾原地构造元素</span><br><span class="line">template &lt;typename... Args&gt;</span><br><span class="line">void emplace_back(Args&amp;&amp;... args) &#123;</span><br><span class="line">    if (size_ == capacity_) &#123;</span><br><span class="line">        reserve(capacity_ == 0 ? 1 : capacity_ * 2);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::construct(alloc_, data_ + size_, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    ++size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除最后一个元素</span><br><span class="line">void pop_back() &#123;</span><br><span class="line">    if (size_ &gt; 0) &#123;</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + size_ - 1);</span><br><span class="line">        --size_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入元素</span><br><span class="line">void insert(T* pos, const T&amp; value) &#123;</span><br><span class="line">    size_t index = pos - data_;</span><br><span class="line">    if (index &gt; size_) throw std::out_of_range(&quot;无效插入位置&quot;);</span><br><span class="line">    if (size_ == capacity_) &#123;</span><br><span class="line">        reserve(capacity_ == 0 ? 1 : capacity_ * 2);</span><br><span class="line">    &#125;</span><br><span class="line">    for (size_t i = size_; i &gt; index; --i) &#123;</span><br><span class="line">        AllocTraits::construct(alloc_, data_ + i, std::move(data_[i - 1]));</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::construct(alloc_, data_ + index, value);</span><br><span class="line">    ++size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素</span><br><span class="line">void erase(T* pos) &#123;</span><br><span class="line">    size_t index = pos - data_;</span><br><span class="line">    if (index &gt;= size_) throw std::out_of_range(&quot;无效删除位置&quot;);</span><br><span class="line">    for (size_t i = index; i &lt; size_ - 1; ++i) &#123;</span><br><span class="line">        AllocTraits::construct(alloc_, data_ + i, std::move(data_[i + 1]));</span><br><span class="line">        AllocTraits::destroy(alloc_, data_ + i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    AllocTraits::destroy(alloc_, data_ + size_ - 1);</span><br><span class="line">    --size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 迭代器</span><br><span class="line">T* begin() &#123; return data_; &#125;</span><br><span class="line">T* end() &#123; return data_ + size_; &#125;</span><br><span class="line">const T* begin() const &#123; return data_; &#125;</span><br><span class="line">const T* end() const &#123; return data_ + size_; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>



<h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>以下是对上述 <code>my_vector.h</code> 实现的详细讲解，涵盖主要功能、设计思路和关键特性：</p>
<ol>
<li><p><strong>内存池分配器（<code>PoolAllocator</code>）</strong>：</p>
<ul>
<li><strong>目的</strong>：提供高效的内存分配，减少动态分配（如 <code>malloc</code>）的开销，适合资源受限环境。</li>
<li><strong>实现</strong>：<ul>
<li>使用固定大小的内存池（<code>POOL_SIZE</code>），通过空闲链表（<code>free_list_</code>）管理块。</li>
<li>每个块的大小为 <code>BLOCK_SIZE</code>，确保足够存储 <code>T</code> 或 <code>Block</code>（取较大者）。</li>
<li><code>allocate</code> 从空闲链表获取块，时间复杂度 ( O(1) )。</li>
<li><code>deallocate</code> 将块归还空闲链表，同样 ( O(1) )。</li>
</ul>
</li>
<li><strong>特性</strong>：<ul>
<li>仅支持单对象分配（<code>n == 1</code>），适合 <code>MyVector</code> 的连续内存需求。</li>
<li>通过 <code>rebind</code> 支持不同类型的分配，符合 C++ 分配器标准。</li>
<li>抛出 <code>std::bad_alloc</code> 处理内存耗尽，增强健壮性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>vector实现（<code>MyVector</code>）</strong>：</p>
<ul>
<li><strong>目的</strong>：模拟 <code>std::vector</code>，支持动态数组功能，同时兼容自定义分配器。</li>
<li><strong>核心功能</strong>：<ul>
<li><strong>构造与销毁</strong>：支持默认、初始化列表、拷贝、移动构造函数，以及析构函数，确保资源正确管理。</li>
<li><strong>元素访问</strong>：通过 <code>operator[]</code>（无边界检查）和 <code>at</code>（带边界检查）访问元素，<code>at</code> 抛出 <code>std::out_of_range</code>。</li>
<li><strong>容量管理</strong>：<ul>
<li><code>reserve</code> 预分配容量，<code>resize</code> 调整大小，必要时构造或销毁元素。</li>
<li>容量翻倍策略（<code>capacity_ * 2</code>）均摊 ( O(1) ) 插入复杂度。</li>
</ul>
</li>
<li><strong>元素操作</strong>：<ul>
<li><code>push_back</code>：追加元素，必要时扩展容量。</li>
<li><code>emplace_back</code>：原地构造元素，减少拷贝&#x2F;移动开销。</li>
<li><code>pop_back</code>：删除末尾元素。</li>
<li><code>insert</code>：在指定位置插入元素，移动后续元素，时间复杂度 ( O(n) )。</li>
<li><code>erase</code>：删除指定位置元素，移动后续元素，时间复杂度 ( O(n) )。</li>
</ul>
</li>
<li><strong>迭代器</strong>：提供简单的指针迭代器（<code>begin</code>、<code>end</code>），支持范围遍历。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异常安全</strong>：</p>
<ul>
<li><strong>强异常保证</strong>：<code>insert</code>、<code>erase</code>、<code>emplace_back</code> 在异常时保持对象一致性，通过移动操作和临时对象实现。</li>
<li><strong>基本异常保证</strong>：内存分配失败不破坏对象，析构函数正确清理。</li>
<li><code>at</code> 和 <code>insert</code>&#x2F;<code>erase</code> 的边界检查抛出 <code>std::out_of_range</code>，便于调试。</li>
</ul>
</li>
<li><p><strong>设计亮点</strong>：</p>
<ul>
<li><strong>分配器抽象</strong>：通过 <code>AllocTraits</code> 支持 <code>std::allocator</code> 或 <code>PoolAllocator</code>，增强灵活性。</li>
<li><strong>移动语义</strong>：拷贝&#x2F;移动构造函数和赋值运算符优化性能，移动操作标记为 <code>noexcept</code>。</li>
<li><strong>内存效率</strong>：<code>PoolAllocator</code> 减少碎片，连续内存布局（<code>data_</code>）保持缓存友好性。</li>
<li><strong>简洁性</strong>：代码结构清晰，注释详细，易于维护和扩展。</li>
</ul>
</li>
<li><p><strong>局限性</strong>：</p>
<ul>
<li><code>PoolAllocator</code> 仅支持单对象分配，内存池大小固定（耗尽时抛异常）。</li>
<li><code>insert</code> 和 <code>erase</code> 时间复杂度为 ( O(n) )，不适合频繁中间操作。</li>
<li>迭代器仅为简单指针，未实现完整随机访问迭代器类。</li>
</ul>
</li>
<li><p><strong>扩展方向</strong>：</p>
<ul>
<li><strong>动态内存池</strong>：支持池扩展，适应更大内存需求。</li>
<li><strong>完整迭代器</strong>：实现 STL 兼容的随机访问迭代器，支持复杂算法。</li>
<li><strong>多对象分配</strong>：扩展 <code>PoolAllocator</code> 支持 <code>n</code> 个对象分配。</li>
<li><strong>性能优化</strong>：调整容量增长策略（如 <code>1.5</code> 倍）以减少内存浪费，或添加 <code>shrink_to_fit</code>。</li>
</ul>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyVector&lt;std::string, PoolAllocator&lt;std::string&gt;&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 原地构造</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 构造 &quot;aaaaa&quot;</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="string">&quot;World&quot;</span>); <span class="comment">// 插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: Hello World aaaaa</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 删除 World</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; s : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出: Hello aaaaa</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        vec.<span class="built_in">at</span>(<span class="number">10</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;错误: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>指向常量的指针与指针常量</title>
    <url>/2024/11/17/%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p>好久没有更新博客了，与最近考试多有关，也与个人怠惰有关</p>
<p>今天的内容是指向常量的指针（pointer to const）（也就是常量指针）与指针常量（const pointer），这是昨天在阅读《c++ primer》中重新理解的内容，有了些许新的感悟，趁热打铁，发在博客上</p>
<h3 id="在讲那两个之前，先说一下const与对常量的引用（reference-to-const）"><a href="#在讲那两个之前，先说一下const与对常量的引用（reference-to-const）" class="headerlink" title="在讲那两个之前，先说一下const与对常量的引用（reference to const）"></a>在讲那两个之前，先说一下const与对常量的引用（reference to const）</h3><h4 id="const修饰词"><a href="#const修饰词" class="headerlink" title="const修饰词"></a>const修饰词</h4><p>使用const修饰词修饰的变量，即常量，是必须初始化的，且初始化后不能修改其值</p>
<p>初始化时除了用如下方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a=1;</span><br></pre></td></tr></table></figure>

<p>同样可以用非常量但同类型的值进行赋值（拷贝）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">const int b=a;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>const修饰的对象在编译时直接替换，类似define，即提前将所有出现其的位置替换成对应的数值，不申请额外空间</p>
<p>以下场景除外(都要等具体的值才能初始化)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a =fun();</span><br><span class="line">const int &amp;b=c;</span><br></pre></td></tr></table></figure>

<p>同时const对象仅在文件内部有效，要实现在一个文件中定义，在多个文件中声明并使用，要用extern 关键字修饰所有const对象</p>
<h4 id="对const的引用（常量引用）"><a href="#对const的引用（常量引用）" class="headerlink" title="对const的引用（常量引用）"></a>对const的引用（常量引用）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常量引用本身是常量，无法修改引用的对象</span><br><span class="line">const int a=1;</span><br><span class="line">const int b=2;</span><br><span class="line">const int &amp;r =a;</span><br><span class="line">r=b;//错误，不可修改</span><br><span class="line">r=2;//错误，不可修改</span><br></pre></td></tr></table></figure>

<p>常量引用不能改变引用的值（毕竟常量的值无法改变）</p>
<p>要对常量使用引用，也只能使用常量引用</p>
<h2 id="但是，常量引用可以引用非常量的同类型变量"><a href="#但是，常量引用可以引用非常量的同类型变量" class="headerlink" title="但是，常量引用可以引用非常量的同类型变量"></a>但是，常量引用可以引用非常量的同类型变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">const int &amp;r =i;//正确</span><br><span class="line"></span><br><span class="line">const int &amp;r2=r1*2;//正确</span><br><span class="line"></span><br><span class="line">i=4;//i不是常量，可以修改，同样会导致r的值变动</span><br></pre></td></tr></table></figure>

<p>这种场景经常出现，甚至比引用常量更多，主要应用场景在函数参数传递时，传递参数的常量引用，可以确保参数不被修改，同时避免拷贝的花销。</p>
<p>在接口等地方非常常见，可以参考《effective c++》中的建议</p>
<p>可以理解为常量引用引用的是一个临时常量，变量的值赋给了临时变量。</p>
<p>ok.到此为止，下面是指向常量的指针与常量指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line"></span><br><span class="line">指针常量</span><br><span class="line">int* const p1 = &amp;a;</span><br><span class="line">*p1 = 6;</span><br><span class="line">// const pointer,本身是个常量，不能改变指向的对象</span><br><span class="line">//只能指向变量，无法指向常量</span><br><span class="line">//如果指向的对象并非是常量，指向对象的值还是可以修改的</span><br><span class="line"></span><br><span class="line">指向常量的指针（常量指针）</span><br><span class="line">const int* p2 = &amp;a;</span><br><span class="line">p2 = &amp;b;//正确，pointer to const,本身不是常量，可以改变指向的对象</span><br><span class="line">*p2=3;//错误，无法通过这种方式修改指向的变量的值</span><br><span class="line">//类似常量引用，可以指向常量，也可以指向变量</span><br><span class="line"></span><br><span class="line">const int* const p3 = &amp;a;//指向常量的常量指针</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h3><p>顶层const表示其本身是常量，即常量和指针常量，无法修改其值（指针常量无法修改指向的对象，即地址，也就是其值）</p>
<p>底层const表示指向（引用）的对象是一个“常量”（常量或变量），无法修改指向（引用）对象的值，即常量引用和指向常量的指针等</p>
<p>拷贝时，两者区别非常明显</p>
<p>顶层const，可以随意赋给变量做值</p>
<p>底层const,不可以赋给变量做值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">const int *r1=a;</span><br><span class="line">int *const r2=a;</span><br><span class="line"></span><br><span class="line">int *p=r1;//错误，底层const无法赋值</span><br><span class="line">int *p=r2;//正确</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>const</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统中的调度算法</title>
    <url>/2025/06/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="操作系统中的调度算法"><a href="#操作系统中的调度算法" class="headerlink" title="操作系统中的调度算法"></a>操作系统中的调度算法</h1><p>操作系统中的调度算法用于决定进程或线程的执行顺序，以优化 CPU 利用率、吞吐量、响应时间等。以下是常见的调度算法，分为<strong>非抢占式</strong>和<strong>抢占式</strong>两类：</p>
<h2 id="1-非抢占式调度算法"><a href="#1-非抢占式调度算法" class="headerlink" title="1. 非抢占式调度算法"></a>1. <strong>非抢占式调度算法</strong></h2><p>进程一旦获得 CPU，将运行至完成或主动让出 CPU。</p>
<ul>
<li><p><strong>先来先服务（First-Come, First-Served, FCFS）</strong>：</p>
<ul>
<li>按进程到达顺序执行。</li>
<li><strong>优点</strong>：简单，易实现。</li>
<li><strong>缺点</strong>：可能导致“短进程等待长进程”问题（护送效应），平均等待时间长。</li>
<li><strong>时间复杂度</strong>：队列操作 ( O(1) )。</li>
</ul>
</li>
<li><p><strong>短作业优先（Shortest Job First, SJF）</strong>：</p>
<ul>
<li>选择预计运行时间最短的进程优先执行。</li>
<li><strong>优点</strong>：最小化平均等待时间（理论上最优）。</li>
<li><strong>缺点</strong>：需预知运行时间，难以实现；长进程可能饥饿。</li>
<li><strong>时间复杂度</strong>：选择最短进程 ( O(n) )，可用优先队列优化。</li>
</ul>
</li>
<li><p><strong>优先级调度（Priority Scheduling）</strong>：</p>
<ul>
<li>根据进程优先级调度，优先级高的先执行。</li>
<li><strong>优点</strong>：支持重要进程优先。</li>
<li><strong>缺点</strong>：低优先级进程可能饥饿。</li>
<li><strong>时间复杂度</strong>：取决于优先级队列实现，通常 ( O(\log n) )。</li>
</ul>
</li>
</ul>
<h2 id="2-抢占式调度算法"><a href="#2-抢占式调度算法" class="headerlink" title="2. 抢占式调度算法"></a>2. <strong>抢占式调度算法</strong></h2><p>运行中的进程可能被更高优先级的进程中断。</p>
<ul>
<li><p><strong>短剩余时间优先（Shortest Remaining Time First, SRTF）</strong>：</p>
<ul>
<li>SJF 的抢占式版本，选择剩余运行时间最短的进程。</li>
<li><strong>优点</strong>：进一步优化平均等待时间。</li>
<li><strong>缺点</strong>：需预知剩余时间，上下文切换开销大。</li>
<li><strong>时间复杂度</strong>：选择进程 ( O(n) ) 或用优先队列优化。</li>
</ul>
</li>
<li><p><strong>抢占式优先级调度（Preemptive Priority Scheduling）</strong>：</p>
<ul>
<li>优先级高的进程可抢占 CPU。</li>
<li><strong>优点</strong>：适合实时系统。</li>
<li><strong>缺点</strong>：低优先级进程可能长期等待。</li>
<li><strong>时间复杂度</strong>：优先级队列操作 ( O(\log n) )。</li>
</ul>
</li>
<li><p><strong>轮转调度（Round-Robin, RR）</strong>：</p>
<ul>
<li>每个进程分配固定时间片（quantum），超时后切换到下一进程。</li>
<li><strong>优点</strong>：公平，响应时间短，适合分时系统。</li>
<li><strong>缺点</strong>：时间片设置不当可能导致性能下降。</li>
<li><strong>时间复杂度</strong>：队列操作 ( O(1) )。</li>
</ul>
</li>
<li><p><strong>多级队列调度（Multilevel Queue Scheduling）</strong>：</p>
<ul>
<li>进程按优先级分为多个队列，每个队列可使用不同调度算法（如高优先级用 RR，低优先级用 FCFS）。</li>
<li><strong>优点</strong>：灵活，适合异构进程。</li>
<li><strong>缺点</strong>：复杂，低优先级队列可能饥饿。</li>
<li><strong>时间复杂度</strong>：取决于队列实现。</li>
</ul>
</li>
<li><p><strong>多级反馈队列调度（Multilevel Feedback Queue, MLFQ）</strong>：</p>
<ul>
<li>类似多级队列，但进程可根据行为动态调整优先级（如 I&#x2F;O 密集型进程优先级提升）。</li>
<li><strong>优点</strong>：自适应，平衡响应时间和吞吐量。</li>
<li><strong>缺点</strong>：实现复杂，需调优参数。</li>
<li><strong>时间复杂度</strong>：队列操作 ( O(\log n) ) 或更高。</li>
</ul>
</li>
</ul>
<h2 id="3-其他调度算法"><a href="#3-其他调度算法" class="headerlink" title="3. 其他调度算法"></a>3. <strong>其他调度算法</strong></h2><ul>
<li><p><strong>最早截止时间优先（Earliest Deadline First, EDF）</strong>：</p>
<ul>
<li>实时系统中，按任务截止时间排序，截止时间近的先执行。</li>
<li><strong>优点</strong>：适合硬实时系统，保证截止时间。</li>
<li><strong>缺点</strong>：需知道截止时间，计算复杂。</li>
<li><strong>时间复杂度</strong>：排序 ( O(n \log n) ) 或优先队列 ( O(\log n) )。</li>
</ul>
</li>
<li><p><strong>速率单调调度（Rate Monotonic Scheduling, RMS）</strong>：</p>
<ul>
<li>实时系统中，周期短的任务优先级高，固定优先级分配。</li>
<li><strong>优点</strong>：简单，适合周期性任务。</li>
<li><strong>缺点</strong>：不适合非周期任务。</li>
<li><strong>时间复杂度</strong>：优先级分配 ( O(1) )。</li>
</ul>
</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h2><ul>
<li><strong>非抢占式</strong>：FCFS、SJF、优先级调度，适合简单或批处理系统。</li>
<li><strong>抢占式</strong>：SRTF、抢占式优先级、RR、MLQ、MLFQ，适合分时或实时系统。</li>
<li><strong>实时调度</strong>：EDF、RMS，专为满足时间约束设计。</li>
<li><strong>选择依据</strong>：<ul>
<li>FCFS 和 RR 适合公平性要求。</li>
<li>SJF 和 SRTF 优化等待时间。</li>
<li>优先级调度和 MLFQ 适合混合负载。</li>
<li>EDF 和 RMS 用于实时系统。</li>
</ul>
</li>
</ul>
<p>如需具体算法的实现代码或应用场景分析，请提供进一步细节！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>无锁循环队列</title>
    <url>/2025/06/30/%E6%97%A0%E9%94%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="无锁循环队列"><a href="#无锁循环队列" class="headerlink" title="无锁循环队列"></a>无锁循环队列</h1><p>无锁循环队列（Lock-Free Circular Queue）是一种线程安全的环形缓冲区数据结构，允许多个线程并发访问而无需使用锁（如互斥锁）。它通过原子操作（如 CAS，Compare-And-Swap）确保线程安全，适用于高并发场景，如生产者-消费者模型。</p>
<h2 id="1-无锁循环队列的特点"><a href="#1-无锁循环队列的特点" class="headerlink" title="1. 无锁循环队列的特点"></a>1. <strong>无锁循环队列的特点</strong></h2><ul>
<li><strong>循环队列</strong>：<ul>
<li>使用固定大小的数组，首尾相连形成环形结构。</li>
<li>通过模运算（<code>% size</code>）实现循环索引。</li>
</ul>
</li>
<li><strong>无锁</strong>：<ul>
<li>使用原子操作（如 <code>std::atomic</code>）避免锁竞争，减少上下文切换和锁开销。</li>
<li>适合多线程环境，降低阻塞，提高吞吐量。</li>
</ul>
</li>
<li><strong>线程安全</strong>：<ul>
<li>允许多个生产者（push）和消费者（pop）并发操作。</li>
<li>需处理并发时的竞争和一致性问题。</li>
</ul>
</li>
<li><strong>限制</strong>：<ul>
<li>通常固定大小（非动态扩展）。</li>
<li>实现复杂，需谨慎处理边界条件和 ABA 问题。</li>
</ul>
</li>
</ul>
<h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. <strong>实现原理</strong></h2><p>无锁循环队列通常基于以下关键点：</p>
<ul>
<li><strong>原子变量</strong>：使用 <code>std::atomic</code> 管理头（<code>head</code>）和尾（<code>tail</code>）索引，确保线程安全的更新。</li>
<li><strong>CAS 操作</strong>：通过比较并交换（Compare-And-Swap）实现无锁的入队（push）和出队（pop）。</li>
<li><strong>循环索引</strong>：通过模运算循环使用数组，避免越界。</li>
<li><strong>单生产者&#x2F;单消费者（SPSC）或多生产者&#x2F;多消费者（MPMC）</strong>：<ul>
<li>SPSC 实现较简单，竞争较少。</li>
<li>MPMC 需要更复杂的同步机制。</li>
</ul>
</li>
</ul>
<h2 id="3-实现代码（C-单生产者-单消费者无锁循环队列）"><a href="#3-实现代码（C-单生产者-单消费者无锁循环队列）" class="headerlink" title="3. 实现代码（C++ 单生产者&#x2F;单消费者无锁循环队列）"></a>3. <strong>实现代码（C++ 单生产者&#x2F;单消费者无锁循环队列）</strong></h2><p>以下是一个简单的单生产者&#x2F;单消费者（SPSC）无锁循环队列实现，适合一个线程入队、一个线程出队的场景。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T buffer[Size];                   <span class="comment">// 固定大小的环形缓冲区</span></span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; head&#123;<span class="number">0</span>&#125;;      <span class="comment">// 出队索引（消费者更新）</span></span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; tail&#123;<span class="number">0</span>&#125;;      <span class="comment">// 入队索引（生产者更新）</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> MASK = Size - <span class="number">1</span>; <span class="comment">// 假设 Size 是 2 的幂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 入队操作（单生产者）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> current_tail = tail.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="type">size_t</span> next_tail = (current_tail + <span class="number">1</span>) &amp; MASK; <span class="comment">// 循环索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (next_tail == head.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队列满</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        buffer[current_tail] = item;</span><br><span class="line">        <span class="comment">// 更新 tail（原子操作，确保内存可见性）</span></span><br><span class="line">        tail.<span class="built_in">store</span>(next_tail, std::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作（单消费者）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> current_head = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (current_head == tail.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队列空</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        item = buffer[current_head];</span><br><span class="line">        <span class="comment">// 更新 head（原子操作）</span></span><br><span class="line">        head.<span class="built_in">store</span>((current_head + <span class="number">1</span>) &amp; MASK, std::memory_order_release);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">load</span>(std::memory_order_acquire) == tail.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否已满</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((tail.<span class="built_in">load</span>(std::memory_order_acquire) + <span class="number">1</span>) &amp; MASK) == head.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a><strong>代码说明</strong></h3><ul>
<li><strong>模板参数</strong>：<ul>
<li><code>T</code>：存储的数据类型。</li>
<li><code>Size</code>：队列大小，必须是 2 的幂（便于模运算优化）。</li>
</ul>
</li>
<li><strong>原子操作</strong>：<ul>
<li><code>head</code> 和 <code>tail</code> 使用 <code>std::atomic</code> 确保线程安全。</li>
<li>使用 <code>memory_order_acquire</code> 和 <code>memory_order_release</code> 保证内存序正确。</li>
</ul>
</li>
<li><strong>入队（push）</strong>：<ul>
<li>检查队列是否满（<code>next_tail == head</code>）。</li>
<li>写入数据后更新 <code>tail</code>。</li>
</ul>
</li>
<li><strong>出队（pop）</strong>：<ul>
<li>检查队列是否空（<code>head == tail</code>）。</li>
<li>读取数据后更新 <code>head</code>。</li>
</ul>
</li>
<li><strong>循环索引</strong>：<ul>
<li>使用 <code>&amp; MASK</code> 代替模运算（<code>% Size</code>），因为 <code>Size</code> 是 2 的幂，优化性能。</li>
</ul>
</li>
<li><strong>内存序</strong>：<ul>
<li><code>acquire</code> 确保读取最新值，防止重排。</li>
<li><code>release</code> 确保写入对其他线程可见。</li>
</ul>
</li>
</ul>
<h2 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. <strong>使用示例</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockFreeQueue&lt;<span class="type">int</span>, <span class="number">8</span>&gt; queue; <span class="comment">// 容量为 8 的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者：入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.<span class="built_in">push</span>(i)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Pushed: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Queue full\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者：出队</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="built_in">pop</span>(value)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Popped: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出</strong>：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pushed: 0</span><br><span class="line">Pushed: 1</span><br><span class="line">Pushed: 2</span><br><span class="line">Pushed: 3</span><br><span class="line">Pushed: 4</span><br><span class="line">Pushed: 5</span><br><span class="line">Pushed: 6</span><br><span class="line">Popped: 0</span><br><span class="line">Popped: 1</span><br><span class="line">Popped: 2</span><br><span class="line">Popped: 3</span><br><span class="line">Popped: 4</span><br><span class="line">Popped: 5</span><br><span class="line">Popped: 6</span><br></pre></td></tr></table></figure>

<h2 id="5-多生产者-多消费者（MPMC）实现"><a href="#5-多生产者-多消费者（MPMC）实现" class="headerlink" title="5. 多生产者&#x2F;多消费者（MPMC）实现"></a>5. <strong>多生产者&#x2F;多消费者（MPMC）实现</strong></h2><p>MPMC 队列更复杂，需要使用 CAS 操作解决并发竞争。以下是关键改动：</p>
<ul>
<li><strong>入队（push）</strong>：<ul>
<li>使用 <code>compare_exchange_strong</code> 原子更新 <code>tail</code>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> current_tail = tail.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line"><span class="keyword">while</span> (!tail.<span class="built_in">compare_exchange_strong</span>(current_tail, (current_tail + <span class="number">1</span>) &amp; MASK,</span><br><span class="line">                                    std::memory_order_release,</span><br><span class="line">                                    std::memory_order_relaxed)) &#123;</span><br><span class="line">    current_tail = tail.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// 重试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>出队（pop）</strong>：<ul>
<li>类似地，使用 CAS 更新 <code>head</code>。</li>
</ul>
</li>
<li><strong>ABA 问题</strong>：<ul>
<li>使用版本计数或双字 CAS（如 <code>std::atomic&lt;std::pair&lt;size_t, size_t&gt;&gt;</code>）避免 ABA 问题。</li>
</ul>
</li>
<li><strong>复杂 Facade Pattern</strong>：<ul>
<li>引入引用计数或其他标记确保数据一致性。</li>
</ul>
</li>
</ul>
<h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. <strong>注意事项</strong></h2><ul>
<li><strong>适用场景</strong>：<ul>
<li>SPSC 适合高性能单线程生产&#x2F;消费场景，如消息队列。</li>
<li>MPMC 适合多线程复杂场景，如任务调度。</li>
</ul>
</li>
<li><strong>局限性</strong>：<ul>
<li>固定大小，需预估最大容量。</li>
<li>MPMC 实现复杂，可能需要额外的同步机制。</li>
<li>原子操作可能因重试导致性能波动。</li>
</ul>
</li>
<li><strong>优化</strong>：<ul>
<li>使用 2 的幂大小优化模运算。</li>
<li>批量操作减少原子操作频率。</li>
<li>考虑内存对齐和缓存行优化。</li>
</ul>
</li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h2><ul>
<li><strong>无锁循环队列</strong>：通过原子操作实现线程安全的环形缓冲区，适合高并发场景。</li>
<li><strong>实现要点</strong>：原子变量、CAS 操作、循环索引、内存序管理。</li>
<li><strong>SPSC vs MPMC</strong>：SPSC 简单高效，MPMC 更通用但实现复杂。</li>
<li><strong>应用</strong>：消息队列、任务调度、数据流处理。</li>
</ul>
<p>如需更详细的 MPMC 实现或性能测试数据，请提供进一步要求！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2025/01/12/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><strong>智能指针</strong>是一种在编程中管理动态内存资源的对象。它封装了原始指针（raw pointer），并提供额外的功能，例如自动释放资源、避免内存泄漏和管理对象的生命周期。智能指针广泛用于需要动态分配内存的语言（如 C++），通过 RAII（Resource Acquisition Is Initialization）原则实现内存管理。</p>
<p>在 C++ 中，智能指针主要在 <strong><code>&lt;memory&gt;</code></strong> 头文件中定义，包括以下几种类型：</p>
<hr>
<h3 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a><strong>1. <code>std::unique_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>独占所有权（一个对象只能有一个 <code>unique_ptr</code> 拥有它）。</li>
<li>不可复制，但可以通过 <code>std::move</code> 转移所有权。</li>
<li>适合需要明确单一所有权的场景。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 创建智能指针</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;                      <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 离开作用域时，自动释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2. std::shared_ptr"></a><strong>2. <code>std::shared_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>共享所有权（多个智能指针可以共享同一个资源）。</li>
<li>通过引用计数管理资源生命周期，计数归零时释放资源。</li>
<li>使用场景：多个对象需要共享同一资源。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享同一资源</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl; <span class="comment">// 输出 42, 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 所有 `shared_ptr` 离开作用域时释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a><strong>3. <code>std::weak_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>与 <code>shared_ptr</code> 配合使用，弱引用（不增加引用计数）。</li>
<li>用于解决循环引用问题（两个对象通过 <code>shared_ptr</code> 相互引用，导致资源无法释放）。</li>
<li>在访问资源前需要检查是否有效。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// 创建弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = weak.<span class="built_in">lock</span>()) &#123; <span class="comment">// 检查资源是否有效</span></span><br><span class="line">        std::cout &lt;&lt; *locked &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 资源离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ol>
<li><strong>避免内存泄漏</strong>：智能指针会自动释放资源，无需手动调用 <code>delete</code>。</li>
<li><strong>安全性</strong>：通过封装原始指针，减少指针操作中的错误（如悬空指针、重复释放）。</li>
<li><strong>易于使用</strong>：支持语义清晰的接口和自动管理生命周期。</li>
</ol>
<hr>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ol>
<li>引入了额外的内存开销（如 <code>shared_ptr</code> 的引用计数）。</li>
<li>需要注意循环引用问题（可通过 <code>weak_ptr</code> 避免）。</li>
<li>不适用于所有场景，例如实时性能要求特别高的代码。</li>
</ol>
<hr>
<h3 id="智能指针-vs-原始指针"><a href="#智能指针-vs-原始指针" class="headerlink" title="智能指针 vs 原始指针"></a><strong>智能指针 vs 原始指针</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>智能指针</strong></th>
<th><strong>原始指针</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存管理</strong></td>
<td>自动释放</td>
<td>手动释放</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>更安全（防止悬空指针等问题）</td>
<td>容易出错</td>
</tr>
<tr>
<td><strong>使用复杂度</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>略有开销（如引用计数）</td>
<td>无开销</td>
</tr>
</tbody></table>
<p>智能指针在现代 C++ 中被广泛使用，是 C++11 引入的重要功能之一，极大地提高了代码的安全性和可维护性。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针们与shared_ptr手撕</title>
    <url>/2025/06/16/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BB%AC%E4%B8%8Eshared-ptr%E6%89%8B%E6%92%95/</url>
    <content><![CDATA[<p>看柠檬微趣c++客户端一面面经，发现shared_ptr手撕不了一点，顺便再复习一下智能指针吧。（真是面试造火箭）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;cstddef&gt;</span><br><span class="line">struct ControlBlock</span><br><span class="line">&#123;</span><br><span class="line">	size_t shared_count;//引用计数</span><br><span class="line">	ControlBlock():shared_count(1)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Shared_ptr</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	T* ptr;</span><br><span class="line">    ControlBlock* ctrl;</span><br><span class="line">  	void release()//一个私有的释放函数</span><br><span class="line">  	&#123;</span><br><span class="line">  		if(ctrl)</span><br><span class="line">  		&#123;</span><br><span class="line">  			--ctrl-&gt;shared_count;</span><br><span class="line">  			if(!ctrl-&gt;shared_count)</span><br><span class="line">  			&#123;</span><br><span class="line">  				delete ctrl;</span><br><span class="line">  				delete ptr;//如果引用计数为0，则自动销毁该引用计数块和对应的指针</span><br><span class="line">  			&#125;</span><br><span class="line">  			ctrl=nullptr;</span><br><span class="line">  			ptr=nullptr;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	</span><br><span class="line">public:</span><br><span class="line"> 	//默认构造函数</span><br><span class="line"> 	Shared_ptr():ptr(nullptr),ctrl(nullptr);</span><br><span class="line"> 	//有参数构造函数</span><br><span class="line"> 	Shared_ptr(T* p):ptr(p),ctrl(p?new ControlBlock:nullptr)</span><br><span class="line"> 	//拷贝构造函数(注意拷贝构造函数是const,且要增加引用计数)</span><br><span class="line"> 	Shared_ptr(const Shared_ptr&amp; other)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		ctrl=other.ctrl;</span><br><span class="line"> 		ptr=other.ptr;</span><br><span class="line"> 		if(ctrl)</span><br><span class="line"> 		++ctrl-&gt;shared_count;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	//移动构造函数（注意是右值引用，不增加引用计数，要将原指针置空）</span><br><span class="line"> 	Shared_ptr(Shared_ptr&amp;&amp; other) noexcept</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		ctrl=other.ctrl;</span><br><span class="line"> 		ptr=other.ptr;</span><br><span class="line"> 		other.ptr=nullptr;</span><br><span class="line"> 		other.ctrl=nullptr;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	//拷贝构造运算符</span><br><span class="line"> 	Shared_ptr&amp; operater=(const Shared_ptr&amp; other)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		if(this!=other)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			release();</span><br><span class="line"> 			ptr=other.ptr;</span><br><span class="line"> 			ctrl=other.ctrl;</span><br><span class="line"> 			if(ctrl)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				++ctrl-&gt;shared_count;</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		return *this;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	Shared_ptr&amp; operater=(Shared_ptr&amp;&amp; other) noexcept</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		if(this!=other)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			release();</span><br><span class="line"> 			ptr=other.ptr;</span><br><span class="line"> 			ctrl=other.ctrl;</span><br><span class="line"> 			other.ptr=nullptr;</span><br><span class="line"> 			other.ctrl=nullptr;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		return *this;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	~Shared_ptr()</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		release();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	//重载操作符，解引用和取地址</span><br><span class="line"> 	T* operater-&gt;() const &#123;return ptr;&#125;</span><br><span class="line"> 	T&amp; operater&amp;() const &#123;return *ptr;&#125;</span><br><span class="line"> 	</span><br><span class="line"> 	 // 获取原始指针</span><br><span class="line">    T* get() const &#123; return ptr; &#125;</span><br><span class="line"></span><br><span class="line">    // 获取引用计数</span><br><span class="line">    size_t use_count() const &#123; return ctrl ? ctrl-&gt;shared_count : 0; &#125;</span><br><span class="line"></span><br><span class="line">    // 检查是否为空</span><br><span class="line">    bool empty() const &#123; return ptr == nullptr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="C-智能指针：shared-ptr-weak-ptr-unique-ptr-scoped-ptr"><a href="#C-智能指针：shared-ptr-weak-ptr-unique-ptr-scoped-ptr" class="headerlink" title="C++ 智能指针：shared_ptr, weak_ptr, unique_ptr, scoped_ptr"></a>C++ 智能指针：<code>shared_ptr</code>, <code>weak_ptr</code>, <code>unique_ptr</code>, <code>scoped_ptr</code></h2><p>智能指针是 C++ 中用于自动管理动态分配内存的工具，避免手动 <code>new</code> 和 <code>delete</code> 带来的内存泄漏或悬空指针问题。以下是对 <code>shared_ptr</code>、<code>weak_ptr</code>、<code>unique_ptr</code> 和 <code>scoped_ptr</code> 的特点、区别和应用场景的对比。</p>
<h3 id="1-shared-ptr"><a href="#1-shared-ptr" class="headerlink" title="1. shared_ptr"></a>1. <code>shared_ptr</code></h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>共享所有权</strong>：多个 <code>shared_ptr</code> 可指向同一对象，通过引用计数 (<code>use_count</code>) 管理资源。</li>
<li><strong>自动释放</strong>：当最后一个 <code>shared_ptr</code> 销毁或重置时，释放资源。</li>
<li><strong>线程安全</strong>：引用计数操作是线程安全的，但对象访问需用户保证。</li>
<li><strong>支持自定义删除器</strong>：可指定释放资源的方式。</li>
<li><strong>标准库实现</strong>：C++11 引入，位于 <code>&lt;memory&gt;</code>。</li>
</ul>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>使用控制块存储引用计数和删除器。</li>
<li>拷贝增加引用计数，析构减少引用计数，计数为 0 时释放资源。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp1 = std::<span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> sp2 = sp1; <span class="comment">// 共享所有权</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sp2 use_count: &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125; <span class="comment">// sp2 销毁，计数减 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1</span></span><br><span class="line">&#125; <span class="comment">// sp1 销毁，资源释放，输出 &quot;Test destroyed&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>共享资源</strong>：多个对象需要共享同一资源（如共享配置对象）。</li>
<li><strong>动态资源管理</strong>：需要动态分配内存且多个指针可能引用。</li>
<li><strong>复杂生命周期</strong>：对象生命周期不明确，需自动管理。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>避免循环引用（可能导致内存泄漏）。</li>
<li>使用 <code>std::make_shared</code> 构造以优化性能（单次分配）。</li>
</ul>
<hr>
<h3 id="2-weak-ptr"><a href="#2-weak-ptr" class="headerlink" title="2. weak_ptr"></a>2. <code>weak_ptr</code></h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>非拥有引用</strong>：指向 <code>shared_ptr</code> 管理的对象，但不控制其生命周期。</li>
<li><strong>避免循环引用</strong>：不会增加 <code>shared_ptr</code> 的引用计数。</li>
<li><strong>需检查有效性</strong>：通过 <code>lock()</code> 获取 <code>shared_ptr</code> 检查对象是否存活。</li>
<li><strong>标准库实现</strong>：C++11 引入，位于 <code>&lt;memory&gt;</code>。</li>
</ul>
<h4 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>与 <code>shared_ptr</code> 共享控制块，跟踪对象但不影响引用计数。</li>
<li>提供 <code>expired()</code> 检查对象是否已释放，<code>lock()</code> 返回有效 <code>shared_ptr</code> 或空指针。</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; wp = sp; <span class="comment">// 弱引用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp expired: &quot;</span> &lt;&lt; wp.<span class="built_in">expired</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 0 (未过期)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> sp2 = wp.<span class="built_in">lock</span>(); <span class="comment">// 获取 shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (sp2) std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *sp2 &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 42</span></span><br><span class="line">    &#125;</span><br><span class="line">    sp.<span class="built_in">reset</span>(); <span class="comment">// 释放资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wp expired: &quot;</span> &lt;&lt; wp.<span class="built_in">expired</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1 (已过期)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>打破循环引用</strong>：如树结构中父子节点互相引用。</li>
<li><strong>缓存</strong>：临时访问共享资源但不控制其生命周期。</li>
<li><strong>事件监听</strong>：观察对象状态而不延长其生命周期。</li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>必须通过 <code>lock()</code> 访问对象，检查是否有效。</li>
<li>不能直接解引用，需转换为 <code>shared_ptr</code>。</li>
</ul>
<hr>
<h3 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3. unique_ptr"></a>3. <code>unique_ptr</code></h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>独占所有权</strong>：单一指针拥有资源，禁止拷贝，只能移动。</li>
<li><strong>轻量高效</strong>：无引用计数开销，性能优于 <code>shared_ptr</code>。</li>
<li><strong>自动释放</strong>：离开作用域时自动删除资源。</li>
<li><strong>支持自定义删除器</strong>：可指定资源释放方式。</li>
<li><strong>标准库实现</strong>：C++11 引入，位于 <code>&lt;memory&gt;</code>。</li>
</ul>
<h4 id="实现机制-2"><a href="#实现机制-2" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>使用 RAII 管理资源，析构时调用删除器。</li>
<li>移动构造&#x2F;赋值转移所有权，原始指针置空。</li>
</ul>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> up = std::<span class="built_in">make_unique</span>&lt;Test&gt;(); <span class="comment">// 独占所有权</span></span><br><span class="line">    <span class="comment">// auto up2 = up; // 错误：不可拷贝</span></span><br><span class="line">    <span class="keyword">auto</span> up2 = std::<span class="built_in">move</span>(up); <span class="comment">// 转移所有权</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;up empty: &quot;</span> &lt;&lt; (up == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1</span></span><br><span class="line">&#125; <span class="comment">// up2 销毁，输出 &quot;Test destroyed&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>独占资源</strong>：对象只需要一个所有者（如文件句柄、单例资源）。</li>
<li><strong>工厂模式</strong>：返回独占对象的所有权。</li>
<li><strong>性能敏感场景</strong>：需要高效内存管理。</li>
</ul>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>使用 <code>std::make_unique</code> (C++14) 构造以避免异常安全问题。</li>
<li>适合需要明确所有权的场景。</li>
</ul>
<hr>
<h3 id="4-scoped-ptr-Boost"><a href="#4-scoped-ptr-Boost" class="headerlink" title="4. scoped_ptr (Boost)"></a>4. <code>scoped_ptr</code> (Boost)</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>非标准库</strong>：来自 Boost 库（C++ 标准库无 <code>scope_ptr</code>，可能是指 <code>boost::scoped_ptr</code>）。</li>
<li><strong>严格作用域所有权</strong>：不可拷贝、不可移动，仅在定义作用域内有效。</li>
<li><strong>轻量</strong>：无引用计数，简单高效。</li>
<li><strong>自动释放</strong>：离开作用域时删除资源。</li>
<li><strong>不支持自定义删除器</strong>：固定使用 <code>delete</code>。</li>
</ul>
<h4 id="实现机制-3"><a href="#实现机制-3" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>类似 <code>unique_ptr</code> 但更严格，禁止任何所有权转移。</li>
<li>析构时直接删除资源。</li>
</ul>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Test destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">boost::scoped_ptr&lt;Test&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">    <span class="comment">// boost::scoped_ptr&lt;Test&gt; sp2 = sp; // 错误：不可拷贝</span></span><br><span class="line">    <span class="comment">// sp2 = std::move(sp); // 错误：不可移动</span></span><br><span class="line">&#125; <span class="comment">// sp 销毁，输出 &quot;Test destroyed&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><strong>严格局部资源</strong>：确保资源在单一作用域内使用（如函数内临时对象）。</li>
<li><strong>简单 RAII</strong>：无需转移所有权的场景。</li>
<li><strong>替换原始指针</strong>：提高局部变量的安全性。</li>
</ul>
<h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>不支持所有权转移，灵活性低于 <code>unique_ptr</code>。</li>
<li>Boost 库依赖，可能不适用于标准 C++ 项目。</li>
</ul>
<hr>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>shared_ptr</code></th>
<th><code>weak_ptr</code></th>
<th><code>unique_ptr</code></th>
<th><code>scoped_ptr</code> (Boost)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>所有权</strong></td>
<td>共享（引用计数）</td>
<td>无所有权（弱引用）</td>
<td>独占（单一所有者）</td>
<td>独占（不可转移）</td>
</tr>
<tr>
<td><strong>拷贝</strong></td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>移动</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>自定义删除器</strong></td>
<td>支持</td>
<td>无（依赖 <code>shared_ptr</code>）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>引用计数线程安全</td>
<td>引用计数线程安全</td>
<td>无需线程安全（独占）</td>
<td>无需线程安全（独占）</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>较高（引用计数+控制块）</td>
<td>中等（依赖 <code>shared_ptr</code>）</td>
<td>低（无引用计数）</td>
<td>最低（无引用计数、无转移）</td>
</tr>
<tr>
<td><strong>标准库</strong></td>
<td>C++11 (<code>&lt;memory&gt;</code>)</td>
<td>C++11 (<code>&lt;memory&gt;</code>)</td>
<td>C++11 (<code>&lt;memory&gt;</code>)</td>
<td>Boost 库</td>
</tr>
</tbody></table>
<h4 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h4><ul>
<li><code>shared_ptr</code> 的引用计数可表示为：<br>[<br>\text{use_count}(p) &#x3D; \sum_{i} \text{shared_ptr}_i \text{ pointing to } p<br>]<br>其中，资源在 (\text{use_count} &#x3D; 0) 时释放。</li>
<li><code>weak_ptr</code> 的有效性检查：<br>[<br>\text{lock}() &#x3D; \begin{cases}<br>\text{shared_ptr}(p), &amp; \text{if } \text{use_count} &gt; 0 \<br>\text{nullptr}, &amp; \text{otherwise}<br>\end{cases}<br>]</li>
<li><code>unique_ptr</code> 和 <code>scoped_ptr</code> 的所有权单一，生命周期严格绑定作用域。</li>
</ul>
<hr>
<h3 id="应用场景总结"><a href="#应用场景总结" class="headerlink" title="应用场景总结"></a>应用场景总结</h3><ul>
<li>**<code>shared_ptr</code>**：多所有者共享资源，如对象池、复杂数据结构。</li>
<li>**<code>weak_ptr</code>**：打破循环引用、缓存、事件监听。</li>
<li>**<code>unique_ptr</code>**：独占资源、工厂模式、传递所有权。</li>
<li>**<code>scoped_ptr</code>**：严格局部资源管理，简单 RAII。</li>
</ul>
<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>优先使用 <code>std::make_shared</code> 和 <code>std::make_unique</code> 构造智能指针以确保异常安全。</li>
<li>避免将原始指针直接传入智能指针构造函数（如 <code>shared_ptr&lt;T&gt;(new T)</code>），可能导致重复删除。</li>
<li><code>scoped_ptr</code> 非标准库，使用需依赖 Boost，若需类似功能，推荐 <code>unique_ptr</code>。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>智能指针</tag>
        <tag>shared_ptr</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树:Prim 算法和Kruskal 算法</title>
    <url>/2024/10/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim-%E7%AE%97%E6%B3%95%E5%92%8CKruskal-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在 C++ 中，实现最小生成树（MST）的常用算法有两种：<strong>Prim 算法</strong>和<strong>Kruskal 算法</strong>。这两种算法适用于加权无向图，用于寻找包含所有顶点的边的集合，使得边的总权重最小，且没有环路。</p>
<h3 id="1-Prim-算法"><a href="#1-Prim-算法" class="headerlink" title="1. Prim 算法"></a>1. Prim 算法</h3><p>Prim 算法通过贪心策略来构建 MST，从任意起始顶点开始，每次选择权重最小的边扩展 MST。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>初始化一个集合 <code>MST</code>，包含图中的任意一个顶点。</li>
<li>找到从集合 <code>MST</code> 到剩余顶点中权重最小的边，并将该边加入 <code>MST</code>。</li>
<li>重复步骤 2，直到所有顶点都包含在 <code>MST</code> 中。</li>
</ol>
<h4 id="C-实现示例（使用优先队列）"><a href="#C-实现示例（使用优先队列）" class="headerlink" title="C++ 实现示例（使用优先队列）"></a>C++ 实现示例（使用优先队列）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来表示边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Prim 算法计算最小生成树的总权重</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">primMST</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();  <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inMST</span><span class="params">(n, <span class="literal">false</span>)</span></span>;  <span class="comment">// 标记顶点是否在 MST 中</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;  <span class="comment">// 最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);  <span class="comment">// 起始顶点的权重为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [weight, u] = pq.<span class="built_in">top</span>();  <span class="comment">// 获取权重最小的边</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inMST[u]) <span class="keyword">continue</span>;  <span class="comment">// 如果已经在 MST 中，跳过</span></span><br><span class="line"></span><br><span class="line">        inMST[u] = <span class="literal">true</span>;  <span class="comment">// 标记顶点 u 在 MST 中</span></span><br><span class="line">        totalWeight += weight;  <span class="comment">// 累加边的权重</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 u 的所有邻接边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.to;</span><br><span class="line">            <span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!inMST[v]) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;w, v&#125;);  <span class="comment">// 将未加入 MST 的顶点及其权重放入优先队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个无向加权图</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;  <span class="comment">// 图中顶点数</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点 0 开始计算最小生成树的总权重</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="built_in">primMST</span>(graph, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><ul>
<li><code>graph</code> 是一个邻接表，每个顶点的邻接边存储在一个 <code>vector</code> 中。</li>
<li><code>priority_queue</code> 用于选择当前权重最小的边。</li>
<li><code>inMST</code> 数组用于标记哪些顶点已经在 MST 中。</li>
<li>算法的时间复杂度为 (O(E \log V))，其中 (E) 是边数，(V) 是顶点数。</li>
</ul>
<h3 id="2-Kruskal-算法"><a href="#2-Kruskal-算法" class="headerlink" title="2. Kruskal 算法"></a>2. Kruskal 算法</h3><p>Kruskal 算法通过贪心策略来构建 MST，每次选择权重最小的边，添加到 MST 中，前提是不会形成环。</p>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>将图中的所有边按权重从小到大排序。</li>
<li>初始化一个并查集，用于判断是否会形成环。</li>
<li>依次选择权重最小的边，如果该边连接的两个顶点属于不同的集合，则将其加入 MST。</li>
<li>重复步骤 3，直到 MST 包含 (V-1) 条边。</li>
</ol>
<h4 id="C-实现示例（使用并查集）"><a href="#C-实现示例（使用并查集）" class="headerlink" title="C++ 实现示例（使用并查集）"></a>C++ 实现示例（使用并查集）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来表示边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">from</span>(f), <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) : <span class="built_in">parent</span>(n), <span class="built_in">rank</span>(n, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u != parent[u]) &#123;</span><br><span class="line">            parent[u] = <span class="built_in">find</span>(parent[u]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootU = <span class="built_in">find</span>(u);</span><br><span class="line">        <span class="type">int</span> rootV = <span class="built_in">find</span>(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootU == rootV) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// u 和 v 在同一个集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 联合集合，按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootU] &gt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootU] &lt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootU] = rootV;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">            ++rank[rootU];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Kruskal 算法计算最小生成树的总权重</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> n, vector&lt;Edge&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将边按权重从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;  <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> edgesUsed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">unionSets</span>(edge.from, edge.to)) &#123;</span><br><span class="line">            totalWeight += edge.weight;</span><br><span class="line">            edgesUsed++;</span><br><span class="line">            <span class="keyword">if</span> (edgesUsed == n - <span class="number">1</span>) <span class="keyword">break</span>;  <span class="comment">// 当使用的边数达到 n-1 时，停止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;  <span class="comment">// 图中顶点数</span></span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最小生成树的总权重</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="built_in">kruskalMST</span>(n, edges);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h4><ul>
<li>使用 <code>Edge</code> 结构体来表示边，包括起点、终点和权重。</li>
<li>使用 <code>UnionFind</code> 类来实现并查集，用于检测是否形成环。</li>
<li>将所有边按权重排序，然后使用贪心算法构建 MST。</li>
<li>算法的时间复杂度为 (O(E \log E))，因为排序耗时 (O(E \log E))，而并查集的操作近似为 (O(\log V))。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Prim 算法</strong>适用于稠密图（边多），通常使用邻接表和优先队列实现。</li>
<li><strong>Kruskal 算法</strong>适用于稀疏图（边少），通过边排序和并查集来实现。</li>
</ul>
<p>这两种算法都能高效地找到图的最小生成树，但适用的场景略有不同。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>最小生成树</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/2025/06/30/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="C-中的构造函数"><a href="#C-中的构造函数" class="headerlink" title="C++中的构造函数"></a>C++中的构造函数</h1><p>在C++中，构造函数是类中用于初始化对象的特殊成员函数。它们与类同名，没有返回类型（连<code>void</code>也没有）。以下是C++中常见的构造函数类型：</p>
<h2 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1. 默认构造函数"></a>1. 默认构造函数</h2><ul>
<li><strong>定义</strong>：不带参数或所有参数有默认值的构造函数。</li>
<li><strong>作用</strong>：创建对象时无需提供初始值。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; x = <span class="number">0</span>; &#125; <span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">MyClass obj; <span class="comment">// 调用默认构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-参数化构造函数"><a href="#2-参数化构造函数" class="headerlink" title="2. 参数化构造函数"></a>2. 参数化构造函数</h2><ul>
<li><strong>定义</strong>：带参数的构造函数，用于初始化对象的成员。</li>
<li><strong>作用</strong>：允许通过参数传递初始值。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125; <span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用参数化构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-拷贝构造函数"><a href="#3-拷贝构造函数" class="headerlink" title="3. 拷贝构造函数"></a>3. 拷贝构造函数</h2><ul>
<li><strong>定义</strong>：以同类型对象的引用作为参数，用于从现有对象复制构造新对象。</li>
<li><strong>作用</strong>：实现对象深拷贝或自定义拷贝行为。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">x</span>(other.x) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-移动构造函数（C-11起）"><a href="#4-移动构造函数（C-11起）" class="headerlink" title="4. 移动构造函数（C++11起）"></a>4. 移动构造函数（C++11起）</h2><ul>
<li><strong>定义</strong>：以右值引用（<code>&amp;&amp;</code>）为参数，转移资源所有权。</li>
<li><strong>作用</strong>：优化性能，避免深拷贝，适合临时对象。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">x</span>(other.x) &#123; other.x = <span class="number">0</span>; &#125; <span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(std::move(obj1))</span></span>; <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-委托构造函数（C-11起）"><a href="#5-委托构造函数（C-11起）" class="headerlink" title="5. 委托构造函数（C++11起）"></a>5. 委托构造函数（C++11起）</h2><ul>
<li><strong>定义</strong>：一个构造函数调用另一个构造函数来完成部分初始化。</li>
<li><strong>作用</strong>：减少代码重复。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">MyClass obj; <span class="comment">// 调用默认构造函数，委托给参数化构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-转换构造函数"><a href="#6-转换构造函数" class="headerlink" title="6. 转换构造函数"></a>6. 转换构造函数</h2><ul>
<li><strong>定义</strong>：单个参数的构造函数（非<code>explicit</code>），可用于类型转换。</li>
<li><strong>作用</strong>：允许从指定类型隐式转换到类类型。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125; <span class="comment">// 转换构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">MyClass obj = <span class="number">10</span>; <span class="comment">// 隐式转换调用转换构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-显式构造函数（使用explicit）"><a href="#7-显式构造函数（使用explicit）" class="headerlink" title="7. 显式构造函数（使用explicit）"></a>7. 显式构造函数（使用<code>explicit</code>）</h2><ul>
<li><strong>定义</strong>：用<code>explicit</code>关键字修饰，禁止隐式转换。</li>
<li><strong>作用</strong>：防止意外的类型转换。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> val)</span> : x(val) &#123;</span>&#125; <span class="comment">// 显式构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">// MyClass obj = 10; // 错误：禁止隐式转换</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><strong>编译器生成的构造函数</strong>：<ul>
<li>如果未定义任何构造函数，编译器会生成默认构造函数。</li>
<li>如果定义了其他构造函数，默认构造函数不会自动生成。</li>
<li>拷贝构造函数和移动构造函数在特定条件下（如无用户定义）由编译器生成。</li>
</ul>
</li>
<li><strong>初始化列表</strong>：构造函数常使用初始化列表（如<code>: x(val)</code>）来高效初始化成员。</li>
<li><strong>禁用构造函数</strong>：可用<code>delete</code>关键字禁用特定构造函数（如<code>MyClass(const MyClass&amp;) = delete;</code>）。</li>
<li><strong>虚继承与构造函数</strong>：在虚继承中，虚基类的构造函数由最底层的派生类负责调用。</li>
</ul>
<h2 id="示例综合代码"><a href="#示例综合代码" class="headerlink" title="示例综合代码"></a>示例综合代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">x</span>(<span class="number">0</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;Default constructor\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Parameterized constructor\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">x</span>(other.x) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">x</span>(other.x) &#123;</span><br><span class="line">        other.x = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move constructor\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">double</span> val)</span> : x(static_cast&lt;int&gt;(val)) &#123;</span> std::cout &lt;&lt; <span class="string">&quot;Conversion constructor\n&quot;</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;           <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>;       <span class="comment">// 参数化构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj3</span><span class="params">(obj2)</span></span>;     <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj4</span><span class="params">(std::move(MyClass(<span class="number">20</span>)))</span></span>; <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj5</span><span class="params">(<span class="number">5.5</span>)</span></span>;      <span class="comment">// 转换构造函数</span></span><br><span class="line">    <span class="comment">// MyClass obj6 = 5.5;  // 错误：explicit禁止隐式转换</span></span><br><span class="line">    </span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">print</span>();</span><br><span class="line">    obj<span class="number">3.</span><span class="built_in">print</span>();</span><br><span class="line">    obj<span class="number">4.</span><span class="built_in">print</span>();</span><br><span class="line">    obj<span class="number">5.</span><span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Default constructor</span><br><span class="line">Parameterized constructor</span><br><span class="line">Copy constructor</span><br><span class="line">Parameterized constructor</span><br><span class="line">Move constructor</span><br><span class="line">Conversion constructor</span><br><span class="line">x = 0</span><br><span class="line">x = 10</span><br><span class="line">x = 10</span><br><span class="line">x = 20</span><br><span class="line">x = 5</span><br></pre></td></tr></table></figure>

<p>这些构造函数类型覆盖了C++中对象初始化的各种场景，根据需求选择合适的构造函数能提高代码效率和安全性。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2025/01/12/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="模板（Template）概述"><a href="#模板（Template）概述" class="headerlink" title="模板（Template）概述"></a><strong>模板（Template）概述</strong></h3><p>模板是 C++ 中的一种<strong>泛型编程机制</strong>，允许编写通用的代码，可以在不指定具体数据类型的情况下定义函数、类或结构体。模板的主要目的是提供代码的复用性和灵活性，从而支持处理多种数据类型的能力。</p>
<p>C++ 中的模板主要分为两种：</p>
<ol>
<li><strong>函数模板</strong>（Function Template）</li>
<li><strong>类模板</strong>（Class Template）</li>
</ol>
<hr>
<h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a><strong>1. 函数模板</strong></h2><p>函数模板是定义一个可以操作多种数据类型的函数。通过模板，函数可以在调用时根据传递的参数类型自动生成具体的函数。</p>
<h3 id="1-1-函数模板的基本语法"><a href="#1-1-函数模板的基本语法" class="headerlink" title="1.1 函数模板的基本语法"></a><strong>1.1 函数模板的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;    <span class="comment">// 显式指定类型为 int</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">4.2</span>) &lt;&lt; endl;    <span class="comment">// 隐式推导类型为 double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">7.7</span><br></pre></td></tr></table></figure>

<h3 id="1-2-关键点"><a href="#1-2-关键点" class="headerlink" title="1.2 关键点"></a><strong>1.2 关键点</strong></h3><ul>
<li><code>template &lt;typename T&gt;</code>：定义模板，其中 <code>T</code> 是占位符，表示数据类型。<ul>
<li>也可以使用 <code>class</code> 代替 <code>typename</code>（两者在模板声明中等价）。</li>
</ul>
</li>
<li>模板函数的具体类型可以<strong>显式指定</strong>（如 <code>add&lt;int&gt;(3, 4)</code>），也可以通过参数<strong>隐式推导</strong>（如 <code>add(3.5, 4.2)</code>）。</li>
</ul>
<hr>
<h3 id="1-3-函数模板的特例化"><a href="#1-3-函数模板的特例化" class="headerlink" title="1.3 函数模板的特例化"></a><strong>1.3 函数模板的特例化</strong></h3><p>有时我们希望对某些特定类型提供专门的实现，可以通过模板特例化实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例化版本（针对 const char* 类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="built_in">max</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>) ? a : b; <span class="comment">// 字符串比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;             <span class="comment">// 输出 7</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>) &lt;&lt; endl; <span class="comment">// 输出 banana</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>特例化版本定义了针对 <code>const char*</code> 类型的专门实现。</li>
<li>当模板匹配到 <code>const char*</code> 类型时，会优先使用特例化版本。</li>
</ul>
<hr>
<h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2. 类模板"></a><strong>2. 类模板</strong></h2><p>类模板是为实现通用的类而设计的，允许类操作不同类型的数据而不需要重复编写代码。</p>
<h3 id="2-1-类模板的基本语法"><a href="#2-1-类模板的基本语法" class="headerlink" title="2.1 类模板的基本语法"></a><strong>2.1 类模板的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;      <span class="comment">// int 类型</span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Value: 10</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Value: 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>template &lt;typename T&gt;</code> 定义了一个类模板。</li>
<li>模板类实例化时，需要为模板参数 <code>T</code> 提供具体类型，如 <code>MyClass&lt;int&gt;</code>。</li>
</ul>
<hr>
<h3 id="2-2-类模板的特例化"><a href="#2-2-类模板的特例化" class="headerlink" title="2.2 类模板的特例化"></a><strong>2.2 类模板的特例化</strong></h3><p>和函数模板一样，类模板也可以为某些特定类型提供特例化实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Generic template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例化版本（针对 int 类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Specialized template for int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj1; <span class="comment">// 使用通用模板</span></span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj2;    <span class="comment">// 使用特例化模板</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Generic template</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Specialized template for int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>通用模板适用于所有类型，但当实例化类型为 <code>int</code> 时，会使用特例化版本。</li>
</ul>
<hr>
<h3 id="2-3-类模板的部分特例化"><a href="#2-3-类模板的部分特例化" class="headerlink" title="2.3 类模板的部分特例化"></a><strong>2.3 类模板的部分特例化</strong></h3><p>类模板还支持<strong>部分特例化</strong>，即只对部分模板参数进行特例化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Generic template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化（当第二个类型参数是 int 时）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Partial specialization for second type int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">double</span>&gt; obj1; <span class="comment">// 通用模板</span></span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">int</span>&gt; obj2;   <span class="comment">// 部分特例化模板</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Generic template</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Partial specialization for second type int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>部分特例化可以只针对某些类型参数组合，提供更灵活的设计。</li>
</ul>
<hr>
<h2 id="3-模板的其他用法"><a href="#3-模板的其他用法" class="headerlink" title="3. 模板的其他用法"></a><strong>3. 模板的其他用法</strong></h2><h3 id="3-1-模板默认参数"><a href="#3-1-模板默认参数" class="headerlink" title="3.1 模板默认参数"></a><strong>3.1 模板默认参数</strong></h3><p>模板参数可以提供默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">display</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;&gt; obj;       <span class="comment">// 使用默认类型 int</span></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2; <span class="comment">// 显式指定类型为 double</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">display</span>();  <span class="comment">// 输出 Type: int</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Type: double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-模板模板参数"><a href="#3-2-模板模板参数" class="headerlink" title="3.2 模板模板参数"></a><strong>3.2 模板模板参数</strong></h3><p>模板参数本身可以是模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : c) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;vector&gt; obj; <span class="comment">// 使用 vector 作为模板模板参数</span></span><br><span class="line">    obj.<span class="built_in">display</span>();       <span class="comment">// 输出 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>template &lt;template &lt;typename, typename&gt; class Container&gt;</code> 定义了模板模板参数。</li>
<li>实例化时，<code>vector</code> 作为模板模板参数被传递。</li>
</ul>
<hr>
<h2 id="4-编译期计算与模板"><a href="#4-编译期计算与模板" class="headerlink" title="4. 编译期计算与模板"></a><strong>4. 编译期计算与模板</strong></h2><p>模板可以用于<strong>编译期计算</strong>，例如实现递归的斐波那契数列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; endl; <span class="comment">// 输出 55</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>模板通过递归定义实现了编译期的斐波那契数列计算。</li>
<li><code>Fibonacci&lt;10&gt;</code> 会在编译时计算出结果。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>模板是 C++ 强大的泛型编程工具，其主要特点包括：</p>
<ol>
<li><strong>函数模板</strong> 和 <strong>类模板</strong>。</li>
<li>支持特例化（全特例化和部分特例化）。</li>
<li>提供了编译期计算能力。</li>
<li>与 STL 紧密结合，广泛用于算法和容器中。</li>
</ol>
<p>模板大大提高了代码的复用性和通用性，但模板的编译错误通常比较复杂，因此需要小心使用。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板元编程</title>
    <url>/2025/06/29/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-模板元编程"><a href="#C-模板元编程" class="headerlink" title="C++ 模板元编程"></a>C++ 模板元编程</h1><p>模板元编程（Template Metaprogramming, TMP）是 C++ 中利用模板在<strong>编译期</strong>进行计算和逻辑处理的编程范式。它将模板作为一种“编译期函数式语言”，在编译时生成代码或执行计算，广泛用于提高代码的通用性、性能和类型安全性。以下是模板元编程的核心概念、用法和示例。</p>
<h2 id="1-什么是模板元编程？"><a href="#1-什么是模板元编程？" class="headerlink" title="1. 什么是模板元编程？"></a>1. <strong>什么是模板元编程？</strong></h2><ul>
<li><strong>定义</strong>：模板元编程利用 C++ 模板在编译期执行计算，通过模板特化和递归生成代码，生成高效的运行时代码。</li>
<li><strong>特点</strong>：<ul>
<li><strong>编译期执行</strong>：所有计算在编译时完成，运行时无额外开销。</li>
<li><strong>类型安全</strong>：通过模板参数推导和特化实现类型检查。</li>
<li><strong>函数式风格</strong>：使用递归、条件判断等函数式编程思想。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>实现通用库（如 <code>std::tuple</code>、<code>std::variant</code>）。</li>
<li>编译期计算（如计算阶乘、斐波那契数）。</li>
<li>类型操作（如类型选择、类型转换）。</li>
<li>优化运行时性能（如展开循环、生成内联代码）。</li>
</ul>
</li>
</ul>
<h2 id="2-模板元编程的核心机制"><a href="#2-模板元编程的核心机制" class="headerlink" title="2. 模板元编程的核心机制"></a>2. <strong>模板元编程的核心机制</strong></h2><h3 id="2-1-模板与特化"><a href="#2-1-模板与特化" class="headerlink" title="2.1 模板与特化"></a><strong>2.1 模板与特化</strong></h3><ul>
<li><strong>模板</strong>：允许定义泛型类或函数，接受类型或非类型参数。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>模板特化</strong>：为特定类型或值提供专用实现。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">IsVoid</span> &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">IsVoid</span>&lt;<span class="type">void</span>&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-编译期计算"><a href="#2-2-编译期计算" class="headerlink" title="2.2 编译期计算"></a><strong>2.2 编译期计算</strong></h3><ul>
<li>使用<strong>递归模板</strong>和<strong>特化终止</strong>实现编译期计算。</li>
<li>示例：计算阶乘。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">static_assert</span>(Factorial&lt;<span class="number">5</span>&gt;::value == <span class="number">120</span>); <span class="comment">// 5! = 120</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-SFINAE（Substitution-Failure-Is-Not-An-Error）"><a href="#2-3-SFINAE（Substitution-Failure-Is-Not-An-Error）" class="headerlink" title="2.3 SFINAE（Substitution Failure Is Not An Error）"></a><strong>2.3 SFINAE（Substitution Failure Is Not An Error）</strong></h3><ul>
<li>SFINAE 是一种模板匹配机制，当模板参数替换失败时，编译器不会报错，而是尝试其他匹配。</li>
<li>常用于条件式函数选择。</li>
<li>示例：检测类型是否可调用 <code>size()</code>。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> HasSize : std::false_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasSize</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">size</span>())&gt;&gt; : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-constexpr-和编译期常量"><a href="#2-4-constexpr-和编译期常量" class="headerlink" title="2.4 constexpr 和编译期常量"></a><strong>2.4 <code>constexpr</code> 和编译期常量</strong></h3><ul>
<li>C++11 引入 <code>constexpr</code>，允许函数在编译期执行，简化模板元编程。</li>
<li>示例：编译期阶乘（替代模板递归）。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">factorial</span>(<span class="number">5</span>) == <span class="number">120</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-类型操作"><a href="#2-5-类型操作" class="headerlink" title="2.5 类型操作"></a><strong>2.5 类型操作</strong></h3><ul>
<li>使用模板操作类型，如类型选择、类型转换。</li>
<li>示例：<code>std::conditional</code> 选择类型。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> IntOrFloat = std::<span class="type">conditional_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="type">int</span>, <span class="type">float</span>&gt;;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;IntOrFloat&lt;<span class="type">char</span>&gt;, <span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;IntOrFloat&lt;<span class="type">double</span>&gt;, <span class="type">float</span>&gt;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-模板元编程的优点与缺点"><a href="#3-模板元编程的优点与缺点" class="headerlink" title="3. 模板元编程的优点与缺点"></a>3. <strong>模板元编程的优点与缺点</strong></h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li><strong>性能优化</strong>：编译期计算避免运行时开销，生成高效代码。</li>
<li><strong>类型安全</strong>：编译期检查类型错误，减少运行时错误。</li>
<li><strong>代码复用</strong>：通过泛型编程支持多种类型，减少冗余代码。</li>
<li><strong>灵活性</strong>：实现复杂逻辑，如类型推导、条件选择。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ul>
<li><strong>代码复杂性</strong>：模板元编程代码通常难以阅读和调试。</li>
<li><strong>编译时间</strong>：大量模板展开可能显著增加编译时间。</li>
<li><strong>错误信息</strong>：模板错误信息冗长，难以理解。</li>
<li><strong>调试困难</strong>：编译期逻辑无法在运行时调试。</li>
</ul>
<h2 id="4-实际应用示例"><a href="#4-实际应用示例" class="headerlink" title="4. 实际应用示例"></a>4. <strong>实际应用示例</strong></h2><h3 id="4-1-编译期斐波那契数"><a href="#4-1-编译期斐波那契数" class="headerlink" title="4.1 编译期斐波那契数"></a><strong>4.1 编译期斐波那契数</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">0</span>; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(Fibonacci&lt;<span class="number">6</span>&gt;::value == <span class="number">8</span>); <span class="comment">// 0, 1, 1, 2, 3, 5, 8</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-类型安全的异构容器"><a href="#4-2-类型安全的异构容器" class="headerlink" title="4.2 类型安全的异构容器"></a><strong>4.2 类型安全的异构容器</strong></h3><p>使用模板元编程实现简单的 <code>std::tuple</code> 类似结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple</span>&lt;T, Rest...&gt; &#123;</span><br><span class="line">    T first;</span><br><span class="line">    Tuple&lt;Rest...&gt; rest;</span><br><span class="line">    <span class="built_in">Tuple</span>(T f, Rest... r) : <span class="built_in">first</span>(f), <span class="built_in">rest</span>(r...) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第 N 个元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleElement</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleElement</span>&lt;<span class="number">0</span>, Tuple&lt;T, Rest...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Rest&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TupleElement</span>&lt;N, Tuple&lt;T, Rest...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> TupleElement&lt;N - <span class="number">1</span>, Tuple&lt;Rest...&gt;&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function">Tuple&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">char</span>&gt; <span class="title">t</span><span class="params">(<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="keyword">typename</span> TupleElement&lt;<span class="number">1</span>, <span class="keyword">decltype</span>(t)&gt;::type, <span class="type">double</span>&gt;);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-编译期循环展开"><a href="#4-3-编译期循环展开" class="headerlink" title="4.3 编译期循环展开"></a><strong>4.3 编译期循环展开</strong></h3><p>模板元编程可用于展开循环，优化性能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N, <span class="type">int</span> I = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> SumArray &#123;</span><br><span class="line">    <span class="type">static</span> T <span class="built_in">compute</span>(T* arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[I] + SumArray&lt;T, N, I + <span class="number">1</span>&gt;::<span class="built_in">compute</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SumArray</span>&lt;T, N, N&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">compute</span><span class="params">(T*)</span> </span>&#123; <span class="keyword">return</span> T&#123;&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = SumArray&lt;<span class="type">int</span>, <span class="number">5</span>&gt;::<span class="built_in">compute</span>(arr); <span class="comment">// 编译期展开为 1 + 2 + 3 + 4 + 5</span></span><br><span class="line">    std::cout &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-C-11-及以后的改进"><a href="#5-C-11-及以后的改进" class="headerlink" title="5. C++11 及以后的改进"></a>5. <strong>C++11 及以后的改进</strong></h2><ul>
<li><p><strong>C++11</strong>：</p>
<ul>
<li><p><code>constexpr</code>：简化编译期计算。</p>
</li>
<li><p><code>std::enable_if</code> 和 SFINAE：更方便的条件选择。</p>
</li>
<li><p>变长模板参数（<code>typename...</code>）：支持异构容器（如 <code>std::tuple</code>）。</p>
</li>
<li><h2 id="constexpr-简化模板元编程"><a href="#constexpr-简化模板元编程" class="headerlink" title="constexpr 简化模板元编程"></a><strong><code>constexpr</code> 简化模板元编程</strong></h2><p>模板元编程传统上依赖模板递归和特化来实现编译期计算，但代码复杂、可读性差，且编译错误信息难以理解。<code>constexpr</code> 提供了一种更直观的方式，通过允许函数和变量在编译期执行，减少对模板的依赖。</p>
<h3 id="1-1-传统模板元编程的复杂性"><a href="#1-1-传统模板元编程的复杂性" class="headerlink" title="1.1 传统模板元编程的复杂性"></a><strong>1.1 传统模板元编程的复杂性</strong></h3><p>传统 TMP 使用模板递归和特化实现编译期计算，例如计算阶乘：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(Factorial&lt;<span class="number">5</span>&gt;::value == <span class="number">120</span>); <span class="comment">// 5! = 120</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>缺点</p>
<p>：</p>
<ul>
<li>代码结构复杂，需定义多个模板类。</li>
<li>递归展开增加编译时间。</li>
<li>错误信息冗长，调试困难。</li>
</ul>
</li>
</ul>
<h3 id="1-2-使用-constexpr-简化"><a href="#1-2-使用-constexpr-简化" class="headerlink" title="1.2 使用 constexpr 简化"></a><strong>1.2 使用 <code>constexpr</code> 简化</strong></h3><p><code>constexpr</code> 函数允许在编译期执行普通函数风格的逻辑，替代模板递归。重写阶乘示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">factorial</span>(<span class="number">5</span>) == <span class="number">120</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>简化点</p>
<p>：</p>
<ul>
<li><strong>直观语法</strong>：使用普通函数语法，逻辑清晰，类似运行时代码。</li>
<li><strong>减少模板</strong>：无需定义多个模板类或特化。</li>
<li><strong>可读性</strong>：代码更易理解，调试更简单。</li>
<li><strong>编译期与运行时兼容</strong>：<code>constexpr</code> 函数既可在编译期求值，也可在运行时执行。</li>
</ul>
</li>
</ul>
<h3 id="1-3-constexpr-的其他优势"><a href="#1-3-constexpr-的其他优势" class="headerlink" title="1.3 constexpr 的其他优势"></a><strong>1.3 <code>constexpr</code> 的其他优势</strong></h3><ul>
<li><p>支持复杂逻辑：C++14 放宽constexpr限制，允许循环、条件语句等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">fib</span>(<span class="number">6</span>) == <span class="number">8</span>); <span class="comment">// 0, 1, 1, 2, 3, 5, 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与模板结合：constexpr可与模板结合，进一步增强灵活性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">square</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">square</span>(<span class="number">5</span>) == <span class="number">25</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++17 的 <code>if constexpr</code>：在编译期进行条件分支，替代部分 SFINAE 和特化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_value</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">get_value</span>(<span class="number">5</span>) == <span class="number">6</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">get_value</span>(<span class="number">3.14</span>) == <span class="number">3.64</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-4-对比总结"><a href="#1-4-对比总结" class="headerlink" title="1.4 对比总结"></a><strong>1.4 对比总结</strong></h3><ul>
<li><strong>传统 TMP</strong>：依赖模板递归和特化，适合复杂类型操作，但代码冗长。</li>
<li>**<code>constexpr</code>**：用函数式逻辑替代模板递归，适合数值计算和简单逻辑，代码更简洁。</li>
<li><strong>结合使用</strong>：复杂类型操作仍需模板，数值计算可交给 <code>constexpr</code>。</li>
</ul>
<h2 id="2-模板特化的实现"><a href="#2-模板特化的实现" class="headerlink" title="2. 模板特化的实现"></a>2. <strong>模板特化的实现</strong></h2><p>模板特化是 TMP 的核心，用于为特定类型或值提供定制实现，分为<strong>全特化</strong>和<strong>偏特化</strong>。</p>
<h3 id="2-1-全特化"><a href="#2-1-全特化" class="headerlink" title="2.1 全特化"></a><strong>2.1 全特化</strong></h3><ul>
<li><p><strong>定义</strong>：为模板的特定参数提供完整实现，替换所有模板参数。</p>
</li>
<li><p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Trait</span> &#123; <span class="comment">/* 通用实现 */</span> &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">Trait</span>&lt;SpecificType&gt; &#123; <span class="comment">/* 特化实现 */</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：判断类型是否为 void。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsVoid</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsVoid</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(IsVoid&lt;<span class="type">void</span>&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(!IsVoid&lt;<span class="type">int</span>&gt;::value);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-偏特化"><a href="#2-2-偏特化" class="headerlink" title="2.2 偏特化"></a><strong>2.2 偏特化</strong></h3><ul>
<li><p><strong>定义</strong>：为模板的部分参数提供实现，保留一些参数为通用类型。</p>
</li>
<li><p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">Trait</span> &#123; <span class="comment">/* 通用实现 */</span> &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Trait</span>&lt;T, SpecificType&gt; &#123; <span class="comment">/* 偏特化实现 */</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：检测指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointer</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IsPointer</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(IsPointer&lt;<span class="type">int</span>*&gt;::value);</span><br><span class="line"><span class="built_in">static_assert</span>(!IsPointer&lt;<span class="type">int</span>&gt;::value);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-非类型参数特化"><a href="#2-3-非类型参数特化" class="headerlink" title="2.3 非类型参数特化"></a><strong>2.3 非类型参数特化</strong></h3><ul>
<li><p>非类型模板参数（如整数）也可特化。</p>
</li>
<li><p>示例：固定数组大小的处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArraySize</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = N;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ArraySize</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = <span class="number">-1</span>; <span class="comment">// 特殊处理</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">static_assert</span>(ArraySize&lt;<span class="number">10</span>&gt;::value == <span class="number">10</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(ArraySize&lt;<span class="number">0</span>&gt;::value == <span class="number">-1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>C++17</strong>：</p>
<ul>
<li><p><code>if constexpr</code>：编译期条件分支，简化模板逻辑。</p>
<h2 id="1-什么是-if-constexpr？"><a href="#1-什么是-if-constexpr？" class="headerlink" title="1. 什么是 if constexpr？"></a>1. <strong>什么是 <code>if constexpr</code>？</strong></h2><ul>
<li><strong>定义</strong>：<code>if constexpr</code> 是一个编译期条件语句，只有满足条件的代码分支会在编译时被保留，其他分支被丢弃。</li>
<li>特点：<ul>
<li><strong>编译期求值</strong>：条件必须是编译期常量表达式（<code>constexpr</code>）。</li>
<li><strong>分支丢弃</strong>：不满足条件的代码不会被编译，减少代码膨胀。</li>
<li><strong>类型安全</strong>：允许在不同分支中使用不同类型的操作，而无需担心编译错误。</li>
</ul>
</li>
</ul>
<h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. <strong>语法</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(condition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 满足条件的代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不满足条件的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>condition</code> 必须是能在编译期求值的表达式（例如 <code>std::is_integral_v&lt;T&gt;</code>）。</li>
<li>不满足条件的代码不会出现在最终的二进制文件中。</li>
</ul>
<h2 id="3-与普通-if-的区别"><a href="#3-与普通-if-的区别" class="headerlink" title="3. 与普通 if 的区别"></a>3. <strong>与普通 <code>if</code> 的区别</strong></h2><ul>
<li>**普通 <code>if</code>**：运行时条件分支，两个分支的代码都会被编译。</li>
<li>**<code>if constexpr</code>**：编译期条件分支，只有满足条件的代码被编译，另一个分支被丢弃。</li>
<li>优势：<ul>
<li>提高性能：减少不必要的代码生成。</li>
<li>简化模板逻辑：避免复杂的 SFINAE 或模板特化。</li>
<li>允许非类型安全的代码：未选择的代码无需满足语法正确性。</li>
</ul>
</li>
</ul>
<h2 id="4-使用场景与示例"><a href="#4-使用场景与示例" class="headerlink" title="4. 使用场景与示例"></a>4. <strong>使用场景与示例</strong></h2><h3 id="4-1-简化类型选择"><a href="#4-1-简化类型选择" class="headerlink" title="4.1 简化类型选择"></a><strong>4.1 简化类型选择</strong></h3><p><code>if constexpr</code> 可替代部分模板特化或 SFINAE，实现类型相关的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_value</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>; <span class="comment">// 整数加 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">0.5</span>; <span class="comment">// 浮点数加 0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">get_value</span>(<span class="number">5</span>) == <span class="number">6</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">get_value</span>(<span class="number">3.14</span>) == <span class="number">3.64</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>说明</strong>：根据 <code>T</code> 是否为整数类型选择不同操作，编译器只生成所需的分支。</li>
</ul>
<h3 id="4-2-处理无效代码"><a href="#4-2-处理无效代码" class="headerlink" title="4.2 处理无效代码"></a><strong>4.2 处理无效代码</strong></h3><p><code>if constexpr</code> 允许在分支中使用不合法的代码（只要该分支不被选择）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">to_string</span>(t); <span class="comment">// 仅对 int 有效</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Not an int&quot;</span>; <span class="comment">// 其他类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">to_string</span>(<span class="number">42</span>) == <span class="string">&quot;42&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">to_string</span>(<span class="number">3.14</span>) == <span class="string">&quot;Not an int&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>说明</strong>：<code>std::to_string</code> 只对特定类型有效，<code>if constexpr</code> 确保非 <code>int</code> 类型不会尝试编译无效代码。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>C++20</strong>：</p>
<ul>
<li>概念（Concepts）：约束模板参数，提高代码可读性和错误信息。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::integral T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="6-与内存管理的关联"><a href="#6-与内存管理的关联" class="headerlink" title="6. 与内存管理的关联"></a>6. <strong>与内存管理的关联</strong></h2><p>结合之前的内存管理讨论（<code>malloc</code>&#x2F;<code>new</code>），模板元编程可用于优化内存分配：</p>
<ul>
<li><strong>自定义分配器</strong>：通过模板实现类型安全的内存分配器（如 <code>std::allocator</code>）。</li>
<li><strong>智能指针模板</strong>：<code>std::shared_ptr</code> 和 <code>std::unique_ptr</code> 使用模板支持任意类型。</li>
<li>示例：自定义分配器。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomAllocator</span> &#123;</span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(T))); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(T* p)</span> </span>&#123; <span class="built_in">free</span>(p); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h2><ul>
<li><strong>模板元编程</strong>：利用 C++ 模板在编译期执行计算和类型操作，实现高效、类型安全的代码。</li>
<li><strong>核心机制</strong>：模板特化、递归、SFINAE、<code>constexpr</code>、类型操作。</li>
<li><strong>应用</strong>：编译期计算、类型选择、性能优化、通用库设计。</li>
<li><strong>注意事项</strong>：平衡代码复杂性与性能，注意编译时间和错误信息。</li>
<li>**现代 C++**：C++11 及以后的 <code>constexpr</code>、变长模板、<code>if constexpr</code> 和概念极大简化 TMP。</li>
</ul>
<p>如需更深入探讨（如复杂模板库实现、概念的使用或特定优化技巧），请提供进一步要求！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>c++，多态</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2025/06/20/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="死锁：定义、必要条件及避免方法"><a href="#死锁：定义、必要条件及避免方法" class="headerlink" title="死锁：定义、必要条件及避免方法"></a>死锁：定义、必要条件及避免方法</h1><p>蚂蚁一面没过QAQ,不知道是存储岗对学历要求比较高还是怎么样，唉，反正确实项目这一块回答的确实不好，等下周的腾讯和快手吧</p>
<hr>
<h2 id="1-死锁的定义"><a href="#1-死锁的定义" class="headerlink" title="1. 死锁的定义"></a>1. <strong>死锁的定义</strong></h2><p><strong>死锁（Deadlock）</strong>是指多个进程或线程因互相等待对方持有的资源而无法继续执行，导致所有相关进程&#x2F;线程永久阻塞的状态。</p>
<ul>
<li><strong>类比</strong>：类似多个线程在访问跳表或B+树时，各自持有部分节点锁并等待对方释放，形成循环等待。</li>
</ul>
<hr>
<h2 id="2-死锁产生的四个必要条件"><a href="#2-死锁产生的四个必要条件" class="headerlink" title="2. 死锁产生的四个必要条件"></a>2. <strong>死锁产生的四个必要条件</strong></h2><p>死锁发生需要以下四个条件同时满足（缺一不可）：</p>
<ol>
<li><p><strong>互斥条件（Mutual Exclusion）</strong>：</p>
<ul>
<li>资源（如锁、文件）一次只能被一个进程&#x2F;线程独占。</li>
<li><strong>示例</strong>：互斥锁（Mutex，上下文回答）保护跳表节点，同一时间仅一个线程可操作。</li>
<li><strong>类比</strong>：B+树节点加锁，禁止并发修改。</li>
</ul>
</li>
<li><p><strong>持有并等待条件（Hold and Wait）</strong>：</p>
<ul>
<li>进程&#x2F;线程持有至少一个资源，同时等待其他进程&#x2F;线程持有的资源。</li>
<li><strong>示例</strong>：线程A持有跳表节点1的锁，等待节点2的锁；线程B持有节点2的锁，等待节点1的锁。</li>
<li><strong>类比</strong>：进程持有数据库连接，等待另一个进程的连接池资源。</li>
</ul>
</li>
<li><p><strong>不可抢占条件（No Preemption）</strong>：</p>
<ul>
<li>资源不能被强制抢占，只能由持有者主动释放。</li>
<li><strong>示例</strong>：Mutex锁只能由持有线程释放，操作系统无法强制解锁。</li>
<li><strong>类比</strong>：B+树节点锁在分裂完成前无法被其他线程抢占。</li>
</ul>
</li>
<li><p><strong>循环等待条件（Circular Wait）</strong>：</p>
<ul>
<li>进程&#x2F;线程形成闭合的资源等待链，每个进程&#x2F;线程等待下一个持有的资源。</li>
<li><strong>示例</strong>：线程A等待线程B的资源，线程B等待线程C的资源，线程C等待线程A的资源。</li>
<li><strong>类比</strong>：跳表多线程插入时，节点锁形成循环依赖。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-如何避免死锁"><a href="#3-如何避免死锁" class="headerlink" title="3. 如何避免死锁"></a>3. <strong>如何避免死锁</strong></h2><p>避免死锁的核心是破坏上述四个必要条件之一。以下是具体方法：</p>
<h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a><strong>破坏互斥条件</strong></h3><ul>
<li><strong>方法</strong>：尽量使用共享资源代替独占资源。</li>
<li><strong>适用场景</strong>：读多写少场景使用读写锁（RWLock，上下文回答），允许多线程并发读。</li>
<li><strong>局限性</strong>：许多资源（如文件、数据库记录）本质上需要互斥，难以完全破坏。</li>
<li><strong>类比</strong>：B+树查询使用读锁，减少独占需求。</li>
</ul>
<h3 id="破坏持有并等待条件"><a href="#破坏持有并等待条件" class="headerlink" title="破坏持有并等待条件"></a><strong>破坏持有并等待条件</strong></h3><ul>
<li><strong>方法</strong>：<ul>
<li><strong>一次性获取所有资源</strong>：线程在开始前申请所有所需资源，失败则不持有任何资源。</li>
<li><strong>释放已持有资源</strong>：申请新资源失败时，释放已持有的资源后重试。</li>
</ul>
</li>
<li><strong>实现</strong>：在代码中检查资源可用性，或使用事务机制。</li>
<li><strong>示例</strong>：线程更新跳表前，检查所有节点锁是否可用，否则回滚。</li>
<li><strong>类比</strong>：数据库事务确保所有资源可用后再执行。</li>
</ul>
<h3 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a><strong>破坏不可抢占条件</strong></h3><ul>
<li><strong>方法</strong>：允许操作系统或程序强制抢占资源。</li>
<li><strong>实现</strong>：<ul>
<li>设置超时机制，超时后释放资源。</li>
<li>使用可中断锁（如Java的<code>Lock.tryLock()</code>）。</li>
</ul>
</li>
<li><strong>示例</strong>：线程尝试获取Mutex失败后，超时释放已有锁。</li>
<li><strong>类比</strong>：B+树分裂时，超时释放节点锁，允许其他线程介入。</li>
<li><strong>局限性</strong>：抢占可能导致数据不一致，需额外恢复机制。</li>
</ul>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a><strong>破坏循环等待条件</strong></h3><ul>
<li><strong>方法</strong>：对资源编号，强制按序获取资源（如按资源ID从小到大）。</li>
<li><strong>实现</strong>：<ul>
<li>定义全局资源顺序，所有线程按相同顺序申请锁。</li>
<li><strong>伪代码</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按资源ID顺序获取锁</span></span><br><span class="line"><span class="built_in">lock</span>(resource[min_id]);</span><br><span class="line"><span class="built_in">lock</span>(resource[max_id]);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>示例</strong>：跳表节点按内存地址或索引排序，线程按序加锁。</li>
<li><strong>类比</strong>：B+树节点按键值顺序加锁，防止循环。</li>
<li><strong>优势</strong>：简单有效，广泛用于数据库和并发系统。</li>
</ul>
<h3 id="其他通用方法"><a href="#其他通用方法" class="headerlink" title="其他通用方法"></a><strong>其他通用方法</strong></h3><ul>
<li><strong>死锁检测与恢复</strong>：<ul>
<li>使用资源分配图检测循环等待。</li>
<li>恢复方式：终止部分进程&#x2F;线程，或回滚操作。</li>
<li><strong>类比</strong>：跳表并发插入时，检测锁依赖图，终止冲突线程。</li>
</ul>
</li>
<li><strong>使用高级同步机制</strong>：<ul>
<li>条件变量（上下文回答）协调线程，避免忙等待。</li>
<li>信号量（上下文回答）限制资源访问，减少竞争。</li>
</ul>
</li>
<li><strong>无锁编程</strong>：<ul>
<li>使用原子操作（如CAS，上下文回答中的跳表实现）替代锁。</li>
<li><strong>类比</strong>：跳表无锁插入，减少死锁可能性。</li>
</ul>
</li>
<li><strong>线程池&#x2F;协程</strong>：<ul>
<li>减少线程数，使用线程池（如上下文中的线程池优化）或协程，降低资源竞争。</li>
<li><strong>类比</strong>：B+树操作使用固定线程池，限制并发。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-结合上下文"><a href="#4-结合上下文" class="headerlink" title="4. 结合上下文"></a>4. <strong>结合上下文</strong></h2><ul>
<li><strong>与同步机制</strong>：<ul>
<li><strong>Mutex</strong>：易导致死锁（如线程A、B互相等待Mutex）。</li>
<li><strong>RWLock</strong>：读写分离降低死锁概率，但写锁仍可能循环等待。</li>
<li><strong>条件变量</strong>：通过等待&#x2F;通知避免忙等，减少死锁（如生产者-消费者）。</li>
<li><strong>信号量</strong>：限制并发线程，降低资源竞争导致的死锁。</li>
</ul>
</li>
<li><strong>与跳表&#x2F;B+树</strong>：<ul>
<li>跳表插入&#x2F;删除需锁节点，易形成循环等待，建议按节点地址排序加锁。</li>
<li>B+树分裂&#x2F;合并涉及多节点锁，使用读写锁或按键值顺序加锁避免死锁。</li>
</ul>
</li>
<li><strong>与上下文切换</strong>：死锁增加线程阻塞，上下文切换开销（上下文回答，1-10μs）累积，影响性能。</li>
</ul>
<hr>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><ul>
<li><strong>定义</strong>：死锁是多进程&#x2F;线程因互相等待资源而永久阻塞。</li>
<li><strong>四个必要条件</strong>：互斥、持有并等待、不可抢占、循环等待。</li>
<li><strong>避免方法</strong>：<ul>
<li>破坏互斥：使用读写锁。</li>
<li>破坏持有并等待：一次性获取或释放资源。</li>
<li>破坏不可抢占：超时或可中断锁。</li>
<li>破坏循环等待：按序加锁。</li>
<li>其他：死锁检测、无锁编程、线程池。</li>
</ul>
</li>
<li><strong>建议</strong>：优先使用按序加锁（简单高效），结合无锁机制（如CAS）或条件变量优化高并发场景（如跳表&#x2F;B+树）。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/2024/10/09/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>米娜桑好久不见，国庆期间没有更新博客，属实有点摆烂</p>
<p>今天我们的主题是树与二叉树的转换，以及树的储存方法，遍历方法与二叉树的区别等</p>
<p>首先，我们要明白的是，树可以有多个子节点，而二叉树最多只有两个，所以二叉树是特殊的树</p>
<h1 id="一-树的存储与转换"><a href="#一-树的存储与转换" class="headerlink" title="一.树的存储与转换"></a>一.树的存储与转换</h1><h3 id="1-父亲表示法（双亲表示法）"><a href="#1-父亲表示法（双亲表示法）" class="headerlink" title="1.父亲表示法（双亲表示法）"></a>1.<strong>父亲表示法</strong>（双亲表示法）</h3><ul>
<li><p>使用一个数组来存储每个节点，其中每个节点只包含一个指针（或索引），指向其父节点。这种表示法的缺点是无法快速找到子节点，但优点是节省了存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    int parentIndex; // 指向父节点在数组中的索引</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-孩子链表表示法"><a href="#2-孩子链表表示法" class="headerlink" title="2.孩子链表表示法"></a>2.<strong>孩子链表表示法</strong></h3><ul>
<li><p>使用一个数组来存储每个节点，每个节点包含一个链表，链表中的每个节点指向该节点的子节点。这样，查找子节点的时间较快，但会增加空间开销。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 孩子链表中的节点</span><br><span class="line">struct ChildNode &#123;</span><br><span class="line">    int childIndex;        // 子节点的索引（或指针）</span><br><span class="line">    ChildNode* next;       // 指向下一个子节点的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 树的节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;              // 数据域，存储该节点的值</span><br><span class="line">    ChildNode* childList;  // 指向孩子链表的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（1）孩子链表表示法的特点"><a href="#（1）孩子链表表示法的特点" class="headerlink" title="（1）孩子链表表示法的特点"></a>（1）<strong>孩子链表表示法的特点</strong></h5><ol>
<li><strong>灵活性</strong>：<ul>
<li>每个节点的子节点数量不受限制，子节点数量可以动态扩展，因此这种表示法适合<strong>多叉树</strong>（即节点可以有多个子节点的树）。</li>
</ul>
</li>
<li><strong>存储空间</strong>：<ul>
<li>每个节点只存储一个指向其孩子链表的指针，而不是为所有可能的子节点预留空间，因此相比顺序存储更加节省空间，特别适合子节点数量较不确定的树结构。</li>
</ul>
</li>
<li><strong>节点操作</strong>：<ul>
<li><strong>插入节点</strong>：插入新子节点只需要在孩子链表的末尾添加一个节点，操作比较简单。</li>
<li><strong>删除节点</strong>：删除某个子节点时，只需要从孩子链表中移除相应的节点，但需要额外处理该子节点的所有子节点。</li>
<li><strong>查找子节点</strong>：查找某个节点的子节点时，需要遍历该节点的孩子链表，这可能导致查找子节点的效率较低。</li>
</ul>
</li>
</ol>
<h5 id="（2）孩子链表表示法的示例"><a href="#（2）孩子链表表示法的示例" class="headerlink" title="（2）孩子链表表示法的示例"></a>（2）<strong>孩子链表表示法的示例</strong></h5><p>假设有如下树结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line"> / | \</span><br><span class="line">2  3  4</span><br><span class="line">  / \</span><br><span class="line"> 5   6</span><br></pre></td></tr></table></figure>

<p>对应的孩子链表表示法如下：</p>
<ul>
<li>节点 1 的孩子链表指向节点 2、3 和 4。</li>
<li>节点 3 的孩子链表指向节点 5 和 6。</li>
</ul>
<p>图解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode(1) -&gt; ChildList -&gt; [TreeNode(2)] -&gt; [TreeNode(3)] -&gt; [TreeNode(4)] -&gt; NULL</span><br><span class="line">TreeNode(3) -&gt; ChildList -&gt; [TreeNode(5)] -&gt; [TreeNode(6)] -&gt; NULL</span><br></pre></td></tr></table></figure>

<p>对应的代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义孩子链表中的节点</span><br><span class="line">struct ChildNode &#123;</span><br><span class="line">    int childIndex;         // 孩子的索引或指针</span><br><span class="line">    ChildNode* next;        // 下一个孩子的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义树的节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;               // 节点的值</span><br><span class="line">    ChildNode* childList;   // 孩子链表的头指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 示例：创建节点和孩子链表</span><br><span class="line">TreeNode node1, node2, node3, node4, node5, node6;</span><br><span class="line">node1.data = 1;</span><br><span class="line">node2.data = 2;</span><br><span class="line">node3.data = 3;</span><br><span class="line">node4.data = 4;</span><br><span class="line">node5.data = 5;</span><br><span class="line">node6.data = 6;</span><br><span class="line"></span><br><span class="line">// 为节点1创建孩子链表</span><br><span class="line">ChildNode* child1 = new ChildNode&#123;2, NULL&#125;;  // 指向节点2</span><br><span class="line">ChildNode* child2 = new ChildNode&#123;3, NULL&#125;;  // 指向节点3</span><br><span class="line">ChildNode* child3 = new ChildNode&#123;4, NULL&#125;;  // 指向节点4</span><br><span class="line"></span><br><span class="line">child1-&gt;next = child2;</span><br><span class="line">child2-&gt;next = child3;</span><br><span class="line">node1.childList = child1;  // 节点1的孩子链表</span><br><span class="line"></span><br><span class="line">// 为节点3创建孩子链表</span><br><span class="line">ChildNode* child5 = new ChildNode&#123;5, NULL&#125;;  // 指向节点5</span><br><span class="line">ChildNode* child6 = new ChildNode&#123;6, NULL&#125;;  // 指向节点6</span><br><span class="line">child5-&gt;next = child6;</span><br><span class="line">node3.childList = child5;  // 节点3的孩子链表</span><br></pre></td></tr></table></figure>

<h3 id="3-孩子兄弟表示法"><a href="#3-孩子兄弟表示法" class="headerlink" title="3.孩子兄弟表示法"></a>3.孩子兄弟表示法</h3><p>在树结构中，<strong>孩子</strong>和<strong>兄弟</strong>是指节点之间的一种关系：</p>
<h5 id="孩子（Child）："><a href="#孩子（Child）：" class="headerlink" title="孩子（Child）："></a><strong>孩子（Child）</strong>：</h5><ul>
<li><strong>孩子节点</strong>是指某个节点的直接下级节点。</li>
<li>如果一个节点有若干子节点，这些子节点就是它的孩子。</li>
<li>每个树节点可以有0个、1个或多个孩子。</li>
</ul>
<h5 id="兄弟（Sibling）："><a href="#兄弟（Sibling）：" class="headerlink" title="兄弟（Sibling）："></a><strong>兄弟（Sibling）</strong>：</h5><ul>
<li><strong>兄弟节点</strong>是指同一个父节点的多个子节点之间的关系。</li>
<li>如果两个或多个节点有相同的父节点，这些节点互为兄弟。</li>
</ul>
<h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>孩子兄弟表示法，是以左孩子的形式存储最左边的孩子，以右孩子的形式存储第一个右兄弟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义多叉树节点结构</span><br><span class="line">struct MultiTreeNode &#123;</span><br><span class="line">    int data;                    // 数据域</span><br><span class="line">    vector&lt;MultiTreeNode*&gt; children; // 子节点列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义二叉树节点结构</span><br><span class="line">struct BinaryTreeNode &#123;</span><br><span class="line">    int data;                    // 数据域</span><br><span class="line">    BinaryTreeNode* left;        // 左子节点，表示第一个子节点</span><br><span class="line">    BinaryTreeNode* right;       // 右子节点，表示兄弟节点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这样的形式将树以二叉树的形式存储了起来，进而实现了树向二叉树的转换</p>
<h4 id="转换步骤："><a href="#转换步骤：" class="headerlink" title="转换步骤："></a><strong>转换步骤</strong>：</h4><ol>
<li><strong>保持第一个子节点为左孩子</strong>：<ul>
<li>在多叉树中，某个节点的第一个子节点转换为二叉树中的左孩子。</li>
</ul>
</li>
<li><strong>其他子节点变为右兄弟</strong>：<ul>
<li>在多叉树中，该节点的第二个及以后的子节点依次作为第一个子节点的右兄弟节点。</li>
</ul>
</li>
<li><strong>兄弟之间的关系通过右子节点表示</strong>：<ul>
<li>在二叉树中，右子节点用来表示多叉树中的兄弟节点。</li>
</ul>
</li>
</ol>
<h4 id="转换示意图"><a href="#转换示意图" class="headerlink" title="转换示意图"></a><strong>转换示意图</strong></h4><p>假设有如下的多叉树结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     A</span><br><span class="line">   / | \</span><br><span class="line">  B  C  D</span><br><span class="line"> / \</span><br><span class="line">E   F</span><br></pre></td></tr></table></figure>

<p>转换成二叉树的步骤如下：</p>
<ol>
<li>节点 <code>A</code> 的第一个子节点 <code>B</code> 作为 <code>A</code> 的左孩子，<code>C</code> 和 <code>D</code> 作为 <code>B</code> 的右兄弟。</li>
<li>节点 <code>B</code> 的第一个子节点 <code>E</code> 作为 <code>B</code> 的左孩子，<code>F</code> 作为 <code>E</code> 的右兄弟。</li>
</ol>
<p>转换成二叉树后的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    A</span><br><span class="line">   /</span><br><span class="line">  B</span><br><span class="line"> / \</span><br><span class="line">E   C</span><br><span class="line"> \   \</span><br><span class="line">  F   D</span><br></pre></td></tr></table></figure>

<p>可以看到，在转换后的二叉树中：</p>
<ul>
<li><p>原来多叉树中节点 <code>A</code> 的子节点 <code>B、C、D</code> 被通过左孩子和右兄弟关系串联在一起。</p>
</li>
<li><p>原来节点 <code>B</code> 的子节点 <code>E、F</code> 也通过相同的方式连接。</p>
<p>  &#x2F;&#x2F; 多叉树转二叉树的递归转换函数<br>  BinaryTreeNode* convertToBinaryTree(MultiTreeNode* root)<br>  {<br>  if (root &#x3D;&#x3D; nullptr) return nullptr;<br>  &#x2F;&#x2F; 创建对应的二叉树节点<br>  BinaryTreeNode* newNode &#x3D; new BinaryTreeNode();<br>  newNode-&gt;data &#x3D; root-&gt;data;<br>  newNode-&gt;left &#x3D; nullptr;<br>  newNode-&gt;right &#x3D; nullptr;</p>
<p>  if (!root-&gt;children.empty())<br>  {<br>  &#x2F;&#x2F; 将第一个孩子作为左子树<br>  newNode-&gt;left &#x3D; convertToBinaryTree(root-&gt;children[0]);<br><br>  &#x2F;&#x2F; 将其他孩子作为兄弟通过右子树连接<br>  BinaryTreeNode* current &#x3D; newNode-&gt;left;<br>  for (size_t i &#x3D; 1; i &lt; root-&gt;children.size(); ++i)<br>  {<br>      current-&gt;right &#x3D; convertToBinaryTree(root-&gt;children[i]);<br>      current &#x3D; current-&gt;right;<br>  }<br>  }</p>
<p>  return newNode;<br>  }</p>
</li>
</ul>
<h3 id="4-森林与二叉树的转换"><a href="#4-森林与二叉树的转换" class="headerlink" title="4.森林与二叉树的转换"></a>4.森林与二叉树的转换</h3><p>将森林中的每棵树都转换成二叉树</p>
<p>然后从第二棵树开始，每棵树的根节点都是前一棵树的根节点的兄弟</p>
<h1 id="二-树和森林的遍历"><a href="#二-树和森林的遍历" class="headerlink" title="二.树和森林的遍历"></a>二.树和森林的遍历</h1><h3 id="1-树的遍历"><a href="#1-树的遍历" class="headerlink" title="1.树的遍历"></a>1.树的遍历</h3><p>树的前序遍历和其转换成的二叉树的前序遍历相同</p>
<p>树的后序遍历与其转换成的二叉树的中序遍历相同</p>
<h5 id="树的中序遍历"><a href="#树的中序遍历" class="headerlink" title="树的中序遍历"></a>树的中序遍历</h5><p>中序遍历树最左边的孩子，访问根节点，再依次访问中序遍历其他孩子</p>
<h3 id="2-森林的遍历：依次遍历每棵树"><a href="#2-森林的遍历：依次遍历每棵树" class="headerlink" title="2.森林的遍历：依次遍历每棵树"></a>2.森林的遍历：依次遍历每棵树</h3>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>树</tag>
        <tag>链表</tag>
        <tag>森林</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>用户态和内核态的区别及切换方法</title>
    <url>/2025/06/30/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="用户态与内核态的区别及切换"><a href="#用户态与内核态的区别及切换" class="headerlink" title="用户态与内核态的区别及切换"></a>用户态与内核态的区别及切换</h1><p>用户态（User Mode）和内核态（Kernel Mode）是操作系统中两种不同的运行状态，用于隔离用户程序和系统核心功能，以确保安全性和稳定性。以下是两者的区别及切换机制。</p>
<h2 id="1-用户态与内核态的区别"><a href="#1-用户态与内核态的区别" class="headerlink" title="1. 用户态与内核态的区别"></a>1. <strong>用户态与内核态的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>用户态 (User Mode)</th>
<th>内核态 (Kernel Mode)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>应用程序运行的状态，受限访问权限</td>
<td>操作系统核心运行的状态，拥有完全控制权</td>
</tr>
<tr>
<td><strong>权限级别</strong></td>
<td>低权限（Ring 3），无法直接访问硬件或核心资源</td>
<td>高权限（Ring 0），可直接访问硬件和系统资源</td>
</tr>
<tr>
<td><strong>可访问资源</strong></td>
<td>受限，仅能访问用户空间内存和部分指令</td>
<td>可访问所有内存、硬件设备和特权指令</td>
</tr>
<tr>
<td><strong>典型操作</strong></td>
<td>执行用户程序、调用库函数、处理用户逻辑</td>
<td>执行系统调用、中断处理、设备驱动管理</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>隔离运行，防止程序破坏系统</td>
<td>完全控制，可能导致系统崩溃</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>较高，因需通过系统调用访问内核</td>
<td>较低，直接访问资源</td>
</tr>
</tbody></table>
<ul>
<li><strong>用户态</strong>：<ul>
<li>用户程序（如浏览器、文本编辑器）运行在此状态。</li>
<li>只能访问用户空间内存，无法直接操作硬件（如 CPU、磁盘）或修改内核数据。</li>
<li>通过系统调用（如 <code>read</code>、<code>write</code>）请求内核服务。</li>
</ul>
</li>
<li><strong>内核态</strong>：<ul>
<li>操作系统内核（包括设备驱动、中断处理程序）运行在此状态。</li>
<li>可执行特权指令（如访问 I&#x2F;O 设备、修改内存映射）。</li>
<li>负责管理进程、内存、文件系统等核心功能。</li>
</ul>
</li>
</ul>
<h2 id="2-用户态与内核态的切换"><a href="#2-用户态与内核态的切换" class="headerlink" title="2. 用户态与内核态的切换"></a>2. <strong>用户态与内核态的切换</strong></h2><p>用户态和内核态的切换通常由特定事件触发，涉及 CPU 状态的转换和上下文切换。以下是切换的主要方式和机制：</p>
<h3 id="切换方式"><a href="#切换方式" class="headerlink" title="切换方式"></a><strong>切换方式</strong></h3><ol>
<li><p><strong>系统调用（System Call）</strong>：</p>
<ul>
<li>用户程序需要内核服务（如文件操作、网络通信）时，通过系统调用触发切换。</li>
<li>例如：调用 <code>open()</code>、<code>fork()</code> 等。</li>
<li><strong>过程</strong>：<ol>
<li>用户程序调用库函数（如 C 库的 <code>write</code>）。</li>
<li>库函数执行特权指令（如 <code>syscall</code> 或 <code>int 0x80</code>），触发软中断。</li>
<li>CPU 从用户态切换到内核态，保存用户态上下文（寄存器、程序计数器等）。</li>
<li>内核执行系统调用处理程序，完成请求后恢复用户态上下文。</li>
</ol>
</li>
<li><strong>示例</strong>：<code>write(fd, buf, size)</code> 调用触发内核态的文件写操作。</li>
</ul>
</li>
<li><p><strong>中断（Interrupt）</strong>：</p>
<ul>
<li>硬件中断（如定时器、键盘输入）或异常（如除零错误、页面错误）触发切换。</li>
<li><strong>过程</strong>：<ol>
<li>硬件或异常事件触发中断信号。</li>
<li>CPU 保存当前用户态上下文，切换到内核态。</li>
<li>内核调用中断处理程序（如时钟中断处理调度）。</li>
<li>处理完成后，恢复用户态上下文或切换到其他进程。</li>
</ol>
</li>
<li><strong>示例</strong>：时钟中断触发进程调度。</li>
</ul>
</li>
<li><p><strong>异常（Exception）</strong>：</p>
<ul>
<li>程序错误（如非法指令、内存访问越界）导致 CPU 抛出异常。</li>
<li><strong>过程</strong>：<ol>
<li>CPU 检测到异常，切换到内核态。</li>
<li>内核执行异常处理程序（如发送 SIGSEGV 信号）。</li>
<li>根据异常类型，可能终止进程或恢复执行。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="切换机制"><a href="#切换机制" class="headerlink" title="切换机制"></a><strong>切换机制</strong></h3><ul>
<li><strong>硬件支持</strong>：<ul>
<li>CPU 提供特权级别（如 x86 的 Ring 0 和 Ring 3）来区分用户态和内核态。</li>
<li>特权指令（如 <code>int</code>、<code>syscall</code>、<code>sysenter</code>）触发状态转换。</li>
<li>中断描述符表（IDT）定义中断和系统调用的入口点。</li>
</ul>
</li>
<li><strong>上下文切换</strong>：<ul>
<li>保存用户态寄存器（如 PC、SP、通用寄存器）到进程控制块（PCB）。</li>
<li>加载内核态堆栈和上下文，执行内核代码。</li>
<li>完成后恢复用户态上下文或切换到其他进程。</li>
</ul>
</li>
<li><strong>典型开销</strong>：<ul>
<li>切换涉及寄存器保存&#x2F;恢复、TLB 刷新等，时间复杂度通常为 ( O(1) )，但实际开销取决于硬件和操作系统实现。</li>
</ul>
</li>
</ul>
<h2 id="3-代码示例（Linux-系统调用）"><a href="#3-代码示例（Linux-系统调用）" class="headerlink" title="3. 代码示例（Linux 系统调用）"></a>3. <strong>代码示例（Linux 系统调用）</strong></h2><p>以下是一个简单的 Linux 系统调用示例（C 语言），展示用户态到内核态的切换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;Hello, kernel!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// write 系统调用，触发用户态到内核态切换</span></span><br><span class="line">    <span class="type">ssize_t</span> ret = write(<span class="number">1</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>解释</strong>：<ul>
<li><code>write</code> 调用触发 <code>syscall</code> 指令，CPU 从用户态切换到内核态。</li>
<li>内核执行文件写操作，完成后返回用户态。</li>
</ul>
</li>
</ul>
<h2 id="4-切换优化"><a href="#4-切换优化" class="headerlink" title="4. 切换优化"></a>4. <strong>切换优化</strong></h2><ul>
<li><strong>减少切换</strong>：通过批量操作（如缓冲 I&#x2F;O）或用户态库（如 <code>vDSO</code>）减少系统调用。</li>
<li><strong>快速系统调用</strong>：现代 CPU 使用 <code>sysenter</code>&#x2F;<code>sysexit</code> 或 <code>syscall</code>&#x2F;<code>sysret</code> 指令，降低切换开销。</li>
<li><strong>中断优化</strong>：合并中断或延迟处理（如 Linux 的软中断）。</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><ul>
<li><strong>用户态</strong>：低权限，运行用户程序，安全但受限。</li>
<li><strong>内核态</strong>：高权限，管理硬件和系统资源，功能强大但需谨慎。</li>
<li><strong>切换</strong>：通过系统调用、中断或异常实现，涉及上下文保存和恢复。</li>
<li><strong>应用场景</strong>：用户态适合应用程序，内核态适合操作系统核心功能，切换是两者交互的桥梁。</li>
</ul>
<p>如需更深入的实现细节（如特定架构的切换流程或性能分析），请提供进一步要求！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>移动语义的方方面面</title>
    <url>/2025/05/11/%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E6%96%B9%E6%96%B9%E9%9D%A2%E9%9D%A2/</url>
    <content><![CDATA[<p>主播刚刚考完计算机组成原理哈，然后浅浅荒废了几天的时间，leetcode也没刷，八股也没看，不过计算机组成原理终究是过了，姑且算对计算机有了更深入的一点点了解，过几天的信号与系统和电动力学才是折磨。</p>
<p>碎碎念结束。</p>
<p>————————————————————————————————————————————————————————————</p>
<p>c++11中引入了一个经常见到的函数，std::move，初次见面是在unique_ptr那一节中，后来在移动构造函数中也有见面，它的作用可以简单的理解为实现将左值转换为右值。</p>
<p>那么我们首先介绍一下什么是左值和右值。</p>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>左值，可以理解为有内存地址的值，与之相对，右值就是没有内存地址的值。</p>
<p>从硬件上说，左值由内存存储，右值由寄存器存储，所以右值就是马上就要消亡的值，生命周期一般只有所在的那一行代码</p>
<p>常见的右值形式包括：</p>
<p>1.int x &#x3D; 5;里面的5等常量</p>
<p>2.调用函数的返回值</p>
<p>3.算术表达式或者逻辑表达式</p>
<p>而左值就是我们常说的变量及所有可以被左赋值的值</p>
<p>从而我们得到了左值引用和右值引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">int &amp;x=a;//左值引用</span><br><span class="line">int &amp;&amp;b=2;//右值引用</span><br></pre></td></tr></table></figure>

<p>而左值引用和右值引用又可以用同一种方式表示，即万能引用</p>
<p>有两种形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void fun(T &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">//这里就是万能引用</span><br><span class="line">&#125;</span><br><span class="line">auto &amp;&amp;ref=x;</span><br><span class="line">auto &amp;&amp;ref1=5;//这是另一种万能引用的表现方式，这里ref被自动推导为左值引用，ref1被自动引用为右值引用</span><br><span class="line">fun(x);</span><br><span class="line">fun(5);</span><br><span class="line">fun(ref);</span><br><span class="line">fun(ref1);//四种情况中万能引用被推导为左值，右值，左值，右值引用</span><br></pre></td></tr></table></figure>

<p>这里左值和右值的引用相遇，具体的结果有一个规则，即折叠引用，可以理解为两者都右值才右值，否则有一个左值，就被推导为左值</p>
<h4 id="右值引用！-万能引用"><a href="#右值引用！-万能引用" class="headerlink" title="右值引用！&#x3D;万能引用"></a>右值引用！&#x3D;万能引用</h4><p>右值引用是已经确定的，只能传入右值的，而万能引用由模板和auto实现，本质是不确定的</p>
<h1 id="为什么要移动语义"><a href="#为什么要移动语义" class="headerlink" title="为什么要移动语义"></a>为什么要移动语义</h1><p>前菜讲完，接下来是移动语义</p>
<p>在常见的类的赋值中，我们常常调用拷贝构造函数，而其底层是深拷贝，是需要在堆上申请空间new的，这样的空间开销是非常大的，特别是在占用空间特别大的类当中，除了这个还有两个原因</p>
<ol>
<li><strong>性能开销大：</strong> 深拷贝涉及到内存分配（可能很慢）和大量数据的复制。对于包含大量数据的对象（如 <code>std::vector</code>, <code>std::string</code>），这会非常耗时。</li>
<li><strong>资源浪费：</strong> 在很多情况下，我们复制一个对象仅仅是为了临时使用，或者原对象在复制后很快就会被销毁。例如，函数返回一个大对象时，会创建一个临时对象，然后将这个临时对象拷贝到接收变量中。这个临时对象马上就没用了，但我们却花费了昂贵的代价去复制它的内容。</li>
<li><strong>无法处理独占资源：</strong> 有些资源是不能被复制的，比如文件句柄、互斥锁（mutex）、智能指针 <code>std::unique_ptr</code> 等。这些资源通常是独占的。如果一个类管理着这样的独占资源，那么它的拷贝构造函数和拷贝赋值运算符就无法实现（或者被显式删除），导致这类对象无法进行正常的复制操作，限制了它们的使用场景（比如不能作为函数返回值，不能放入需要复制的标准容器）。</li>
</ol>
<p>于是为了提高效率，处理独占资源，避免不必要的拷贝，我们采用了移动语义</p>
<p>举一个移动语义的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class S</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	char[5] student;</span><br><span class="line">	S(const S&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">    	size=new char[5];</span><br><span class="line">    	for(int i=0;i&lt;5;++i)</span><br><span class="line">    	&#123;</span><br><span class="line">    		student[i]=other.student[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;//拷贝构造函数</span><br><span class="line">    S(S&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">    	student=other.student;</span><br><span class="line">    	other.student=nullptr;</span><br><span class="line">    &#125;//移动构造函数</span><br><span class="line">    </span><br><span class="line">    ~S()</span><br><span class="line">    &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的移动构造函数类似浅拷贝，参数要是右值，可以是真正的右值，也可以是move实现的左值转换成的右值</p>
<p><strong>需要移动语义的典型场景：</strong></p>
<ul>
<li><p>函数返回大对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">createLargeVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">1000000</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 填充数据</span></span><br><span class="line">    <span class="keyword">return</span> vec; <span class="comment">// C++11 后，这里通常会发生移动而不是拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVec = <span class="built_in">createLargeVector</span>(); <span class="comment">// 接收返回值时，使用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>在没有移动语义之前，返回 vec会创建一个临时std::vector对象，并将vec的所有元素拷贝到这个临时对象中，然后将这个临时对象拷贝到myVec中（如果 RVO&#x2F;NRVO 不起作用的话）。有了移动语义，vec的资源可以直接转移给临时对象，再从临时对象转移给myVec</p>
<p>，避免了两次昂贵的拷贝。</p>
</li>
<li><p>将对象放入容器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; names;</span><br><span class="line">std::string s = <span class="string">&quot;very long string...&quot;</span>;</span><br><span class="line">names.<span class="built_in">push_back</span>(s); <span class="comment">// 拷贝</span></span><br><span class="line">names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(s)); <span class="comment">// 移动，s 的内容被转移，s 变为空或有效但未指定状态</span></span><br><span class="line">names.<span class="built_in">push_back</span>(<span class="string">&quot;another long string...&quot;</span>); <span class="comment">// 临时右值，移动</span></span><br></pre></td></tr></table></figure>

<p>当std::vector需要扩容时，它会分配新的内存并将现有元素转移到新位置。有了移动语义，这个转移过程是移动操作，而不是拷贝操作，大大提高了性能。</p>
</li>
<li><p>对象交换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">std::<span class="built_in">swap</span>(v1, v2); <span class="comment">// std::swap 的高效实现依赖于移动语义</span></span><br></pre></td></tr></table></figure>

<p>std::swap 的标准实现通常是：通过三次移动操作实现高效交换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp = std::move(a); a = std::move(b); b = std::move(temp);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>移动语义</tag>
        <tag>右值引用</tag>
      </tags>
  </entry>
  <entry>
    <title>类和结构体</title>
    <url>/2025/06/30/%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="类和结构体的区别"><a href="#类和结构体的区别" class="headerlink" title="类和结构体的区别"></a>类和结构体的区别</h1><p>类和结构体是面向对象编程中两种重要的数据结构，它们有以下主要区别：</p>
<h2 id="1-默认访问控制"><a href="#1-默认访问控制" class="headerlink" title="1. 默认访问控制"></a>1. 默认访问控制</h2><ul>
<li><strong>类</strong>：成员默认为私有（private）</li>
<li><strong>结构体</strong>：成员默认为公开（public）</li>
</ul>
<h2 id="2-内存分配位置"><a href="#2-内存分配位置" class="headerlink" title="2. 内存分配位置"></a>2. 内存分配位置</h2><ul>
<li><strong>类</strong>：通常在堆（heap）上分配内存</li>
<li><strong>结构体</strong>：通常在栈（stack）上分配内存</li>
</ul>
<h2 id="3-继承特性"><a href="#3-继承特性" class="headerlink" title="3. 继承特性"></a>3. 继承特性</h2><ul>
<li><strong>类</strong>：可以实现继承、多态等完整的面向对象特性</li>
<li><strong>结构体</strong>：在许多语言中不支持继承或有限支持继承</li>
</ul>
<h2 id="4-语言差异"><a href="#4-语言差异" class="headerlink" title="4. 语言差异"></a>4. 语言差异</h2><p>不同编程语言对类和结构体的区别处理不同：</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 默认public</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 默认private</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPoint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; x = a; y = b; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值类型，存储在栈上</span></span><br><span class="line"><span class="keyword">struct</span> Point </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型，存储在堆上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Int</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PointClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">x</span>: <span class="type">Int</span>, <span class="params">y</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x <span class="operator">=</span> x</span><br><span class="line">        <span class="keyword">self</span>.y <span class="operator">=</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Int</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-复制行为"><a href="#5-复制行为" class="headerlink" title="5. 复制行为"></a>5. 复制行为</h2><ul>
<li><strong>类</strong>：引用语义（reference semantics），复制时是浅拷贝</li>
<li><strong>结构体</strong>：值语义（value semantics），复制时是深拷贝</li>
</ul>
<h2 id="6-用途区别"><a href="#6-用途区别" class="headerlink" title="6. 用途区别"></a>6. 用途区别</h2><ul>
<li><strong>类</strong>：适合表示复杂的、有身份特性的对象，有状态变化</li>
<li><strong>结构体</strong>：适合表示简单的、无状态或状态简单的数据结构</li>
</ul>
<h2 id="7-性能差异"><a href="#7-性能差异" class="headerlink" title="7. 性能差异"></a>7. 性能差异</h2><ul>
<li><strong>类</strong>：操作可能涉及引用计数、虚函数表等额外开销</li>
<li><strong>结构体</strong>：直接操作内存，性能通常更高</li>
</ul>
<p>根据应用场景和性能需求，合理选择类或结构体可以显著提高程序的效率和可维护性。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2025/06/17/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h3 id="红黑树介绍"><a href="#红黑树介绍" class="headerlink" title="红黑树介绍"></a>红黑树介绍</h3><p>红黑树（Red-Black Tree）是一种<strong>自平衡的二叉搜索树</strong>，在插入和删除操作时通过特定的规则保持树的平衡，从而保证高效的查找、插入和删除操作。其时间复杂度通常为 ( O(\log n) )，适用于需要频繁动态更新的场景。</p>
<h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><p>红黑树在普通二叉搜索树（BST）的基础上增加了颜色属性（红或黑），并通过以下五条性质保持平衡：</p>
<ol>
<li><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</li>
<li><strong>根节点</strong>：根节点始终是黑色。</li>
<li><strong>红色节点约束</strong>：红色节点的子节点必须是黑色（即红色节点不能连续）。</li>
<li><strong>黑色路径等价</strong>：从根节点到每个叶子节点（或 NULL 节点）的路径上，黑色节点数量相同（称为黑色高度）。</li>
<li><strong>叶子节点</strong>：所有叶子节点（通常是 NULL 节点）视为黑色。</li>
</ol>
<p>这些性质确保红黑树的高度不会超过 ( 2 \log (n+1) )，从而保证高效的操作。</p>
<h4 id="红黑树的操作"><a href="#红黑树的操作" class="headerlink" title="红黑树的操作"></a>红黑树的操作</h4><ol>
<li><p><strong>查找</strong>：</p>
<ul>
<li>与普通二叉搜索树相同，根据键值比较沿树向下搜索，时间复杂度为 ( O(\log n) )。</li>
</ul>
</li>
<li><p><strong>插入</strong>：</p>
<ul>
<li>新节点插入时默认标记为红色（以最小化对黑色高度的影响）。</li>
<li>插入后可能违反性质（如红色节点连续），需要通过<strong>旋转</strong>和<strong>重新着色</strong>修复：<ul>
<li><strong>旋转</strong>：分为左旋和右旋，调整子树结构以恢复平衡。</li>
<li><strong>重新着色</strong>：调整节点的颜色以满足红黑树性质。</li>
</ul>
</li>
<li>修复场景包括：父节点为红色时的几种情况（取决于叔节点、父节点和祖父节点的颜色与位置）。</li>
<li>时间复杂度：( O(\log n) )。</li>
</ul>
</li>
<li><p><strong>删除</strong>：</p>
<ul>
<li>删除节点后可能破坏黑色高度或颜色约束，需通过旋转和重新着色修复。</li>
<li>删除操作比插入复杂，涉及“双黑”节点（黑色节点被删除后路径黑色高度减少）处理。</li>
<li>时间复杂度：( O(\log n) )。</li>
</ul>
</li>
</ol>
<h4 id="红黑树的优点"><a href="#红黑树的优点" class="headerlink" title="红黑树的优点"></a>红黑树的优点</h4><ul>
<li><strong>高效性</strong>：通过自平衡机制，查找、插入、删除操作的时间复杂度均为 ( O(\log n) )。</li>
<li><strong>稳定性</strong>：相比 AVL 树，红黑树在插入和删除时旋转次数较少，适合频繁更新的场景。</li>
<li><strong>广泛应用</strong>：常用于实现关联容器（如 C++ 的 <code>std::map</code> 和 <code>std::set</code>）、内存管理、数据库索引等。</li>
</ul>
<h4 id="红黑树与-AVL-树的对比"><a href="#红黑树与-AVL-树的对比" class="headerlink" title="红黑树与 AVL 树的对比"></a>红黑树与 AVL 树的对比</h4><ul>
<li><strong>AVL 树</strong>：严格平衡（左右子树高度差不超过 1），查找更快，但插入&#x2F;删除需要更多旋转。</li>
<li><strong>红黑树</strong>：较宽松的平衡（通过颜色和黑色高度约束），插入&#x2F;删除效率更高，适合动态更新场景。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设插入序列为 <code>&#123;7, 3, 18, 10, 22, 8, 11, 26&#125;</code>，红黑树可能如下（简化表示）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   7(B)</span><br><span class="line">  /   \</span><br><span class="line">3(R)  18(B)</span><br><span class="line">     /  \</span><br><span class="line">   10(R) 22(R)</span><br><span class="line">   /       \</span><br><span class="line">  8(B)    26(B)</span><br><span class="line">          /</span><br><span class="line">        11(R)</span><br></pre></td></tr></table></figure>
<p>（B 表示黑色，R 表示红色）</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池中的意外发现</title>
    <url>/2025/10/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E6%84%8F%E5%A4%96%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>本来我在认真学习bind和function的区别</p>
<h3 id="1-std-bind-的作用"><a href="#1-std-bind-的作用" class="headerlink" title="1. std::bind 的作用"></a>1. <strong><code>std::bind</code> 的作用</strong></h3><p><code>std::bind</code> 的作用是将函数和其参数绑定在一起，返回一个<strong>可调用对象</strong>。当你调用这个对象时，<strong>已经绑定好的函数和参数</strong>会被执行。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 bind 绑定 add 函数和参数</span></span><br><span class="line">    <span class="keyword">auto</span> bound_func = std::<span class="built_in">bind</span>(add, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">bound_func</span>(); <span class="comment">// 执行 add(3, 4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::bind</code> 将 <code>add</code> 函数与参数 <code>3</code> 和 <code>4</code> 绑定，返回的 <code>bound_func</code> 是一个可调用对象，调用时就相当于执行了 <code>add(3, 4)</code>。</p>
<hr>
<h3 id="2-std-function-的作用"><a href="#2-std-function-的作用" class="headerlink" title="2. std::function 的作用"></a>2. <strong><code>std::function</code> 的作用</strong></h3><p><code>std::function</code> 是一个<strong>类型擦除</strong>的类模板，它可以封装任何可调用的对象，无论是普通函数、成员函数、函数指针、lambda 表达式等。它可以作为参数传递或者存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = std::<span class="built_in">bind</span>(add, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 执行 add(3, 4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>std::function&lt;void()&gt;</code> 是一个可调用对象，它存储了通过 <code>std::bind</code> 创建的 <code>add</code> 函数的绑定版本。<code>std::function</code> 允许你动态传递任何符合签名的可调用对象。</p>
<p>然后忽然想让ai生成一个线程池综合运用一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line"></span><br><span class="line">class ThreadPool &#123;</span><br><span class="line">public:</span><br><span class="line">    ThreadPool(size_t numThreads) : stop(false) &#123;</span><br><span class="line">        for (size_t i = 0; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            workers.emplace_back([this] &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    std::function&lt;void()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queueMutex);</span><br><span class="line">                        this-&gt;cv.wait(lock, [this] &#123; return this-&gt;stop || !this-&gt;tasks.empty(); &#125;);</span><br><span class="line">                        if (this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        task = std::move(this-&gt;tasks.front());</span><br><span class="line">                        this-&gt;tasks.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    task(); // 执行任务</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename F&gt;</span><br><span class="line">    void enqueue(F&amp;&amp; f) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; lock(queueMutex);</span><br><span class="line">            tasks.emplace(std::forward&lt;F&gt;(f)); // 将任务添加到队列</span><br><span class="line">        &#125;</span><br><span class="line">        cv.notify_one(); // 唤醒一个线程来处理任务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void shutdown() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; lock(queueMutex);</span><br><span class="line">            stop = true;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.notify_all(); // 唤醒所有线程退出</span><br><span class="line">        for (std::thread&amp; worker : workers) &#123;</span><br><span class="line">            worker.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;</span><br><span class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;</span><br><span class="line">    std::mutex queueMutex;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    bool stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print_message(const std::string&amp; msg) &#123;</span><br><span class="line">    std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ThreadPool pool(4); // 创建一个有4个线程的线程池</span><br><span class="line"></span><br><span class="line">    pool.enqueue(std::bind(print_message, &quot;Hello from thread pool!&quot;));</span><br><span class="line">    pool.enqueue(std::bind(print_message, &quot;Another task!&quot;));</span><br><span class="line"></span><br><span class="line">    pool.shutdown(); // 关闭线程池</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我发现在主函数中明明enqueue时使用的是bind，但是实际在线程池中没有使用function进行类型擦除，而是使用了模板+右值+完美转发的一个操作，顿时引起了我的好奇。</p>
<p>为什么要半路使用模板呢？</p>
<p>ai的给我的回答是，一部分原因是要用完美转发，将bind绑定中的参数如果有右值的情况，也能正确的转发给函数。另一部分原因是，function本身在包装时有开销。</p>
<p>这个回答是没有问题的，但是为什么queue却使用了function来再次包装，然后运行呢，不是可以用模板吗。</p>
<ul>
<li><h3 id="1-模板如何在前面工作？"><a href="#1-模板如何在前面工作？" class="headerlink" title="1. 模板如何在前面工作？"></a>1. <strong>模板如何在前面工作？</strong></h3><p>回顾你之前提到的代码中的模板成员函数（<code>enqueue</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">        tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(f)); <span class="comment">// 将任务添加到队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个线程来处理任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>为什么模板可以在这里工作</strong>：<br>这里的 <code>enqueue</code> 是一个模板成员函数，意味着它在编译时会根据传入的参数类型 <code>F</code> 生成不同的函数版本。</p>
<p>在此情况下，模板可以使用<strong>类型推导</strong>来确定 <code>F</code> 的类型。只要你传入一个类型兼容的任务对象（如函数指针、lambda 表达式或 <code>std::bind</code> 的结果），编译器就会自动推导出 <code>F</code> 的类型，并生成对应的代码版本。</p>
</li>
<li><p><strong>编译时多态</strong>：<br>这里的模板是一种典型的 <strong>编译时多态</strong>，因为模板生成不同的函数版本，而不是在运行时决定使用哪个函数版本。<code>tasks.emplace(std::forward&lt;F&gt;(f));</code> 会在编译期根据 <code>F</code> 的类型推导出正确的代码。</p>
<p>因此，模板函数可以处理不同类型的任务，只要这些任务的类型能够匹配 <code>std::function&lt;void()&gt;</code> 或 <code>void()</code> 的签名（如 <code>lambda</code>、<code>std::bind</code>、普通函数等）。</p>
</li>
</ul>
<hr>
<h3 id="2-为什么后面不能再用模板了？"><a href="#2-为什么后面不能再用模板了？" class="headerlink" title="2. 为什么后面不能再用模板了？"></a>2. <strong>为什么后面不能再用模板了？</strong></h3><p>当你到了这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queueMutex)</span></span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks.<span class="built_in">front</span>());</span><br><span class="line">    <span class="keyword">this</span>-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">task</span>(); <span class="comment">// 执行任务</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里不能使用模板的原因</p>
<p>：</p>
<ol>
<li><p><strong>任务类型不一致</strong>：<br><code>std::function&lt;void()&gt; task</code> 是一个具体的类型，它要求队列中的任务能够转换为 <code>std::function&lt;void()&gt;</code> 类型，而模板只能在编译时根据传入的类型推导生成对应的函数版本。所以这里的 <code>task()</code> 必须是一个统一的可调用对象（如 <code>std::function&lt;void()&gt;</code>），否则无法调用。</p>
<p>但是模板在这里无法直接解决任务队列中每个任务类型的差异。任务队列中的任务类型是 <strong>不确定的</strong>，可能有不同的参数、返回值类型等。因此，无法在运行时动态推导出每个任务的类型并调用它们。</p>
</li>
<li><p><strong><code>std::function</code> 的类型擦除机制</strong>：<br>由于你将任务存储在 <code>std::function&lt;void()&gt;</code> 中，你就 <strong>丧失了类型信息</strong>。<code>std::function&lt;void()&gt;</code> 是一个类型擦除（type-erasure）的容器，它把任何可调用对象（函数指针、<code>lambda</code>、<code>std::bind</code> 等）包装成统一的 <code>void()</code> 类型。模板无法在此情况下直接工作，因为 <strong>你已经失去了任务类型的详细信息</strong>。</p>
<p>例如，假设你希望支持有返回值的任务（比如 <code>int task() &#123; return 42; &#125;</code>）。但是 <code>std::function&lt;void()&gt;</code> 无法包装带返回值的任务（如 <code>std::function&lt;int()&gt;</code>）。要处理这种情况，你就需要 <strong>模板化</strong> 任务类型（例如，使用 <code>std::future</code> 来返回任务结果）。</p>
</li>
<li><p><strong>模板无法在运行时推导</strong>：<br>模板是在编译时实例化的，而 <code>std::function&lt;void()&gt;</code> 是一种 <strong>运行时的封装</strong>。在编译时，模板知道任务类型，但是在运行时 <code>std::function</code> 执行了类型擦除。你只能在编译期确定模板参数类型，而在运行时你必须通过 <code>std::function</code> 来调用具体的任务。所以，当你将任务存储到 <code>std::function&lt;void()&gt;</code> 中后，任务的实际类型就被“隐藏”了。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="模板成员函数的编译原理"><a href="#模板成员函数的编译原理" class="headerlink" title="模板成员函数的编译原理"></a>模板成员函数的编译原理</h2><p>当你写下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">pool.<span class="built_in">enqueue</span>([] &#123; std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span>; &#125;);</span><br></pre></td></tr></table></figure>

<p>编译器会自动为该 lambda 类型（假设是 <code>lambda_type_123</code>）实例化 <code>enqueue</code> 的一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ThreadPool::<span class="built_in">enqueue</span>&lt;lambda_type_123&gt;(lambda_type_123&amp;&amp; f);</span><br></pre></td></tr></table></figure>

<p>如果你下一次又传入另一个类型（比如 <code>std::function&lt;void()&gt;</code>），<br>编译器会自动生成新的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ThreadPool::enqueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt;(std::function&lt;<span class="built_in">void</span>()&gt;&amp;&amp; f);</span><br></pre></td></tr></table></figure>

<p>这样线程池就能通用地支持各种任务类型，但不需要为每种任务类型创建一个不同的线程池类。</p>
<hr>
<h2 id="为什么不能让整个类模板化？"><a href="#为什么不能让整个类模板化？" class="headerlink" title="为什么不能让整个类模板化？"></a>为什么不能让整个类模板化？</h2><p>你当然可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但那样意味着：</p>
<ul>
<li>每种任务类型都要生成一个新的线程池类型（例如 <code>ThreadPool&lt;void(*)()&gt;</code>、<code>ThreadPool&lt;lambda_type&gt;</code>）。</li>
<li>不同类型任务的线程池无法共存或共享任务队列。</li>
</ul>
<p>这完全违背了线程池的设计初衷 ——<br><strong>“统一管理任务”</strong>。</p>
<p>因此，只有 <code>enqueue()</code> 需要模板化，而类本身保持非模板。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>模板</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树及其遍历</title>
    <url>/2024/09/25/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h1><h3 id="以下是实现该结构并进行中序遍历的代码："><a href="#以下是实现该结构并进行中序遍历的代码：" class="headerlink" title="以下是实现该结构并进行中序遍历的代码："></a>以下是实现该结构并进行中序遍历的代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线索二叉树节点的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;                      <span class="comment">// 节点的值</span></span><br><span class="line">    ThreadedNode* left;             <span class="comment">// 指向左子节点</span></span><br><span class="line">    ThreadedNode* right;            <span class="comment">// 指向右子节点</span></span><br><span class="line">    <span class="type">bool</span> lThread;                   <span class="comment">// 左指针是否为线索</span></span><br><span class="line">    <span class="type">bool</span> rThread;                   <span class="comment">// 右指针是否为线索</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化节点值，并将左右指针初始化为空，线索标志初始化为 false</span></span><br><span class="line">    <span class="built_in">ThreadedNode</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">lThread</span>(<span class="literal">false</span>), <span class="built_in">rThread</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点并构建线索二叉树的函数</span></span><br><span class="line"><span class="function">ThreadedNode* <span class="title">insert</span><span class="params">(ThreadedNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新节点</span></span><br><span class="line">    ThreadedNode* newNode = <span class="keyword">new</span> <span class="built_in">ThreadedNode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树为空，直接返回新节点作为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `current` 用于跟踪当前节点，`parent` 用于跟踪当前节点的父节点</span></span><br><span class="line">    ThreadedNode* current = root;</span><br><span class="line">    ThreadedNode* parent = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要插入的位置</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        parent = current;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入左子树</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; current-&gt;value) &#123;</span><br><span class="line">            <span class="comment">// 如果左指针不是线索，继续向左子树移动</span></span><br><span class="line">            <span class="keyword">if</span> (!current-&gt;lThread)</span><br><span class="line">                current = current-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 遇到线索停止</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 插入右子树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果右指针不是线索，继续向右子树移动</span></span><br><span class="line">            <span class="keyword">if</span> (!current-&gt;rThread)</span><br><span class="line">                current = current-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 遇到线索停止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据值的大小决定插入到左子树还是右子树</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; parent-&gt;value) &#123;</span><br><span class="line">        <span class="comment">// 左子树插入</span></span><br><span class="line">        newNode-&gt;left = parent-&gt;left;  <span class="comment">// 新节点的左指针指向父节点的左指针</span></span><br><span class="line">        newNode-&gt;right = parent;       <span class="comment">// 新节点的右指针指向父节点</span></span><br><span class="line">        parent-&gt;lThread = <span class="literal">false</span>;       <span class="comment">// 插入后，父节点的左指针不再是线索</span></span><br><span class="line">        parent-&gt;left = newNode;        <span class="comment">// 父节点的左子树变为新节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 右子树插入</span></span><br><span class="line">        newNode-&gt;right = parent-&gt;right; <span class="comment">// 新节点的右指针指向父节点的右指针</span></span><br><span class="line">        newNode-&gt;left = parent;         <span class="comment">// 新节点的左指针指向父节点</span></span><br><span class="line">        parent-&gt;rThread = <span class="literal">false</span>;        <span class="comment">// 插入后，父节点的右指针不再是线索</span></span><br><span class="line">        parent-&gt;right = newNode;        <span class="comment">// 父节点的右子树变为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到中序遍历的起点（即最左边的节点）</span></span><br><span class="line"><span class="function">ThreadedNode* <span class="title">leftmost</span><span class="params">(ThreadedNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 一直移动到没有左子节点的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!node-&gt;lThread) </span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线索化二叉树的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraversal</span><span class="params">(ThreadedNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最左边的节点开始</span></span><br><span class="line">    ThreadedNode* current = <span class="built_in">leftmost</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个树</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出当前节点的值</span></span><br><span class="line">        cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点的右指针是线索，直接跳到下一个中序节点</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;rThread)</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则找到当前节点右子树中的最左节点</span></span><br><span class="line">            current = <span class="built_in">leftmost</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadedNode* root = <span class="literal">nullptr</span>;  <span class="comment">// 创建一个空的线索二叉树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点，构建线索二叉树</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">5</span>);  <span class="comment">// 插入根节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">3</span>);  <span class="comment">// 插入左子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">8</span>);  <span class="comment">// 插入右子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">2</span>);  <span class="comment">// 插入左子树中的左子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">4</span>);  <span class="comment">// 插入左子树中的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化后的中序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrderTraversal</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a>代码说明：</h3><ol>
<li><p><strong>树的结构</strong>：</p>
<ul>
<li>我们插入节点顺序为 <code>5, 3, 8, 2, 4</code>，构造如下的树：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>中序遍历顺序</strong>：</p>
<ul>
<li>中序遍历的顺序是：<strong>先访问左子树，再访问根节点，最后访问右子树</strong>.</li>
<li>对于这棵树的中序遍历顺序是：<code>2 3 4 5 8</code>.</li>
</ul>
</li>
<li><p><strong>关键函数</strong>：</p>
<ul>
<li><code>insert</code>：在二叉树中插入节点，同时维护线索化指针.</li>
<li><code>leftmost</code>：寻找中序遍历中最左边的节点，作为遍历起点.</li>
<li><code>inOrderTraversal</code>：通过线索化指针进行中序遍历.</li>
</ul>
</li>
</ol>
<h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><p>运行此代码，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中序遍历: 2 3 4 5 8</span><br></pre></td></tr></table></figure>

<h1 id="线索化二叉树解释："><a href="#线索化二叉树解释：" class="headerlink" title="线索化二叉树解释："></a>线索化二叉树解释：</h1><h3 id="1-初始状态："><a href="#1-初始状态：" class="headerlink" title="1. 初始状态："></a>1. <strong>初始状态</strong>：</h3><p>我们创建了一个空的线索二叉树 <code>root</code>，即 <code>root = nullptr</code>.</p>
<h3 id="2-插入节点-5："><a href="#2-插入节点-5：" class="headerlink" title="2. 插入节点 5："></a>2. <strong>插入节点 5</strong>：</h3><ul>
<li>调用 <code>insert(root, 5)</code>.</li>
<li>因为 <code>root</code> 是 <code>nullptr</code>，直接返回新节点 <code>5</code> 作为根节点.此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></li>
<li><code>5</code> 没有子节点，也没有线索.</li>
</ul>
<h3 id="3-插入节点-3："><a href="#3-插入节点-3：" class="headerlink" title="3. 插入节点 3："></a>3. <strong>插入节点 3</strong>：</h3><ul>
<li>调用 <code>insert(root, 3)</code>，即在节点 <code>5</code> 的基础上插入.</li>
<li><code>3 &lt; 5</code>，因此我们将其插入到 <code>5</code> 的左子树中.</li>
<li>节点 <code>3</code> 的右指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  5 (线索)</span><br></pre></td></tr></table></figure></li>
<li><code>5</code> 的左指针不再是线索，它现在有一个真正的左子树（节点 <code>3</code>）.</li>
</ul>
<h3 id="4-插入节点-8："><a href="#4-插入节点-8：" class="headerlink" title="4. 插入节点 8："></a>4. <strong>插入节点 8</strong>：</h3><ul>
<li>调用 <code>insert(root, 8)</code>，即在当前树结构上插入.</li>
<li><code>8 &gt; 5</code>，因此我们将其插入到节点 <code>5</code> 的右子树中.</li>
<li>节点 <code>8</code> 的左指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">3   8</span><br><span class="line"> \</span><br><span class="line">  5 (线索)</span><br><span class="line">  8 (线索)</span><br></pre></td></tr></table></figure></li>
<li>节点 <code>5</code> 的右指针现在指向真正的右子树（节点 <code>8</code>）.</li>
</ul>
<h3 id="5-插入节点-2："><a href="#5-插入节点-2：" class="headerlink" title="5. 插入节点 2："></a>5. <strong>插入节点 2</strong>：</h3><ul>
<li>调用 <code>insert(root, 2)</code>，即在当前树结构上插入.</li>
<li><code>2 &lt; 5</code>，继续向左走，<code>2 &lt; 3</code>，因此我们将其插入到节点 <code>3</code> 的左子树中.</li>
<li>节点 <code>2</code> 的右指针作为线索指向节点 <code>3</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   5 (线索)</span><br><span class="line"> \</span><br><span class="line">  3 (线索)</span><br></pre></td></tr></table></figure></li>
<li>节点 <code>3</code> 的左指针不再是线索，它现在有一个真正的左子树（节点 <code>2</code>）.</li>
</ul>
<h3 id="6-插入节点-4："><a href="#6-插入节点-4：" class="headerlink" title="6. 插入节点 4："></a>6. <strong>插入节点 4</strong>：</h3><ul>
<li>调用 <code>insert(root, 4)</code>，即在当前树结构上插入.</li>
<li><code>4 &lt; 5</code>，继续向左走，<code>4 &gt; 3</code>，因此我们将其插入到节点 <code>3</code> 的右子树中.</li>
<li>节点 <code>4</code> 的右指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br><span class="line">\	 \</span><br><span class="line">3(线) 5 (线索)</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-树的最终结构："><a href="#7-树的最终结构：" class="headerlink" title="7. 树的最终结构："></a>7. <strong>树的最终结构</strong>：</h3><p>经过上述插入操作，最终树的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br></pre></td></tr></table></figure>

<ul>
<li>左子树是：<code>3 -&gt; 2, 3 -&gt; 4</code>，并且线索指向相应的节点.</li>
</ul>
<h3 id="8-中序遍历过程："><a href="#8-中序遍历过程：" class="headerlink" title="8. 中序遍历过程："></a>8. <strong>中序遍历过程</strong>：</h3><h4 id="步骤-1：找到最左边的节点"><a href="#步骤-1：找到最左边的节点" class="headerlink" title="步骤 1：找到最左边的节点"></a>步骤 1：找到最左边的节点</h4><ul>
<li>调用 <code>leftmost(root)</code>，找到树中最左边的节点，即 <code>2</code>.</li>
</ul>
<h4 id="步骤-2：遍历中序节点"><a href="#步骤-2：遍历中序节点" class="headerlink" title="步骤 2：遍历中序节点"></a>步骤 2：遍历中序节点</h4><ul>
<li>当前节点是 <code>2</code>，输出 <code>2</code>，然后查看 <code>2</code> 的右指针，发现它是线索指向节点 <code>3</code>，因此移动到节点 <code>3</code>.</li>
<li>当前节点是 <code>3</code>，输出 <code>3</code>，然后查看 <code>3</code> 的右指针，发现它指向节点 <code>4</code>，移动到节点 <code>4</code>.</li>
<li>当前节点是 <code>4</code>，输出 <code>4</code>，然后查看 <code>4</code> 的右指针，发现它是线索，指向节点 <code>5</code>，移动到节点 <code>5</code>.</li>
<li>当前节点是 <code>5</code>，输出 <code>5</code>，然后查看 <code>5</code> 的右指针，指向真正的右子树，找到最左边的节点 <code>8</code>.</li>
<li>当前节点是 <code>8</code>，输出 <code>8</code>，然后它没有右子树或线索，遍历结束.</li>
</ul>
<h3 id="9-中序遍历输出："><a href="#9-中序遍历输出：" class="headerlink" title="9. 中序遍历输出："></a>9. <strong>中序遍历输出</strong>：</h3><p>最终中序遍历输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 5 8</span><br></pre></td></tr></table></figure>

<p>这就是整个代码的运行过程和中序遍历结果.</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2025/06/29/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<ul>
<li><h1 id="线程池（Thread-Pool）与-C-实现"><a href="#线程池（Thread-Pool）与-C-实现" class="headerlink" title="线程池（Thread Pool）与 C++ 实现"></a>线程池（Thread Pool）与 C++ 实现</h1><h2 id="1-什么是线程池？"><a href="#1-什么是线程池？" class="headerlink" title="1. 什么是线程池？"></a>1. <strong>什么是线程池？</strong></h2><p>线程池是一种多线程编程模式，用于管理一组预先创建的线程，以高效执行多个任务。它通过复用线程避免频繁创建和销毁线程的开销，适合处理大量短生命周期任务的场景。</p>
<h3 id="线程池的核心思想"><a href="#线程池的核心思想" class="headerlink" title="线程池的核心思想"></a><strong>线程池的核心思想</strong></h3><ul>
<li><strong>预分配线程</strong>：启动时创建固定数量的线程，保持空闲状态等待任务。</li>
<li><strong>任务队列</strong>：将待执行的任务放入队列，线程从队列中获取任务执行。</li>
<li><strong>线程复用</strong>：任务完成后，线程不销毁，而是返回线程池等待新任务。</li>
<li><strong>负载均衡</strong>：多个线程并行处理任务，提高并发性能。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li><strong>性能提升</strong>：减少线程创建&#x2F;销毁的开销（创建线程可能需要数百微秒）。</li>
<li><strong>资源管理</strong>：限制线程数量，防止系统资源耗尽。</li>
<li><strong>任务管理</strong>：通过队列管理任务，支持优先级或异步执行。</li>
<li><strong>可扩展性</strong>：适合动态调整任务负载。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li>Web 服务器处理 HTTP 请求。</li>
<li>数据库查询并行处理。</li>
<li>批量任务处理（如图像处理、文件解析）。</li>
<li>实时计算任务（如游戏服务器）。</li>
</ul>
<h2 id="2-C-线程池实现"><a href="#2-C-线程池实现" class="headerlink" title="2. C++ 线程池实现"></a>2. <strong>C++ 线程池实现</strong></h2><p>C++11 及以上提供了 <code>&lt;thread&gt;</code>、<code>&lt;mutex&gt;</code>、<code>&lt;condition_variable&gt;</code> 等工具，方便实现线程池。以下是一个简单的线程池实现，支持任务提交和线程管理。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">size_t</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建指定数量的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">            workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 获取锁，等待任务</span></span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">                        condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>; <span class="comment">// 线程池停止且无任务</span></span><br><span class="line">                        task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">                        tasks.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            tasks.<span class="built_in">emplace</span>([f, args...]() &#123; <span class="built_in">f</span>(args...); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        condition_.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，停止线程池</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        condition_.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        <span class="keyword">for</span> (std::thread&amp; worker : workers) &#123;</span><br><span class="line">            worker.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers; <span class="comment">// 线程池中的线程</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks; <span class="comment">// 任务队列</span></span><br><span class="line">    std::mutex mutex_; <span class="comment">// 互斥锁，保护任务队列</span></span><br><span class="line">    std::condition_variable condition_; <span class="comment">// 条件变量，用于线程同步</span></span><br><span class="line">    <span class="type">bool</span> stop; <span class="comment">// 停止标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包含 4 个线程的线程池</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        pool.<span class="built_in">enqueue</span>([i] &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is running on thread &quot;</span></span><br><span class="line">                      &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池析构时自动等待所有任务完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a><strong>代码说明</strong></h3><ol>
<li><p><strong>线程池结构</strong>：</p>
<ul>
<li><code>workers</code>：存储线程的向量，初始化时创建固定数量的线程。</li>
<li><code>tasks</code>：任务队列，存储待执行的函数（<code>std::function&lt;void()&gt;</code>）。</li>
<li><code>mutex_</code>：保护任务队列的互斥锁，确保线程安全。</li>
<li><code>condition_</code>：条件变量，用于线程等待和唤醒。</li>
<li><code>stop</code>：标志线程池是否停止。</li>
</ul>
</li>
<li><p><strong>工作流程</strong>：</p>
<ul>
<li><strong>构造函数</strong>：创建 <code>numThreads</code> 个线程，每个线程循环等待任务。</li>
<li><strong>任务提交（<code>enqueue</code>）</strong>：将任务（函数+参数）封装为 <code>std::function</code>，放入队列，并通知一个线程。</li>
<li><strong>线程执行</strong>：线程从队列获取任务，执行后继续等待新任务。</li>
<li><strong>析构函数</strong>：设置 <code>stop</code> 标志，唤醒所有线程并等待它们结束。</li>
</ul>
</li>
<li><p><strong>关键技术</strong>：</p>
<ul>
<li><strong>C++11 特性</strong>：<ul>
<li><code>std::thread</code>：创建和管理线程。</li>
<li><code>std::mutex</code> 和 <code>std::unique_lock</code>：线程同步。</li>
<li><code>std::condition_variable</code>：线程等待&#x2F;通知机制。</li>
<li><code>std::function</code> 和 lambda：封装任意可调用对象。</li>
</ul>
</li>
<li><strong>线程安全</strong>：通过锁保护任务队列，防止数据竞争。</li>
<li><strong>任务泛化</strong>：使用模板和变参模板（<code>Args&amp;&amp;... args</code>）支持任意函数和参数。</li>
</ul>
</li>
</ol>
<h1 id="线程池中的条件变量和可变参数详解"><a href="#线程池中的条件变量和可变参数详解" class="headerlink" title="线程池中的条件变量和可变参数详解"></a>线程池中的条件变量和可变参数详解</h1><p>在上述线程池实现中，<strong>条件变量</strong>（<code>std::condition_variable</code>）和<strong>可变参数模板</strong>（<code>Args&amp;&amp;... args</code>）是关键技术点。由于你提到未学过相关概念，我会详细讲解这两个部分的原理、作用和代码实现，结合线程池的上下文，确保通俗易懂。</p>
<h2 id="1-条件变量（std-condition-variable）"><a href="#1-条件变量（std-condition-variable）" class="headerlink" title="1. 条件变量（std::condition_variable）"></a>1. <strong>条件变量（<code>std::condition_variable</code>）</strong></h2><h3 id="1-1-什么是条件变量？"><a href="#1-1-什么是条件变量？" class="headerlink" title="1.1 什么是条件变量？"></a><strong>1.1 什么是条件变量？</strong></h3><p>条件变量是 C++11 提供的一种同步原语，用于线程间的协调，解决“线程等待特定条件成立”的问题。它通常与互斥锁（<code>std::mutex</code>）一起使用，允许线程在条件不满足时等待，并在条件满足时被唤醒。</p>
<ul>
<li><strong>作用</strong>：在线程池中，条件变量用于：<ul>
<li>让空闲线程等待任务队列中有新任务。</li>
<li>通知工作线程有新任务可执行。</li>
</ul>
</li>
<li><strong>为什么需要？</strong>：没有条件变量，线程可能需要通过轮询（不断检查队列）来判断是否有任务，浪费 CPU 资源。条件变量让线程高效等待，节省资源。</li>
</ul>
<h3 id="1-2-条件变量的核心机制"><a href="#1-2-条件变量的核心机制" class="headerlink" title="1.2 条件变量的核心机制"></a><strong>1.2 条件变量的核心机制</strong></h3><ul>
<li><strong>等待（<code>wait</code>）</strong>：线程调用 <code>condition_.wait(lock, predicate)</code>，检查条件（<code>predicate</code>）是否满足：<ul>
<li>如果条件不满足，线程释放锁并进入阻塞状态（休眠）。</li>
<li>如果条件满足，线程继续执行。</li>
</ul>
</li>
<li><strong>通知（<code>notify_one</code>&#x2F;<code>notify_all</code>）</strong>：其他线程调用 <code>condition_.notify_one()</code> 或 <code>notify_all()</code> 唤醒一个或所有等待的线程。</li>
<li><strong>配合互斥锁</strong>：条件变量总是与 <code>std::mutex</code> 和 <code>std::unique_lock</code> 配合使用，确保线程安全访问共享资源（如任务队列）。</li>
</ul>
<h3 id="1-3-线程池中的使用"><a href="#1-3-线程池中的使用" class="headerlink" title="1.3 线程池中的使用"></a><strong>1.3 线程池中的使用</strong></h3><p>在线程池代码中，条件变量用于管理线程等待和任务分配。以下是相关代码的详细解释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mutex_; <span class="comment">// 互斥锁，保护任务队列</span></span><br><span class="line">std::condition_variable condition_; <span class="comment">// 条件变量，用于线程同步</span></span><br><span class="line">std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks; <span class="comment">// 任务队列</span></span><br><span class="line"><span class="type">bool</span> stop; <span class="comment">// 停止标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池构造函数中的工作线程</span></span><br><span class="line">workers.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">            condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">            <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>; <span class="comment">// 线程池停止且无任务</span></span><br><span class="line">            task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">            tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">task</span>(); <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a><strong>代码分析</strong></h4><ol>
<li><p><strong>等待任务</strong>：</p>
<ul>
<li>每个工作线程运行一个无限循环，尝试从任务队列 <code>tasks</code> 获取任务。</li>
<li>在 <code>condition_.wait(lock, [this] &#123; return stop || !tasks.empty(); &#125;)</code> 中：<ul>
<li><code>lock</code> 是 <code>std::unique_lock&lt;std::mutex&gt;</code>，用于锁定 <code>mutex_</code>，保护任务队列。</li>
<li>谓词（<code>[this] &#123; return stop || !tasks.empty(); &#125;</code>）检查条件：<ul>
<li>如果 <code>stop</code> 为 <code>true</code>（线程池停止）或队列非空（有任务），条件满足，线程继续执行。</li>
<li>否则，线程释放 <code>mutex_</code> 并进入阻塞状态，等待通知。</li>
</ul>
</li>
</ul>
</li>
<li>阻塞时，线程不消耗 CPU 资源，效率高。</li>
</ul>
</li>
<li><p><strong>获取任务</strong>：</p>
<ul>
<li>当条件满足（队列有任务或线程池停止），线程被唤醒，重新获取 <code>mutex_</code>。</li>
<li>从队列中取出任务（<code>tasks.front()</code>），移除（<code>tasks.pop()</code>），然后释放锁。</li>
</ul>
</li>
<li><p><strong>任务提交中的通知</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        tasks.<span class="built_in">emplace</span>([f, args...]() &#123; <span class="built_in">f</span>(args...); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition_.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个线程执行任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提交任务时，锁定 <code>mutex_</code>，将任务加入队列。</li>
<li>调用 <code>condition_.notify_one()</code>，唤醒一个等待的线程（如果有线程在等待）。</li>
<li>唤醒的线程会检查条件（队列非空），获取任务并执行。</li>
</ul>
</li>
</ol>
<h4 id="为什么用-std-unique-lock-而不是-std-lock-guard？"><a href="#为什么用-std-unique-lock-而不是-std-lock-guard？" class="headerlink" title="为什么用 std::unique_lock 而不是 std::lock_guard？"></a><strong>为什么用 <code>std::unique_lock</code> 而不是 <code>std::lock_guard</code>？</strong></h4><ul>
<li><code>std::unique_lock</code> 支持在 <code>wait</code> 时临时释放锁（<code>wait</code> 会自动解锁 <code>mutex_</code> 并在唤醒时重新加锁），而 <code>std::lock_guard</code> 不支持这种灵活性。</li>
<li><code>std::unique_lock</code> 提供了更细粒度的锁管理，适合条件变量场景。</li>
</ul>
<h4 id="为什么用谓词（predicate）？"><a href="#为什么用谓词（predicate）？" class="headerlink" title="为什么用谓词（predicate）？"></a><strong>为什么用谓词（predicate）？</strong></h4><ul>
<li><code>condition_.wait(lock, predicate)</code> 的谓词防止<strong>伪唤醒</strong>（spurious wakeup）。有时线程可能被意外唤醒，即使条件不满足。谓词确保线程只在条件真正满足时继续执行。</li>
</ul>
<h3 id="1-4-条件变量的优势"><a href="#1-4-条件变量的优势" class="headerlink" title="1.4 条件变量的优势"></a><strong>1.4 条件变量的优势</strong></h3><ul>
<li><strong>高效</strong>：线程休眠时不占用 CPU，相比轮询更节省资源。</li>
<li><strong>线程安全</strong>：与互斥锁结合，确保任务队列访问安全。</li>
<li><strong>灵活性</strong>：支持动态任务分配，线程池可以处理任意数量的任务。</li>
</ul>
<h3 id="1-5-注意事项"><a href="#1-5-注意事项" class="headerlink" title="1.5 注意事项"></a><strong>1.5 注意事项</strong></h3><ul>
<li><strong>必须加锁</strong>：调用 <code>wait</code> 或 <code>notify</code> 时，必须持有互斥锁。</li>
<li><strong>伪唤醒</strong>：总是使用谓词检查条件，避免意外唤醒导致错误。</li>
<li><strong>通知时机</strong>：<code>notify_one</code> 或 <code>notify_all</code> 需在修改条件（如添加任务）后调用。</li>
</ul>
<h2 id="2-可变参数模板（Args-args）"><a href="#2-可变参数模板（Args-args）" class="headerlink" title="2. 可变参数模板（Args&amp;&amp;... args）"></a>2. <strong>可变参数模板（<code>Args&amp;&amp;... args</code>）</strong></h2><h3 id="2-1-什么是可变参数模板？"><a href="#2-1-什么是可变参数模板？" class="headerlink" title="2.1 什么是可变参数模板？"></a><strong>2.1 什么是可变参数模板？</strong></h3><p>可变参数模板（Variadic Templates）是 C++11 引入的特性，允许函数或类模板接受任意数量的参数（类型或值）。在线程池中，它用于让 <code>enqueue</code> 函数支持任意类型和数量的参数，灵活提交不同类型的任务。</p>
<ul>
<li><strong>语法</strong>：<ul>
<li><code>typename... Args</code>：表示任意数量的类型参数。</li>
<li><code>Args&amp;&amp;... args</code>：表示任意数量的实际参数（支持左值和右值）。</li>
<li><code>...</code> 是参数包（parameter pack），可以展开为多个参数。</li>
</ul>
</li>
</ul>
<h3 id="2-2-线程池中的使用"><a href="#2-2-线程池中的使用" class="headerlink" title="2.2 线程池中的使用"></a><strong>2.2 线程池中的使用</strong></h3><p>在 <code>enqueue</code> 函数中，可变参数模板用于封装任务函数及其参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        tasks.<span class="built_in">emplace</span>([f, args...]() &#123; <span class="built_in">f</span>(args...); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    condition_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a><strong>代码分析</strong></h4><ol>
<li><p><strong>函数签名</strong>：</p>
<ul>
<li><code>F&amp;&amp; f</code>：表示任务函数（可以是函数指针、lambda、仿函数等），使用<strong>通用引用</strong>（<code>&amp;&amp;</code>）支持左值和右值。</li>
<li><code>Args&amp;&amp;... args</code>：表示任意数量的参数，传递给任务函数 <code>f</code>。</li>
<li>例如，调用 <code>pool.enqueue(func, 1, 2.0, &quot;hello&quot;)</code> 时：<ul>
<li><code>F</code> 是 <code>func</code> 的类型。</li>
<li><code>Args</code> 是 <code>&#123;int, double, const char*&#125;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>任务封装</strong>：</p>
<ul>
<li><code>[f, args...]() &#123; f(args...); &#125;</code> 是一个 lambda 表达式：<ul>
<li>捕获：<code>[f, args...]</code> 捕获函数 <code>f</code> 和所有参数 <code>args</code>（按值捕获）。</li>
<li>执行体：<code>f(args...)</code> 调用函数 <code>f</code>，将参数包 <code>args...</code> 展开传递。</li>
</ul>
</li>
<li>lambda 被封装为 <code>std::function&lt;void()&gt;</code>，存储到任务队列 <code>tasks</code>。</li>
</ul>
</li>
<li><p><strong>参数展开</strong>：</p>
<ul>
<li><code>args...</code> 是参数包展开操作，将参数逐一传递给 <code>f</code>。</li>
<li>例如，若 <code>args</code> 包含 <code>&#123;1, 2.0, &quot;hello&quot;&#125;</code>，则 <code>f(args...)</code> 等价于 <code>f(1, 2.0, &quot;hello&quot;)</code>。</li>
</ul>
</li>
</ol>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y, <span class="type">const</span> <span class="type">char</span>* z)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    pool.<span class="built_in">enqueue</span>(print, <span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="comment">// 任务执行时，调用 print(42, 3.14, &quot;hello&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-可变参数模板的优势"><a href="#2-3-可变参数模板的优势" class="headerlink" title="2.3 可变参数模板的优势"></a><strong>2.3 可变参数模板的优势</strong></h3><ul>
<li><strong>灵活性</strong>：支持任意数量和类型的参数，无需为不同参数个数定义多个重载。</li>
<li><strong>类型安全</strong>：模板推导确保参数类型正确，编译期检查错误。</li>
<li><strong>通用性</strong>：结合 <code>std::function</code> 和 lambda，线程池可处理任何可调用对象及其参数。</li>
</ul>
<h3 id="2-4-工作原理（展开参数包）"><a href="#2-4-工作原理（展开参数包）" class="headerlink" title="2.4 工作原理（展开参数包）"></a><strong>2.4 工作原理（展开参数包）</strong></h3><p>可变参数模板的展开依赖递归或直接展开：</p>
<ul>
<li><strong>直接展开</strong>：如 <code>f(args...)</code>，C++ 编译器自动将参数包展开为 <code>f(arg1, arg2, ..., argN)</code>。</li>
<li><strong>递归展开</strong>（若需要更复杂处理）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">(F&amp;&amp; f, T&amp;&amp; t)</span> </span>&#123; <span class="built_in">f</span>(t); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">(F&amp;&amp; f, T&amp;&amp; t, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(t);</span><br><span class="line">    <span class="built_in">call</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
线程池中直接使用 lambda 展开，简洁高效。</li>
</ul>
<h3 id="2-5-注意事项"><a href="#2-5-注意事项" class="headerlink" title="2.5 注意事项"></a><strong>2.5 注意事项</strong></h3><ul>
<li><strong>完美转发</strong>：使用 <code>std::forward&lt;Args&gt;(args)...</code> 确保参数以原始类型（左值&#x2F;右值）传递，保留性能和语义。</li>
<li><strong>编译开销</strong>：大量使用可变参数模板可能增加编译时间。</li>
<li><strong>lambda 捕获</strong>：捕获参数时注意生命周期，确保参数在任务执行时有效。</li>
</ul>
<h2 id="3-结合线程池的整体理解"><a href="#3-结合线程池的整体理解" class="headerlink" title="3. 结合线程池的整体理解"></a>3. <strong>结合线程池的整体理解</strong></h2><ul>
<li><strong>条件变量</strong>：<ul>
<li>作用：让线程高效等待任务，节省 CPU 资源。</li>
<li>实现：通过 <code>condition_.wait</code> 和 <code>notify_one</code> 协调线程与任务队列。</li>
<li>关键点：与 <code>std::mutex</code> 配合，防止伪唤醒。</li>
</ul>
</li>
<li><strong>可变参数模板</strong>：<ul>
<li>作用：让 <code>enqueue</code> 函数灵活接受任意任务函数和参数。</li>
<li>实现：通过 <code>Args&amp;&amp;... args</code> 和 lambda 封装任务，存储到队列。</li>
<li>关键点：参数包展开和完美转发确保通用性和效率。</li>
</ul>
</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ol>
<li>用户通过 <code>enqueue</code> 提交任务（如 <code>print(42, 3.14, &quot;hello&quot;)</code>），任务被封装为 lambda 存入队列。</li>
<li>条件变量通知一个等待线程（<code>notify_one</code>）。</li>
<li>线程被唤醒，检查队列非空（<code>!tasks.empty()</code>），取出任务并执行。</li>
<li>可变参数模板确保任务函数和参数正确传递，执行 <code>print(42, 3.14, &quot;hello&quot;)</code>。</li>
</ol>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h2><ul>
<li><strong>条件变量</strong>：解决了线程等待任务的问题，通过 <code>wait</code> 和 <code>notify</code> 实现高效同步，核心是与互斥锁配合和谓词检查。</li>
<li><strong>可变参数模板</strong>：提供了灵活的任务提交接口，支持任意函数和参数，通过参数包展开和 lambda 实现通用性。</li>
<li><strong>线程池中的结合</strong>：条件变量管理线程调度，可变参数模板支持多样化任务，共同实现高效、灵活的并发任务处理。</li>
</ul>
<h1 id="线程池中加锁的作用"><a href="#线程池中加锁的作用" class="headerlink" title="线程池中加锁的作用"></a>线程池中加锁的作用</h1><h2 id="1-加锁的作用"><a href="#1-加锁的作用" class="headerlink" title="1. 加锁的作用"></a>1. <strong>加锁的作用</strong></h2><p>在线程池实现中，<code>std::mutex</code> 和 <code>std::unique_lock</code> 用于保护共享资源（主要是任务队列 <code>tasks</code>），确保线程安全。加锁的主要作用如下：</p>
<h3 id="1-1-保护任务队列的线程安全"><a href="#1-1-保护任务队列的线程安全" class="headerlink" title="1.1 保护任务队列的线程安全"></a><strong>1.1 保护任务队列的线程安全</strong></h3><p>任务队列 <code>std::queue&lt;std::function&lt;void()&gt;&gt; tasks</code> 是所有线程共享的资源，多个线程可能同时访问它（例如，一个线程添加任务，另一个线程取出任务）。没有锁的保护，可能会导致以下问题：</p>
<ul>
<li><strong>数据竞争（Data Race）</strong>：多个线程同时读写队列，可能导致数据损坏或未定义行为。例如，一个线程在 <code>tasks.pop()</code> 时，另一个线程也在修改队列，可能导致崩溃。</li>
<li><strong>不一致性</strong>：线程可能读取到不完整的任务数据，或任务被意外重复执行。</li>
</ul>
<p><strong>加锁的解决办法</strong>：</p>
<ul>
<li><p>使用 <code>std::mutex mutex_</code> 和 <code>std::unique_lock&lt;std::mutex&gt; lock(mutex_)</code> 确保同一时间只有一个线程能访问任务队列。</p>
</li>
<li><p>例如，在函数中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    tasks.<span class="built_in">emplace</span>([f, args...]() &#123; <span class="built_in">f</span>(args...); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁后，<code>tasks.emplace</code> 操作是线程安全的，其他线程无法同时修改队列。</li>
</ul>
</li>
<li><p>在工作线程中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">    <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">    tasks.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>加锁确保 <code>tasks.front()</code> 和 <code>tasks.pop()</code> 操作不会被其他线程干扰。</li>
</ul>
</li>
</ul>
<h3 id="1-2-配合条件变量同步"><a href="#1-2-配合条件变量同步" class="headerlink" title="1.2 配合条件变量同步"></a><strong>1.2 配合条件变量同步</strong></h3><p>条件变量（<code>std::condition_variable</code>）需要与互斥锁一起使用，<code>std::unique_lock</code> 在 <code>condition_.wait</code> 时会临时释放锁，并在唤醒时重新加锁：</p>
<ul>
<li><p><strong>等待时释放锁</strong>：当线程调用 <code>condition_.wait(lock, ...)</code> 时，<code>lock</code> 自动解锁，允许其他线程访问队列（例如添加任务）。</p>
</li>
<li><p><strong>唤醒时重新加锁</strong>：线程被唤醒后，<code>lock</code> 重新锁定，确保安全访问队列。</p>
</li>
<li><p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>等待期间，<code>mutex_</code> 被释放，其他线程可以添加任务。</li>
<li>唤醒后，<code>mutex_</code> 被重新锁定，线程安全地取出任务。</li>
</ul>
</li>
</ul>
<h3 id="1-3-防止伪唤醒的影响"><a href="#1-3-防止伪唤醒的影响" class="headerlink" title="1.3 防止伪唤醒的影响"></a><strong>1.3 防止伪唤醒的影响</strong></h3><p>条件变量可能发生<strong>伪唤醒</strong>（线程被意外唤醒，但条件不满足）。加锁确保即使发生伪唤醒，线程在访问队列前会检查条件（如 <code>!tasks.empty()</code>），避免错误操作。</p>
<h3 id="1-4-加锁的作用总结"><a href="#1-4-加锁的作用总结" class="headerlink" title="1.4 加锁的作用总结"></a><strong>1.4 加锁的作用总结</strong></h3><ul>
<li><strong>线程安全</strong>：保护任务队列，防止多线程并发访问导致的数据竞争。</li>
<li><strong>同步协调</strong>：与条件变量配合，管理线程等待和唤醒。</li>
<li><strong>数据一致性</strong>：确保任务的添加和取出操作按预期顺序执行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>条件变量</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>结构化绑定</title>
    <url>/2025/09/23/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="结构化绑定-Structured-Bindings-C-17"><a href="#结构化绑定-Structured-Bindings-C-17" class="headerlink" title="结构化绑定 (Structured Bindings) (C++17)"></a>结构化绑定 (Structured Bindings) (C++17)</h3><p>结构化绑定是 C++17 引入的一项语法糖，它允许你将一个复合类型（如数组、结构体、类、<code>std::pair</code>、<code>std::tuple</code> 等）的成员或元素<strong>解构</strong>到独立的变量中，而无需显式地访问每个成员。这极大地简化了从复合类型中提取数据的代码，提高了可读性。</p>
<p><strong>核心思想：</strong><br>结构化绑定的目标是让代码更简洁、更富有表现力，尤其是在处理返回多个值的函数、遍历 <code>std::map</code> 或处理复杂数据结构时。它本质上是编译器生成的一些代码，将复合类型的值绑定到一系列新的变量上。</p>
<p><strong>语法：</strong><br><code>[[attributes]] decl_specifier_seq ref_binding = expression;</code></p>
<ul>
<li><code>decl_specifier_seq</code>: 类型说明符序列，通常是 <code>auto</code> 或 <code>const auto</code> 等。</li>
<li><code>ref_binding</code>: 绑定列表，形如 <code>[e1, e2, e3, ...]</code>，其中 <code>e1, e2, ...</code> 是你要声明的新变量名。</li>
<li><code>expression</code>: 要解构的复合类型对象。</li>
</ul>
<p><strong>适用场景：</strong></p>
<p>结构化绑定可以用于解构以下几种类型的对象：</p>
<ol>
<li><p><strong>数组：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = arr; <span class="comment">// x=1, y=2, z=3</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl; <span class="comment">// 输出 1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 数组的大小必须在编译时已知。</p>
</li>
<li><p><strong><code>std::pair</code>：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// For std::pair</span></span></span><br><span class="line"></span><br><span class="line">std::pair&lt;<span class="type">int</span>, std::string&gt; p = &#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, name] = p; <span class="comment">// id=1, name=&quot;hello&quot;</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>这在遍历 <code>std::map</code> 时特别有用，因为 <code>std::map</code> 的 <code>value_type</code> 是 <code>std::pair&lt;const Key, Value&gt;</code>。</p>
</li>
<li><p><strong><code>std::tuple</code> (以及 <code>std::array</code>)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span> <span class="comment">// For std::tuple</span></span></span><br><span class="line"></span><br><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; t = &#123;<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = t; <span class="comment">// a=10, b=3.14, c=&quot;world&quot;</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::array 也是类似的</span></span><br><span class="line"><span class="comment">// std::array&lt;int, 3&gt; arr_std = &#123;4,5,6&#125;;</span></span><br><span class="line"><span class="comment">// auto [d, e, f] = arr_std;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结构体和类：</strong><br>对于结构体和类，结构化绑定要求该类型满足以下条件之一：</p>
<ul>
<li><strong>所有非静态数据成员都是公共的。</strong> (最常见和推荐的方式)</li>
<li><strong>具有 <code>std::tuple_size</code> 和 <code>std::tuple_element</code> 特化，并且有 <code>get&lt;i&gt;()</code> 成员函数或非成员函数。</strong> (用于自定义类型，使其行为像元组)</li>
</ul>
<p><strong>示例 (公共数据成员的结构体)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">get_origin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [px, py] = p; <span class="comment">// px=1.0, py=2.0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point: (&quot;</span> &lt;&lt; px &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; py &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数返回值的解构</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> [ox, oy] = <span class="built_in">get_origin</span>(); <span class="comment">// ox=0.0, oy=0.0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Origin: (&quot;</span> &lt;&lt; ox &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; oy &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>典型应用场景：</strong></p>
<ol>
<li><p><strong>遍历 <code>std::map</code> 或 <code>std::unordered_map</code>：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; ages = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [name, age] : ages) &#123; <span class="comment">// 解构每个 pair</span></span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入操作的返回值也可以解构</span></span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] = ages.<span class="built_in">insert</span>(&#123;<span class="string">&quot;David&quot;</span>, <span class="number">40</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;David inserted. Age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;David already exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++17 之前，你需要这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : ages) &#123;</span><br><span class="line">    <span class="type">const</span> std::string&amp; name = pair.first;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; age = pair.second;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构化绑定显然更简洁。</p>
</li>
<li><p><strong>函数返回多个值：</strong><br>当函数需要返回多个相关联的值时，通常会使用 <code>std::pair</code> 或 <code>std::tuple</code>。结构化绑定使得接收这些返回值变得非常方便。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个包含姓名、年龄和性别的元组</span></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">get_person_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">28</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [name, age, gender] = <span class="built_in">get_person_info</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Gender: &quot;</span> &lt;&lt; gender &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理 <code>std::variant</code> 或 <code>std::tuple</code> 的嵌套结构：</strong><br>虽然不能直接解构 <code>std::variant</code>，但可以在 <code>std::visit</code> 的 lambda 表达式中结合使用。</p>
</li>
</ol>
<p><strong>幕后原理 (Compiler Magic)：</strong></p>
<p>结构化绑定并不是真正创建了新的引用或变量到原始对象的成员，而是编译器在幕后做了一些转换。</p>
<p>当编译器看到 <code>auto [x, y] = expr;</code> 时，它大致会做以下事情：</p>
<ol>
<li>创建一个<strong>隐藏的、不可见的变量</strong>来存储 <code>expr</code> 的结果（如果 <code>expr</code> 是一个右值，则移动构造；如果 <code>expr</code> 是一个左值，则复制构造）。这个隐藏变量的类型是 <code>expr</code> 的类型。</li>
<li>然后，<code>x</code> 和 <code>y</code> 实际上是这个隐藏变量的<strong>引用</strong>或<strong>成员访问</strong>。</li>
</ol>
<p>例如，对于 <code>std::pair&lt;int, std::string&gt; p = &#123;1, &quot;hello&quot;&#125;; auto [id, name] = p;</code>，编译器可能生成类似这样的代码（简化版）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 p 是一个左值</span></span><br><span class="line"><span class="keyword">auto</span> __hidden_var = p; <span class="comment">// 复制构造一个隐藏变量</span></span><br><span class="line"><span class="keyword">auto</span>&amp; id = __hidden_var.first;</span><br><span class="line"><span class="keyword">auto</span>&amp; name = __hidden_var.second;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 p 是一个右值，例如 auto [id, name] = std::make_pair(1, &quot;hello&quot;);</span></span><br><span class="line"><span class="comment">// auto __hidden_var = std::make_pair(1, &quot;hello&quot;); // 移动构造一个隐藏变量</span></span><br><span class="line"><span class="comment">// auto&amp; id = __hidden_var.first;</span></span><br><span class="line"><span class="comment">// auto&amp; name = __hidden_var.second;</span></span><br></pre></td></tr></table></figure>

<p><strong>重要的细节：</strong></p>
<ul>
<li><p><strong>类型推断：</strong> <code>auto</code> 是最常见的用法，但你也可以使用 <code>const auto&amp;</code>、<code>auto&amp;&amp;</code> 等。</p>
<ul>
<li><code>auto [x, y] = expr;</code>：<code>x</code> 和 <code>y</code> 是副本。</li>
<li><code>const auto&amp; [x, y] = expr;</code>：<code>x</code> 和 <code>y</code> 是常量引用，绑定到原始对象或隐藏的临时副本。这是最常见的用法，因为它避免了不必要的拷贝。</li>
<li><code>auto&amp; [x, y] = expr;</code>：<code>x</code> 和 <code>y</code> 是非常量引用，可以修改原始对象（如果 <code>expr</code> 是左值）。</li>
<li><code>auto&amp;&amp; [x, y] = expr;</code>：<code>x</code> 和 <code>y</code> 是右值引用，通常用于移动语义。</li>
</ul>
</li>
<li><p><strong>未使用的绑定：</strong> 如果你不需要解构出的所有变量，可以省略它们的名称，但需要保留逗号。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; t = &#123;<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, , c] = t; <span class="comment">// 忽略第二个元素 (double)</span></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl; <span class="comment">// 输出 10, world</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 这种“忽略”在 C++17 中是不标准的，但一些编译器（如 GCC）作为扩展支持。标准 C++20 引入了 <code>[[maybe_unused]]</code> 属性或直接使用 <code>_</code> 作为占位符（虽然 <code>_</code> 只是一个合法的变量名，不是特殊语法）。最标准的方式是给它一个名字，然后用 <code>[[maybe_unused]]</code> 标记。</p>
</li>
<li><p><strong>成员顺序：</strong> 对于结构体和类，绑定变量的顺序必须与数据成员的声明顺序一致。</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><strong>代码简洁性：</strong> 减少了重复的 <code>.first</code>, <code>.second</code>, <code>.get&lt;N&gt;()</code> 调用。</li>
<li><strong>可读性：</strong> 变量名称直接反映了它们所代表的含义，提高了代码的可理解性。</li>
<li><strong>避免错误：</strong> 减少了手动解构时可能出现的拼写错误或索引错误。</li>
<li><strong>与泛型编程的结合：</strong> 在模板中处理返回复合类型的函数时非常有用。</li>
</ul>
<p><strong>缺点&#x2F;注意事项：</strong></p>
<ul>
<li><strong>隐藏的临时对象：</strong> 当解构一个右值时，会创建一个隐藏的临时对象。如果你使用 <code>auto&amp;</code> 或 <code>const auto&amp;</code>，绑定会指向这个临时对象。</li>
<li><strong>无法跳过成员：</strong> 虽然一些编译器支持省略名称，但标准 C++17 不支持。你必须为所有成员提供一个名称（即使只是一个占位符）。</li>
<li><strong>调试：</strong> 在调试时，结构化绑定创建的变量可能不会像普通变量那样直接显示在调试器中，因为它们是编译器生成的内部引用。</li>
</ul>
<p>总而言之，结构化绑定是 C++17 中一个非常受欢迎的特性，它极大地改善了处理复合类型数据的语法和可读性，是现代 C++ 编程中不可或缺的工具。</p>
<ul>
<li><strong><code>std::tuple</code> 存储“所有这些类型”：</strong> 它是一个固定大小的异构容器，可以同时持有多个不同类型的值。你可以想象它是一个结构体，但成员的类型和数量可以在编译时通过模板参数指定。</li>
<li><strong><code>std::variant</code> 存储“这些类型中的一个”：</strong> 它是一个类型安全的联合体（union），在任何给定时间点，它只持有一个指定类型列表中的值。你可以想象它是一个枚举，但每个枚举值可以携带不同类型的数据。</li>
</ul>
<hr>
<h3 id="std-tuple-C-11-14-改进于-C-17-结构化绑定"><a href="#std-tuple-C-11-14-改进于-C-17-结构化绑定" class="headerlink" title="std::tuple (C++11&#x2F;14, 改进于 C++17 结构化绑定)"></a><code>std::tuple</code> (C++11&#x2F;14, 改进于 C++17 结构化绑定)</h3><ul>
<li><strong>概念：</strong> 一个固定大小的、异构的、值语义的容器。它将多个不同类型的值打包成一个单一的对象。</li>
<li><strong>内容：</strong> <code>std::tuple</code> 的所有模板参数类型的值都<strong>同时存在</strong>于 <code>tuple</code> 对象中。</li>
<li><strong>内存：</strong> 它的内存占用大致是所有包含类型大小的总和（加上可能的对齐填充）。</li>
<li>访问：<ul>
<li>通过 <code>std::get&lt;index&gt;(tuple_obj)</code> 按索引访问。</li>
<li>通过 <code>std::get&lt;Type&gt;(tuple_obj)</code> 按类型访问（如果类型不重复）。</li>
<li>通过 C++17 的<strong>结构化绑定</strong>解包到独立的变量中。</li>
</ul>
</li>
<li><strong>状态：</strong> <code>std::tuple</code> 总是包含所有其声明的类型的值，它不会处于“空”或“无效”状态。</li>
<li>用例：<ul>
<li><strong>函数返回多个值：</strong> 当一个函数需要逻辑上返回多个不同类型的值时，<code>std::tuple</code> 是一个比输出参数或自定义结构体更灵活的选择。</li>
<li><strong>临时聚合数据：</strong> 当你需要临时将一些不相关的变量组合在一起，而又不想定义一个完整的结构体时。</li>
<li><strong>泛型编程：</strong> 在模板元编程中，<code>std::tuple</code> 经常用于传递一组类型或值。</li>
<li><strong><code>std::map</code> 的 <code>value_type</code>：</strong> <code>std::map&lt;K, V&gt;</code> 的迭代器解引用得到的是 <code>std::pair&lt;const K, V&gt;</code>，而 <code>std::pair</code> 可以看作是 <code>std::tuple</code> 的一个特例（只有两个元素）。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span> <span class="comment">// For std::tuple</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个包含姓名、年龄和性别的元组</span></span><br><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">get_person_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 tuple</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">my_tuple</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element 0: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(my_tuple) &lt;&lt; std::endl; <span class="comment">// Output: 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element 1: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(my_tuple) &lt;&lt; std::endl; <span class="comment">// Output: 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定 (C++17)</span></span><br><span class="line">    <span class="keyword">auto</span> [id, value, message] = my_tuple;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;, Message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解构函数返回值</span></span><br><span class="line">    <span class="keyword">auto</span> [name, age, gender] = <span class="built_in">get_person_info</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;, Gender: &quot;</span> &lt;&lt; gender &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++17</tag>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存一致性与伪共享</title>
    <url>/2025/09/19/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<p>结束了两个月的魔都牛马生活，下周又要续上了。也是好久没有更新blog了，面试时被面试官Eric当场打开，才意识到这个的重要性。</p>
<ol>
<li>什么是False Sharing（虚假共享）？</li>
</ol>
<ul>
<li><p><strong>定义</strong>：在多核处理器中，多个核心的缓存行（Cache Line，通常64字节）存储共享数据。当不同核心的线程修改同一缓存行内的<strong>不同变量</strong>时，缓存一致性协议（如MESI）会认为整个缓存行被修改，导致其他核心的缓存行失效，引发不必要的通信和性能损失。</p>
</li>
<li><p><strong>场景</strong>：</p>
</li>
<li><p>核心A的线程更新缓存行中的变量<code>X</code>。</p>
</li>
<li><p>核心B的线程更新同一缓存行中的变量<code>Y</code>（ទ</p>
</li>
<li><p>尽管<code>X</code>和<code>Y</code>无关，MESI协议使整个缓存行在B的缓存失效，B需重新加载数据。</p>
</li>
<li><p><strong>影响</strong>：频繁的缓存失效和同步（总线嗅探或目录协议）增加延迟，降低性能（如IPC下降）。</p>
</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> x; <span class="type">int</span> y; &#125; data; <span class="comment">// x和y在同一缓存行</span></span><br><span class="line"><span class="comment">// 线程1（核心A）更新data.x，线程2（核心B）更新data.y</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>data.x</code>导致缓存行失效，核心B的<code>data.y</code>需重新加载，尽管<code>y</code>未变。</li>
</ul>
<hr>
<h3 id="2-为什么会发生False-Sharing？"><a href="#2-为什么会发生False-Sharing？" class="headerlink" title="2. 为什么会发生False Sharing？"></a>2. 为什么会发生False Sharing？</h3><ul>
<li><strong>缓存行机制</strong>：缓存以固定大小的块（通常64字节）加载数据。多个变量可能共享同一缓存行。</li>
<li><strong>一致性协议</strong>：当一个核心修改缓存行，MESI协议标记其他核心的该缓存行为Invalid，强制更新，即使实际数据未受影响。</li>
<li><strong>RISC联系</strong>：RISC系统的Load&#x2F;Store操作频繁访问缓存，False Sharing可能放大一致性开销，影响高效并行。</li>
</ul>
<hr>
<h3 id="3-为什么内存对齐可以解决False-Sharing？"><a href="#3-为什么内存对齐可以解决False-Sharing？" class="headerlink" title="3. 为什么内存对齐可以解决False Sharing？"></a>3. 为什么内存对齐可以解决False Sharing？</h3><ul>
<li><p><strong>内存对齐原理</strong>：</p>
</li>
<li><p>通过将不同线程访问的变量分配到<strong>不同缓存行</strong>（如每64字节对齐），避免多个变量共享同一缓存行。</p>
</li>
<li><p>例如，在64字节缓存行系统中，确保<code>X</code>和<code>Y</code>地址相差至少64字节（或填充无用数据）。</p>
</li>
<li><p><strong>实现方法</strong>：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">60</span>]; <span class="comment">// 填充至64字节</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>编译器优化</strong>：使用对齐指令（如<code>__attribute__((aligned(64)))</code>或<code>#pragma pack</code>）。</p>
</li>
<li><p><strong>手动填充</strong>（Padding）：在结构体中添加无用字段，使变量占用单独缓存行。</p>
</li>
<li><p><strong>效果</strong>：核心A修改<code>X</code>的缓存行不会影响核心B的<code>Y</code>缓存行，消除虚假共享的失效和同步开销。</p>
</li>
</ul>
<hr>
<h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><ul>
<li><strong>False Sharing</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">int</span> x; <span class="type">int</span> y; &#125; data; <span class="comment">// x, y可能在同一64字节缓存行</span></span><br><span class="line"><span class="comment">// 线程1：data.x++; 线程2：data.y++;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>核心A更新<code>x</code>，缓存行失效，核心B需重新加载<code>y</code>，性能下降。</p>
</li>
<li><p><strong>内存对齐解决</strong>：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">60</span>]; <span class="comment">// 确保y在新的缓存行</span></span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">64</span>))) data;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>x</code>和<code>y</code>在不同缓存行，核心A更新<code>x</code>不影响核心B的<code>y</code>。</li>
</ul>
<hr>
<h3 id="5-性能影响"><a href="#5-性能影响" class="headerlink" title="5. 性能影响"></a>5. 性能影响</h3><ul>
<li><strong>False Sharing的开销</strong>：频繁缓存失效增加通信延迟，IPC可能从2降至0.5（视工作负载）。</li>
<li><strong>内存对齐的代价</strong>：浪费内存（如填充字节），但性能提升通常更重要。</li>
</ul>
<hr>
<h2 id="1-什么是缓存一致性？"><a href="#1-什么是缓存一致性？" class="headerlink" title="1. 什么是缓存一致性？"></a>1. 什么是缓存一致性？</h2><ul>
<li><strong>背景</strong>：多核CPU中，每个核心有私有缓存（如L1），存储主内存数据的副本。若多个核心同时访问&#x2F;修改同一数据，可能导致缓存数据不一致。</li>
<li><strong>目标</strong>：确保所有核心看到的同一内存地址的数据一致，维护程序正确性。</li>
<li><strong>RISC联系</strong>：RISC系统的简单指令（如Load&#x2F;Store）和高效缓存设计依赖一致性协议来支持多核并行。</li>
</ul>
<hr>
<h2 id="2-缓存一致性问题"><a href="#2-缓存一致性问题" class="headerlink" title="2. 缓存一致性问题"></a>2. 缓存一致性问题</h2><ul>
<li><p><strong>场景</strong>：核心A修改缓存中地址X的数据，核心B的缓存中X仍是旧值，可能导致错误。</p>
</li>
<li><p><strong>问题来源</strong>：</p>
</li>
<li><p><strong>写操作</strong>：一个核心更新缓存，未同步到其他核心或内存。</p>
</li>
<li><p><strong>共享数据</strong>：多核心访问同一内存地址（如共享变量）。</p>
</li>
<li><p><strong>例子</strong>：线程1在核心A上写<code>X = 10</code>，线程2在核心B上读<code>X</code>，若无一致性协议，核心B可能读到旧值（如0）。</p>
</li>
</ul>
<hr>
<h2 id="3-MESI协议（常见实现）"><a href="#3-MESI协议（常见实现）" class="headerlink" title="3. MESI协议（常见实现）"></a>3. MESI协议（常见实现）</h2><p>MESI（Modified, Exclusive, Shared, Invalid）是广泛使用的缓存一致性协议，通过为每个缓存行（Cache Line）标记状态来维护一致性。</p>
<ul>
<li><p><strong>状态说明</strong>：</p>
</li>
<li><p><strong>Modified（修改）</strong>：缓存行被修改，独占且与内存不一致，需写回内存。</p>
</li>
<li><p><strong>Exclusive（独占）</strong>：缓存行独占，未修改，与内存一致。</p>
</li>
<li><p><strong>Shared（共享）</strong>：缓存行被多个核心共享，与内存一致。</p>
</li>
<li><p><strong>Invalid（无效）</strong>：缓存行数据无效，需重新从内存或他核加载。</p>
</li>
<li><p><strong>工作原理</strong>：</p>
</li>
<li><p>核心通过<strong>总线嗅探（Bus Snooping）</strong>或<strong>目录协议（Directory Protocol）</strong>监控其他核心的读写操作，更新缓存行状态。</p>
</li>
<li><p>例如：核心A写地址X，X在A的缓存变为Modified，其他核心的X变为Invalid。</p>
</li>
<li><p><strong>状态转换示例</strong>：</p>
</li>
<li><p>核心A读X（未被其他核心缓存）：X状态为Exclusive。</p>
</li>
<li><p>核心B读X：A和B的X变为Shared。</p>
</li>
<li><p>核心A写X：A的X变为Modified，B的X变为Invalid，A需写回内存。</p>
</li>
</ul>
<hr>
<h2 id="4-实现机制"><a href="#4-实现机制" class="headerlink" title="4. 实现机制"></a>4. 实现机制</h2><ul>
<li><p><strong>总线嗅探</strong>：每个核心监听共享总线的读写请求，更新本地缓存状态。适合小规模多核，简单但总线带宽有限。</p>
</li>
<li><p><strong>目录协议</strong>：维护一个目录记录缓存行位置和状态，适合大规模多核，减少总线通信开销。</p>
</li>
<li><p><strong>写策略</strong>：</p>
</li>
<li><p><strong>写回（Write-Back）</strong>：修改缓存后延迟写回内存（如MESI的Modified状态）。</p>
</li>
<li><p><strong>写直达（Write-Through）</strong>：修改缓存时立即写回内存，简单但效率低。</p>
</li>
<li><p><strong>RISC优化</strong>：RISC的Load&#x2F;Store架构简化内存访问，MESI协议配合高效缓存（如小而快的L1）减少一致性开销。</p>
</li>
</ul>
<hr>
<h2 id="5-性能与挑战"><a href="#5-性能与挑战" class="headerlink" title="5. 性能与挑战"></a>5. 性能与挑战</h2><ul>
<li><p><strong>性能瓶颈</strong>：</p>
</li>
<li><p><strong>通信开销</strong>：总线或目录的嗅探&#x2F;查询增加延迟。</p>
</li>
<li><p><strong>虚假共享（False Sharing）</strong>：多核心修改同一缓存行内的不同数据，导致频繁失效。</p>
</li>
<li><p><strong>优化方法</strong>：</p>
</li>
<li><p>设计小缓存行，减少虚假共享。</p>
</li>
<li><p>使用锁或原子指令（如RISC-V的AMO）降低一致性冲突。</p>
</li>
<li><p>编译器优化：数据对齐，避免跨缓存行访问。</p>
</li>
</ul>
<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>假设两核心（A、B），共享变量X：</p>
<ol>
<li>A读X：X在A缓存为Exclusive。</li>
<li>B读X：X在A、B缓存为Shared。</li>
<li>A写X&#x3D;10：A的X变为Modified，B的X变为Invalid，A需写回内存。</li>
<li>B读X：B从内存或A缓存加载X，双方X变为Shared。</li>
</ol>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>false sharing</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存穿透</title>
    <url>/2025/06/17/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h3 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h3><p>缓存穿透是指攻击者或异常请求频繁查询<strong>缓存和后端数据库中都不存在</strong>的数据，导致每次请求都直接穿透缓存，命中数据库，增加数据库压力，可能导致系统性能下降甚至崩溃。</p>
<h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ol>
<li><strong>恶意攻击</strong>：攻击者故意请求不存在的 key（如随机生成的 ID）。</li>
<li><strong>业务逻辑问题</strong>：用户查询的数据在系统中不存在（如查询无效商品 ID）。</li>
<li><strong>缓存失效</strong>：热点数据未及时缓存，导致请求直接访问数据库。</li>
</ol>
<h4 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h4><ul>
<li>数据库负载激增，响应变慢。</li>
<li>系统吞吐量下降，可能引发雪崩效应。</li>
</ul>
<hr>
<h3 id="如何解决缓存穿透？"><a href="#如何解决缓存穿透？" class="headerlink" title="如何解决缓存穿透？"></a>如何解决缓存穿透？</h3><p>以下是常见的解决方案，结合实际场景选择使用：</p>
<ol>
<li><p><strong>缓存空对象</strong></p>
<ul>
<li><strong>方法</strong>：当查询的数据在数据库中不存在时，在缓存中存储一个空对象（如 <code>null</code> 或空字符串），并设置较短的过期时间。</li>
<li><strong>优点</strong>：简单有效，减少对数据库的直接访问。</li>
<li><strong>缺点</strong>：可能占用缓存空间，需设置合理过期时间。</li>
<li><strong>示例</strong>（伪代码）：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = cache.get(key)</span><br><span class="line"><span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    value = db.query(key)</span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cache.<span class="built_in">set</span>(key, <span class="string">&quot;&quot;</span>, expire=<span class="number">60</span>)  <span class="comment"># 缓存空对象，过期时间 60 秒</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cache.<span class="built_in">set</span>(key, value, expire=<span class="number">3600</span>)</span><br><span class="line"><span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>布隆过滤器（Bloom Filter）</strong></p>
<ul>
<li><strong>方法</strong>：在缓存前部署布隆过滤器，预先将数据库中存在的 key 映射到布隆过滤器中。查询时，先检查 key 是否在布隆过滤器中，若不在则直接返回，阻止穿透。</li>
<li><strong>优点</strong>：内存占用小，查询效率高，适合大规模数据场景。</li>
<li><strong>缺点</strong>：存在误判率（可能误认为存在的 key 不存在），需定期更新布隆过滤器。</li>
<li><strong>适用场景</strong>：数据量大，存在性查询频繁。</li>
<li><strong>示例</strong>：使用 Redis 的布隆过滤器插件（如 <code>redis-bloom</code>）。</li>
</ul>
<p>贴一个布隆过滤器</p>
<p>布隆过滤器（Bloom Filter）是一种<strong>空间高效的概率性数据结构</strong>，用于快速判断一个元素是否可能存在于一个集合中。它以极小的内存占用和高效的查询性能著称，广泛应用于缓存穿透、大数据去重、分布式系统等场景。</p>
<h4 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h4><p>布隆过滤器基于以下机制：</p>
<ol>
<li><strong>数据结构</strong>：一个长度为 m<em>m</em> 的位数组（bit array），初始全为 0。</li>
<li><strong>哈希函数</strong>：使用 k<em>k</em> 个独立的哈希函数，将元素映射到位数组的 k<em>k</em> 个位置。</li>
<li><strong>添加元素</strong>：对元素计算 k<em>k</em> 个哈希值，将对应的位数组位置置为 1。</li>
<li><strong>查询元素</strong><ul>
<li>计算元素的 k<em>k</em> 个哈希值，检查对应位是否全为 1。</li>
<li>若全为 1，元素<strong>可能存在</strong>；若任一位为 0，元素<strong>一定不存在</strong>。</li>
</ul>
</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>优点<ul>
<li><strong>空间效率高</strong>：只需存储位数组，远小于实际数据。</li>
<li><strong>查询速度快</strong>：时间复杂度为 O(k)<em>O</em>(<em>k</em>)，与集合大小无关。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>误判率</strong>：可能将不存在的元素误判为存在（false positive），但不会漏判（false negative）。</li>
<li><strong>不可删除</strong>：传统布隆过滤器不支持元素删除（因为多个元素可能共享同一位置）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>参数校验与限流</strong></p>
<ul>
<li><strong>方法</strong>：<ul>
<li>在接口层对请求参数进行校验，拦截明显无效的请求（如非数字 ID、超范围值）。</li>
<li>使用限流机制（如 Nginx 或 Redis）限制同一 IP 或用户的请求频率。</li>
</ul>
</li>
<li><strong>优点</strong>：从源头减少无效请求，保护后端。</li>
<li><strong>缺点</strong>：可能误伤合法请求，需精细配置。</li>
<li><strong>示例</strong>（Nginx 限流）：<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=mylimit:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=mylimit burst=<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>异步缓存预热</strong></p>
<ul>
<li><strong>方法</strong>：在系统启动或数据变更时，提前将热点数据加载到缓存中，减少查询不存在数据的可能。</li>
<li><strong>优点</strong>：从源头降低穿透风险。</li>
<li><strong>缺点</strong>：需额外维护缓存预热逻辑。</li>
<li><strong>示例</strong>：定时任务将数据库热点数据写入 Redis。</li>
</ul>
</li>
<li><p><strong>设置默认值</strong></p>
<ul>
<li><strong>方法</strong>：对于某些业务场景，查询不存在的数据时返回默认值（如空列表），并缓存默认值。</li>
<li><strong>优点</strong>：对用户友好，减少数据库压力。</li>
<li><strong>缺点</strong>：需根据业务场景设计默认值。</li>
<li><strong>示例</strong>：查询用户订单列表，若无订单，缓存空列表 <code>[]</code>。</li>
</ul>
</li>
<li><p><strong>数据库降级或熔断</strong></p>
<ul>
<li><strong>方法</strong>：当检测到大量穿透请求时，触发降级机制（如直接返回错误）或熔断，暂停对数据库的访问。</li>
<li><strong>优点</strong>：保护数据库，防止系统崩溃。</li>
<li><strong>缺点</strong>：可能影响正常用户体验。</li>
<li><strong>示例</strong>：使用 Hystrix 或 Sentinel 实现熔断。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>缓存穿透</strong>：查询不存在数据导致请求穿透缓存，命中数据库。</li>
<li><strong>解决方案</strong>：<ol>
<li>缓存空对象（简单快速）。</li>
<li>布隆过滤器（高效，适合大数据）。</li>
<li>参数校验与限流（源头拦截）。</li>
<li>缓存预热（预防为主）。</li>
<li>设置默认值（用户友好）。</li>
<li>降级或熔断（保护系统）。</li>
</ol>
</li>
</ul>
<p><strong>推荐实践</strong>：</p>
<ul>
<li>小型系统：优先使用缓存空对象 + 参数校验。</li>
<li>大型系统：结合布隆过滤器 + 限流 + 缓存预热。</li>
<li>监控：监控缓存命中率和数据库 QPS，及时发现穿透问题。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数与虚函数表</title>
    <url>/2025/06/16/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="C-中的多态、虚函数、虚函数表、虚函数表指针和虚析构函数"><a href="#C-中的多态、虚函数、虚函数表、虚函数表指针和虚析构函数" class="headerlink" title="C++ 中的多态、虚函数、虚函数表、虚函数表指针和虚析构函数"></a>C++ 中的多态、虚函数、虚函数表、虚函数表指针和虚析构函数</h2><p>以下是对 C++ 中多态、虚函数、虚函数表（vtable）、虚函数表指针（vptr）以及虚析构函数的详细介绍，使用 Markdown 格式，包含代码示例和 LaTeX 表示（若适用）。内容基于 C++ 的运行时多态机制，并结合上下文（如内存对齐、智能指针等）。</p>
<hr>
<h3 id="1-多态"><a href="#1-多态" class="headerlink" title="1. 多态"></a>1. 多态</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>多态（Polymorphism）是面向对象编程的核心特性，允许通过基类指针或引用调用派生类的行为。C++ 中的多态主要分为：</p>
<ul>
<li><strong>编译时多态</strong>：通过函数重载或模板实现。</li>
<li><strong>运行时多态</strong>：通过虚函数和继承实现，依赖动态绑定。</li>
</ul>
<h4 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h4><ul>
<li>通过基类指针或引用调用派生类的虚函数，根据对象的实际类型动态决定调用哪个函数。</li>
<li>依赖<strong>虚函数表</strong>和<strong>虚函数表指针</strong>实现。</li>
</ul>
<h4 id="数学表示"><a href="#数学表示" class="headerlink" title="数学表示"></a>数学表示</h4><p>对于基类指针 ( p ) 指向派生类对象，调用虚函数 ( f )，实际执行的函数为：<br>[<br>\text{Execute}(p \to f) &#x3D; \text{Dispatch}(p.\text{vptr}, f)<br>]<br>其中，(\text{Dispatch}) 根据虚函数表解析具体函数地址。</p>
<hr>
<h3 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2. 虚函数"></a>2. 虚函数</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><ul>
<li>使用 <code>virtual</code> 关键字声明的成员函数，允许在派生类中被重写（override）。</li>
<li>实现运行时多态，调用时根据对象的实际类型选择函数实现。</li>
</ul>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul>
<li>基类函数声明为 <code>virtual</code>，派生类重写时无需重复 <code>virtual</code>（但建议使用 <code>override</code> 明确）。</li>
<li>虚函数调用通过虚函数表动态解析。</li>
<li>构造函数不能为虚函数，析构函数可以（见虚析构函数）。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">func</span>(); <span class="comment">// 输出: Derived::func</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-虚函数表（vtable）"><a href="#3-虚函数表（vtable）" class="headerlink" title="3. 虚函数表（vtable）"></a>3. 虚函数表（vtable）</h3><h4 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h4><ul>
<li>虚函数表是一个编译器生成的数组，存储类中虚函数的地址。</li>
<li>每个包含虚函数的类有一个唯一的 vtable，共享给该类的所有对象。</li>
</ul>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>编译器为每个包含虚函数的类生成一个 vtable。</li>
<li>vtable 包含该类及其基类的虚函数地址，按声明顺序排列。</li>
<li>派生类重写虚函数时，vtable 中对应的地址更新为派生类的实现。</li>
</ul>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>对于类 ( C ) 包含 ( n ) 个虚函数，vtable 是一个数组：<br>[<br>\text{vtable}_C &#x3D; [\text{addr}(f_1), \text{addr}(f_2), \dots, \text{addr}(f_n)]<br>]<br>其中 (\text{addr}(f_i)) 是虚函数 ( f_i ) 的地址。</p>
<hr>
<h3 id="4-虚函数表指针（vptr）"><a href="#4-虚函数表指针（vptr）" class="headerlink" title="4. 虚函数表指针（vptr）"></a>4. 虚函数表指针（vptr）</h3><h4 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h4><ul>
<li>虚函数表指针（vptr）是对象内存中的一个隐藏指针，指向该对象的类的 vtable。</li>
<li>每个包含虚函数的对象在构造时由编译器插入 vptr。</li>
</ul>
<h4 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>vptr 通常位于对象内存布局的开头（与内存对齐相关，参考上下文）。</li>
<li>构造派生类对象时，vptr 会被设置为指向派生类的 vtable。</li>
<li>调用虚函数时，编译器通过 vptr 查找 vtable 中的函数地址。</li>
</ul>
<h4 id="内存影响"><a href="#内存影响" class="headerlink" title="内存影响"></a>内存影响</h4><ul>
<li>vptr 增加对象大小，通常为指针大小（32 位系统为 4 字节，64 位为 8 字节）。</li>
<li>对齐要求（参考上下文）可能导致额外填充。</li>
</ul>
<h4 id="代码示例（概念性）"><a href="#代码示例（概念性）" class="headerlink" title="代码示例（概念性）"></a>代码示例（概念性）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// vptr 隐式添加，指向 Base 的 vtable</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// vptr 指向 Derived 的 vtable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>内存布局</strong>（假设 64 位系统）：</p>
<ul>
<li><code>Base</code> 对象：8 字节（vptr）。</li>
<li><code>Derived</code> 对象：8 字节（vptr，指向不同的 vtable）。</li>
</ul>
<hr>
<h3 id="5-虚析构函数"><a href="#5-虚析构函数" class="headerlink" title="5. 虚析构函数"></a>5. 虚析构函数</h3><h4 id="含义-4"><a href="#含义-4" class="headerlink" title="含义"></a>含义</h4><ul>
<li>将基类的析构函数声明为 <code>virtual</code>，确保通过基类指针删除派生类对象时，正确调用派生类的析构函数。</li>
<li>防止内存泄漏或未定义行为，特别是在使用智能指针（如 <code>std::unique_ptr</code>）时（参考上下文）。</li>
</ul>
<h4 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h4><ul>
<li>通过基类指针删除派生类对象时，非虚析构函数只调用基类的析构函数，导致派生类部分未清理。</li>
<li>虚析构函数通过 vtable 动态调用正确的析构函数。</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base::~Base\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() <span class="keyword">override</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Derived::~Derived\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Base&gt; ptr = std::<span class="built_in">make_unique</span>&lt;Derived&gt;();</span><br><span class="line">    <span class="comment">// 删除时调用 Derived::~Derived 然后 Base::~Base</span></span><br><span class="line">&#125; <span class="comment">// 输出: Derived::~Derived, Base::~Base</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：若 <code>Base::~Base</code> 非虚，则只调用 <code>Base::~Base</code>，可能导致内存泄漏。</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ul>
<li>基类析构函数应始终为虚函数（除非明确不需要多态删除）。</li>
<li>虚析构函数增加 vtable 条目，略微增加开销。</li>
<li>C++11 起，建议默认析构函数为虚：<code>virtual ~Base() = default;</code></li>
</ul>
<hr>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li><strong>多态</strong>：通过虚函数实现运行时动态绑定。</li>
<li><strong>虚函数</strong>：使用 <code>virtual</code> 声明，动态调用派生类实现。</li>
<li><strong>虚函数表（vtable）</strong>：存储虚函数地址的数组，每个类一个。</li>
<li><strong>虚函数表指针（vptr）</strong>：对象中的指针，指向类的 vtable，增加内存开销。</li>
<li><strong>虚析构函数</strong>：确保通过基类指针删除对象时正确清理，防止内存泄漏。</li>
<li><strong>注意事项</strong>：<ul>
<li>虚函数和 vptr 增加性能和内存开销，需权衡使用。</li>
<li>虚析构函数在多态场景中几乎总是必要的。</li>
<li>与智能指针结合时，虚析构函数和 <code>noexcept</code> 优化至关重要。</li>
</ul>
</li>
</ul>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p>虚函数表和虚函数表指针是一一对应的关系</p>
<h4 id="虚函数可以被重写为虚函数吗？"><a href="#虚函数可以被重写为虚函数吗？" class="headerlink" title="虚函数可以被重写为虚函数吗？"></a>虚函数可以被重写为虚函数吗？</h4><ul>
<li><strong>答案</strong>：是的，虚函数可以被<strong>派生类重写</strong>（override），且重写的函数<strong>自动成为虚函数</strong>，无需再次声明 <code>virtual</code> 关键字。</li>
<li><strong>原因</strong>：C++ 中，一旦基类函数被声明为 <code>virtual</code>，其在派生类中的重写版本（具有相同函数签名）默认继承虚函数属性。这是 C++ 的虚函数机制确保运行时多态（参考上下文：运行时多态）。</li>
<li><strong>注意</strong>：派生类可以使用 <code>override</code> 关键字显式标记重写，以提高代码可读性并确保正确性。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base::func\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::func\n&quot;</span>; &#125; <span class="comment">// 重写，自动为虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-所有包含虚函数的类的实例共享一个-vtable-吗？如果被重写了，所有实例的虚函数实现都改为调用重写的函数吗？"><a href="#2-所有包含虚函数的类的实例共享一个-vtable-吗？如果被重写了，所有实例的虚函数实现都改为调用重写的函数吗？" class="headerlink" title="2. 所有包含虚函数的类的实例共享一个 vtable 吗？如果被重写了，所有实例的虚函数实现都改为调用重写的函数吗？"></a>2. 所有包含虚函数的类的实例共享一个 vtable 吗？如果被重写了，所有实例的虚函数实现都改为调用重写的函数吗？</h4><ul>
<li><strong>答案</strong>：<ul>
<li><strong>共享 vtable</strong>：同一个类的所有实例共享<strong>同一个虚函数表（vtable）</strong>。vtable 是<strong>类级别</strong>的静态数据结构，存储该类的虚函数地址。</li>
<li><strong>重写的影响</strong>：当派生类重写基类的虚函数时，派生类会生成<strong>自己的 vtable</strong>，其中重写的函数地址覆盖基类的对应函数地址。<strong>基类实例的 vtable 不受影响</strong>，仍指向基类的函数实现。</li>
</ul>
</li>
<li><strong>详细说明</strong>：<ul>
<li>每个类（基类或派生类）有自己的 vtable，包含该类的虚函数地址。</li>
<li>基类实例的 vptr（虚函数表指针）指向基类的 vtable，派生类实例的 vptr 指向派生类的 vtable。</li>
<li>重写只影响派生类的 vtable，不会改变基类的 vtable。因此，基类实例仍调用基类的函数实现，派生类实例调用重写的函数实现。</li>
</ul>
</li>
</ul>
<h3 id="3-哪些函数不能被声明为虚函数？"><a href="#3-哪些函数不能被声明为虚函数？" class="headerlink" title="3.哪些函数不能被声明为虚函数？"></a>3.哪些函数不能被声明为虚函数？</h3><p>构造函数，静态成员函数，非成员函数，友元函数，内联函数</p>
<h3 id="4-为什么不需要虚构造函数？"><a href="#4-为什么不需要虚构造函数？" class="headerlink" title="4.为什么不需要虚构造函数？"></a>4.为什么不需要虚构造函数？</h3><p>在 C++ 中，不需要虚构造函数的原因如下：</p>
<ol>
<li><strong>构造函数的调用时机和目的</strong>：<ul>
<li>构造函数用于在对象创建时初始化对象，其调用发生在对象类型确定时（即 <code>new Class()</code> 时类型已明确）。</li>
<li>虚函数机制依赖运行时多态，通过虚函数表（vtable）和虚函数表指针（vptr）根据对象实际类型动态调用函数。然而，在构造对象时，vtable 尚未完全初始化（派生类构造函数可能尚未运行），因此无法依赖 vtable 实现“虚”调用。</li>
</ul>
</li>
<li><strong>类型已知的静态绑定</strong>：<ul>
<li>构造函数调用是静态绑定的，程序员在代码中明确指定创建的类型（例如 <code>Base* p = new Derived()</code>），编译器直接生成对应的构造函数调用。</li>
<li>运行时多态（虚函数）解决的是通过基类指针&#x2F;引用调用未知派生类函数的问题，而构造函数调用不需要这种动态分派，因为类型在创建时已知。</li>
</ul>
</li>
<li><strong>构造顺序的固定性</strong>：<ul>
<li>在继承体系中，构造函数调用遵循严格的顺序：先基类，后派生类。这确保对象逐步构建，vptr 在每个阶段被正确设置为当前类的 vtable（参考上下文：vptr 设置）。</li>
<li>如果构造函数是虚函数，可能导致未定义行为，因为派生类构造函数可能在基类构造未完成时调用，破坏对象初始化逻辑。</li>
</ul>
</li>
<li><strong>虚函数依赖对象存在</strong>：<ul>
<li>虚函数调用需要一个已构造的对象（包含有效的 vptr 和 vtable）。在构造函数运行时，对象尚未完全构造，vptr 可能未指向正确的 vtable（参考上下文：vtable 和 vptr）。</li>
<li>因此，构造函数无法通过虚机制动态分派。</li>
</ul>
</li>
</ol>
<h4 id="当前类没有指向自己的虚函数表的-vptr，只有指向基类的-vptr？"><a href="#当前类没有指向自己的虚函数表的-vptr，只有指向基类的-vptr？" class="headerlink" title="当前类没有指向自己的虚函数表的 vptr，只有指向基类的 vptr？"></a>当前类没有指向自己的虚函数表的 vptr，只有指向基类的 vptr？</h4><p><strong>回答</strong>：不完全正确。</p>
<ul>
<li><p><strong>派生类的 vptr 情况</strong>：</p>
<ul>
<li><p>在非虚继承中，派生类对象通常包含多个 vptr（如果有多个基类包含虚函数），每个 vptr 指向对应基类的 vtable 分区。派生类自身的虚函数（如 <code>Derived::g</code>）通常被合并到某个基类的 vtable 中（通常是第一个非虚继承的基类），因此派生类可能没有独立的“指向自己的 vptr”。</p>
</li>
<li><p>示例（非虚继承）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Derived对象的内存布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| vptr_Base1 | Base1 数据 | vptr_Base2 | Base2 数据 | Derived 数据 |</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vptr_Base1</code> 指向 <code>Derived</code> 的 vtable 中与 <code>Base1</code> 兼容的部分（包含 <code>Base1::f1</code> 和 <code>Derived::f3</code>）。</p>
</li>
<li><p><code>vptr_Base2</code> 指向 <code>Derived</code> 的 vtable 中与 <code>Base2</code> 兼容的部分（包含 <code>Base2::f2</code>）。</p>
</li>
<li><p><code>Derived::f3</code> 被追加到 <code>Base1</code> 的 vtable 分区，因此 <code>Derived</code> 没有独立的 vptr。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>虚继承中的 vptr</strong>：</p>
<ul>
<li><p>在虚继承中，共享基类（如菱形继承中的顶层基类）只有一个实例，其 vptr 由派生类管理。派生类对象仍包含多个 vptr（对应每个有虚函数的基类和共享基类），但虚基类的 vptr 可能通过虚基类表（vbase table）或偏移量间接访问。</p>
</li>
<li><p>示例（虚继承）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Derived对象的内存布局（简化）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| vptr_Base1 | Base1 数据 | vptr_Base2 | Base2 数据 | vptr_Base | Base 数据 | Derived 数据 |</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vptr_Base1</code> 指向 <code>Base1</code> 的 vtable 分区（包含 <code>Base1::f1</code> 和 <code>Derived::f3</code>）。</p>
</li>
<li><p><code>vptr_Base2</code> 指向 <code>Base2</code> 的 vtable 分区（包含 <code>Base2::f2</code>）。</p>
</li>
<li><p><code>vptr_Base</code> 指向共享 <code>Base</code> 子对象的 vtable（包含 <code>Base::f</code>）。</p>
</li>
<li><p>虚继承可能引入虚基类指针（vbptr）来定位 <code>Base</code> 子对象，但这与 vptr 不同。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>为什么派生类没有“自己的 vptr”</strong>：</p>
<ul>
<li>编译器为了优化内存和性能，通常将派生类的虚函数（如 <code>Derived::f3</code>）合并到某个基类的 vtable 中（通常是第一个非虚继承的基类）。</li>
<li>派生类的 vtable 可能被分割为多个部分，分别由基类的 vptr 管理，因此派生类不需要额外的 vptr。</li>
<li>如果派生类是单一继承且没有多重继承或虚继承，派生类对象通常只有一个 vptr，指向包含基类和派生类虚函数的 vtable。</li>
</ul>
</li>
<li><p><strong>例外情况</strong>：</p>
<ul>
<li><p>如果派生类没有继承任何基类的虚函数，且自身定义了虚函数，对象会包含一个 vptr，指向派生类自己的 vtable。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Derived</code> 对象只有一个 vptr，指向 <code>Derived</code> 的 vtable（包含 <code>f</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-虚继承与非虚继承的内存布局对比"><a href="#4-虚继承与非虚继承的内存布局对比" class="headerlink" title="4. 虚继承与非虚继承的内存布局对比"></a>4. 虚继承与非虚继承的内存布局对比</h4><ul>
<li><p><strong>非虚继承</strong>：</p>
<ul>
<li><p>每个基类子对象独立存在，包含自己的 vptr（如果基类有虚函数）。</p>
</li>
<li><p>派生类对象的 vptr 数量等于有虚函数的基类数量。</p>
</li>
<li><p>派生类的虚函数合并到某个基类的 vtable 分区，无需额外 vptr。</p>
</li>
<li><p>内存布局示例（Base1 和Base2非虚继承）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| vptr_Base1 | Base1 数据 | vptr_Base2 | Base2 数据 | Derived 数据 |</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>虚继承</strong>：</p>
<ul>
<li><p>虚基类（如 <code>Base</code>）在派生类对象中只有一份实例，包含一个 vptr。</p>
</li>
<li><p>派生类对象包含每个非虚基类的 vptr，以及共享虚基类的 vptr。</p>
</li>
<li><p>虚基类子对象的位置可能通过虚基类指针（vbptr）或偏移量管理，增加内存开销。</p>
</li>
<li><p>内存布局示例（Base1和Base2虚继承Base）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| vptr_Base1 | Base1 数据 | vptr_Base2 | Base2 数据 | Derived 数据 | vptr_Base | Base 数据 |</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚基类子对象（<code>Base</code>）通常放在对象末尾，位置由 vbptr 间接引用</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多态</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>赫夫曼树与赫夫曼编码</title>
    <url>/2024/10/09/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h3 id="1-哈夫曼树（Huffman-Tree）："><a href="#1-哈夫曼树（Huffman-Tree）：" class="headerlink" title="1. 哈夫曼树（Huffman Tree）："></a>1. <strong>哈夫曼树（Huffman Tree）</strong>：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>哈夫曼树是一种带权路径长度最短的二叉树，通常用于<strong>数据压缩</strong>。</p>
<h3 id="它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。"><a href="#它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。" class="headerlink" title="它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。"></a>它的“最优”体现在<strong>权重大的节点离根节点更近</strong>，从而使加权路径长度最小。</h3><h4 id="构造过程："><a href="#构造过程：" class="headerlink" title="构造过程："></a>构造过程：</h4><p>哈夫曼树的构建基于贪心算法，步骤如下：</p>
<ol>
<li>将给定的所有权值看作是森林中的单节点树。</li>
<li>每次选择两个权值最小的节点进行合并，构成一个新的父节点，其权值为两个子节点的权值之和。</li>
<li>重复上述过程，直到所有节点合并成一棵二叉树。</li>
</ol>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul>
<li><strong>数据压缩</strong>：哈夫曼树用于<strong>哈夫曼编码</strong>，它通过为高频率字符分配较短的编码，低频率字符分配较长的编码，达到压缩数据的目的。</li>
</ul>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>假设我们有字符集和对应的权值（频率）如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>频率</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>5</td>
</tr>
<tr>
<td>B</td>
<td>9</td>
</tr>
<tr>
<td>C</td>
<td>12</td>
</tr>
<tr>
<td>D</td>
<td>13</td>
</tr>
<tr>
<td>E</td>
<td>16</td>
</tr>
<tr>
<td>F</td>
<td>45</td>
</tr>
</tbody></table>
<p>构建哈夫曼树的过程如下：</p>
<ol>
<li>选择频率最小的 <code>A(5)</code> 和 <code>B(9)</code>，合并为一个新节点，权值为 14。</li>
<li>再选择 <code>C(12)</code> 和 <code>D(13)</code> 合并，权值为 25。</li>
<li>合并 <code>14</code> 和 <code>E(16)</code>，权值为 30。</li>
<li>合并 <code>25</code> 和 <code>F(45)</code>，权值为 70。</li>
<li>最后合并 <code>30</code> 和 <code>70</code>，得到哈夫曼树的根节点。</li>
</ol>
<p>这棵树是<strong>最优的</strong>，因为它最小化了每个字符的加权路径长度。</p>
<h5 id="最终生成的最优二叉树如下："><a href="#最终生成的最优二叉树如下：" class="headerlink" title="最终生成的最优二叉树如下："></a>最终生成的最优二叉树如下：</h5><pre><code>        R(100)
       /     \
   N3(30)   N4(70)
    /   \      /   \
 A(5)  E(16) N2(25) F(45)
            /   \
         C(12) D(13)
</code></pre>
<h1 id="2-赫夫曼编码"><a href="#2-赫夫曼编码" class="headerlink" title="2.赫夫曼编码"></a>2.赫夫曼编码</h1><p>为了实现高效率，我们要采取不等长编码原则，以及前缀编码原则</p>
<h3 id="赫夫曼编码过程："><a href="#赫夫曼编码过程：" class="headerlink" title="赫夫曼编码过程："></a>赫夫曼编码过程：</h3><p>向左用0表示，向右用1表示</p>
<p>根据树的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         R(100)</span><br><span class="line">        /     \</span><br><span class="line">    N3(30)   N4(70)</span><br><span class="line">   /   \      /   \</span><br><span class="line">A(5)  E(16) N2(25) F(45)</span><br><span class="line">           /   \</span><br><span class="line">        C(12) D(13)</span><br></pre></td></tr></table></figure>

<p>生成的赫夫曼编码应该是：</p>
<ul>
<li><strong>A</strong>: 00</li>
<li><strong>E</strong>: 01</li>
<li><strong>C</strong>: 100</li>
<li><strong>D</strong>: 101</li>
<li><strong>F</strong>: 11</li>
</ul>
<h3 id="对应的编码表："><a href="#对应的编码表：" class="headerlink" title="对应的编码表："></a>对应的编码表：</h3><table>
<thead>
<tr>
<th>字符</th>
<th>赫夫曼编码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>00</td>
</tr>
<tr>
<td>E</td>
<td>01</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>101</td>
</tr>
<tr>
<td>F</td>
<td>11</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>贪心算法</tag>
        <tag>树</tag>
        <tag>最优二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载与友元函数</title>
    <url>/2025/05/02/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>众所周知，运算符重载作为多态的一种实现，使用是较为普遍的</p>
<p>但是重载运算符，本身是几元就有几个参数，对于二元运算符，第一个参数对应左侧运算对象，第二个参数对应右侧运算对象</p>
<p>而重载运算符作为类的成员函数的时候，第一个参数就隐式绑定了this指针，即左侧运算对象固定为this指针</p>
<p>举个最常见的拷贝赋值重载函数例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DeepCopy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int *data;</span><br><span class="line">	//省略构造函数</span><br><span class="line">	DeepCopy&amp; operator=(const DeepCopy &amp;other)</span><br><span class="line">	&#123;</span><br><span class="line">		if(this!=other)</span><br><span class="line">		&#123;</span><br><span class="line">			delete data;</span><br><span class="line">			data=new int (*(other.data));</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">DeepCopy a，b;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>但是，我们难免会遇到非成员函数重载的情况，此时我们就要借助友元函数或者全局函数，但友元函数相对更为常规，比如以下例子</p>
<h3 id="1-需要对称性或隐式转换支持"><a href="#1-需要对称性或隐式转换支持" class="headerlink" title="1. 需要对称性或隐式转换支持"></a>1. <strong>需要对称性或隐式转换支持</strong></h3><ul>
<li><strong>场景</strong>：当运算符的两个操作数需要平等对待（如 <code>+</code>、<code>*</code>、<code>==</code> 等双目运算符），且可能涉及不同类型的隐式转换。</li>
<li><strong>原因</strong>：成员函数将左侧操作数（<code>this</code>）固定为类类型，限制了左侧操作数的隐式转换。而非成员函数允许左右操作数都进行隐式转换，提供更自然的语义。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MyClass</span>(lhs.value + rhs.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">a</span><span class="params">(<span class="number">5</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">MyClass c = a + b; <span class="comment">// OK</span></span><br><span class="line">MyClass d = <span class="number">5</span> + a; <span class="comment">// 非成员函数支持 int 到 MyClass 的隐式转换</span></span><br></pre></td></tr></table></figure>
如果 <code>operator+</code> 是成员函数，<code>5 + a</code> 会失败，因为左侧的 <code>int</code> 无法调用成员函数。</li>
</ul>
<h3 id="2-涉及非类类型或标准库类型"><a href="#2-涉及非类类型或标准库类型" class="headerlink" title="2. 涉及非类类型或标准库类型"></a>2. <strong>涉及非类类型或标准库类型</strong></h3><ul>
<li><strong>场景</strong>：运算符涉及自定义类与内置类型（如 <code>int</code>、<code>double</code>）或标准库类型（如 <code>std::string</code>）的交互。</li>
<li><strong>原因</strong>：你无法修改内置类型或标准库类型的定义来添加成员函数，因此只能使用非成员函数。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::string data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> std::string&amp; d) : <span class="built_in">data</span>(d) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::string <span class="keyword">operator</span>+(<span class="type">const</span> std::string&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs + rhs.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::string s = <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">MyClass</span>(<span class="string">&quot;World&quot;</span>); <span class="comment">// 非成员函数支持</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-提高封装性或避免侵入式修改"><a href="#3-提高封装性或避免侵入式修改" class="headerlink" title="3. 提高封装性或避免侵入式修改"></a>3. <strong>提高封装性或避免侵入式修改</strong></h3><ul>
<li><strong>场景</strong>：当你不希望修改类的定义（例如第三方库的类）或想保持类接口简洁。</li>
<li><strong>原因</strong>：非成员函数（通常声明为 <code>friend</code> 或通过公共接口访问）可以在类外部定义，减少对类内部实现的依赖。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(lhs.<span class="built_in">getValue</span>() + rhs.<span class="built_in">getValue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里无需修改 <code>MyClass</code> 的定义，保持了封装性。</li>
</ul>
<h3 id="4-流运算符（）"><a href="#4-流运算符（）" class="headerlink" title="4. 流运算符（&lt;&lt; 和 &gt;&gt;）"></a>4. <strong>流运算符（<code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>）</strong></h3><ul>
<li><strong>场景</strong>：重载输入输出流运算符（如 <code>std::ostream</code> 的 <code>&lt;&lt;</code> 或 <code>std::istream</code> 的 <code>&gt;&gt;</code>）。</li>
<li><strong>原因</strong>：这些运算符的左侧操作数是 <code>std::ostream</code> 或 <code>std::istream</code>，无法修改其类定义，因此必须使用非成员函数。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        os &lt;&lt; obj.value;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">MyClass <span class="title">x</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; x; <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>友元 vs. 公共接口</strong>：非成员函数可以通过 <code>friend</code> 访问私有成员，或通过公共 getter 方法操作。前者更简洁但可能降低封装性，后者更符合封装但代码稍冗长。</li>
<li><strong>隐式转换的副作用</strong>：非成员函数支持双边隐式转换，可能导致意外的类型转换，需谨慎设计构造函数（考虑 <code>explicit</code>）。</li>
<li><strong>性能</strong>：非成员函数通常是内联的（<code>inline</code>），性能与成员函数相当，但复杂运算需注意临时对象的创建和销毁开销。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>建议将运算符重载定义为非成员函数的场景包括：</p>
<ol>
<li>需要左右操作数的对称性或隐式转换（如 <code>+</code>、<code>*</code>）。</li>
<li>涉及非类类型或标准库类型（如 <code>std::string</code>、<code>std::ostream</code>）。</li>
<li>提高封装性或避免修改类定义。</li>
<li>流运算符（<code>&lt;&lt;</code>、<code>&gt;&gt;</code>）。</li>
</ol>
<p>关于友元的相关介绍，可以查看另一篇帖子。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>友元</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2025/06/24/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程（Process）和线程（Thread）是操作系统中执行程序的基本单位，它们在资源分配、调度、并发、独立性、系统开销和通信机制等方面存在显著差异。以下从这些方面详细对比进程和线程，并介绍进程切换过程及Linux中的进程和线程实现。</p>
<hr>
<h4 id="1-资源分配"><a href="#1-资源分配" class="headerlink" title="1. 资源分配"></a><strong>1. 资源分配</strong></h4><ul>
<li><strong>进程</strong>：<ul>
<li>进程是操作系统分配资源的基本单位，每个进程拥有独立的地址空间，包括代码段、数据段、堆、栈等。</li>
<li>进程分配独立的资源，如内存、文件句柄、I&#x2F;O设备等，进程间资源隔离，互不干扰。</li>
<li>每个进程有自己的进程控制块（PCB，Process Control Block），记录进程状态、寄存器值、内存分配等信息。</li>
</ul>
</li>
<li><strong>线程</strong>：<ul>
<li>线程是进程内的执行单元，共享进程的地址空间和资源（如代码段、数据段、文件句柄）。</li>
<li>线程只拥有少量私有资源，如栈、寄存器、程序计数器（PC），其他资源由所属进程提供。</li>
<li>多个线程在同一进程内共享内存和资源，减少资源分配的开销。</li>
</ul>
</li>
</ul>
<p><strong>对比</strong>：进程资源隔离，独占资源；线程共享进程资源，资源利用率更高。</p>
<hr>
<h4 id="2-调度"><a href="#2-调度" class="headerlink" title="2. 调度"></a><strong>2. 调度</strong></h4><ul>
<li><strong>进程</strong>：<ul>
<li>进程是操作系统调度的基本单位，调度通过PCB管理，涉及上下文切换（保存和恢复CPU状态）。</li>
<li>进程调度通常基于时间片轮转、优先级或其他调度算法，调度开销较大。</li>
</ul>
</li>
<li><strong>线程</strong>：<ul>
<li>线程是CPU调度的基本单位（在某些系统中，称为轻量级进程，LWP）。</li>
<li>线程调度在进程内部进行，切换仅涉及栈、寄存器等少量状态，调度开销较小。</li>
<li>操作系统（如Linux）通常将线程视为“轻量级进程”，通过线程控制块（TCB，Thread Control Block）管理。</li>
</ul>
</li>
</ul>
<p><strong>对比</strong>：进程调度涉及整个地址空间切换，成本高；线程调度仅涉及部分状态，效率更高。</p>
<hr>
<h4 id="3-并发"><a href="#3-并发" class="headerlink" title="3. 并发"></a><strong>3. 并发</strong></h4><ul>
<li><strong>进程</strong>：<ul>
<li>进程间并发通过多进程实现，多个进程可同时运行在多核CPU上，充分利用硬件并行性。</li>
<li>进程间并发需要操作系统支持，适合需要高隔离的任务（如不同应用程序）。</li>
</ul>
</li>
<li><strong>线程</strong>：<ul>
<li>线程在同一进程内并发执行，共享内存，适合高并发、数据共享的任务（如Web服务器处理请求）。</li>
<li>线程并发效率高，但需处理同步问题（如锁、信号量）以避免竞争条件。</li>
</ul>
</li>
</ul>
<p><strong>对比</strong>：进程并发隔离性强，适合独立任务；线程并发效率高，适合共享数据的高并发场景。</p>
<hr>
<h4 id="4-独立性"><a href="#4-独立性" class="headerlink" title="4. 独立性"></a><strong>4. 独立性</strong></h4><ul>
<li><strong>进程</strong>：<ul>
<li>进程是独立的执行实体，拥有独立的地址空间和资源，一个进程的崩溃通常不影响其他进程。</li>
<li>进程间隔离性强，安全性高，但通信复杂。</li>
</ul>
</li>
<li><strong>线程</strong>：<ul>
<li>线程依赖于所属进程，共享地址空间，一个线程的错误（如非法内存访问）可能导致整个进程崩溃。</li>
<li>线程间耦合紧密，独立性较弱，但通信简单。</li>
</ul>
</li>
</ul>
<p><strong>对比</strong>：进程独立性强，安全性高；线程依赖进程，独立性差但协作性强。</p>
<hr>
<h4 id="5-系统开销"><a href="#5-系统开销" class="headerlink" title="5. 系统开销"></a><strong>5. 系统开销</strong></h4><ul>
<li><strong>进程</strong>：<ul>
<li>创建进程（fork）需要分配新地址空间、复制父进程资源，销毁进程（exit）需要回收资源，开销大。</li>
<li>进程切换涉及保存和恢复整个地址空间、PCB等，上下文切换成本高。</li>
</ul>
</li>
<li><strong>线程</strong>：<ul>
<li>创建线程（pthread_create）仅需分配栈和TCB，销毁线程开销小。</li>
<li>线程切换仅保存栈、寄存器等少量状态，上下文切换成本低。</li>
</ul>
</li>
</ul>
<p><strong>对比</strong>：进程创建和切换开销大，适合资源隔离场景；线程创建和切换开销小，适合高并发场景。</p>
<hr>
<h4 id="6-通信机制"><a href="#6-通信机制" class="headerlink" title="6. 通信机制"></a><strong>6. 通信机制</strong></h4><p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因<br>很简单，每个进程都是共享一个内核空间。</p>
<p>Linux内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名<br>管道」。</p>
<p>匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell<br>命令中的「｜」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数<br>据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系<br>的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。</p>
<p>命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统<br>创建一个类型为p的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿<br>名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获<br>取，同时通信数据都遵循先进先出原则，不支持Iseek之类的文件定位操作。</p>
<p>消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链<br>表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，<br>当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。<br>消息队列通信的速度不是最及时的，毕竞每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过<br>程。</p>
<p>共享内存可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空<br>间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调<br>用，大大提高了通信的速度，享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的<br>问题，多进程竞争同个共享资源会造成数据的错乱。</p>
<p>那么，就需要信号量来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥<br>访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的<br>是资源个数，其值可以通过两个原子操作来控制，分别是P操作和V操作。</p>
<p>与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。信号是异步通信机制，信号<br>可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，<br>信号事件的来源主要有硬件来源（如键盘CItr+C）和软件来源（如kil命令），一旦有信号发生，进程有<br>三种方式响应信号1.执行默认操作、2.捕捉信号、3.忽略信号。有两个信号是应用进程无法捕捉和忽略<br>的，即SIGKILL和SIGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。</p>
<p>前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要Socket通<br>信了。Socket实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建<br>Socket的类型不同，分为三种常见的通信方式，一个是基于TCP协议的通信方式，一个是基于UDP协议<br>的通信方式，一个是本地进程间通信方式。</p>
<ul>
<li><strong>线程</strong>：<ul>
<li>线程共享进程的地址空间，直接通过共享变量通信，效率高。</li>
<li>需要同步机制（如互斥锁、条件变量、读写锁）避免数据竞争。</li>
<li>通信简单，但容易引发竞争条件或死锁。</li>
</ul>
</li>
</ul>
<p><strong>对比</strong>：进程间通信复杂但隔离性强；线程间通信简单但需小心同步。</p>
<hr>
<h3 id="进程切换过程"><a href="#进程切换过程" class="headerlink" title="进程切换过程"></a><strong>进程切换过程</strong></h3><p>进程切换是操作系统在调度时将CPU从一个进程交给另一个进程的过程，涉及上下文切换。以下是详细步骤（以Linux为例）：</p>
<ol>
<li><p><strong>触发切换</strong>：</p>
<ul>
<li>进程切换由调度器触发，可能因时间片用尽、优先级调度、I&#x2F;O阻塞或中断引起。</li>
<li>调度器根据调度算法（如CFS，Completely Fair Scheduler）选择下一个运行的进程。</li>
</ul>
</li>
<li><p><strong>保存当前进程上下文</strong>：</p>
<ul>
<li>保存当前进程的CPU状态到PCB，包括：<ul>
<li>寄存器状态（通用寄存器、程序计数器PC、栈指针SP等）。</li>
<li>程序状态字（PSW，包含中断标志、条件码等）。</li>
<li>内存管理信息（如页面表指针）。</li>
</ul>
</li>
<li>更新PCB中的进程状态（如从“运行”变为“就绪”或“阻塞”）。</li>
</ul>
</li>
<li><p><strong>选择新进程</strong>：</p>
<ul>
<li>调度器从就绪队列中选择下一个进程（基于优先级、时间片等）。</li>
<li>加载新进程的PCB。</li>
</ul>
</li>
<li><p><strong>恢复新进程上下文</strong>：</p>
<ul>
<li>从新进程的PCB恢复CPU状态，包括寄存器、PC、SP等。</li>
<li>更新内存管理单元（MMU），切换到新进程的地址空间（更新页面表）。</li>
</ul>
</li>
<li><p><strong>执行新进程</strong>：</p>
<ul>
<li>CPU开始执行新进程的指令，从上次中断的PC位置继续。</li>
</ul>
</li>
</ol>
<p><strong>开销分析</strong>：</p>
<ul>
<li>进程切换涉及地址空间切换（更新TLB、页面表），成本高。</li>
<li>缓存失效（新进程可能需要重新加载数据到缓存），增加延迟。</li>
<li>典型切换时间在微秒到毫秒级，具体取决于硬件和系统负载。</li>
</ul>
<p><strong>线程切换优化</strong>：</p>
<ul>
<li>线程切换无需更改地址空间，仅保存&#x2F;恢复栈、寄存器等，成本远低于进程切换。</li>
</ul>
<hr>
<h3 id="Linux-中的进程与线程"><a href="#Linux-中的进程与线程" class="headerlink" title="Linux 中的进程与线程"></a><strong>Linux 中的进程与线程</strong></h3><p>在Linux中，进程和线程的实现有独特的设计，统一由内核管理。</p>
<h4 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a><strong>Linux 进程</strong></h4><ul>
<li><strong>实现</strong>：<ul>
<li>Linux通过<code>task_struct</code>结构（相当于PCB）管理进程，包含进程ID（PID）、状态、内存信息、文件描述符等。</li>
<li>创建进程使用<code>fork()</code>系统调用，复制父进程的地址空间（通过写时复制优化，COW）。</li>
<li>进程通过<code>exec()</code>加载新程序，替换代码和数据。</li>
</ul>
</li>
<li><strong>调度</strong>：<ul>
<li>Linux使用CFS（Completely Fair Scheduler）调度进程，基于“虚拟运行时间”分配CPU。</li>
<li>进程状态包括运行（TASK_RUNNING）、可中断睡眠（TASK_INTERRUPTIBLE）、不可中断睡眠（TASK_UNINTERRUPTIBLE）等。</li>
</ul>
</li>
<li><strong>通信</strong>：<ul>
<li>支持管道、消息队列、共享内存、信号等IPC机制。</li>
<li>跨进程通信通常通过内核中介。</li>
</ul>
</li>
</ul>
<h4 id="Linux-线程"><a href="#Linux-线程" class="headerlink" title="Linux 线程"></a><strong>Linux 线程</strong></h4><ul>
<li><strong>实现</strong>：<ul>
<li>Linux没有传统意义上的线程，而是将线程视为“轻量级进程”（LWP），同样使用<code>task_struct</code>管理。</li>
<li>线程通过<code>clone()</code>系统调用创建，与进程共享地址空间、文件描述符等（通过设置共享标志）。</li>
<li>用户态线程库（如pthread）基于<code>clone()</code>实现，提供线程创建、同步等功能。</li>
<li>线程有独立的栈、TID（线程ID），但共享进程的PID。</li>
</ul>
</li>
<li><strong>调度</strong>：<ul>
<li>线程与进程统一调度，CFS不区分进程和线程，按<code>task_struct</code>分配CPU时间。</li>
<li>线程切换开销低，仅保存少量状态。</li>
</ul>
</li>
<li><strong>通信与同步</strong>：<ul>
<li>线程通过共享内存通信，使用pthread提供的锁（mutex）、条件变量、信号量等同步机制。</li>
<li>Linux内核提供futex（快速用户态互斥锁）优化用户态同步。</li>
</ul>
</li>
</ul>
<p><strong>Linux 的独特设计</strong>：</p>
<ul>
<li>进程和线程在内核层面统一为<code>task_struct</code>，线程只是共享资源的特殊进程。</li>
<li>这种设计简化了内核实现，但用户态需依赖线程库（如glibc的pthread）提供高级功能。</li>
<li>线程组（Thread Group）通过相同的TGID（线程组ID，等同于进程PID）管理多个线程。</li>
</ul>
<hr>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><strong>总结对比</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td><strong>资源分配</strong></td>
<td>独立地址空间、资源</td>
<td>共享进程资源，仅有私有栈和寄存器</td>
</tr>
<tr>
<td><strong>调度</strong></td>
<td>PCB管理，切换成本高</td>
<td>TCB管理，切换成本低</td>
</tr>
<tr>
<td><strong>并发</strong></td>
<td>进程间并发，隔离性强</td>
<td>进程内并发，效率高</td>
</tr>
<tr>
<td><strong>独立性</strong></td>
<td>高，崩溃不影响其他进程</td>
<td>低，线程错误可能导致进程崩溃</td>
</tr>
<tr>
<td><strong>系统开销</strong></td>
<td>创建、切换、销毁开销大</td>
<td>创建、切换、销毁开销小</td>
</tr>
<tr>
<td><strong>通信机制</strong></td>
<td>IPC复杂（管道、共享内存等）</td>
<td>共享内存，需同步机制</td>
</tr>
</tbody></table>
<p><strong>Linux 实现特点</strong>：</p>
<ul>
<li>进程和线程统一为<code>task_struct</code>，线程是共享资源的轻量级进程。</li>
<li>进程切换涉及地址空间切换，开销大；线程切换仅涉及栈和寄存器，效率高。</li>
<li>Linux通过CFS统一调度，提供高效的并发支持。</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>操作系统，进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的信息与如何设置进程退出</title>
    <url>/2025/06/30/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA/</url>
    <content><![CDATA[<h1 id="查看进程信息与设置进程优雅退出"><a href="#查看进程信息与设置进程优雅退出" class="headerlink" title="查看进程信息与设置进程优雅退出"></a>查看进程信息与设置进程优雅退出</h1><p>以下是如何在Linux&#x2F;Unix系统中查看进程信息以及设置进程优雅退出的方法，使用常用命令和工具，结合C++编程示例。</p>
<h2 id="1-查看进程信息"><a href="#1-查看进程信息" class="headerlink" title="1. 查看进程信息"></a>1. <strong>查看进程信息</strong></h2><h3 id="方法1：使用-ps-命令"><a href="#方法1：使用-ps-命令" class="headerlink" title="方法1：使用 ps 命令"></a>方法1：使用 <code>ps</code> 命令</h3><p><code>ps</code> 命令用于显示进程信息，常用选项如下：</p>
<ul>
<li><code>ps aux</code>：显示所有用户的所有进程。<ul>
<li><code>a</code>：显示所有用户的进程。</li>
<li><code>u</code>：显示详细用户信息。</li>
<li><code>x</code>：显示无终端的进程。</li>
</ul>
</li>
<li><code>ps -ef</code>：显示所有进程，包含完整命令行。</li>
<li><code>ps -p &lt;PID&gt;</code>：查看指定进程ID（PID）的详细信息。</li>
</ul>
<p><strong>示例</strong>：<br>查看所有进程的PID、用户、CPU&#x2F;内存使用情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.1 123456  7892 ?        Ss   Jun28   0:01 /sbin/init</span><br><span class="line">alice     1234  1.2  0.5 987654 12345 pts/0    S    10:00   0:10 myapp</span><br></pre></td></tr></table></figure>

<p>筛选特定进程（如名为 <code>myapp</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep myapp</span><br></pre></td></tr></table></figure>

<h3 id="方法2：使用-top-或-htop"><a href="#方法2：使用-top-或-htop" class="headerlink" title="方法2：使用 top 或 htop"></a>方法2：使用 <code>top</code> 或 <code>htop</code></h3><ul>
<li><code>top</code>：实时显示进程信息，按CPU&#x2F;内存使用排序。<ul>
<li>按 <code>q</code> 退出，<code>k</code> 输入PID终止进程。</li>
</ul>
</li>
<li><code>htop</code>：更友好的交互式工具（需安装）。<ul>
<li>示例：<code>htop</code>，然后用箭头选择进程，按 <code>F9</code> 选择信号终止。</li>
</ul>
</li>
</ul>
<h3 id="方法3：使用-proc-文件系统"><a href="#方法3：使用-proc-文件系统" class="headerlink" title="方法3：使用 /proc 文件系统"></a>方法3：使用 <code>/proc</code> 文件系统</h3><p>Linux下，<code>/proc/&lt;PID&gt;</code> 目录包含进程详细信息：</p>
<ul>
<li><code>/proc/&lt;PID&gt;/status</code>：进程状态、内存使用等。</li>
<li><code>/proc/&lt;PID&gt;/cmdline</code>：进程启动命令。</li>
</ul>
<p><strong>示例</strong>：<br>查看PID为1234的进程状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/1234/status</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name:   myapp</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Pid:    1234</span><br><span class="line">VmSize: 987654 kB</span><br></pre></td></tr></table></figure>

<h3 id="方法4：使用-pidstat（需安装-sysstat）"><a href="#方法4：使用-pidstat（需安装-sysstat）" class="headerlink" title="方法4：使用 pidstat（需安装 sysstat）"></a>方法4：使用 <code>pidstat</code>（需安装 <code>sysstat</code>）</h3><p>查看进程资源使用情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pidstat -p 1234</span><br></pre></td></tr></table></figure>
<p>输出CPU、内存、I&#x2F;O等详细信息。</p>
<h2 id="2-设置进程优雅退出"><a href="#2-设置进程优雅退出" class="headerlink" title="2. 设置进程优雅退出"></a>2. <strong>设置进程优雅退出</strong></h2><p>优雅退出（Graceful Shutdown）是指进程在接收终止信号后，完成当前任务、释放资源（如关闭文件、网络连接）后安全退出。通常通过捕获信号（如SIGTERM）实现。</p>
<h3 id="方法1：使用信号终止进程"><a href="#方法1：使用信号终止进程" class="headerlink" title="方法1：使用信号终止进程"></a>方法1：使用信号终止进程</h3><p>Linux常用信号：</p>
<ul>
<li><code>SIGTERM</code>（15）：请求进程优雅退出（默认信号）。</li>
<li><code>SIGKILL</code>（9）：强制终止（不推荐，可能导致资源未释放）。</li>
<li><code>SIGHUP</code>（1）：常用于重新加载配置或优雅退出。</li>
</ul>
<p><strong>命令行终止进程</strong>：</p>
<ul>
<li>优雅退出：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -SIGTERM &lt;PID&gt;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">kill</span> &lt;PID&gt;  <span class="comment"># 默认发送SIGTERM</span></span><br></pre></td></tr></table></figure></li>
<li>强制终止：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -SIGKILL &lt;PID&gt;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">kill</span> -9 &lt;PID&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>查找并终止特定进程</strong>：<br>杀死名为 <code>myapp</code> 的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill -SIGTERM myapp</span><br></pre></td></tr></table></figure>

<h3 id="方法2：编程实现优雅退出（C-示例）"><a href="#方法2：编程实现优雅退出（C-示例）" class="headerlink" title="方法2：编程实现优雅退出（C++示例）"></a>方法2：编程实现优雅退出（C++示例）</h3><p>在程序中捕获 <code>SIGTERM</code> 信号，执行清理操作后退出。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">running</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalHandler</span><span class="params">(<span class="type">int</span> signum)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Received signal &quot;</span> &lt;&lt; signum &lt;&lt; <span class="string">&quot;, shutting down gracefully...\n&quot;</span>;</span><br><span class="line">    running = <span class="literal">false</span>; <span class="comment">// 设置标志，通知程序退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册SIGTERM信号处理</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, signalHandler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGHUP, signalHandler);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Process running (PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;). Press Ctrl+C or send SIGTERM to exit.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟工作循环</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cleaning up resources...\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 关闭文件、网络连接等</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Process exited gracefully.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li><code>signal(SIGTERM, signalHandler)</code>：注册 <code>SIGTERM</code> 信号处理函数。</li>
<li><code>std::atomic&lt;bool&gt;</code>：确保线程安全的标志变量。</li>
<li>程序收到 <code>SIGTERM</code> 后，设置 <code>running = false</code>，退出循环，执行清理后退出。</li>
</ul>
<p><strong>编译与运行</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o myapp graceful_shutdown.cpp</span><br><span class="line">./myapp</span><br></pre></td></tr></table></figure>
<p>在另一个终端发送 <code>SIGTERM</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -SIGTERM &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<p>程序将打印清理信息并退出。</p>
<h3 id="方法3：使用-systemd-管理服务优雅退出"><a href="#方法3：使用-systemd-管理服务优雅退出" class="headerlink" title="方法3：使用 systemd 管理服务优雅退出"></a>方法3：使用 <code>systemd</code> 管理服务优雅退出</h3><p>若进程作为 <code>systemd</code> 服务运行，可通过 <code>systemd</code> 配置优雅退出。</p>
<p><strong>示例服务文件</strong>（<code>/etc/systemd/system/myapp.service</code>）：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Application</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/path/to/myapp</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">KillSignal</span>=SIGTERM</span><br><span class="line"><span class="attr">TimeoutStopSec</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<ul>
<li><code>KillSignal=SIGTERM</code>：发送 <code>SIGTERM</code> 信号请求优雅退出。</li>
<li><code>TimeoutStopSec=10</code>：等待10秒后若未退出，强制终止。</li>
</ul>
<p><strong>控制服务</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start myapp</span><br><span class="line"><span class="comment"># 停止服务（发送SIGTERM）</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop myapp</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status myapp</span><br></pre></td></tr></table></figure>

<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. <strong>注意事项</strong></h2><ul>
<li><strong>查看进程信息</strong>：<ul>
<li>使用 <code>ps</code> 或 <code>top</code> 快速查看，<code>/proc</code> 适合脚本化处理。</li>
<li>定期监控避免遗漏（如 <code>watch ps aux</code>）。</li>
</ul>
</li>
<li><strong>优雅退出</strong>：<ul>
<li>优先使用 <code>SIGTERM</code>，避免 <code>SIGKILL</code> 导致数据丢失或资源泄漏。</li>
<li>程序设计时需处理信号，确保释放文件句柄、网络连接等资源。</li>
<li>对于复杂应用，考虑超时机制（如 <code>TimeoutStopSec</code>）。</li>
</ul>
</li>
<li><strong>测试信号处理</strong>：<ul>
<li>在开发时，测试程序对 <code>SIGTERM</code> 和 <code>SIGHUP</code> 的响应，确保清理逻辑正确。</li>
</ul>
</li>
</ul>
<h2 id="4-综合示例"><a href="#4-综合示例" class="headerlink" title="4. 综合示例"></a>4. <strong>综合示例</strong></h2><p>查看进程并优雅终止：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找myapp进程</span></span><br><span class="line">ps aux | grep myapp</span><br><span class="line"><span class="comment"># 输出：alice 1234 ... myapp</span></span><br><span class="line"><span class="comment"># 发送SIGTERM</span></span><br><span class="line"><span class="built_in">kill</span> -SIGTERM 1234</span><br><span class="line"><span class="comment"># 验证进程已退出</span></span><br><span class="line">ps -p 1234</span><br></pre></td></tr></table></figure>

<p>若使用C++程序，结合上述代码，进程会捕获信号并安全退出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>查看进程</strong>：使用 <code>ps</code>、<code>top</code>、<code>htop</code> 或 <code>/proc</code> 获取进程信息。</li>
<li><strong>优雅退出</strong>：通过 <code>SIGTERM</code> 信号或 <code>systemd</code> 配置触发，程序需实现信号处理逻辑。</li>
<li><strong>编程实现</strong>：捕获信号，清理资源后退出，确保数据完整性和资源释放。</li>
</ul>
<p>如需更具体场景或代码示例，请提供进一步细节！</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/2025/05/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>昨天忽然想到，emplace_back和push_back，emplace_back本质就是移动语义吗，然后在容器后边直接构造，只有一次构造，我就想，那push_back一个右值的时候，是不是和emplace_back一模一样的啊，然后翻了翻以前自己的博客（请神上身了属于是）,然后直接绷不住了，写的什么玩意，一点不深刻。有一种看自己五年前QQ动态的美（人果然不能共情曾经的自己）。</p>
<p>实际上哈，push_back左值右值是不一样的，会调用重载的不同版本的push_back函数，都要调用构造函数创建对象，区别只在于传入左值调用拷贝构造函数，传入右值调用移动构造函数，而emplace_back是完美转发参数给内部，调用的构造函数。</p>
<p>到此为止。</p>
<p>———————————————————不知道华不华丽的分割线—————————————————</p>
<p>迭代器，用b站宇文新粥的说法，就是给指针穿上了华丽的衣服，是指针的钢铁侠战甲</p>
<p>迭代器，实际上是类or结构体，里面封装了一个对应容器的指针，以及所有相关的操作符重载，目的就是让迭代器有指针的所有功能</p>
<h3 id="为什么要迭代器而不是指针"><a href="#为什么要迭代器而不是指针" class="headerlink" title="为什么要迭代器而不是指针"></a>为什么要迭代器而不是指针</h3><p>因为容器是多种多样的，比如vector是内存分布在相邻地址，而list就是链表，每个节点相隔甚远，map什么的用红黑树实现就更别说了，而容器算法很多又是通用的，比如sort（list不能用），find等，为了让list也能用类似原生指针的东西访问，我们采用了迭代器。</p>
<p>不同容器的迭代器是不一样的，比如vector就很类似原生指针，而其他的只是重载函数实现了类似效果</p>
<p><strong>容器与迭代器的关系</strong></p>
<ul>
<li>每个容器类（如 <code>std::vector</code>, <code>std::list</code>, <code>std::map</code> 等）都在其内部定义了至少一种或多种迭代器类型（例如 <code>iterator</code> 和 <code>const_iterator</code>）。这些迭代器类型是该容器的<strong>友元类</strong>，或者直接定义在容器类内部，以便访问容器的私有成员（如 <code>vector</code> 的底层数组指针，<code>list</code> 的节点指针）。</li>
<li>容器的 <code>begin()</code> 和 <code>end()</code> 成员函数负责创建并返回该容器特定类型的迭代器对象。</li>
</ul>
<p><strong>迭代器特性 (Iterator Traits)</strong></p>
<p>标准库算法（如 <code>std::sort</code>, <code>std::find</code>）是泛型的，它们通过模板参数接收迭代器。为了知道传入的迭代器具备哪些能力（属于哪个类别），以及它指向的元素类型是什么，标准库使用了一个叫做 <code>std::iterator_traits</code> 的模板元编程技术。</p>
<p><code>std::iterator_traits&lt;Iterator&gt;</code> 可以提取出迭代器的以下信息：</p>
<ul>
<li><code>iterator_category</code>: 迭代器类别（如 <code>std::random_access_iterator_tag</code>）</li>
<li><code>value_type</code>: 迭代器指向的元素类型</li>
<li><code>difference_type</code>: 两个迭代器之间的距离类型</li>
<li><code>pointer</code>: 指向元素类型的指针类型</li>
<li><code>reference</code>: 元素类型的引用类型</li>
</ul>
<p>自定义的迭代器需要通过继承 <code>std::iterator</code> 或在迭代器类中定义这些 <code>typedef</code> 来配合 <code>std::iterator_traits</code>。</p>
<h3 id="type-traits-类型萃取"><a href="#type-traits-类型萃取" class="headerlink" title="type traits(类型萃取)"></a>type traits(类型萃取)</h3><p>主要体现在<strong>算法如何根据迭代器的特性来选择最优化的实现路径</strong>。</p>
<p>核心机制是通过 <code>std::iterator_traits</code> 这个类型萃取模板来实现的。</p>
<p><strong>1. <code>std::iterator_traits</code> 的作用</strong></p>
<p><code>std::iterator_traits</code> 是一个特殊的类型萃取模板，它的作用是从任何迭代器类型 <code>Iterator</code> 中提取出关于该迭代器的标准信息。这些信息通常是通过迭代器类内部定义的 <code>typedef</code> 来提供的。<code>std::iterator_traits</code> 会查找并暴露这些嵌套类型，使得算法可以通过统一的方式访问它们。</p>
<p><code>std::iterator_traits&lt;Iterator&gt;</code> 通常会提供以下几个重要的嵌套类型（即萃取出的特性）：</p>
<ul>
<li><code>value_type</code>: 迭代器所指向元素的类型。</li>
<li><code>difference_type</code>: 用于表示两个迭代器之间距离的类型（通常是 <code>ptrdiff_t</code>）。</li>
<li><code>pointer</code>: 迭代器指向元素的指针类型。</li>
<li><code>reference</code>: 迭代器指向元素的引用类型。</li>
<li><code>iterator_category</code>: 这是一个非常重要的特性，它指示了迭代器的能力（例如，输入迭代器、前向迭代器、随机访问迭代器等）。</li>
</ul>
<p><code>std::iterator_traits</code> 还为原始指针类型（如 <code>T*</code>）提供了偏特化，使得原始指针也能像 STL 迭代器一样工作，并被识别为随机访问迭代器。</p>
<p><strong>2. 迭代器分类与标签 (Iterator Categories and Tags)</strong></p>
<p><code>iterator_category</code> 是连接 Type Traits 和迭代器能力的关键。C++ 定义了一系列的标签类型来表示不同的迭代器类别，它们之间存在继承关系：</p>
<ul>
<li><code>std::input_iterator_tag</code> (输入迭代器)</li>
<li><code>std::output_iterator_tag</code> (输出迭代器)</li>
<li><code>std::forward_iterator_tag</code> (前向迭代器) - 继承自 <code>input_iterator_tag</code> 和 <code>output_iterator_tag</code></li>
<li><code>std::bidirectional_iterator_tag</code> (双向迭代器) - 继承自 <code>forward_iterator_tag</code></li>
<li><code>std::random_access_iterator_tag</code> (随机访问迭代器) - 继承自 <code>bidirectional_iterator_tag</code></li>
</ul>
<p>一个迭代器类型通过在其内部定义 <code>iterator_category</code> 为这些标签类型之一，来声明自己的能力。例如，<code>std::vector</code> 的迭代器内部会定义 <code>typedef std::random_access_iterator_tag iterator_category;</code>。</p>
<p><strong>3. 算法如何利用 <code>std::iterator_traits</code> 和分类标签</strong></p>
<p>STL 算法（如 <code>std::advance</code>, <code>std::distance</code>, <code>std::copy</code>, <code>std::sort</code> 等）是模板函数，它们接受迭代器作为参数。在算法的内部实现中，它们会使用 <code>std::iterator_traits</code> 来获取迭代器的特性，尤其是 <code>iterator_category</code>。</p>
<p>基于 <code>iterator_category</code> 的不同，算法会采用不同的实现策略。这通常通过<strong>标签分派 (Tag Dispatching)</strong> 或 C++17 后的 <code>if constexpr</code> 来实现，这是一种编译时多态。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接表，邻接矩阵和十字链表</title>
    <url>/2024/10/16/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="1-邻接表的实现"><a href="#1-邻接表的实现" class="headerlink" title="1. 邻接表的实现"></a>1. 邻接表的实现</h3><p>邻接表使用一个数组或 <code>vector</code> 来存储每个顶点的边列表。每个顶点的边列表存储在一个链表或 <code>vector</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// 顶点数量</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adj.<span class="built_in">resize</span>(V);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj[i]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; v;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-邻接矩阵的实现"><a href="#2-邻接矩阵的实现" class="headerlink" title="2. 邻接矩阵的实现"></a>2. 邻接矩阵的实现</h3><p>邻接矩阵使用一个二维数组来存储顶点之间的边。每个元素表示顶点之间是否存在边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// 顶点数量</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMatrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adjMatrix.<span class="built_in">resize</span>(V, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjMatrix[u][v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是无向图，也要添加下面这一行</span></span><br><span class="line">        <span class="comment">// adjMatrix[v][u] = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                cout &lt;&lt; adjMatrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-十字链表的实现"><a href="#3-十字链表的实现" class="headerlink" title="3. 十字链表的实现"></a>3. 十字链表的实现</h3><p>十字链表是一种复杂的数据结构，特别适用于有向图。它包含每个顶点的出边和入边链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> tail;  <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> head;  <span class="comment">// 边的终点</span></span><br><span class="line">    EdgeNode *nextOut; <span class="comment">// 下一条出边</span></span><br><span class="line">    EdgeNode *nextIn;  <span class="comment">// 下一条入边</span></span><br><span class="line">    <span class="built_in">EdgeNode</span>(<span class="type">int</span> t, <span class="type">int</span> h) : <span class="built_in">tail</span>(t), <span class="built_in">head</span>(h), <span class="built_in">nextOut</span>(<span class="literal">nullptr</span>), <span class="built_in">nextIn</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 顶点的数据</span></span><br><span class="line">    EdgeNode *firstOut; <span class="comment">// 出边链表头节点</span></span><br><span class="line">    EdgeNode *firstIn;  <span class="comment">// 入边链表头节点</span></span><br><span class="line">    <span class="built_in">VertexNode</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(d), <span class="built_in">firstOut</span>(<span class="literal">nullptr</span>), <span class="built_in">firstIn</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrthogonalList</span> &#123;</span><br><span class="line">    vector&lt;VertexNode*&gt; vertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrthogonalList</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">            vertices.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">VertexNode</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        EdgeNode* edge = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(u, v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到出边链表</span></span><br><span class="line">        edge-&gt;nextOut = vertices[u]-&gt;firstOut;</span><br><span class="line">        vertices[u]-&gt;firstOut = edge;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到入边链表</span></span><br><span class="line">        edge-&gt;nextIn = vertices[v]-&gt;firstIn;</span><br><span class="line">        vertices[v]-&gt;firstIn = edge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打印出边链表</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;  Out-edges:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode* e = vertices[i]-&gt;firstOut; e != <span class="literal">nullptr</span>; e = e-&gt;nextOut) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; e-&gt;head;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印入边链表</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;  In-edges:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode* e = vertices[i]-&gt;firstIn; e != <span class="literal">nullptr</span>; e = e-&gt;nextIn) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &lt;- &quot;</span> &lt;&lt; e-&gt;tail;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">OrthogonalList <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>十字链表</strong>（Orthogonal List）是一种用于表示<strong>有向图</strong>的链式存储结构，它同时包含了每个顶点的<strong>入边</strong>和<strong>出边</strong>信息。十字链表是一种扩展的邻接表，能够方便地访问有向图中的边和顶点的入度、出度关系。该结构特别适合处理复杂的有向图问题。</p>
<h3 id="十字链表的定义"><a href="#十字链表的定义" class="headerlink" title="十字链表的定义"></a>十字链表的定义</h3><p>在十字链表中，每个顶点既有一个<strong>出边链表</strong>，也有一个<strong>入边链表</strong>，分别存储从该顶点出发和指向该顶点的边。具体来说：</p>
<ul>
<li>每条边由两个链表节点表示：<strong>出边节点</strong>（表示从某顶点出发的边）和<strong>入边节点</strong>（表示指向某顶点的边）。</li>
<li>顶点包含两个指针：一个指向该顶点的出边链表的头节点，另一个指向该顶点的入边链表的头节点。</li>
</ul>
<h3 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h3><ul>
<li><strong>顶点结构（Vertex Node）</strong>：每个顶点有两个指针，一个指向该顶点的出边链表（out-edge list），另一个指向该顶点的入边链表（in-edge list）。</li>
<li><strong>边结构（Edge Node）</strong>：每条边有两个指针，一个指向下一个出边（out-edge），另一个指向下一个入边（in-edge）。此外，边节点会记录边的起点和终点信息（通常是用来标识的起点和终点索引）。</li>
</ul>
<h3 id="十字链表的节点结构"><a href="#十字链表的节点结构" class="headerlink" title="十字链表的节点结构"></a>十字链表的节点结构</h3><p>假设有向图有 ( V ) 个顶点， ( E ) 条边，十字链表的基本节点可以定义为以下形式：</p>
<ol>
<li><p><strong>顶点节点（Vertex Node）</strong>：</p>
<ul>
<li><strong>data</strong>：顶点的值或标识。</li>
<li><strong>firstOut</strong>：指向该顶点的<strong>出边链表</strong>的头节点。</li>
<li><strong>firstIn</strong>：指向该顶点的<strong>入边链表</strong>的头节点。</li>
</ul>
</li>
<li><p><strong>边节点（Edge Node）</strong>：</p>
<ul>
<li><strong>tail</strong>：起点（边的出发顶点）。</li>
<li><strong>head</strong>：终点（边的目标顶点）。</li>
<li><strong>nextOut</strong>：指向<strong>出边链表</strong>中的下一条边（从相同顶点出发的下一条边）。</li>
<li><strong>nextIn</strong>：指向<strong>入边链表</strong>中的下一条边（指向相同顶点的下一条边）。</li>
<li><strong>weight</strong>（可选）：如果是加权图，则可以包含边的权重信息。</li>
</ul>
</li>
</ol>
<h3 id="十字链表的示例"><a href="#十字链表的示例" class="headerlink" title="十字链表的示例"></a>十字链表的示例</h3><p>我们通过一个简单的有向图来说明十字链表的结构。假设有如下有向图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">顶点：A, B, C, D</span><br><span class="line">边：A → B, A → C, B → C, C → D</span><br></pre></td></tr></table></figure>

<h4 id="1-顶点的出边链表和入边链表"><a href="#1-顶点的出边链表和入边链表" class="headerlink" title="1. 顶点的出边链表和入边链表"></a>1. 顶点的出边链表和入边链表</h4><ul>
<li>顶点 A 的<strong>出边链表</strong>：A → B, A → C</li>
<li>顶点 A 的<strong>入边链表</strong>：无</li>
<li>顶点 B 的<strong>出边链表</strong>：B → C</li>
<li>顶点 B 的<strong>入边链表</strong>：A → B</li>
<li>顶点 C 的<strong>出边链表</strong>：C → D</li>
<li>顶点 C 的<strong>入边链表</strong>：A → C, B → C</li>
<li>顶点 D 的<strong>入边链表</strong>：C → D</li>
</ul>
<h4 id="2-十字链表表示"><a href="#2-十字链表表示" class="headerlink" title="2. 十字链表表示"></a>2. 十字链表表示</h4><p>顶点节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A: firstOut -&gt; (A → B), firstIn -&gt; null</span><br><span class="line">B: firstOut -&gt; (B → C), firstIn -&gt; (A → B)</span><br><span class="line">C: firstOut -&gt; (C → D), firstIn -&gt; (A → C)</span><br><span class="line">D: firstOut -&gt; null,      firstIn -&gt; (C → D)</span><br></pre></td></tr></table></figure>

<p>边节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(A → B): nextOut -&gt; (A → C), nextIn -&gt; null</span><br><span class="line">(A → C): nextOut -&gt; null,      nextIn -&gt; null</span><br><span class="line">(B → C): nextOut -&gt; null,      nextIn -&gt; (A → C)</span><br><span class="line">(C → D): nextOut -&gt; null,      nextIn -&gt; null</span><br></pre></td></tr></table></figure>

<p>在这个结构中，顶点 A 通过 <code>firstOut</code> 链接了出边 <code>(A → B)</code>，并通过 <code>nextOut</code> 指向下一条出边 <code>(A → C)</code>，而 <code>firstIn</code> 为 <code>null</code>，因为没有指向 A 的边。同样，边 <code>(A → B)</code> 的 <code>nextIn</code> 为空，因为没有指向 B 的其他边。</p>
<h3 id="十字链表的优缺点"><a href="#十字链表的优缺点" class="headerlink" title="十字链表的优缺点"></a>十字链表的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>方便处理有向图</strong>：十字链表同时存储了<strong>出边</strong>和<strong>入边</strong>信息，因此可以方便地遍历从顶点出发的边以及指向该顶点的边。这使得在处理有向图的算法中（如拓扑排序、求解强连通分量等）非常高效。</li>
<li><strong>高效的边操作</strong>：可以快速获取某个顶点的所有出边和入边，适合需要频繁查询边信息的场景。</li>
<li><strong>适合稀疏图</strong>：十字链表只存储实际存在的边，因此在边数较少的稀疏图中节省空间。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>复杂性高</strong>：相比于普通的邻接表或邻接矩阵，十字链表的数据结构较为复杂，构建和维护成本较高。每条边需要维护两个链表，代码实现上较为复杂。</li>
<li><strong>空间占用较大</strong>：由于每条边需要存储两个链表指针（<code>nextOut</code> 和 <code>nextIn</code>），十字链表比简单的邻接表占用更多的空间。</li>
</ol>
<h3 id="十字链表的时间复杂度"><a href="#十字链表的时间复杂度" class="headerlink" title="十字链表的时间复杂度"></a>十字链表的时间复杂度</h3><ul>
<li><strong>空间复杂度</strong>：由于每条边都需要额外维护两个指针，十字链表的空间复杂度为 ( O(V + 2E) )，即每个顶点存储两个指针，每条边也存储两个指针。</li>
<li><strong>遍历所有出边&#x2F;入边</strong>：从某个顶点出发，遍历所有出边或入边的时间复杂度是 ( O(d) )，其中 ( d ) 是该顶点的度数。</li>
<li><strong>查找特定边</strong>：查找某个顶点的所有出边或入边仍然需要遍历整个链表，时间复杂度为 ( O(d) )。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>有向图的遍历</strong>：十字链表适合处理需要同时遍历出边和入边的有向图算法，例如：</p>
<ul>
<li><strong>拓扑排序</strong>：需要同时考虑入度和出度，十字链表方便在 O(1) 时间内访问这些信息。</li>
<li><strong>强连通分量</strong>算法：在求解强连通分量时，需要遍历有向图的逆图，十字链表能够高效支持这种操作。</li>
</ul>
</li>
<li><p><strong>网络流</strong>：在最大流或最小费用流等问题中，十字链表能够高效表示网络中的有向边及其流量信息。</p>
</li>
</ul>
<p><strong>十字链表</strong>是一种用于表示<strong>有向图</strong>的链式结构，通过同时维护顶点的出边和入边链表，能够高效处理有向图的遍历和操作，尤其适用于那些需要频繁查询边信息和入度、出度关系的应用场景。虽然其空间开销较大，结构复杂，但在有向图的高级算法中，十字链表提供了很高的效率。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>邻接表</strong>适用于稀疏图，空间效率高，但查询特定边的时间复杂度较高。</li>
<li><strong>邻接矩阵</strong>适用于稠密图，查询特定边的时间复杂度为 $O(1)$，但空间效率较低。</li>
<li><strong>十字链表</strong>适用于有向图，能够高效地处理出边和入边的操作，适合复杂的有向图算法。</li>
</ul>
<p>通过这些实现，我们可以根据具体问题的需求选择合适的数据结构来表示图。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>静态编译与动态编译</title>
    <url>/2025/06/08/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>静态编译和动态编译是两种编译的形式，静态编译简单来说就是全部编译完毕，编译器将代码直接编译成二进制码，链接器把静态库（.a)编译进去。而动态编译也叫延时编译，只将代码编译成中间码，就是将编译过程延迟到程序运行时进行。</p>
<p>相比较而言，两种编译各有优点，c++使用较多的是静态编译</p>
<h2 id="1-静态编译"><a href="#1-静态编译" class="headerlink" title="1. 静态编译"></a>1. 静态编译</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>编译器（如 GCC、Clang）将源代码（C&#x2F;C++ 等）翻译为目标机器的二进制代码。</li>
<li>链接器将目标代码与静态库（.a 文件）链接，生成完整可执行文件。</li>
<li><strong>所有符号解析和地址分配在编译时完成。</strong></li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>性能高效</strong>：运行时直接执行机器码，无编译开销，速度快。</li>
<li><strong>独立性强</strong>：可执行文件包含所有依赖，运行时无需额外库（除系统级动态库）。</li>
<li><strong>优化充分</strong>：编译器可在编译时进行全局优化（如内联、死代码消除）。</li>
<li><strong>可预测性</strong>：资源需求固定，适合嵌入式系统。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>文件较大</strong>：因包含所有依赖，可执行文件体积大。</li>
<li><strong>不可动态更新</strong>：修改代码需重新编译和部署。</li>
<li><strong>兼容性问题</strong>：针对特定平台编译，跨平台需重新编译。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>嵌入式系统：资源受限，需独立运行（如微控制器程序）。</li>
<li>高性能应用：游戏引擎、操作系统内核（如 Linux 内核部分）。</li>
<li>静态链接程序：不依赖外部库的工具。</li>
</ul>
<h2 id="2-动态编译"><a href="#2-动态编译" class="headerlink" title="2. 动态编译"></a>2. 动态编译</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>源代码先编译为中间表示（如 Java 字节码、.NET IL 代码）。</li>
<li>运行时，JIT 编译器（如 Java 的 HotSpot、JavaScript 的 V8 引擎）将中间代码动态编译为机器码。</li>
<li>编译可能只针对热点代码（频繁执行的部分），结合解释执行。</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>灵活性高</strong>：运行时可根据硬件和上下文优化代码（如 CPU 特性）。</li>
<li><strong>跨平台</strong>：中间代码与平台无关，JIT 编译适配目标机器。</li>
<li><strong>动态优化</strong>：根据运行时数据（如分支预测）优化性能。</li>
<li><strong>更新便捷</strong>：无需重新编译整个程序，适合动态语言。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>启动延迟</strong>：运行时编译增加启动时间。</li>
<li><strong>资源占用</strong>：编译过程消耗 CPU 和内存。</li>
<li><strong>复杂性高</strong>：JIT 编译器实现复杂，调试困难。</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>虚拟机：Java（JVM）、.NET（CLR）运行时环境。</li>
<li>动态语言：JavaScript（V8 引擎）、Python（PyPy 的 JIT）。</li>
<li>性能敏感应用：结合运行时信息优化的场景（如数据库查询）。</li>
</ul>
<h2 id="3-对比表格"><a href="#3-对比表格" class="headerlink" title="3. 对比表格"></a>3. 对比表格</h2><table>
<thead>
<tr>
<th>特性</th>
<th>静态编译</th>
<th>动态编译</th>
</tr>
</thead>
<tbody><tr>
<td><strong>编译时机</strong></td>
<td>运行前</td>
<td>运行时</td>
</tr>
<tr>
<td><strong>输出</strong></td>
<td>机器码（可执行文件）</td>
<td>中间代码 + 运行时机器码</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>启动快，运行高效</td>
<td>启动慢，运行可优化</td>
</tr>
<tr>
<td><strong>文件大小</strong></td>
<td>较大（含依赖）</td>
<td>较小（中间代码）</td>
</tr>
<tr>
<td><strong>跨平台</strong></td>
<td>需为各平台单独编译</td>
<td>中间代码跨平台，运行时适配</td>
</tr>
<tr>
<td><strong>优化</strong></td>
<td>编译时全局优化</td>
<td>运行时动态优化</td>
</tr>
<tr>
<td><strong>典型语言</strong></td>
<td>C, C++, Rust</td>
<td>Java, JavaScript, Python</td>
</tr>
</tbody></table>
<p>顺便说一下，静态链接与动态链接</p>
<h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><p>静态链接在静态编译上说到了，是将.a这种静态库直接编译进去，而动态编译只是在运行时才调用.so库</p>
<h2 id="对比表格"><a href="#对比表格" class="headerlink" title="对比表格"></a>对比表格</h2><table>
<thead>
<tr>
<th>特性</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>链接时机</strong></td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td><strong>可执行文件大小</strong></td>
<td>较大（包含库代码）</td>
<td>较小（仅符号引用）</td>
</tr>
<tr>
<td><strong>内存使用</strong></td>
<td>每个程序复制库代码，占用高</td>
<td>共享库代码，节省内存</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>快，无加载开销</td>
<td>慢，需加载和解析符号</td>
</tr>
<tr>
<td><strong>部署</strong></td>
<td>简单，自包含</td>
<td>需确保共享库存在</td>
</tr>
<tr>
<td><strong>更新</strong></td>
<td>需重新编译整个程序</td>
<td>仅更新共享库</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>不支持插件或动态加载</td>
<td>支持插件和模块化设计</td>
</tr>
<tr>
<td><strong>典型库文件</strong></td>
<td><code>.a</code> (Linux), <code>.lib</code> (Windows)</td>
<td><code>.so</code> (Linux), <code>.dll</code> (Windows)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>编译</tag>
      </tags>
  </entry>
</search>
