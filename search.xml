<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Github拒绝push</title>
    <url>/2024/09/19/Github%E6%8B%92%E7%BB%9Dpush/</url>
    <content><![CDATA[<h2 id="Github-拒绝了你的push"><a href="#Github-拒绝了你的push" class="headerlink" title="Github 拒绝了你的push"></a>Github 拒绝了你的push</h2><p>你有没有出现以下问题？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ! [remote rejected] HEAD -&gt; main (push declined due to repository rule violations)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/cmzcc/cmzcc.github.io.git&#x27;</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教"><a href="#今天本人在像往常一样运行hexo-d-时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教" class="headerlink" title="今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教."></a>今天本人在像往常一样运行hexo d 时出现了以上报错，苦思冥想，绞尽脑汁，最终勉强解决，如有大能，望不吝赐教.</h4><h3 id="1-出现问题的原因"><a href="#1-出现问题的原因" class="headerlink" title="1.出现问题的原因"></a>1.出现问题的原因</h3><h4 id="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用"><a href="#出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用" class="headerlink" title="出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用."></a>出现这种问题基本就是像我一样作死，在某一处加入了token之类的隐私，然后github识别到了，觉得有风险，就把你列入失信名单了，把token删了也没用.</h4><h4 id="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用"><a href="#我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用" class="headerlink" title="我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用."></a>我亲测是必须换一个地方创建新的hexo才能解决，像什么删除github仓库之类的都没用.</h4><h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h3><h4 id="（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下"><a href="#（1）在你的github主页里找到setting，然后找到一个code-security，有一个push-protection-for-yourself-把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下" class="headerlink" title="（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下."></a>（1）在你的github主页里找到setting，然后找到一个code security，有一个push protection for yourself,把这玩意关了，能解决以后的问题，但亲测当前的问题无法解决，你们可以试一下.</h4><h4 id="（2）找到你放网站的仓库，add-file看到没有"><a href="#（2）找到你放网站的仓库，add-file看到没有" class="headerlink" title="（2）找到你放网站的仓库，add file看到没有"></a>（2）找到你放网站的仓库，add file看到没有</h4><h4 id="然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去-（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"><a href="#然后upload-files-在你的git里面运行hexo-g之后将public里面的文件拖动上去-（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）" class="headerlink" title="然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去.（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）"></a>然后upload files 在你的git里面运行hexo  g之后将public里面的文件拖动上去.（注意，是public下的文件，不是public这个文件夹，类比上图里面的东西）</h4><h4 id="等上传完毕后，不要退出！！！"><a href="#等上传完毕后，不要退出！！！" class="headerlink" title="等上传完毕后，不要退出！！！"></a>等上传完毕后，不要退出！！！</h4><h4 id="点下面的提交即可，你的网站就水灵灵的更新啦"><a href="#点下面的提交即可，你的网站就水灵灵的更新啦" class="headerlink" title="点下面的提交即可，你的网站就水灵灵的更新啦."></a>点下面的提交即可，你的网站就水灵灵的更新啦.</h4>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>error</tag>
        <tag>hexo</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2025/01/12/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>Lambda 表达式</strong>是一种轻量级的函数对象（或匿名函数），可以在代码中定义并直接使用。它是从 C++11 引入的功能，常用于需要定义短小函数的场景，比如多线程、STL 算法或回调函数中。</p>
<hr>
<h2 id="1-Lambda-表达式的基本语法"><a href="#1-Lambda-表达式的基本语法" class="headerlink" title="1. Lambda 表达式的基本语法"></a><strong>1. Lambda 表达式的基本语法</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[捕获列表](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>捕获列表</code>**：定义 lambda 可以捕获哪些变量，以及如何捕获（按值或按引用）。</li>
<li>**<code>参数列表</code>**：和普通函数类似，定义函数的参数。</li>
<li>**<code>返回类型</code>**：可选，通常由编译器自动推断。</li>
<li>**<code>函数体</code>**：函数的逻辑部分。</li>
</ul>
<hr>
<h2 id="2-Lambda-表达式的基本示例"><a href="#2-Lambda-表达式的基本示例" class="headerlink" title="2. Lambda 表达式的基本示例"></a><strong>2. Lambda 表达式的基本示例</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最简单的 Lambda</span></span><br><span class="line">    <span class="keyword">auto</span> lambda = [] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, Lambda!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda</span>(); <span class="comment">// 调用 lambda</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的 Lambda</span></span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, Lambda!</span><br><span class="line">Sum: 8</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-捕获列表"><a href="#3-捕获列表" class="headerlink" title="3. 捕获列表"></a><strong>3. 捕获列表</strong></h2><p>Lambda 可以通过 <strong>捕获列表</strong> 访问外部变量。捕获列表控制外部变量的作用域和捕获方式。</p>
<h3 id="1-按值捕获"><a href="#1-按值捕获" class="headerlink" title="(1) 按值捕获"></a><strong>(1) 按值捕获</strong></h3><ul>
<li>Lambda 会复制外部变量的值。</li>
<li>外部变量的值在 Lambda 定义时捕获，不受后续修改影响。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> byValue = [x] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Captured by value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">20</span>; <span class="comment">// 修改外部变量</span></span><br><span class="line">    <span class="built_in">byValue</span>(); <span class="comment">// 输出仍然是 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Captured by value: 10</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-按引用捕获"><a href="#2-按引用捕获" class="headerlink" title="(2) 按引用捕获"></a><strong>(2) 按引用捕获</strong></h3><ul>
<li>Lambda 捕获外部变量的引用，因此可以修改外部变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> byReference = [&amp;x] &#123;</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Captured by reference: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">byReference</span>(); <span class="comment">// 修改了 x</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Captured by reference: 20</span><br><span class="line">Modified x: 20</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-捕获所有变量"><a href="#3-捕获所有变量" class="headerlink" title="(3) 捕获所有变量"></a><strong>(3) 捕获所有变量</strong></h3><ul>
<li><strong>按值捕获所有变量</strong>：使用 <code>[=]</code>。</li>
<li><strong>按引用捕获所有变量</strong>：使用 <code>[&amp;]</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> captureAllByValue = [=] &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> captureAllByReference = [&amp;] &#123;</span><br><span class="line">        x += <span class="number">5</span>;</span><br><span class="line">        y += <span class="number">5</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Modified x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">captureAllByValue</span>(); <span class="comment">// 按值捕获，不影响外部变量</span></span><br><span class="line">    <span class="built_in">captureAllByReference</span>(); <span class="comment">// 按引用捕获，修改外部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x: 10, y: 20</span><br><span class="line">Modified x: 15, y: 25</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Lambda-的返回类型"><a href="#4-Lambda-的返回类型" class="headerlink" title="4. Lambda 的返回类型"></a><strong>4. Lambda 的返回类型</strong></h2><h3 id="1-自动推断返回类型"><a href="#1-自动推断返回类型" class="headerlink" title="(1) 自动推断返回类型"></a><strong>(1) 自动推断返回类型</strong></h3><ul>
<li>如果函数体只有一条 <code>return</code> 语句，返回类型会自动推断。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b; <span class="comment">// 自动推断为 int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-显式指定返回类型"><a href="#2-显式指定返回类型" class="headerlink" title="(2) 显式指定返回类型"></a><strong>(2) 显式指定返回类型</strong></h3><ul>
<li>如果返回类型不能自动推断，可以显式指定。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="type">double</span>)a / b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="5-Lambda-在-STL-中的使用"><a href="#5-Lambda-在-STL-中的使用" class="headerlink" title="5. Lambda 在 STL 中的使用"></a><strong>5. Lambda 在 STL 中的使用</strong></h2><p>Lambda 通常用作回调函数，尤其在 STL 算法中非常常见。</p>
<h3 id="1-用于-std-sort"><a href="#1-用于-std-sort" class="headerlink" title="(1) 用于 std::sort"></a><strong>(1) 用于 <code>std::sort</code></strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式自定义排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 按降序排序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5 3 2 1</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-用于-std-for-each"><a href="#2-用于-std-for-each" class="headerlink" title="(2) 用于 std::for_each"></a><strong>(2) 用于 <code>std::for_each</code></strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并打印每个元素</span></span><br><span class="line">    std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-带状态的-Lambda"><a href="#6-带状态的-Lambda" class="headerlink" title="6. 带状态的 Lambda"></a><strong>6. 带状态的 Lambda</strong></h2><ul>
<li>Lambda 本质是一个函数对象，因此它可以存储状态。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [counter]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter; <span class="comment">// 由于捕获的是值，必须加 `mutable` 才能修改</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">increment</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">increment</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><strong>Lambda 表达式</strong>是一种简洁的方式定义匿名函数，非常适合短小的逻辑。</li>
<li><strong>捕获列表</strong>允许访问外部变量，通过值或引用捕获，甚至可以捕获所有变量。</li>
<li>在现代 C++ 中，Lambda 经常用于 STL 算法、多线程、回调等场景，是高效编写代码的重要工具。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS，BFS遍历非联通图</title>
    <url>/2024/10/16/DFS%E9%81%8D%E5%8E%86%E9%9D%9E%E8%81%94%E9%80%9A%E5%9B%BE/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数 (DFS)</span><br><span class="line">// 从当前节点 `node` 开始访问，并递归访问其所有相邻的未访问节点</span><br><span class="line">void DFS(char node, unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph, unordered_set&lt;char&gt;&amp; visited) &#123;</span><br><span class="line">    // 标记当前节点为已访问</span><br><span class="line">    visited.insert(node);</span><br><span class="line">    // 输出当前节点（此处可以进行自定义的处理，像打印或其他操作）</span><br><span class="line">    cout &lt;&lt; node &lt;&lt; &quot; &quot;;  </span><br><span class="line"></span><br><span class="line">    // 遍历该节点的所有相邻节点</span><br><span class="line">    for (char neighbor : graph[node]) &#123;</span><br><span class="line">        // 如果相邻节点未访问过，则递归调用 DFS 访问该相邻节点</span><br><span class="line">        if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">            DFS(neighbor, graph, visited);  // 递归调用 DFS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历整个非联通图的DFS</span><br><span class="line">// 对于图中的每一个顶点，如果该顶点未访问过，执行 DFS 来遍历与其相连的部分</span><br><span class="line">void DFSForDisconnectedGraph(unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    // 创建一个集合，用于记录哪些节点已经访问过</span><br><span class="line">    unordered_set&lt;char&gt; visited;</span><br><span class="line">    </span><br><span class="line">    // 遍历图中的所有顶点（unordered_map 的每个键）</span><br><span class="line">    for (auto&amp; pair : graph) &#123;</span><br><span class="line">        char node = pair.first;  // 当前顶点</span><br><span class="line">        // 如果当前顶点未访问过，则从该顶点开始进行 DFS</span><br><span class="line">        if (visited.find(node) == visited.end()) &#123;</span><br><span class="line">            // 从一个新的连通分量的顶点开始新的 DFS</span><br><span class="line">            cout &lt;&lt; &quot;Starting new DFS from node: &quot; &lt;&lt; node &lt;&lt; endl;</span><br><span class="line">            DFS(node, graph, visited);  // 对该连通分量进行DFS遍历</span><br><span class="line">            cout &lt;&lt; endl;  // DFS 完成后换行，以区分不同的连通分量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用邻接表表示图：unordered_map&lt;char, vector&lt;char&gt;&gt;，表示图中每个顶点及其相邻顶点</span><br><span class="line">    unordered_map&lt;char, vector&lt;char&gt;&gt; graph;</span><br><span class="line">    </span><br><span class="line">    // 定义图的边</span><br><span class="line">    graph[&#x27;a&#x27;] = &#123;&#x27;b&#x27;&#125;;   // 顶点 a 和 b 相连</span><br><span class="line">    graph[&#x27;b&#x27;] = &#123;&#x27;a&#x27;, &#x27;d&#x27;&#125;;  // 顶点 b 与 a 和 d 相连</span><br><span class="line">    graph[&#x27;c&#x27;] = &#123;&#x27;e&#x27;&#125;;   // 顶点 c 与 e 相连</span><br><span class="line">    graph[&#x27;d&#x27;] = &#123;&#x27;b&#x27;&#125;;   // 顶点 d 与 b 相连</span><br><span class="line">    graph[&#x27;e&#x27;] = &#123;&#x27;c&#x27;&#125;;   // 顶点 e 与 c 相连</span><br><span class="line"></span><br><span class="line">    // 调用 DFSForDisconnectedGraph 对非联通图进行遍历</span><br><span class="line">    DFSForDisconnectedGraph(graph);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 广度优先搜索函数</span><br><span class="line">void bfs(const unordered_map&lt;char, vector&lt;char&gt;&gt;&amp; graph, char start) &#123;</span><br><span class="line">    // 用于存储待访问节点的队列</span><br><span class="line">    queue&lt;char&gt; q;</span><br><span class="line">    // 用于标记已访问的节点</span><br><span class="line">    unordered_set&lt;char&gt; visited;</span><br><span class="line"></span><br><span class="line">    // 将起始节点标记为已访问并加入队列</span><br><span class="line">    visited.insert(start);</span><br><span class="line">    q.push(start);</span><br><span class="line"></span><br><span class="line">    // 开始遍历</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        // 取出队列中的当前节点</span><br><span class="line">        char node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        // 输出当前节点</span><br><span class="line">        cout &lt;&lt; &quot;Visited: &quot; &lt;&lt; node &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        // 遍历该节点的所有邻接节点</span><br><span class="line">        for (char neighbor : graph.at(node)) &#123;</span><br><span class="line">            // 如果该邻接节点尚未访问过，加入队列并标记为已访问</span><br><span class="line">            if (visited.find(neighbor) == visited.end()) &#123;</span><br><span class="line">                visited.insert(neighbor);</span><br><span class="line">                q.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 图的邻接表表示法</span><br><span class="line">    unordered_map&lt;char, vector&lt;char&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;&#x27;a&#x27;, &#123;&#x27;b&#x27;, &#x27;c&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;b&#x27;, &#123;&#x27;a&#x27;, &#x27;d&#x27;, &#x27;e&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;c&#x27;, &#123;&#x27;a&#x27;, &#x27;f&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;d&#x27;, &#123;&#x27;b&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;e&#x27;, &#123;&#x27;b&#x27;, &#x27;f&#x27;&#125;&#125;,</span><br><span class="line">        &#123;&#x27;f&#x27;, &#123;&#x27;c&#x27;, &#x27;e&#x27;&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 从节点 &#x27;a&#x27; 开始执行 BFS</span><br><span class="line">    bfs(graph, &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问顺序的区别示例"><a href="#访问顺序的区别示例" class="headerlink" title="访问顺序的区别示例"></a><strong>访问顺序的区别示例</strong></h3><p>以一个简单的图为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    a</span><br><span class="line">   / \</span><br><span class="line">  b   c</span><br><span class="line"> / \   \</span><br><span class="line">d   e   f</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>DFS 访问顺序</strong>（从节点 <code>a</code> 开始）：<code>a, b, d, e, c, f</code><ul>
<li>先从 <code>a</code> 开始，访问 <code>b</code>，然后继续到 <code>d</code>，没有其他未访问的邻接节点后回溯到 <code>b</code>，再访问 <code>e</code>，继续回溯到 <code>a</code>，然后访问 <code>c</code>，最后访问 <code>f</code>。</li>
</ul>
</li>
<li><strong>BFS 访问顺序</strong>（从节点 <code>a</code> 开始）：<code>a, b, c, d, e, f</code><ul>
<li>先从 <code>a</code> 开始，访问其所有邻接节点 <code>b</code> 和 <code>c</code>，然后继续访问 <code>b</code> 和 <code>c</code> 的所有邻接节点 <code>d, e, f</code>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity（一）</title>
    <url>/2024/09/19/Unity%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="平动和转动"><a href="#平动和转动" class="headerlink" title="平动和转动"></a>平动和转动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class instance : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public float moveSpeed = 10f;</span><br><span class="line">    public float turnSpeed = 50f;</span><br><span class="line">    private void Update()//update是每帧更新的函数</span><br><span class="line">    &#123;</span><br><span class="line">        if(Input.GetKey(KeyCode.UpArrow))</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Translate(Vector3.forward * moveSpeed*Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        //translate是平移，vector3是一个三维数组，forward代表（0，0，1)</span><br><span class="line">        //deltatime是两帧之间的时间间隔</span><br><span class="line">        //没有使用 Time.deltaTime 的问题</span><br><span class="line">        //如果你只是使用 moveSpeed 来移动物体，而不使用 Time.deltaTime，</span><br><span class="line">        //物体每帧的移动量将是恒定的.如果帧率提高，物体移动的频率就会增加</span><br><span class="line">        //移动速度就会变快；如果帧率降低，物体的移动频率减小，移动速度就会变慢.</span><br><span class="line">        //使用 Time.deltaTime</span><br><span class="line">        //通过乘以 Time.deltaTime，可以保证物体每秒的移动量保持一致，不受帧率影响.</span><br><span class="line">        if (Input.GetKey(KeyCode.LeftArrow)) </span><br><span class="line">        &#123;</span><br><span class="line">            transform.Rotate(Vector3.up,turnSpeed*Time.deltaTime); </span><br><span class="line">        &#125;</span><br><span class="line">        //rotate是旋转，vector3.up表示（0，1，0），这里是转动的轴</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="摄像机的平滑跟随和视角锁定"><a href="#摄像机的平滑跟随和视角锁定" class="headerlink" title="摄像机的平滑跟随和视角锁定"></a>摄像机的平滑跟随和视角锁定</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SerializeField] Transform target;</span><br><span class="line">[SerializeField] Vector3 offset;</span><br><span class="line">[SerializeField] float transitionSpeed = 2;</span><br><span class="line"></span><br><span class="line">private void LateUpdate()</span><br><span class="line">&#123;</span><br><span class="line">    if (target != null)</span><br><span class="line">    &#123;</span><br><span class="line">       Vector3 targetPos = target.position + offset;</span><br><span class="line">        transform.position = Vector3.Lerp(transform.position, targetPos, transitionSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Transform target;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.LookAt(target);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两种对摄像头的设置<br>第一种是摄像机的平滑跟随，第二种是视角锁定（摄像机不动，只转动）</p>
<h1 id="GetAxis"><a href="#GetAxis" class="headerlink" title="GetAxis"></a>GetAxis</h1><p>在 <strong>Unity</strong> 的 <strong>Input Manager</strong> 中，<code>Positive Button</code> 和 <code>Negative Button</code> 是用来处理轴输入（axis input）的.当你配置诸如 <code>&quot;Horizontal&quot;</code> 或 <code>&quot;Vertical&quot;</code> 这样代表方向或动作的输入轴时，这两个按钮起到了重要的作用.</p>
<h3 id="轴输入（Axis-Input）简介"><a href="#轴输入（Axis-Input）简介" class="headerlink" title="轴输入（Axis Input）简介"></a>轴输入（Axis Input）简介</h3><p>Unity 中的轴输入通常用来处理类似于左右、上下移动这样的操作.输入轴是一种 <strong>模拟输入</strong>，而不是简单的二元按键（开&#x2F;关）.例如：</p>
<ul>
<li><code>&quot;Horizontal&quot;</code> 轴可以映射到 <strong>A&#x2F;D</strong> 键或 <strong>左&#x2F;右</strong> 方向键，表示横向移动.</li>
<li><code>&quot;Vertical&quot;</code> 轴可以映射到 <strong>W&#x2F;S</strong> 键或 <strong>上&#x2F;下</strong> 方向键，表示纵向移动.</li>
</ul>
<p>这些轴输入返回的值在 <strong>-1 到 1</strong> 之间，用来表示不同的方向或强度.</p>
<h3 id="Positive-Button-和-Negative-Button-的作用"><a href="#Positive-Button-和-Negative-Button-的作用" class="headerlink" title="Positive Button 和 Negative Button 的作用"></a><code>Positive Button</code> 和 <code>Negative Button</code> 的作用</h3><ul>
<li><strong>Positive Button</strong> 是用来指定当你按下该按钮时，输入轴返回正向值（如 <code>1</code>）.例如，”D” 键或右方向键通常用作 <code>Positive Button</code>，它会让角色向右移动.</li>
<li><strong>Negative Button</strong> 是用来指定当你按下该按钮时，输入轴返回负向值（如 <code>-1</code>）.例如，”A” 键或左方向键通常用作 <code>Negative Button</code>，它会让角色向左移动.</li>
</ul>
<h3 id="示例：Horizontal-轴配置"><a href="#示例：Horizontal-轴配置" class="headerlink" title="示例：Horizontal 轴配置"></a>示例：<code>Horizontal</code> 轴配置</h3><p>假设我们在 <strong>Input Manager</strong> 中配置了一个名为 <code>&quot;Horizontal&quot;</code> 的输入轴.常见的设置可能是这样的：</p>
<ul>
<li><strong>Name</strong>: Horizontal</li>
<li><strong>Negative Button</strong>: A (或 Left Arrow)</li>
<li><strong>Positive Button</strong>: D (或 Right Arrow)</li>
<li><strong>Gravity</strong>: 3</li>
<li><strong>Dead</strong>: 0.001</li>
<li><strong>Sensitivity</strong>: 3</li>
<li><strong>Type</strong>: Key or Mouse Button</li>
<li><strong>Axis</strong>: X axis</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>当你按下 <code>Positive Button</code>（比如 <code>&quot;D&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个正值，接近 <code>1</code>.</li>
<li>当你按下 <code>Negative Button</code>（比如 <code>&quot;A&quot;</code> 键），<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 会返回一个负值，接近 <code>-1</code>.</li>
<li>如果没有按下任何按钮，<code>Input.GetAxis(&quot;Horizontal&quot;)</code> 将返回 <code>0</code>，表示没有水平输入.</li>
</ol>
<h3 id="为什么使用-Positive-和-Negative-按钮？"><a href="#为什么使用-Positive-和-Negative-按钮？" class="headerlink" title="为什么使用 Positive 和 Negative 按钮？"></a>为什么使用 Positive 和 Negative 按钮？</h3><p>它们的主要作用是提供一种简便的方式来处理方向性输入.例如，移动角色时，可以根据返回的轴值决定角色的移动方向：</p>
<ul>
<li>如果 <code>Input.GetAxis(&quot;Horizontal&quot;)</code> 返回正值（如 1），角色向右移动.</li>
<li>如果返回负值（如 -1），角色向左移动.</li>
</ul>
<h3 id="示例：检测水平轴输入并移动角色"><a href="#示例：检测水平轴输入并移动角色" class="headerlink" title="示例：检测水平轴输入并移动角色"></a>示例：检测水平轴输入并移动角色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float move = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">    transform.Translate(Vector3.right * move * Time.deltaTime * speed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果玩家按下 <strong>“D”</strong> 或 <strong>右方向键</strong>（<code>Positive Button</code>），<code>move</code> 会变成正值，角色向右移动.</li>
<li>如果玩家按下 <strong>“A”</strong> 或 <strong>左方向键</strong>（<code>Negative Button</code>），<code>move</code> 会变成负值，角色向左移动.</li>
</ul>
<h3 id="配置解释"><a href="#配置解释" class="headerlink" title="配置解释"></a>配置解释</h3><ul>
<li><strong>Gravity</strong>: 控制按键松开后，轴值回到零的速度.数值越大，返回到 0 的速度越快.</li>
<li><strong>Sensitivity</strong>: 控制按键按下时，轴值从 0 加速到 1（或 -1）的速度.数值越大，响应越快.</li>
<li><strong>Dead</strong>: 一个小阈值，避免微小输入造成意外响应.小于该值的输入会被视为 0.</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Positive Button</strong>：用于正方向的输入，通常映射为右&#x2F;上方向键或控制器的正向输入.</li>
<li><strong>Negative Button</strong>：用于负方向的输入，通常映射为左&#x2F;下方向键或控制器的反向输入.</li>
<li>它们是用于控制方向性输入的核心元素，特别是在控制角色移动时.</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>打卡</tag>
        <tag>闲得无聊所以发发</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性之emplace</title>
    <url>/2024/11/25/c++11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bemplace/</url>
    <content><![CDATA[<p><code>emplace</code> 是 C++ 中标准库（STL）提供的一种高效的元素插入方式，常用于容器（如 <code>std::vector</code>, <code>std::map</code>, <code>std::unordered_map</code> 等）中。<code>emplace</code> 通过直接在容器内部构造元素，避免了不必要的拷贝或移动操作，从而提高了性能。</p>
<h3 id="emplace-和-insert-的区别"><a href="#emplace-和-insert-的区别" class="headerlink" title="emplace 和 insert 的区别"></a><code>emplace</code> 和 <code>insert</code> 的区别</h3><ul>
<li><p>**<code>insert</code>**：将一个已构造的对象插入到容器中。通常需要通过拷贝或移动构造将元素插入容器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">vec.<span class="built_in">insert</span>(vec.<span class="built_in">end</span>(), x);  <span class="comment">// 插入时会发生一次拷贝构造</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace</code>**：直接在容器内部构造元素，避免了额外的拷贝或移动操作。<code>emplace</code> 接受构造元素所需的参数，然后直接在容器中构造该元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">5</span>);  <span class="comment">// 在容器内部构造元素，避免拷贝</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="为什么使用-emplace？"><a href="#为什么使用-emplace？" class="headerlink" title="为什么使用 emplace？"></a>为什么使用 <code>emplace</code>？</h3><ol>
<li><p><strong>避免不必要的拷贝或移动</strong>：</p>
<ul>
<li><code>insert</code> 必须先构造一个对象，然后将该对象插入容器，这可能涉及拷贝或移动构造。</li>
<li><code>emplace</code> 直接在容器中构造元素，省去了额外的拷贝或移动操作。</li>
</ul>
</li>
<li><p><strong>提高效率</strong>：</p>
<ul>
<li>特别是在容器中插入复杂对象时，使用 <code>emplace</code> 能显著提高性能，因为它直接传递构造参数，而不需要先创建一个对象。</li>
</ul>
</li>
</ol>
<h3 id="常见的-emplace-使用场景"><a href="#常见的-emplace-使用场景" class="headerlink" title="常见的 emplace 使用场景"></a>常见的 <code>emplace</code> 使用场景</h3><ul>
<li><p>**<code>emplace_back</code>**：用于 <code>std::vector</code> 等容器，在容器的末尾构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);  <span class="comment">// 直接构造元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace</code>**：对于 <code>std::map</code>、<code>std::unordered_map</code> 等关联容器，在指定位置构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">m.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);  <span class="comment">// 直接在 map 中构造一个键值对</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>emplace_front</code>**：用于 <code>std::list</code> 等容器，在容器的前面构造元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line">lst.<span class="built_in">emplace_front</span>(<span class="number">10</span>);  <span class="comment">// 在容器前面直接构造一个元素</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="emplace-示例代码"><a href="#emplace-示例代码" class="headerlink" title="emplace 示例代码"></a><code>emplace</code> 示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 emplace_back 在 vector 中插入元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">10</span>);  <span class="comment">// 直接构造元素</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出: 10 20</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace 在 map 中插入元素</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m;</span><br><span class="line">    m.<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    m.<span class="built_in">emplace</span>(<span class="number">2</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : m) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// 1: apple</span></span><br><span class="line">    <span class="comment">// 2: banana</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>emplace</code> 提供了比 <code>insert</code> 更高效的方式来插入元素，因为它避免了不必要的对象构造、拷贝或移动操作。</li>
<li><code>emplace</code> 通过传递构造元素所需的参数，直接在容器内构造元素，而不是先创建元素再插入。</li>
<li>常见的 <code>emplace</code> 变种有 <code>emplace_back</code>（用于 <code>std::vector</code>）、<code>emplace</code>（用于 <code>std::map</code>, <code>std::unordered_map</code> 等）以及 <code>emplace_front</code>（用于 <code>std::list</code>）。</li>
</ul>
<p>使用 <code>emplace</code> 可以让你的程序更加高效，尤其是在需要频繁插入复杂对象时。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中关于深拷贝与重载赋值运算符的思考</title>
    <url>/2024/09/17/c++%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class instance</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int age;</span><br><span class="line">	int* height;</span><br><span class="line">instance(int a,int h)</span><br><span class="line">&#123;</span><br><span class="line">	age = a;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	height=new int(h);</span><br><span class="line">	cout &lt;&lt; *height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~instance()</span><br><span class="line">&#123;</span><br><span class="line">	if (height != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		delete height;</span><br><span class="line">		height = NULL;</span><br><span class="line">		cout &lt;&lt; &quot;已清空&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">instance(const instance&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	age = p.age;</span><br><span class="line">	//height = p.height;编译器默认实现的就是这行代码</span><br><span class="line">	//深拷贝如下</span><br><span class="line">	height = new int(*p.height); </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//浅拷贝使两个height指向同一内存地址，会导致将已释放的内存再次释放，引发双重释放安全问题</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	instance p1(18,160);</span><br><span class="line">	instance p2(p1);</span><br><span class="line">	cout &lt;&lt; p2.age &lt;&lt;*p2.height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h1><p>众所周知，运算符重载后使运算符能实现原本无法完成的工作<br>赋值运算符，这里我们实现类对类的赋值.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">    char* data;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 默认构造函数</span><br><span class="line">    MyClass(const char* str = &quot;&quot;) &#123;</span><br><span class="line">        data = new char[strlen(str) + 1];</span><br><span class="line">        strcpy(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拷贝构造函数</span><br><span class="line">    MyClass(const MyClass&amp; other) &#123;</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重载赋值运算符</span><br><span class="line">    MyClass&amp; operator=(const MyClass&amp; other) &#123;</span><br><span class="line">        if (this == &amp;other) &#123;</span><br><span class="line">            return *this;  // 处理自赋值情况</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 先释放原有资源</span><br><span class="line">        delete[] data;</span><br><span class="line"></span><br><span class="line">        // 分配新内存并拷贝数据</span><br><span class="line">        data = new char[strlen(other.data) + 1];</span><br><span class="line">        strcpy(data, other.data);</span><br><span class="line"></span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 析构函数</span><br><span class="line">    ~MyClass() &#123;</span><br><span class="line">        delete[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印数据</span><br><span class="line">    void print() const &#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass a(&quot;Hello&quot;);</span><br><span class="line">    MyClass b(&quot;World&quot;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Before assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;Hello&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    a = b; // 使用重载的赋值运算符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;After assignment:&quot; &lt;&lt; std::endl;</span><br><span class="line">    a.print(); // 输出 &quot;World&quot;</span><br><span class="line">    b.print(); // 输出 &quot;World&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="注意：一定要将被赋值对象中在堆中的数据释放掉"><a href="#注意：一定要将被赋值对象中在堆中的数据释放掉" class="headerlink" title="注意：一定要将被赋值对象中在堆中的数据释放掉."></a>注意：一定要将被赋值对象中在堆中的数据释放掉.</h3><h3 id="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"><a href="#否则会导致旧资源直接被新资源赋值后，内存覆盖掉" class="headerlink" title="否则会导致旧资源直接被新资源赋值后，内存覆盖掉"></a>否则会导致旧资源直接被新资源赋值后，内存覆盖掉</h3><h2 id="有内存泄露，资源浪费的风险，以及未定义行为的风险"><a href="#有内存泄露，资源浪费的风险，以及未定义行为的风险" class="headerlink" title="有内存泄露，资源浪费的风险，以及未定义行为的风险"></a>有内存泄露，资源浪费的风险，以及未定义行为的风险</h2><h4 id="具体会不会发生所谓的双重释放，个人认为不会"><a href="#具体会不会发生所谓的双重释放，个人认为不会" class="headerlink" title="具体会不会发生所谓的双重释放，个人认为不会"></a>具体会不会发生所谓的双重释放，个人认为不会</h4>]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>重载</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的I/O流</title>
    <url>/2024/11/25/c++%E4%B8%AD%E7%9A%84IO%E6%B5%81/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>输入输出（I&#x2F;O）库</strong>提供了流（<code>stream</code>）的状态管理功能。每个流对象（如 <code>cin</code>, <code>cout</code>, <code>ifstream</code>, <code>ofstream</code> 等）都有一个与之相关的状态，标志着当前流的操作是否成功。流的状态主要通过流的<strong>条件标志</strong>（flags）来表示。这些标志通常用于检查流是否处于有效的状态，以便在进行输入输出操作时处理异常或错误。</p>
<h3 id="流的条件状态（Flags）"><a href="#流的条件状态（Flags）" class="headerlink" title="流的条件状态（Flags）"></a>流的条件状态（Flags）</h3><p>流的条件状态通过 <code>ios</code> 类中的几个成员标志进行管理，这些标志包括：</p>
<ol>
<li>**<code>good()</code>**：流是否处于正常状态，即没有发生任何错误。</li>
<li>**<code>eof()</code>**：流是否已经到达文件末尾。</li>
<li>**<code>fail()</code>**：流是否遇到输入&#x2F;输出错误。</li>
<li>**<code>bad()</code>**：流是否发生严重错误，导致无法继续读取或写入。</li>
</ol>
<p>这些状态标志可以通过流对象的方法访问，通常用于判断流的状态。</p>
<h3 id="流的状态检查"><a href="#流的状态检查" class="headerlink" title="流的状态检查"></a>流的状态检查</h3><h4 id="1-good"><a href="#1-good" class="headerlink" title="1. good()"></a>1. <code>good()</code></h4><ul>
<li><p><strong><code>good()</code></strong> 返回 <code>true</code> 如果流没有遇到任何错误，输入输出操作可以继续进行。它相当于检查流的状态是否为 <code>ios::goodbit</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入流状态正常。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-eof"><a href="#2-eof" class="headerlink" title="2. eof()"></a>2. <code>eof()</code></h4><ul>
<li><p><strong><code>eof()</code></strong> 检查流是否已经到达文件末尾或输入结束标志。对于从文件读取或从输入流读取数据时，可以使用该标志判断是否已读取完所有数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;已到达输入的末尾。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-fail"><a href="#3-fail" class="headerlink" title="3. fail()"></a>3. <code>fail()</code></h4><ul>
<li><p><strong><code>fail()</code></strong> 检查流是否发生了格式错误或输入输出错误。如果输入的数据类型不匹配或文件无法打开等操作失败时，会返回 <code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入数据失败，数据格式错误。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-bad"><a href="#4-bad" class="headerlink" title="4. bad()"></a>4. <code>bad()</code></h4><ul>
<li><p><strong><code>bad()</code></strong> 返回 <code>true</code>，如果流处于严重错误状态，通常在硬件故障或流被意外关闭时会发生。这是最严重的错误状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发生了严重错误，流无法继续使用。&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见的流状态标志"><a href="#常见的流状态标志" class="headerlink" title="常见的流状态标志"></a>常见的流状态标志</h3><ul>
<li>**<code>ios::goodbit</code>**：正常状态，表示流没有错误。</li>
<li>**<code>ios::eofbit</code>**：表示流已到达文件末尾或输入结束。</li>
<li>**<code>ios::failbit</code>**：表示流遇到非致命错误，通常是格式错误或读取错误。</li>
<li>**<code>ios::badbit</code>**：表示流遇到致命错误，通常是硬件故障或无法继续操作。</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例 1: 标准输入流 (cin)</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个整数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入失败，格式错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你输入的整数是: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 2: 文件输入流 (ifstream)</span></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否读取到末尾</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;已到达文件末尾。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 3: 检查文件流是否出现严重错误</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件流出现严重错误！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>good()</code></strong> 用于检查流是否没有任何错误。</li>
<li><strong><code>eof()</code></strong> 用于检查是否已到达输入流的末尾。</li>
<li><strong><code>fail()</code></strong> 用于检查流是否发生了可恢复的错误（如输入数据不匹配）。</li>
<li><strong><code>bad()</code></strong> 用于检查流是否发生了致命错误。</li>
</ul>
<p>通过检查这些状态标志，你可以更加精确地控制和管理程序中的输入输出操作，及时捕获和处理异常。</p>
<h1 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h1><p>在 C++ 中，<code>string</code> 流（<code>stringstream</code>）是用于处理字符串输入和输出的流类，它包含在 <code>&lt;sstream&gt;</code> 头文件中。<code>stringstream</code> 可以被用来从字符串中提取数据，或者将数据格式化并输出到字符串中。它是 <code>iostream</code> 库的扩展，结合了输入流（<code>istringstream</code>）、输出流（<code>ostringstream</code>）和读写流（<code>stringstream</code>）。</p>
<h3 id="使用-stringstream（stringstream即可代替istringstream与ostringstream）"><a href="#使用-stringstream（stringstream即可代替istringstream与ostringstream）" class="headerlink" title="使用 stringstream（stringstream即可代替istringstream与ostringstream）"></a>使用 <code>stringstream</code>（stringstream即可代替istringstream与ostringstream）</h3><ol>
<li><p><strong>创建和初始化：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream ss; <span class="comment">// 创建一个空的 stringstream 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 &lt;&lt; 操作符向 stringstream 中写入数据</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot; world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出 stringstream 中的内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Stringstream content: &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们创建了一个空的 <code>stringstream</code> 对象 <code>ss</code>，并通过 <code>&lt;&lt;</code> 操作符向其中写入数据。通过 <code>ss.str()</code> 可以获取当前 <code>stringstream</code> 中的字符串。</p>
</li>
<li><p><strong>从字符串中提取数据：</strong><br>使用 <code>istringstream</code> 来从字符串中读取数据，类似于从文件或标准输入中读取数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;123 45.67 Hello&quot;</span>;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>; <span class="comment">// 创建一个从字符串读取数据的 istringstream</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 stringstream 中提取数据</span></span><br><span class="line">    iss &gt;&gt; i &gt;&gt; d &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>iss &gt;&gt; i &gt;&gt; d &gt;&gt; s;</code>，我们从字符串 <code>str</code> 中依次提取数据，将其赋值给变量 <code>i</code>（整数）、<code>d</code>（浮动数）和 <code>s</code>（字符串）。</p>
</li>
<li><p><strong>向字符串写入数据：</strong><br>使用 <code>ostringstream</code> 可以将数据写入到一个字符串中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ostringstream oss; <span class="comment">// 创建一个输出流对象</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">    string name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 stringstream 写入数据</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取存储在 stringstream 中的字符串</span></span><br><span class="line">    string result = oss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们使用 <code>ostringstream</code> 将变量 <code>name</code> 和 <code>age</code> 写入字符串流 <code>oss</code> 中，然后通过 <code>oss.str()</code> 获取最终的字符串。</p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>**<code>istringstream</code>**：从字符串中读取数据。</li>
<li>**<code>ostringstream</code>**：将数据写入字符串。</li>
<li>**<code>stringstream</code>**：既能从字符串读取数据，也能将数据写入字符串。</li>
</ul>
<p>这种流的使用场景很多，常用于处理复杂的字符串格式转换、提取和拼接。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>I/O流</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的四种命名的强制类型转换</title>
    <url>/2024/11/19/c++%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%91%BD%E5%90%8D%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>在 C++ 中，有四种强制类型转换操作符，分别是：</p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<p>这四种类型转换都属于强制类型转换,值得一提的是其实这四种强制转换都是较为危险的，很容易出现错误，尽量少用</p>
<h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><code>static_cast</code> 用于在类型之间进行转换时，进行编译时类型检查。</p>
<p>它适用于转换那些在语义上兼容的类型，例如基本数据类型、类之间的转换等。</p>
<p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><ul>
<li><strong>类之间的转换</strong>（如父类和子类的转换）。</li>
<li><strong>基本数据类型之间的转换</strong>。</li>
<li><strong>指针类型之间的转换</strong>，当有继承关系时，可以转换指向基类的指针和指向派生类的指针。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//类之间的转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Base* 转换为 Derived*，这里是安全的</span></span><br><span class="line">    Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 上行是通过 static_cast</span></span><br><span class="line">    d-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);  <span class="comment">// 基本数据类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="comment">// 输出 10.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static_cast</code> 会进行类型检查，并且不允许不兼容的类型之间的转换。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//进行强制类型转换以便执行浮点数除法</span><br><span class="line">int i,j;</span><br><span class="line">double slope=static_cast&lt;double&gt;(j)/i;</span><br><span class="line">//进行指针的转换</span><br><span class="line">void *p=&amp;i;//任何非常量的对象的地址都能存入void*</span><br><span class="line">int *ij=static_cast&lt;int*&gt;(p);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 主要用于处理类层次结构中的指针或引用转换。它用于在类之间进行转换时，确保类型安全。<code>dynamic_cast</code> 在运行时进行类型检查，因此它适用于多态类型的转换（即包含虚函数的类）。</p>
<h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于处理继承体系中的转换，确保安全的类型转换。</li>
<li>可以用于将基类指针或引用转换为派生类指针或引用，前提是基类至少有一个虚函数（多态）。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 错误的转换，d会为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">        d-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 输出 Conversion failed!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dynamic_cast</code> 在运行时检查类型，如果转换失败，返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。它主要用于确保在继承关系中指针或引用的类型转换安全。</li>
</ul>
<h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><code>const_cast</code> 用于修改对象的常量性。</p>
<p>它允许去除或添加 <code>const</code> 限定符。注意，此处只能修改底层const</p>
<p>常见的用途包括将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型，或者反之。</p>
<h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>去除 <code>const</code> 限定符：可以将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型。</li>
<li>添加 <code>const</code> 限定符：可以将非 <code>const</code> 类型的指针或引用转换为 <code>const</code> 类型。</li>
</ul>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去除 const 限定符，允许修改对象</span></span><br><span class="line">    <span class="type">int</span>* modifiablePtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);</span><br><span class="line">    *modifiablePtr = <span class="number">20</span>;  <span class="comment">// 修改原对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除 const 限定符</span></span><br><span class="line">    <span class="built_in">modify</span>(ptr);  <span class="comment">// 此处会导致未定义行为</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 未定义行为，x值不可预测</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>警告</strong>：如果你去除 <code>const</code> 限定符并修改对象，该对象实际上可能是常量，修改它会导致未定义行为，因此这种转换应谨慎使用。</li>
</ul>
<h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 是最强大的类型转换操作符，它允许将一种类型的指针或引用转换为另一种完全不相关类型的指针或引用。它不进行任何类型检查，因此使用时必须非常小心。</p>
<h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于进行指针或引用之间的转换，即使它们在类型上没有任何继承关系。</li>
<li>可以将指针转换为整数类型，或将整数转换为指针类型。</li>
</ul>
<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> int_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pointer as integer: &quot;</span> &lt;&lt; int_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回指针</span></span><br><span class="line">    <span class="type">int</span>* new_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(int_ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dereferenced pointer: &quot;</span> &lt;&lt; *new_ptr &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reinterpret_cast</code> 可以将指针转换为整数，或将整数转换为指针，甚至可以在没有任何类型关系的类型之间进行转换。使用时需要非常小心，因为它可以绕过编译器的类型检查。</li>
</ul>
<h3 id="总结：四种类型转换的对比"><a href="#总结：四种类型转换的对比" class="headerlink" title="总结：四种类型转换的对比"></a>总结：四种类型转换的对比</h3><table>
<thead>
<tr>
<th>转换操作符</th>
<th>适用场景</th>
<th>编译时检查</th>
<th>运行时检查</th>
<th>类型安全</th>
</tr>
</thead>
<tbody><tr>
<td><code>static_cast</code></td>
<td>基本类型转换，类之间的转换，指针之间的转换</td>
<td>是</td>
<td>否</td>
<td>高</td>
</tr>
<tr>
<td><code>dynamic_cast</code></td>
<td>类之间的安全转换，主要用于多态（继承）</td>
<td>是</td>
<td>是</td>
<td>高</td>
</tr>
<tr>
<td><code>const_cast</code></td>
<td>修改对象的常量性（去除或添加 <code>const</code> 限定符）</td>
<td>是</td>
<td>否</td>
<td>中</td>
</tr>
<tr>
<td><code>reinterpret_cast</code></td>
<td>强制转换，指针与整数之间的转换，指针之间的任意转换</td>
<td>否</td>
<td>否</td>
<td>低（非常危险）</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>static_cast</code></strong> 用于编译时类型安全转换，适合大多数常规类型转换。</li>
<li><strong><code>dynamic_cast</code></strong> 用于多态类型的安全转换，尤其是指针和引用之间的转换，支持运行时类型检查。</li>
<li><strong><code>const_cast</code></strong> 用于修改 <code>const</code> 限定符（添加或去除 <code>const</code>）。</li>
<li><strong><code>reinterpret_cast</code></strong> 用于底层转换，指针和整数之间的转换，不进行类型检查，需要小心使用。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
        <tag>强制类型转换操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的线程</title>
    <url>/2025/01/12/c++%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在 C++ 中，线程是用来实现并发编程的重要工具，它允许程序同时执行多个任务。C++11 标准引入了多线程支持，主要通过 <strong><code>&lt;thread&gt;</code></strong> 标头文件提供相关功能，包括线程创建、管理和同步等。</p>
<hr>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h2><ul>
<li><strong>线程</strong>是程序执行的基本单位，一个程序可以包含多个线程。</li>
<li><strong>多线程</strong>可以提高程序效率，特别是在多核 CPU 上，每个线程可以在不同的核上运行。</li>
<li>C++ 提供的多线程功能包括：<ul>
<li>线程的创建与管理（<code>std::thread</code>）。</li>
<li>同步机制（如互斥锁 <code>std::mutex</code>、条件变量 <code>std::condition_variable</code> 等）。</li>
<li>数据保护（如线程安全的操作）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-创建和管理线程"><a href="#2-创建和管理线程" class="headerlink" title="2. 创建和管理线程"></a><strong>2. 创建和管理线程</strong></h2><h3 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1) 创建线程"></a><strong>1) 创建线程</strong></h3><p>线程可以通过 <strong><code>std::thread</code></strong> 创建，并且可以使用函数、lambda 表达式或可调用对象作为线程入口。</p>
<h4 id="a-使用普通函数"><a href="#a-使用普通函数" class="headerlink" title="(a) 使用普通函数"></a><strong>(a) 使用普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建线程</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>std::thread t(threadFunction)</code>**：创建线程并执行 <code>threadFunction</code>。</li>
<li>**<code>t.join()</code>**：主线程等待 <code>t</code> 线程执行完成。</li>
</ul>
<hr>
<h4 id="b-使用-lambda-表达式"><a href="#b-使用-lambda-表达式" class="headerlink" title="(b) 使用 lambda 表达式"></a><strong>(b) 使用 lambda 表达式</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;Thread running with lambda!&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="c-使用类的成员函数"><a href="#c-使用类的成员函数" class="headerlink" title="(c) 使用类的成员函数"></a><strong>(c) 使用类的成员函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread running with functor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Worker worker;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>; <span class="comment">// 创建线程并执行 Worker 的重载函数</span></span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-分离线程（detach）"><a href="#2-分离线程（detach）" class="headerlink" title="2) 分离线程（detach）"></a><strong>2) 分离线程（<code>detach</code>）</strong></h3><p>分离线程允许主线程与新线程独立运行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Detached thread completed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 分离线程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：分离的线程在程序结束前需要完成，否则会出现未定义行为。</p>
<hr>
<h3 id="3-获取线程-ID"><a href="#3-获取线程-ID" class="headerlink" title="3) 获取线程 ID"></a><strong>3) 获取线程 ID</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::thread::id id = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3. 线程同步"></a><strong>3. 线程同步</strong></h2><p>由于线程是并发执行的，因此多个线程访问共享资源时可能会导致数据竞争（Race Condition）。C++ 提供了多种同步工具来避免这种问题。</p>
<h3 id="1-互斥锁（std-mutex）"><a href="#1-互斥锁（std-mutex）" class="headerlink" title="1) 互斥锁（std::mutex）"></a><strong>1) 互斥锁（<code>std::mutex</code>）</strong></h3><p><strong>互斥锁</strong>用于保证只有一个线程可以访问共享资源。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁和解锁</span></span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printMessage, <span class="string">&quot;Thread 1: Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printMessage, <span class="string">&quot;Thread 2: World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>std::lock_guard</code>**：管理锁的生命周期，防止忘记解锁。</li>
<li>**<code>mtx.lock()</code> 和 <code>mtx.unlock()</code>**：手动加锁和解锁，但可能导致死锁，不推荐使用。</li>
</ul>
<hr>
<h3 id="2-条件变量（std-condition-variable）"><a href="#2-条件变量（std-condition-variable）" class="headerlink" title="2) 条件变量（std::condition_variable）"></a><strong>2) 条件变量（<code>std::condition_variable</code>）</strong></h3><p>条件变量用于实现线程间的协调，例如一个线程等待某个条件成立时再执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件成立</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is running!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>; <span class="comment">// 修改条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知一个等待线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(notify)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-原子操作（std-atomic）"><a href="#3-原子操作（std-atomic）" class="headerlink" title="3) 原子操作（std::atomic）"></a><strong>3) 原子操作（<code>std::atomic</code>）</strong></h3><p><strong>原子操作</strong>用于多线程中对单个变量的操作，避免数据竞争。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        ++counter; <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a><strong>4. 注意事项</strong></h2><ol>
<li><strong>数据竞争</strong>：多个线程同时修改共享资源可能导致错误，需要使用同步机制。</li>
<li><strong>死锁</strong>：多个线程互相等待资源，导致程序无法继续。</li>
<li><strong>分离线程的风险</strong>：主线程结束时，分离的线程未完成可能会导致崩溃。</li>
<li><strong>性能开销</strong>：线程切换会带来一定的系统开销。</li>
</ol>
<hr>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h2><ul>
<li><strong>线程创建</strong>：<code>std::thread</code> 提供简单易用的接口。</li>
<li><strong>线程同步</strong>：使用 <code>std::mutex</code>、<code>std::condition_variable</code> 等工具保护共享数据。</li>
<li><strong>线程安全</strong>：推荐使用 <code>std::atomic</code> 或其他同步机制避免数据竞争。</li>
</ul>
<p>线程是 C++ 中实现并发的核心工具，但需要小心处理共享资源和线程生命周期，确保程序的正确性和性能。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>kahn算法实现拓扑排序</title>
    <url>/2024/10/21/kahn%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="1-拓扑排序（Topological-Sorting）是什么？"><a href="#1-拓扑排序（Topological-Sorting）是什么？" class="headerlink" title="1. 拓扑排序（Topological Sorting）是什么？"></a>1. <strong>拓扑排序</strong>（Topological Sorting）是什么？</h3><p><strong>拓扑排序</strong>是一种用于 <strong>有向无环图</strong>（DAG, Directed Acyclic Graph） 的节点排序算法。它的目标是将图中的所有节点排成一个 <strong>线性序列</strong>，使得对于图中每一条从节点 <code>u</code> 到节点 <code>v</code> 的有向边 <code>u -&gt; v</code>，在排序中节点 <code>u</code> 都排在节点 <code>v</code> 的前面。</p>
<p><strong>简单来说</strong>，如果图中有一条边 <code>u -&gt; v</code>，那么在拓扑排序中，节点 <code>u</code> 必须排在节点 <code>v</code> 的前面。这个排序是图中所有节点的线性排列，并且保证了这种有向依赖关系。</p>
<h3 id="2-拓扑序列是什么？"><a href="#2-拓扑序列是什么？" class="headerlink" title="2. 拓扑序列是什么？"></a>2. <strong>拓扑序列</strong>是什么？</h3><p><strong>拓扑序列</strong>是拓扑排序的结果，即节点的一个线性排列，满足上述的依赖关系。对于给定的有向无环图，可能存在多个不同的拓扑序列，只要它们满足图中所有边的依赖关系。</p>
<h3 id="3-拓扑排序的应用场景"><a href="#3-拓扑排序的应用场景" class="headerlink" title="3. 拓扑排序的应用场景"></a>3. <strong>拓扑排序的应用场景</strong></h3><p>拓扑排序通常用于需要考虑依赖关系的场景，比如：</p>
<ul>
<li><strong>任务调度</strong>：例如，某些任务需要在其他任务完成后才能开始工作，可以将任务的依赖关系表示为有向无环图，通过拓扑排序确定任务的执行顺序。</li>
<li><strong>课程安排</strong>：如果某些课程有先修课要求，可以用拓扑排序来安排课程学习的顺序。</li>
<li><strong>构建系统</strong>：如果某些模块需要依赖其他模块编译，可以通过拓扑排序决定编译顺序。</li>
</ul>
<h3 id="4-如何进行拓扑排序？"><a href="#4-如何进行拓扑排序？" class="headerlink" title="4. 如何进行拓扑排序？"></a>4. <strong>如何进行拓扑排序？</strong></h3><p>有多种算法可以实现拓扑排序，最常用的有以下两种：</p>
<h4 id="（1）Kahn算法（基于入度的算法）"><a href="#（1）Kahn算法（基于入度的算法）" class="headerlink" title="（1）Kahn算法（基于入度的算法）"></a>（1）<strong>Kahn算法</strong>（基于入度的算法）</h4><ul>
<li><p><strong>思路</strong>：</p>
<ul>
<li>找到所有 <strong>入度为0</strong> 的节点（即没有任何节点指向它们的节点）。</li>
<li>将这些节点从图中移除，并将它们的邻接节点的入度减1。</li>
<li>如果某个邻接节点的入度减为0，将它也加入排序序列中。</li>
<li>重复该过程，直到所有节点都被处理。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>计算图中每个节点的 <strong>入度</strong>（指向该节点的边的数量）。</li>
<li>将所有 <strong>入度为0</strong> 的节点加入队列。</li>
<li>从队列中取出一个节点，加入拓扑序列，并将该节点的邻接节点入度减1。</li>
<li>如果某个邻接节点的入度变为0，将其加入队列。</li>
<li>重复步骤3和4，直到队列为空。如果此时拓扑序列包含了所有节点，则排序成功；否则，说明图中存在环，无法进行拓扑排序。</li>
</ol>
</li>
<li><p><strong>Kahn算法的时间复杂度</strong>：<code>O(V + E)</code>，其中 <code>V</code> 是节点数，<code>E</code> 是边数。</p>
</li>
</ul>
<h4 id="（2）深度优先搜索（DFS）法"><a href="#（2）深度优先搜索（DFS）法" class="headerlink" title="（2）深度优先搜索（DFS）法"></a>（2）<strong>深度优先搜索（DFS）法</strong></h4><ul>
<li><p><strong>思路</strong>：</p>
<ul>
<li>对图进行 <strong>DFS</strong> 遍历，在每次访问完成一个节点的所有邻接节点后，将该节点加入一个栈。</li>
<li>当所有节点都被访问完后，栈中的节点顺序即为拓扑排序的逆序。</li>
</ul>
</li>
<li><p><strong>步骤</strong>：</p>
<ol>
<li>对图中的每个未访问的节点执行 DFS。</li>
<li>当遍历到某个节点时，先递归访问它的所有邻接节点（即访问所有依赖它的节点）。</li>
<li>在访问完所有邻接节点后，将该节点加入栈。</li>
<li>最后栈中节点的顺序就是拓扑序列。</li>
</ol>
</li>
<li><p><strong>DFS法的时间复杂度</strong>：<code>O(V + E)</code>，其中 <code>V</code> 是节点数，<code>E</code> 是边数。</p>
</li>
</ul>
<h3 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5. 举例说明"></a>5. <strong>举例说明</strong></h3><h4 id="图示："><a href="#图示：" class="headerlink" title="图示："></a>图示：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 → 0 ← 4</span><br><span class="line">↓       ↑</span><br><span class="line">2 → 3 → 1</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>有向图</strong> 表示：</p>
<ul>
<li>任务 <code>5</code> 和 <code>4</code> 是任务 <code>0</code> 的前置任务，任务 <code>5</code> 也是任务 <code>2</code> 的前置任务。</li>
<li>任务 <code>2</code> 是任务 <code>3</code> 的前置任务，任务 <code>3</code> 是任务 <code>1</code> 的前置任务。</li>
<li>任务 <code>4</code> 是任务 <code>0</code> 的前置任务。</li>
</ul>
</li>
<li><p><strong>拓扑排序结果</strong>：</p>
<ul>
<li>可能的 <strong>拓扑序列</strong> 为：<code>4, 5, 2, 3, 1, 0</code>。</li>
<li>也可能是：<code>5, 4, 2, 3, 1, 0</code>。</li>
</ul>
</li>
</ul>
<h4 id="Kahn算法实现（队列实现）："><a href="#Kahn算法实现（队列实现）：" class="headerlink" title="Kahn算法实现（队列实现）："></a><strong>Kahn算法实现（队列实现）</strong>：</h4><p>个人理解：将每个入度为0的顶点加入队列，然后依次处理，先加入拓扑序列，将其邻接结点入度减1后再判断是否为0，如果是就加入队列，然后将原节点推出队列，再获取队列第一个，直到队列为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">kahnTopologicalSort</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;  <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="comment">// 邻接表表示的图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjList = &#123;</span><br><span class="line">        &#123;&#125;,       <span class="comment">// 节点 0</span></span><br><span class="line">        &#123;<span class="number">0</span>&#125;,      <span class="comment">// 节点 1 指向 0</span></span><br><span class="line">        &#123;<span class="number">3</span>&#125;,      <span class="comment">// 节点 2 指向 3</span></span><br><span class="line">        &#123;<span class="number">1</span>&#125;,      <span class="comment">// 节点 3 指向 1</span></span><br><span class="line">        &#123;<span class="number">0</span>&#125;,      <span class="comment">// 节点 4 指向 0</span></span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>&#125;    <span class="comment">// 节点 5 指向 0 和 2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topoOrder = <span class="built_in">kahnTopologicalSort</span>(n, adjList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查拓扑排序结果</span></span><br><span class="line">    <span class="keyword">if</span> (topoOrder.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拓扑排序结果: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : topoOrder) &#123;</span><br><span class="line">            cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;图中存在环，无法进行拓扑排序。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kahn算法实现</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">kahnTopologicalSort</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adjList)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n, <span class="number">0</span>)</span></span>;  <span class="comment">// 记录每个节点的入度</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topoOrder;       <span class="comment">// 存储拓扑排序的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[i]) &#123;</span><br><span class="line">            inDegree[neighbor]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">// 用于存放入度为0的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有入度为0的节点加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理队列中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        topoOrder.<span class="built_in">push_back</span>(node);  <span class="comment">// 将节点加入拓扑排序结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历该节点的所有邻接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : adjList[node]) &#123;</span><br><span class="line">            inDegree[neighbor]--;  <span class="comment">// 将邻接节点的入度减1</span></span><br><span class="line">            <span class="keyword">if</span> (inDegree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);  <span class="comment">// 如果邻接节点的入度为0，加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> topoOrder;  <span class="comment">// 返回拓扑排序结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-如何判断是否存在拓扑排序？"><a href="#6-如何判断是否存在拓扑排序？" class="headerlink" title="6. 如何判断是否存在拓扑排序？"></a>6. <strong>如何判断是否存在拓扑排序？</strong></h3><p>拓扑排序仅适用于 <strong>有向无环图</strong>（DAG），也就是说图中不能有环。如果图中存在环，则无法进行拓扑排序，因为环中的节点之间存在相互依赖，无法线性排序。因此，在进行拓扑排序的过程中，如果图中存在环，算法将无法处理完所有节点。对于 Kahn 算法而言，如果最终没有处理完所有节点（即队列中还有节点入度不为 0），则说明图中存在环。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>拓扑排序</strong> 是将 <strong>有向无环图（DAG）</strong> 的所有节点按照依赖关系排序的过程。</li>
<li><strong>拓扑序列</strong> 是拓扑排序的结果，满足在图中每条边 <code>u -&gt; v</code> 中，节点 <code>u</code> 必须在节点 <code>v</code> 之前。</li>
<li>常见的拓扑排序算法有 <strong>Kahn算法</strong>（基于入度）和 <strong>DFS算法</strong>。</li>
<li>拓扑排序广泛应用于任务调度、编译依赖等需要考虑顺序依赖的场景。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode心得</title>
    <url>/2024/11/02/leetcode%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>1.对于复杂条件的题，看能不能将条件简化，比如通过排序让题目简单，比如去掉多余空格，让后序算法简化操作</p>
<p>2.双指针对于局部的变化有奇效</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历访问的实现</title>
    <url>/2024/09/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>我们从小学二年级开始，就学过二叉树了（bushi）</p>
<p>那么，如何用编程实现二叉树的遍历呢？</p>
<p>（这里使用c艹）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二叉树的每个结点都是如此定义的</p>
<h1 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h1><h5 id="分为前序，中序，后序三种遍历方法。"><a href="#分为前序，中序，后序三种遍历方法。" class="headerlink" title="分为前序，中序，后序三种遍历方法。"></a>分为前序，中序，后序三种遍历方法。</h5><p>前序是从根结点开始，访问到最左侧第一个叶子结点后，访问右侧叶子，然后返回上一级（不访问），访问同级右侧结点，然后往下按照先左后右的顺序访问，等左子树访问完毕后，访问右子树。</p>
<p>中序是从左侧第一个叶子结点开始，返回上一级（访问），下一级右侧，返回上上级，右侧最下方左侧结点，然后返回上一级（访问），以此类推。</p>
<p>后序是按从左到右的顺序，左侧第一个叶子结点开始，访问完上一级结点左侧后，去右侧，然后返回上一级。</p>
<h5 id="每种遍历方法又分为递归和非递归两种"><a href="#每种遍历方法又分为递归和非递归两种" class="headerlink" title="每种遍历方法又分为递归和非递归两种"></a>每种遍历方法又分为递归和非递归两种</h5><h2 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h2><h3 id="1-前序遍历（非递归）"><a href="#1-前序遍历（非递归）" class="headerlink" title="1. 前序遍历（非递归）"></a>1. 前序遍历（非递归）</h3><p>前序遍历的顺序是：根节点 -&gt; 左子树 -&gt; 右子树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;int&gt; result; // 存储遍历结果</span><br><span class="line">    if (!root) return result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk; // 辅助栈</span><br><span class="line">    stk.push(root);       // 首先将根节点入栈</span><br><span class="line"></span><br><span class="line">    while (!stk.empty()) &#123;</span><br><span class="line">        TreeNode* node = stk.top();  // 获取栈顶元素</span><br><span class="line">        stk.pop();                   // 弹出栈顶元素</span><br><span class="line">        result.push_back(node-&gt;val); // 访问节点（加入结果）</span><br><span class="line"></span><br><span class="line">        // 先压右子节点，再压左子节点，保证左子节点先处理</span><br><span class="line">        if (node-&gt;right) stk.push(node-&gt;right);</span><br><span class="line">        if (node-&gt;left) stk.push(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历（非递归）"><a href="#2-中序遍历（非递归）" class="headerlink" title="2. 中序遍历（非递归）"></a>2. 中序遍历（非递归）</h3><p>中序遍历的顺序是：左子树 -&gt; 根节点 -&gt; 右子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 遍历到最左节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        current = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">// 转向右子树</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong>：创建一个栈来存储节点，并将当前节点指向根节点。</p>
<p><strong>遍历左子树</strong>：使用一个 <code>while</code> 循环，持续将当前节点的左子节点压入栈中，直到当前节点为 <code>NULL</code>。这一步实际上是在找到最左侧的节点。</p>
<p><strong>处理节点</strong>：当当前节点为 <code>NULL</code> 且栈不为空时，弹出栈顶节点，输出该节点的值。这就是中序遍历的核心步骤。</p>
<p><strong>转向右子树</strong>：将当前节点更新为弹出的节点的右子节点，继续上述过程。</p>
<p><strong>结束条件</strong>：当当前节点为 <code>NULL</code> 且栈为空时，遍历结束。</p>
<h3 id="3-后序遍历（非递归）"><a href="#3-后序遍历（非递归）" class="headerlink" title="3. 后序遍历（非递归）"></a>3. 后序遍历（非递归）</h3><p>后序遍历的顺序是：左子树 -&gt; 右子树 -&gt; 根节点。</p>
<p>后序遍历的非递归实现较复杂，可以使用两个栈来实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">    stk<span class="number">1.</span><span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个栈，stk1用于遍历，stk2用于存储结果</span></span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">1.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = stk<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">        stk<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        stk<span class="number">2.</span><span class="built_in">push</span>(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子节点和右子节点按顺序压入stk1</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) stk<span class="number">1.</span><span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) stk<span class="number">1.</span><span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将stk2中的节点依次弹出到结果中</span></span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">2.</span><span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(stk<span class="number">2.</span><span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        stk<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三种非递归遍历方法使用栈来模拟递归调用的过程，顺序不同是由于每种遍历访问节点的顺序不同。</p>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>递归算法是一种非常常见且简单的二叉树遍历实现方式，它依赖函数调用栈的隐式机制来完成节点的访问。在二叉树的递归遍历中，递归函数会按照特定的顺序调用自身来遍历树的各个节点。</p>
<h3 id="1-前序遍历（递归）"><a href="#1-前序遍历（递归）" class="headerlink" title="1. 前序遍历（递归）"></a>1. 前序遍历（递归）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>前序遍历的顺序是：<strong>先访问根节点</strong>，再访问左子树，最后访问右子树。</p>
<p>前序遍历顺序：</p>
<ul>
<li>根节点 -&gt; 左子树 -&gt; 右子树。</li>
</ul>
<h4 id="递归算法步骤"><a href="#递归算法步骤" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>先访问当前节点（根节点）。</li>
<li>递归访问左子树。</li>
<li>递归访问右子树。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                  <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);         <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">preorderTraversal</span>(root-&gt;left, result); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">preorderTraversal</span>(root-&gt;right, result); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明"><a href="#过程说明" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先访问根节点 <code>1</code>，然后递归访问它的右子节点 <code>2</code>。</li>
<li>访问 <code>2</code> 后，递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问 <code>3</code> 后，没有更多节点，递归结束。</li>
</ul>
<p>最终前序遍历的结果为 <code>[1, 2, 3]</code>。</p>
<hr>
<h3 id="2-中序遍历（递归）"><a href="#2-中序遍历（递归）" class="headerlink" title="2. 中序遍历（递归）"></a>2. 中序遍历（递归）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>中序遍历的顺序是：<strong>先访问左子树</strong>，然后访问根节点，最后访问右子树。</p>
<p>中序遍历顺序：</p>
<ul>
<li>左子树 -&gt; 根节点 -&gt; 右子树。</li>
</ul>
<h4 id="递归算法步骤-1"><a href="#递归算法步骤-1" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>递归访问左子树。</li>
<li>访问当前节点（根节点）。</li>
<li>递归访问右子树。</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                    <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;left, result);   <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);            <span class="comment">// 访问根节点</span></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;right, result);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明-1"><a href="#过程说明-1" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先递归访问 <code>1</code> 的左子树，但为空，直接访问根节点 <code>1</code>。</li>
<li>然后递归访问右子树，从 <code>2</code> 开始，递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问完 <code>3</code>，回到 <code>2</code>，访问 <code>2</code>。</li>
</ul>
<p>最终中序遍历的结果为 <code>[1, 3, 2]</code>。</p>
<hr>
<h3 id="3-后序遍历（递归）"><a href="#3-后序遍历（递归）" class="headerlink" title="3. 后序遍历（递归）"></a>3. 后序遍历（递归）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>后序遍历的顺序是：<strong>先访问左子树</strong>，再访问右子树，最后访问根节点。</p>
<p>后序遍历顺序：</p>
<ul>
<li>左子树 -&gt; 右子树 -&gt; 根节点。</li>
</ul>
<h4 id="递归算法步骤-2"><a href="#递归算法步骤-2" class="headerlink" title="递归算法步骤"></a>递归算法步骤</h4><ol>
<li>递归访问左子树。</li>
<li>递归访问右子树。</li>
<li>访问当前节点（根节点）。</li>
</ol>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;                    <span class="comment">// 递归终止条件：节点为空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left, result);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;right, result); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);             <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过程说明-2"><a href="#过程说明-2" class="headerlink" title="过程说明"></a>过程说明</h4><p>假设二叉树结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>首先递归访问 <code>1</code> 的左子树，空节点返回。</li>
<li>然后递归访问 <code>1</code> 的右子节点 <code>2</code>，继续递归访问 <code>2</code> 的左子节点 <code>3</code>。</li>
<li>访问 <code>3</code> 后返回，访问 <code>2</code> 后返回，最后访问根节点 <code>1</code>。</li>
</ul>
<p>最终后序遍历的结果为 <code>[3, 2, 1]</code>。</p>
<hr>
<h3 id="递归遍历的工作原理"><a href="#递归遍历的工作原理" class="headerlink" title="递归遍历的工作原理"></a>递归遍历的工作原理</h3><p>递归遍历的核心思想是利用系统调用栈隐式地保存当前节点的状态，并通过函数的自我调用完成对二叉树各个节点的遍历。在每一次递归调用时，栈帧会记录当前函数的上下文（包括参数和本地变量），当递归返回时，栈帧会恢复之前的状态。因此，递归算法中不需要显式地使用栈结构来保存节点状态，递归的函数调用本身就是栈的模拟。</p>
<h1 id="通过遍历确定二叉树"><a href="#通过遍历确定二叉树" class="headerlink" title="通过遍历确定二叉树"></a>通过遍历确定二叉树</h1><p>首先，一种遍历是肯定不能的</p>
<p>前序遍历＋后序也不能</p>
<p>但中序＋任意就可以</p>
<p>下面是后序和中序的一个例子</p>
<p>给定二叉树的<strong>后序遍历</strong>和<strong>中序遍历</strong>，可以确定这棵二叉树的结构。</p>
<ul>
<li><strong>后序遍历</strong>：<code>dabec</code></li>
<li><strong>中序遍历</strong>：<code>debac</code></li>
</ul>
<h3 id="重建二叉树的步骤"><a href="#重建二叉树的步骤" class="headerlink" title="重建二叉树的步骤"></a>重建二叉树的步骤</h3><ol>
<li><p><strong>后序遍历的特点</strong>：后序遍历的最后一个节点是根节点。因此，通过后序遍历可以找到二叉树的根节点。</p>
<ul>
<li>在后序遍历 <code>dabec</code> 中，最后一个元素 <code>c</code> 是二叉树的根节点。</li>
</ul>
</li>
<li><p><strong>在中序遍历中找到根节点</strong>：通过中序遍历，可以将二叉树分为左子树和右子树。</p>
<ul>
<li>中序遍历是 <code>debac</code>，根节点 <code>c</code> 在中序遍历中的位置是最后一位，因此 <code>deba</code> 是左子树，右子树为空。</li>
</ul>
</li>
<li><p><strong>递归构建左子树</strong>：</p>
<ul>
<li>左子树的中序遍历是 <code>deba</code>，左子树的后序遍历是 <code>dabe</code>（从后序遍历中取去掉根节点的部分）。</li>
<li>继续对 <code>dabe</code> 和 <code>deba</code> 递归构建。</li>
</ul>
</li>
<li><p><strong>对左子树进行递归构建</strong>：</p>
<ul>
<li>在后序遍历 <code>dabe</code> 中，最后一个元素 <code>e</code> 是左子树的根节点。</li>
<li>在中序遍历 <code>deba</code> 中，根节点 <code>e</code> 的位置将 <code>d</code> 和 <code>ba</code> 分为左右子树，左子树为 <code>d</code>，右子树为 <code>ba</code>。</li>
</ul>
</li>
<li><p><strong>递归构建左子树和右子树</strong>：</p>
<ul>
<li>对左子树 <code>d</code>，中序遍历和后序遍历均为 <code>d</code>，因此它是叶子节点。</li>
<li>对右子树 <code>ba</code>：<ul>
<li>在后序遍历 <code>ba</code> 中，根节点是 <code>a</code>，剩下的 <code>b</code> 是它的左子树。</li>
<li>对左子树 <code>b</code>，中序遍历和后序遍历均为 <code>b</code>，因此它是叶子节点。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="最终二叉树的结构"><a href="#最终二叉树的结构" class="headerlink" title="最终二叉树的结构"></a>最终二叉树的结构</h3><p>将上述步骤的结果组合在一起，二叉树的形状如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    c</span><br><span class="line">   /</span><br><span class="line">  e</span><br><span class="line"> / \</span><br><span class="line">d   a</span><br><span class="line">   /</span><br><span class="line">  b</span><br></pre></td></tr></table></figure>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul>
<li>根节点是 <code>c</code>，它的左子树是 <code>e</code>。</li>
<li>节点 <code>e</code> 的左子树是 <code>d</code>，右子树是 <code>a</code>。</li>
<li>节点 <code>a</code> 有一个左子树 <code>b</code>，而 <code>b</code> 和 <code>d</code> 都是叶子节点。</li>
</ul>
<p>通过后序遍历和中序遍历，我们成功地重建了这棵二叉树。</p>
<hr>
<h1 id="递归-vs-非递归"><a href="#递归-vs-非递归" class="headerlink" title="递归 vs. 非递归"></a>递归 vs. 非递归</h1><ol>
<li><p><strong>递归遍历</strong>：</p>
<ul>
<li>简洁且符合思维逻辑。</li>
<li>利用系统调用栈来管理递归状态，不需要手动维护栈。</li>
<li>如果树的深度较深，递归深度过大会导致栈溢出。</li>
</ul>
</li>
<li><p><strong>非递归遍历</strong>：</p>
<ul>
<li>使用显式栈来模拟递归，避免了函数调用的开销。</li>
<li>更加适合处理非常深的树，避免了递归栈溢出的问题。</li>
<li>实现较为复杂，尤其是后序遍历，需要用到两个栈。</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>递归遍历是通过系统调用栈隐式地实现节点状态的保存与恢复，而非递归遍历则通过显式的栈来模拟递归过程。选择递归或非递归方法通常取决于具体应用场景以及对性能和栈深度的要求。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>仿函数</title>
    <url>/2025/01/12/%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>仿函数（Function Object 或 Functor）</strong> 是一种行为类似于函数的对象。仿函数是通过重载 <code>operator()</code> 运算符来实现的，这样一个对象就可以像函数一样调用。</p>
<p>仿函数的核心思想是：<strong>对象可以具有类似函数的行为，并且可以携带状态</strong>。这为设计灵活的函数调用方式提供了可能性，尤其是在 STL（标准模板库）中，仿函数被广泛应用于算法、容器操作等场景。</p>
<hr>
<h2 id="1-仿函数的基本概念"><a href="#1-仿函数的基本概念" class="headerlink" title="1. 仿函数的基本概念"></a><strong>1. 仿函数的基本概念</strong></h2><p>仿函数是通过在一个类中重载 <code>operator()</code> 运算符来实现的。这样，类的对象就可以被调用（表现得像一个函数）。</p>
<h3 id="仿函数的基本语法"><a href="#仿函数的基本语法" class="headerlink" title="仿函数的基本语法"></a><strong>仿函数的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载 operator()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Called with: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyFunctor functor; <span class="comment">// 创建仿函数对象</span></span><br><span class="line">    <span class="built_in">functor</span>(<span class="number">10</span>);       <span class="comment">// 像函数一样调用对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Called with: 10</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>functor(10)</code> 的调用会自动调用 <code>MyFunctor</code> 类的 <code>operator()</code> 函数。这样，<code>functor</code> 对象就表现得像一个函数。</p>
<hr>
<h2 id="2-仿函数的优点"><a href="#2-仿函数的优点" class="headerlink" title="2. 仿函数的优点"></a><strong>2. 仿函数的优点</strong></h2><ol>
<li><p><strong>携带状态：</strong><br>仿函数可以包含成员变量，用于保存状态，而普通函数无法做到这一点。</p>
</li>
<li><p><strong>灵活性和可扩展性：</strong><br>仿函数是一个类，可以拥有额外的功能，如构造函数、成员函数等，提供比普通函数更多的功能和灵活性。</p>
</li>
<li><p><strong>STL 算法支持：</strong><br>仿函数与 STL 算法（如 <code>std::sort</code>、<code>std::for_each</code>）配合得非常好，用于定义自定义的行为。</p>
</li>
</ol>
<hr>
<h2 id="3-仿函数的应用"><a href="#3-仿函数的应用" class="headerlink" title="3. 仿函数的应用"></a><strong>3. 仿函数的应用</strong></h2><h3 id="3-1-仿函数与-STL-算法结合"><a href="#3-1-仿函数与-STL-算法结合" class="headerlink" title="3.1 仿函数与 STL 算法结合"></a><strong>3.1 仿函数与 STL 算法结合</strong></h3><p>仿函数可以作为参数传递给 STL 算法，例如 <code>std::sort</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b; <span class="comment">// 降序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数作为自定义排序规则</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Compare</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : vec) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5 3 2 1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>仿函数 <code>Compare</code> 定义了一个自定义排序规则：返回 <code>true</code> 时表示 <code>a</code> 应该排在 <code>b</code> 的前面。</li>
<li><code>std::sort</code> 接受仿函数作为第三个参数，用于对容器中的元素进行排序。</li>
</ul>
<hr>
<h3 id="3-2-状态保存的仿函数"><a href="#3-2-状态保存的仿函数" class="headerlink" title="3.2 状态保存的仿函数"></a><strong>3.2 状态保存的仿函数</strong></h3><p>仿函数可以保存状态，普通函数无法做到这一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 保存状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + value; <span class="comment">// 返回加上状态值后的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Adder <span class="title">add5</span><span class="params">(<span class="number">5</span>)</span></span>;   <span class="comment">// 创建一个仿函数对象，保存状态值 5</span></span><br><span class="line">    <span class="function">Adder <span class="title">add10</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建另一个仿函数对象，保存状态值 10</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add5</span>(<span class="number">3</span>) &lt;&lt; endl;  <span class="comment">// 输出 8（3 + 5）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add10</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 输出 13（3 + 10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">13</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>仿函数 <code>Adder</code> 内部保存了一个状态 <code>value</code>，通过构造函数进行初始化。</li>
<li>调用仿函数时，可以使用该状态进行计算，类似于闭包（closure）的效果。</li>
</ul>
<hr>
<h3 id="3-3-使用-STL-的-std-for-each"><a href="#3-3-使用-STL-的-std-for-each" class="headerlink" title="3.3 使用 STL 的 std::for_each"></a><strong>3.3 使用 STL 的 <code>std::for_each</code></strong></h3><p>仿函数可以用于 STL 算法 <code>std::for_each</code>，实现对容器中每个元素的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个仿函数，用于打印元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用仿函数与 for_each</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">Print</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>Print</code> 仿函数定义了如何处理每个元素。</li>
<li><code>std::for_each</code> 将容器中的每个元素依次传递给仿函数。</li>
</ul>
<hr>
<h3 id="3-4-Lambda-表达式的替代"><a href="#3-4-Lambda-表达式的替代" class="headerlink" title="3.4 Lambda 表达式的替代"></a><strong>3.4 Lambda 表达式的替代</strong></h3><p>在现代 C++（C++11 及以上）中，仿函数可以被 <strong>Lambda 表达式</strong> 替代。Lambda 表达式更简洁，但仿函数在某些复杂场景下依然有优势。</p>
<p>等价于上面的 <code>std::for_each</code> 示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式替代仿函数</span></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a><strong>输出</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-STL-中常见的仿函数"><a href="#4-STL-中常见的仿函数" class="headerlink" title="4. STL 中常见的仿函数"></a><strong>4. STL 中常见的仿函数</strong></h2><p>C++ STL 提供了一些常用的内置仿函数，主要定义在头文件 <code>&lt;functional&gt;</code> 中：</p>
<h3 id="4-1-算术仿函数"><a href="#4-1-算术仿函数" class="headerlink" title="4.1 算术仿函数"></a><strong>4.1 算术仿函数</strong></h3><ul>
<li><code>std::plus</code>：加法。</li>
<li><code>std::minus</code>：减法。</li>
<li><code>std::multiplies</code>：乘法。</li>
<li><code>std::divides</code>：除法。</li>
<li><code>std::modulus</code>：取模。</li>
<li><code>std::negate</code>：取负。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="type">int</span>&gt; add;           <span class="comment">// 加法仿函数</span></span><br><span class="line">    multiplies&lt;<span class="type">int</span>&gt; multiply; <span class="comment">// 乘法仿函数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;        <span class="comment">// 输出 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;  <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-逻辑仿函数"><a href="#4-2-逻辑仿函数" class="headerlink" title="4.2 逻辑仿函数"></a><strong>4.2 逻辑仿函数</strong></h3><ul>
<li><code>std::equal_to</code>：等于。</li>
<li><code>std::not_equal_to</code>：不等于。</li>
<li><code>std::greater</code>：大于。</li>
<li><code>std::less</code>：小于。</li>
<li><code>std::greater_equal</code>：大于等于。</li>
<li><code>std::less_equal</code>：小于等于。</li>
</ul>
<h3 id="4-3-逻辑操作仿函数"><a href="#4-3-逻辑操作仿函数" class="headerlink" title="4.3 逻辑操作仿函数"></a><strong>4.3 逻辑操作仿函数</strong></h3><ul>
<li><code>std::logical_and</code>：逻辑与。</li>
<li><code>std::logical_or</code>：逻辑或。</li>
<li><code>std::logical_not</code>：逻辑非。</li>
</ul>
<hr>
<h2 id="5-仿函数与-Lambda-的对比"><a href="#5-仿函数与-Lambda-的对比" class="headerlink" title="5. 仿函数与 Lambda 的对比"></a><strong>5. 仿函数与 Lambda 的对比</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>仿函数</strong></th>
<th><strong>Lambda 表达式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态管理</strong></td>
<td>通过类的成员变量保存状态</td>
<td>捕获变量（自动或手动捕获）</td>
</tr>
<tr>
<td><strong>代码长度</strong></td>
<td>需要定义一个类，代码较长</td>
<td>简洁（C++11 及以上）</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>灵活，可定义复杂行为</td>
<td>简单场景更适用</td>
</tr>
<tr>
<td><strong>兼容性</strong></td>
<td>C++98 开始支持</td>
<td>C++11 及以上支持</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li>仿函数是通过重载 <code>operator()</code> 实现的对象，可以像函数一样调用。</li>
<li>仿函数能够保存状态，并灵活应用于 STL 算法。</li>
<li>在现代 C++ 中，仿函数仍然有其独特的作用，尤其是在复杂的场景中，而简单场景更推荐使用 Lambda 表达式。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>几种排序</title>
    <url>/2024/11/12/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>冒泡排序</strong>（Bubble Sort）是一种简单直观的排序算法，其基本思想是通过多次遍历待排序的序列，比较相邻元素并交换它们的位置，使较大的元素逐渐“冒泡”到序列的末尾。尽管效率较低，但它是介绍排序算法时常用的例子之一，适合对小规模数据的排序。</p>
<h3 id="冒泡排序的原理"><a href="#冒泡排序的原理" class="headerlink" title="冒泡排序的原理"></a>冒泡排序的原理</h3><ol>
<li>从序列的第一个元素开始，依次比较相邻的两个元素。如果前面的元素大于后面的元素，就交换它们的位置。</li>
<li>每次遍历后，最大的元素会被交换到当前未排序部分的末尾。</li>
<li>对未排序部分重复上述过程，直到没有元素需要交换为止。</li>
</ol>
<h3 id="冒泡排序的特点"><a href="#冒泡排序的特点" class="headerlink" title="冒泡排序的特点"></a>冒泡排序的特点</h3><ul>
<li><strong>时间复杂度</strong>：<ul>
<li>最坏情况： $O(n^2)$（数组逆序）</li>
<li>最好情况： $O(n)$（数组已经有序，只需一次遍历）</li>
<li>平均情况： $O(n^2)$</li>
</ul>
</li>
<li><strong>空间复杂度</strong>： $O(1)$（只需常数级的额外空间）</li>
<li><strong>稳定性</strong>：起泡排序是稳定的排序算法，即相同的元素在排序后不会改变相对顺序。</li>
</ul>
<h3 id="冒泡排序的实现"><a href="#冒泡排序的实现" class="headerlink" title="冒泡排序的实现"></a>冒泡排序的实现</h3><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外层循环控制需要进行的轮数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 标志变量用于检测数组是否已经有序</span></span><br><span class="line">        <span class="type">bool</span> swapped = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 内层循环用于比较和交换相邻元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换相邻元素</span></span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                swapped = <span class="literal">true</span>;  <span class="comment">// 记录交换发生</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果本轮没有发生交换，数组已排序，提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>快速排序</strong>（Quick Sort）是一种高效的基于分治法的排序算法，它通过递归地将数组分成两个子数组来排序。快速排序通常是实际应用中最快的排序算法之一，适用于大规模数据排序。</p>
<h3 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h3><ol>
<li><strong>选取基准（pivot）</strong>：从数组中选择一个元素作为基准，可以是第一个元素、最后一个元素、中间元素或随机选择。</li>
<li><strong>分区（Partition）</strong>：将数组分成两部分，使得左侧子数组的所有元素都小于基准，而右侧子数组的所有元素都大于或等于基准。</li>
<li><strong>递归排序</strong>：对左右两个子数组分别递归地应用快速排序。</li>
<li><strong>合并</strong>：由于在分区的过程中数组已经部分有序，所以不需要额外的合并操作。</li>
</ol>
<h3 id="快速排序的特点"><a href="#快速排序的特点" class="headerlink" title="快速排序的特点"></a>快速排序的特点</h3><ul>
<li><strong>时间复杂度</strong>：<ul>
<li>最坏情况： $O(n^2)$（当数组基本有序或基准选择不当时）</li>
<li>最好情况： $O(n \log n)$（理想情况下，基准能将数组均匀分割）</li>
<li>平均情况： $O(n \log n)$</li>
</ul>
</li>
<li><strong>空间复杂度</strong>： $O(\log n)$，用于递归栈空间。</li>
<li><strong>不稳定性</strong>：快速排序是不稳定的排序算法，即相同的元素在排序后可能会改变相对顺序。</li>
</ul>
<h3 id="快速排序的实现"><a href="#快速排序的实现" class="headerlink" title="快速排序的实现"></a>快速排序的实现</h3><p>下面是快速排序的经典实现，其中基准选取最后一个元素。</p>
<h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++ 实现"></a>C++ 实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，将基准放到正确位置，并返回基准的最终位置索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最后一个元素为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;        <span class="comment">// i 为较小元素的边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素小于等于基准</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">            i++;  <span class="comment">// 增加边界索引</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);  <span class="comment">// 交换当前元素与边界元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i + <span class="number">1</span>], arr[high]);  <span class="comment">// 将基准放到正确位置</span></span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);  <span class="comment">// 返回基准的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 分区，并获取基准位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归排序左右子数组</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h3><ol>
<li><strong>三数取中</strong>：选择基准时，可以取头、中、尾三个元素的中间值，避免数组本身有序时出现最坏情况。</li>
<li><strong>随机选择基准</strong>：通过随机选择基准位置，打乱输入数组，减少最坏情况发生的概率。</li>
<li><strong>小数组插入排序</strong>：当子数组长度较小时（如10以下），可以使用插入排序代替快速排序，以提高效率。</li>
</ol>
<h3 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="headerlink" title="快速排序的性能分析"></a>快速排序的性能分析</h3><p>$$<br>快速排序的性能在很大程度上取决于分区是否平衡。<br>$$</p>
<p>$$<br>平衡的分区能保证时间复杂度接近 O(n \log n)，而极端不平衡的分区会导致最坏的 O(n^2)复杂度。因此，优化基准的选择非常重要。<br>$$</p>
<p>简单选择排序（Selection Sort）是一种排序算法，通过反复找到未排序部分中的最小元素，将其放到数组的起始位置，逐步构建有序序列。这个算法适合数据量较小的情况，时间复杂度为 $O(n^2)$。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>从数组的第一个元素开始，假设它是最小元素。</li>
<li>遍历数组的剩余部分，找到比当前最小元素更小的值并更新最小元素。</li>
<li>遍历完成后，将找到的最小值和当前未排序部分的第一个元素交换。</li>
<li>移动到下一个位置，重复上述步骤，直到整个数组排序完毕。</li>
</ol>
<h3 id="实现代码（C-）"><a href="#实现代码（C-）" class="headerlink" title="实现代码（C++）"></a>实现代码（C++）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 逐一确定数组中每一个位置的最终元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i; <span class="comment">// 假设当前索引 i 是最小元素的位置</span></span><br><span class="line">        <span class="comment">// 查找从 i+1 到 n-1 中比 arr[minIndex] 更小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123; <span class="comment">// 更新最小元素的位置</span></span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换最小元素到当前的 i 位置</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123; <span class="comment">// 避免自身交换</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[minIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">selectionSort</span>(arr, n); <span class="comment">// 对数组进行选择排序</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n); <span class="comment">// 输出排序结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>堆排序（Heap Sort）是一种基于二叉堆的数据结构实现的排序算法，具有时间复杂度为 $O(n \log n)$，可以被认为是一种改进的选择排序。堆排序的特点是无论数据情况如何，其时间复杂度都能保持稳定，是一种不稳定的原地排序算法。</p>
<h3 id="二叉堆简介"><a href="#二叉堆简介" class="headerlink" title="二叉堆简介"></a>二叉堆简介</h3><p>堆排序使用<strong>最大堆</strong>或<strong>最小堆</strong>来辅助排序：</p>
<ul>
<li><strong>最大堆</strong>：父节点的值总是大于或等于子节点的值。</li>
<li><strong>最小堆</strong>：父节点的值总是小于或等于子节点的值。</li>
</ul>
<p>在堆排序中，通常使用<strong>最大堆</strong>来实现升序排序。</p>
<h3 id="堆排序算法步骤"><a href="#堆排序算法步骤" class="headerlink" title="堆排序算法步骤"></a>堆排序算法步骤</h3><ol>
<li><strong>构建最大堆</strong>：将数组视为一个完全二叉树，从最后一个非叶子节点开始，对每个节点进行<strong>堆调整</strong>，使整个数组满足最大堆的性质。</li>
<li><strong>排序</strong>：<ul>
<li>将堆顶元素（最大值）与数组末尾元素交换，这样最大值就处于正确的最终位置。</li>
<li>将堆的大小减一，对新的堆顶元素进行<strong>堆调整</strong>，以重新保持最大堆的性质。</li>
<li>重复上述过程，直到堆的大小减为 1，排序完成。</li>
</ul>
</li>
</ol>
<h3 id="堆排序代码实现（C-）"><a href="#堆排序代码实现（C-）" class="headerlink" title="堆排序代码实现（C++）"></a>堆排序代码实现（C++）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将以 root 为根的子树调整为最大堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = root;         <span class="comment">// 将根节点设为最大值</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * root + <span class="number">1</span>;    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * root + <span class="number">2</span>;   <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大值不是根节点，则交换并递归调整</span></span><br><span class="line">    <span class="keyword">if</span> (largest != root) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[root], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);  <span class="comment">// 递归调整受影响的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 逐一取出元素并调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);    <span class="comment">// 将最大元素移动到末尾</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);      <span class="comment">// 调整剩下的元素形成最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapSort</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例执行过程"><a href="#示例执行过程" class="headerlink" title="示例执行过程"></a>示例执行过程</h3><p>假设我们对数组 <code>&#123;12, 11, 13, 5, 6, 7&#125;</code> 进行堆排序：</p>
<ol>
<li><p><strong>构建最大堆</strong>：  </p>
<ul>
<li>选择非叶子节点 <code>5</code> 和 <code>6</code>，调整以 <code>5</code> 和 <code>6</code> 为根的子树。</li>
<li>继续调整上层节点，最后整个数组满足最大堆的结构：<code>&#123;13, 11, 12, 5, 6, 7&#125;</code>。</li>
</ul>
</li>
<li><p><strong>排序过程</strong>：</p>
<ul>
<li>将堆顶元素 <code>13</code> 与最后一个元素交换：<code>&#123;7, 11, 12, 5, 6, 13&#125;</code>，缩小堆的范围到 <code>[0, n-2]</code>，再对堆顶进行堆调整。</li>
<li>重复此过程直到排序完成，最终结果为：<code>&#123;5, 6, 7, 11, 12, 13&#125;</code>。</li>
</ul>
</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>堆排序的时间复杂度为 $O(n \log n)$，因为：</p>
<ul>
<li>建堆操作的时间复杂度为 $O(n)$。</li>
<li>排序过程中需要 $O(\log n)$ 的时间进行堆调整，总体复杂度为 $O(n \log n)$。</li>
</ul>
<p>归并排序（Merge Sort）是一种基于<strong>分治法（Divide and Conquer）</strong>的排序算法。它将数组分成较小的子数组，分别排序后再合并，最终完成排序。</p>
<h3 id="1-算法原理"><a href="#1-算法原理" class="headerlink" title="1. 算法原理"></a>1. 算法原理</h3><p>归并排序的核心思想是：</p>
<ol>
<li><strong>分</strong>：将待排序数组分成两个子数组，分别对这两个子数组进行排序。</li>
<li><strong>治</strong>：通过递归将子数组继续分割，直到每个子数组的长度为 1。</li>
<li><strong>合</strong>：将两个有序子数组合并成一个有序数组。</li>
</ol>
<h3 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h3><ol>
<li><strong>递归分割数组</strong>：<ul>
<li>将数组从中间分成两部分，直到每部分只剩一个元素。</li>
</ul>
</li>
<li><strong>合并子数组</strong>：<ul>
<li>合并两个已排序的子数组为一个有序数组。</li>
</ul>
</li>
</ol>
<h3 id="3-时间复杂度"><a href="#3-时间复杂度" class="headerlink" title="3. 时间复杂度"></a>3. 时间复杂度</h3><ul>
<li><strong>时间复杂度</strong>：$O(n \log n)$<ul>
<li>每次分割数组的时间复杂度为 $O(\log n)$，合并数组的时间复杂度为 $O(n)$。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：$O(n)$<ul>
<li>归并排序需要额外的数组空间来存储合并后的结果。</li>
</ul>
</li>
</ul>
<h3 id="4-C-实现"><a href="#4-C-实现" class="headerlink" title="4. C++ 实现"></a>4. C++ 实现</h3><p>以下是归并排序的完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>; <span class="comment">// 左子数组大小</span></span><br><span class="line">    <span class="type">int</span> n2 = right - mid;    <span class="comment">// 右子数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数据到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">        R[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left; <span class="comment">// 初始索引</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, left, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后的数组: &quot;</span>;</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始数组: 12 11 13 5 6 7 </span><br><span class="line">排序后的数组: 5 6 7 11 12 13 </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><p><strong>merge 函数</strong>：</p>
<ul>
<li>将两个有序数组（<code>L</code> 和 <code>R</code>）合并为一个有序数组。</li>
<li>使用两个指针遍历子数组，同时更新原数组中的值。</li>
</ul>
</li>
<li><p><strong>mergeSort 函数</strong>：</p>
<ul>
<li>递归分割数组为两部分，直到每部分只剩一个元素。</li>
<li>调用 <code>merge</code> 函数将子数组合并。</li>
</ul>
</li>
<li><p><strong>递归基线条件</strong>：</p>
<ul>
<li>当 <code>left &gt;= right</code> 时，数组无法再分割，递归结束。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>稳定性</strong>：归并排序是一种稳定的排序算法。</li>
<li><strong>性能稳定</strong>：时间复杂度始终为 $O(n \log n)$，无论最佳、最差或平均情况。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>空间复杂度较高</strong>：需要额外的数组空间来辅助合并操作。</li>
<li><strong>递归开销</strong>：递归调用会增加时间和空间的开销。</li>
</ol>
<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>归并排序适用于需要稳定排序的场景，特别是在处理大规模数据集或链表时（链表中归并排序的空间复杂度为 $O(1)$）。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>堆排序</tag>
        <tag>快速排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀表与KMP算法</title>
    <url>/2024/11/02/%E5%89%8D%E7%BC%80%E8%A1%A8%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p> KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配的高效算法，它能够在文本串中查找模式串出现的位置。KMP算法的核心在于避免重复比较字符，从而提高匹配效率。</p>
<h3 id="KMP算法的基本思路"><a href="#KMP算法的基本思路" class="headerlink" title="KMP算法的基本思路"></a>KMP算法的基本思路</h3><ol>
<li><strong>预处理模式串</strong>：通过构建一个“部分匹配表”（或称为“失配表”），在模式串中记录每个位置的最长可匹配前缀长度。</li>
<li><strong>匹配过程</strong>：利用部分匹配表，在匹配失败时，根据前缀信息跳过不必要的比较，从而加速匹配过程。</li>
</ol>
<h3 id="部分匹配表（LPS数组）"><a href="#部分匹配表（LPS数组）" class="headerlink" title="部分匹配表（LPS数组）"></a>部分匹配表（LPS数组）</h3><p>LPS（Longest Prefix Suffix）数组用于存储模式串的每个前缀的最长相等前后缀的长度。具体构建方式如下：</p>
<ul>
<li>**LPS[i]**：表示模式串的前缀（<code>pattern[0]</code> 到 <code>pattern[i]</code>）的最长相等前后缀的长度。</li>
</ul>
<h3 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h3><p>下面是KMP算法的完整实现，包括LPS数组的构建和匹配过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于构建LPS数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">computeLPS</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lps</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>; <span class="comment">// 上一个最长前缀后缀的长度</span></span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;     <span class="comment">// LPS[0]始终为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (length &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[length]) &#123;</span><br><span class="line">            length = lps[length - <span class="number">1</span>]; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[length]) &#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        lps[i] = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP搜索算法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">KMPSearch</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; lps = <span class="built_in">computeLPS</span>(pattern);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; positions; <span class="comment">// 存储匹配的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 文本指针</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 模式指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == text[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配</span></span><br><span class="line">            positions.<span class="built_in">push_back</span>(i - j);</span><br><span class="line">            j = lps[j - <span class="number">1</span>]; <span class="comment">// 继续查找下一个匹配</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; pattern[j] != text[i]) &#123; <span class="comment">// 匹配失败</span></span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = lps[j - <span class="number">1</span>]; <span class="comment">// 根据LPS表跳转</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++; <span class="comment">// 否则向前移动文本指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">KMPSearch</span>(text, pattern);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pos : result) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pattern found at index: &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol>
<li><strong>computeLPS函数</strong>：构建LPS数组，遍历模式串并填充LPS数组，使用回溯逻辑。</li>
<li><strong>KMPSearch函数</strong>：使用LPS数组进行模式匹配：<ul>
<li>使用两个指针 <code>i</code> 和 <code>j</code> 分别指向文本和模式串。</li>
<li>如果字符匹配，两个指针同时移动。</li>
<li>如果模式串匹配完成，将起始位置保存。</li>
<li>如果不匹配，根据LPS数组调整模式指针。</li>
</ul>
</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n + m)，其中 n 是文本串的长度，m 是模式串的长度。</li>
<li><strong>空间复杂度</strong>：O(m)，用于存储LPS数组。</li>
</ul>
<p>KMP算法是一个非常高效的字符串匹配算法，适用于大规模文本搜索。希望这个解释和示例代码对你理解KMP算法有帮助！如果你有任何问题或需要进一步的解释，请告诉我！</p>
<p> 当然可以！让我们通过一个具体的实例来演示KMP算法的工作过程。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有以下文本串和模式串：</p>
<ul>
<li><strong>文本串</strong>：<code>text = &quot;ABABDABACDABABCABAB&quot;</code></li>
<li><strong>模式串</strong>：<code>pattern = &quot;ABABCABAB&quot;</code></li>
</ul>
<p>我们要找到模式串在文本串中的所有出现位置。</p>
<h3 id="步骤-1：构建LPS数组"><a href="#步骤-1：构建LPS数组" class="headerlink" title="步骤 1：构建LPS数组"></a>步骤 1：构建LPS数组</h3><p>首先，我们需要构建模式串的LPS数组。</p>
<h4 id="模式串：ABABCABAB"><a href="#模式串：ABABCABAB" class="headerlink" title="模式串：ABABCABAB"></a>模式串：<code>ABABCABAB</code></h4><ul>
<li>计算LPS数组：<ul>
<li><code>lps[0] = 0</code>（第一个字符没有前缀和后缀）</li>
<li><code>lps[1] = 0</code>（<code>A</code>没有相等的前后缀）</li>
<li><code>lps[2] = 1</code>（<code>AB</code>的前缀<code>A</code>和后缀<code>A</code>相等）</li>
<li><code>lps[3] = 2</code>（<code>ABA</code>的前缀<code>AB</code>和后缀<code>AB</code>相等）</li>
<li><code>lps[4] = 0</code>（<code>ABAB</code>没有相等的前后缀）</li>
<li><code>lps[5] = 1</code>（<code>ABABC</code>的前缀<code>A</code>和后缀<code>A</code>相等）</li>
<li><code>lps[6] = 2</code>（<code>ABABCA</code>的前缀<code>AB</code>和后缀<code>AB</code>相等）</li>
<li><code>lps[7] = 3</code>（<code>ABABCAB</code>的前缀<code>ABA</code>和后缀<code>ABA</code>相等）</li>
<li><code>lps[8] = 4</code>（<code>ABABCABA</code>的前缀<code>ABAB</code>和后缀<code>ABAB</code>相等）</li>
</ul>
</li>
</ul>
<p>最终的LPS数组为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lps = [0, 0, 1, 2, 0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="步骤-2：进行KMP搜索"><a href="#步骤-2：进行KMP搜索" class="headerlink" title="步骤 2：进行KMP搜索"></a>步骤 2：进行KMP搜索</h3><p>接下来我们使用KMP算法进行匹配。</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>i = 0</code>（文本指针）</li>
<li><code>j = 0</code>（模式指针）</li>
<li><code>positions = []</code>（存储匹配位置）</li>
</ul>
</li>
<li><p><strong>开始匹配</strong>：</p>
<ul>
<li><strong>第 1 次比较</strong>：<code>text[0] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 1</code>, <code>j = 1</code></li>
<li><strong>第 2 次比较</strong>：<code>text[1] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 2</code>, <code>j = 2</code></li>
<li><strong>第 3 次比较</strong>：<code>text[2] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 3</code>, <code>j = 3</code></li>
<li><strong>第 4 次比较</strong>：<code>text[3] = &#39;B&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 4</code>, <code>j = 4</code></li>
<li><strong>第 5 次比较</strong>：<code>text[4] = &#39;D&#39;</code>, <code>pattern[4] = &#39;C&#39;</code> → 不匹配。根据LPS数组，<code>j = lps[3] = 2</code>，回溯到<code>pattern[2]</code>。</li>
<li><strong>继续比较</strong>：<code>text[4] = &#39;D&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 不匹配，<code>j = lps[1] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 5</code>。</li>
</ul>
</li>
<li><p><strong>继续匹配</strong>：</p>
<ul>
<li><strong>第 6 次比较</strong>：<code>text[5] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 6</code>, <code>j = 1</code></li>
<li><strong>第 7 次比较</strong>：<code>text[6] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 7</code>, <code>j = 2</code></li>
<li><strong>第 8 次比较</strong>：<code>text[7] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 8</code>, <code>j = 3</code></li>
<li><strong>第 9 次比较</strong>：<code>text[8] = &#39;C&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 不匹配。根据LPS，<code>j = lps[2] = 1</code>，回溯到<code>pattern[1]</code>。</li>
<li><strong>继续比较</strong>：<code>text[8] = &#39;C&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 不匹配，<code>j = lps[0] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 9</code>。</li>
</ul>
</li>
<li><p><strong>再次匹配</strong>：</p>
<ul>
<li><strong>第 10 次比较</strong>：<code>text[9] = &#39;D&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 不匹配，<code>i++</code> → <code>i = 10</code>。</li>
<li><strong>第 11 次比较</strong>：<code>text[10] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 11</code>, <code>j = 1</code></li>
<li><strong>第 12 次比较</strong>：<code>text[11] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 12</code>, <code>j = 2</code></li>
<li><strong>第 13 次比较</strong>：<code>text[12] = &#39;C&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 不匹配，<code>j = lps[1] = 0</code>，重置<code>j</code>。<code>i++</code> → <code>i = 13</code>。</li>
<li><strong>第 14 次比较</strong>：<code>text[13] = &#39;A&#39;</code>, <code>pattern[0] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 14</code>, <code>j = 1</code></li>
<li><strong>第 15 次比较</strong>：<code>text[14] = &#39;B&#39;</code>, <code>pattern[1] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 15</code>, <code>j = 2</code></li>
<li><strong>第 16 次比较</strong>：<code>text[15] = &#39;A&#39;</code>, <code>pattern[2] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 16</code>, <code>j = 3</code></li>
<li><strong>第 17 次比较</strong>：<code>text[16] = &#39;B&#39;</code>, <code>pattern[3] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 17</code>, <code>j = 4</code></li>
<li><strong>第 18 次比较</strong>：<code>text[17] = &#39;C&#39;</code>, <code>pattern[4] = &#39;C&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 18</code>, <code>j = 5</code></li>
<li><strong>第 19 次比较</strong>：<code>text[18] = &#39;A&#39;</code>, <code>pattern[5] = &#39;A&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 19</code>, <code>j = 6</code></li>
<li><strong>第 20 次比较</strong>：<code>text[19] = &#39;B&#39;</code>, <code>pattern[6] = &#39;B&#39;</code> → 匹配，<code>i++</code>, <code>j++</code> → <code>i = 20</code>, <code>j = 7</code></li>
<li><strong>第 21 次比较</strong>：<code>i = 20</code>，超出文本长度，停止匹配。</li>
</ul>
</li>
</ol>
<h3 id="匹配结果"><a href="#匹配结果" class="headerlink" title="匹配结果"></a>匹配结果</h3><p>在整个过程中，我们找到了模式串在文本串中的匹配起始位置：</p>
<ul>
<li><strong>匹配位置</strong>：<code>positions = [10]</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>模式串 <code>&quot;ABABCABAB&quot;</code> 在文本串 <code>&quot;ABABDABACDABABCABAB&quot;</code> 中的匹配位置是 <code>10</code>。</li>
</ul>
<p>这种通过LPS数组的预处理，使得算法能够避免重复比较，提高了效率，特别是在文本较长和模式较短的情况下尤为明显。如果你有其他问题或需要更深入的解释，请随时问我！</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>kmp</tag>
        <tag>前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>单源最短路径问题与Dijkstra算法</title>
    <url>/2024/10/23/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%B8%8EDijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="单源最短路径问题（Single-Source-Shortest-Path-SSSP）"><a href="#单源最短路径问题（Single-Source-Shortest-Path-SSSP）" class="headerlink" title="单源最短路径问题（Single Source Shortest Path, SSSP）"></a><strong>单源最短路径问题</strong>（Single Source Shortest Path, SSSP）</h2><h5 id="是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。"><a href="#是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。" class="headerlink" title="是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的起点（源点）到图中所有其他节点的最短路径。"></a>是图论中的一个经典问题。它的目标是在一个加权图中，找到给定的<strong>起点</strong>（源点）到图中<strong>所有其他节点</strong>的最短路径。</h5><h3 id="问题定义："><a href="#问题定义：" class="headerlink" title="问题定义："></a>问题定义：</h3><ul>
<li><strong>图</strong>：图可以是有向图或无向图，通常包含若干个节点和边，每条边都有一个非负权重（即从一个节点到另一个节点的代价或距离）。</li>
<li><strong>起点（源点）</strong>：单源最短路径问题会指定一个起始节点，称为源节点，问题要求从这个源节点出发，计算它到图中其他所有节点的最短路径。</li>
<li><strong>最短路径</strong>：最短路径是指从源节点到目标节点经过的路径中，总边权重之和最小的路径。</li>
</ul>
<h3 id="具体目标："><a href="#具体目标：" class="headerlink" title="具体目标："></a>具体目标：</h3><p>对于给定的源节点s，你需要找到从s到每个其他节点v的最短路径长度，并且路径上的权重和最小。</p>
<h3 id="常见的算法："><a href="#常见的算法：" class="headerlink" title="常见的算法："></a>常见的算法：</h3><ol>
<li><strong>Dijkstra算法</strong>：<ul>
<li>解决<strong>边权非负</strong>的单源最短路径问题，时间复杂度为$O((V + E) \log V)$，适合稀疏图。</li>
</ul>
</li>
<li><strong>Bellman-Ford算法</strong>：<ul>
<li>可以处理<strong>负权边</strong>的情况，且能够检测负权环，时间复杂度为$O(V \times E)$。</li>
</ul>
</li>
<li><strong>Floyd-Warshall算法</strong>：<ul>
<li>这是一个<strong>多源最短路径</strong>算法，可以计算图中任意两个节点之间的最短路径，时间复杂度为O(V^3)。</li>
</ul>
</li>
<li><strong>SPFA算法</strong>（Shortest Path Faster Algorithm）：<ul>
<li>Bellman-Ford的优化版本，通常在图较稀疏时运行更快。</li>
</ul>
</li>
</ol>
<h2 id="Dijkstra算法："><a href="#Dijkstra算法：" class="headerlink" title="Dijkstra算法："></a><strong>Dijkstra算法</strong>：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个结构体来表示边</span><br><span class="line">struct Edge &#123;</span><br><span class="line">    int to;     // 边的目标节点</span><br><span class="line">    int weight; // 边的权重</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义一个pair来表示优先队列中的元素，first为当前距离，second为当前节点</span><br><span class="line">using pii = pair&lt;int, int&gt;;</span><br><span class="line"></span><br><span class="line">// Dijkstra算法函数，参数为起点和图的邻接表</span><br><span class="line">vector&lt;int&gt; dijkstra(int start, const vector&lt;vector&lt;Edge&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    int n = graph.size();  // 获取图中节点的数量</span><br><span class="line">    vector&lt;int&gt; dist(n, INT_MAX);  // 初始化每个节点的距离为无穷大</span><br><span class="line">    dist[start] = 0;  // 起点到自身的距离为0</span><br><span class="line"></span><br><span class="line">    // 定义优先队列，按照距离升序排列，pair的格式是&#123;距离, 节点&#125;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123;0, start&#125;);  // 将起点放入优先队列</span><br><span class="line"></span><br><span class="line">    // 当优先队列不为空时，执行以下操作</span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        int curr_dist = pq.top().first;  // 获取当前节点的距离</span><br><span class="line">        int curr_node = pq.top().second;  // 获取当前节点</span><br><span class="line">        pq.pop();  // 弹出队首元素</span><br><span class="line"></span><br><span class="line">        // 如果当前距离已经大于记录的最短距离，跳过（优化）</span><br><span class="line">        if (curr_dist &gt; dist[curr_node]) continue;</span><br><span class="line"></span><br><span class="line">        // 遍历当前节点的邻居</span><br><span class="line">        for (const Edge&amp; edge : graph[curr_node]) &#123;</span><br><span class="line">            int next_node = edge.to;        // 邻居节点</span><br><span class="line">            int weight = edge.weight;       // 边的权重</span><br><span class="line"></span><br><span class="line">            // 计算从当前节点到邻居节点的距离</span><br><span class="line">            if (dist[curr_node] + weight &lt; dist[next_node]) &#123;</span><br><span class="line">                dist[next_node] = dist[curr_node] + weight;  // 更新邻居节点的最短距离</span><br><span class="line">                pq.push(&#123;dist[next_node], next_node&#125;);  // 将邻居节点加入优先队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dist;  // 返回从起点到其他所有节点的最短距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;  // n为节点数，m为边数</span><br><span class="line">    cout &lt;&lt; &quot;输入图的节点数和边数：&quot;;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    // 定义图的邻接表</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; graph(n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;输入每条边（格式：起点 终点 权重）：\n&quot;;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int u, v, w;  // u为起点，v为终点，w为权重</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        graph[u].push_back(&#123;v, w&#125;);  // 添加从u到v的边，权重为w</span><br><span class="line">        // 如果是无向图，需要加上这行代码：</span><br><span class="line">        // graph[v].push_back(&#123;u, w&#125;);  // 添加从v到u的边</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int start;  // 起点</span><br><span class="line">    cout &lt;&lt; &quot;输入起点：&quot;;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line"></span><br><span class="line">    // 执行Dijkstra算法</span><br><span class="line">    vector&lt;int&gt; dist = dijkstra(start, graph);</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    cout &lt;&lt; &quot;从起点到其他节点的最短距离：&quot; &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (dist[i] == INT_MAX)</span><br><span class="line">            cout &lt;&lt; &quot;节点 &quot; &lt;&lt; i &lt;&lt; &quot; 不可达&quot; &lt;&lt; endl;  // 如果距离为无穷大，说明不可达</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;到节点 &quot; &lt;&lt; i &lt;&lt; &quot; 的最短距离为： &quot; &lt;&lt; dist[i] &lt;&lt; endl;  // 输出最短距离</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="图的描述"><a href="#图的描述" class="headerlink" title="图的描述"></a>图的描述</h3><ul>
<li>节点: 0, 1, 2, 3, 4</li>
<li>边及其权重：<ul>
<li>0 → 1 (权重 1)</li>
<li>0 → 2 (权重 4)</li>
<li>1 → 2 (权重 2)</li>
<li>1 → 3 (权重 5)</li>
<li>2 → 3 (权重 3)</li>
<li>3 → 4 (权重 1)</li>
</ul>
</li>
</ul>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>我们将从节点 <code>0</code> 开始，使用Dijkstra算法计算到其他节点的最短路径。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p><strong>距离数组</strong> <code>dist[]</code>：初始化为无穷大，源节点的距离为0。</p>
<ul>
<li><code>dist[0] = 0</code></li>
<li><code>dist[1] = ∞</code></li>
<li><code>dist[2] = ∞</code></li>
<li><code>dist[3] = ∞</code></li>
<li><code>dist[4] = ∞</code></li>
</ul>
</li>
<li><p><strong>优先队列</strong>：将源节点加入优先队列。</p>
<ul>
<li><code>pq = [(0, 0)]</code>（表示距离为0，节点为0）</li>
</ul>
</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol>
<li><p><strong>处理节点 0</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(0, 0)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>1</code>，更新距离：<ul>
<li><code>dist[1] = min(∞, 0 + 1) = 1</code></li>
<li>加入优先队列：<code>pq = [(1, 1)]</code></li>
</ul>
</li>
<li>对于 <code>2</code>，更新距离：<ul>
<li><code>dist[2] = min(∞, 0 + 4) = 4</code></li>
<li>加入优先队列：<code>pq = [(1, 1), (4, 2)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 1</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(1, 1)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>2</code>，更新距离：<ul>
<li><code>dist[2] = min(4, 1 + 2) = 3</code></li>
<li>更新优先队列：<code>pq = [(3, 2), (4, 2)]</code>（会自动调整优先队列顺序）</li>
</ul>
</li>
<li>对于 <code>3</code>，更新距离：<ul>
<li><code>dist[3] = min(∞, 1 + 5) = 6</code></li>
<li>加入优先队列：<code>pq = [(3, 2), (4, 2), (6, 3)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 2</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(3, 2)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>3</code>，更新距离：<ul>
<li><code>dist[3] = min(6, 3 + 3) = 6</code>（不变）</li>
</ul>
</li>
<li>这个节点不更新，不加入队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 3</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(6, 3)</code>。</li>
<li>遍历邻居节点：<ul>
<li>对于 <code>4</code>，更新距离：<ul>
<li><code>dist[4] = min(∞, 6 + 1) = 7</code></li>
<li>加入优先队列：<code>pq = [(7, 4)]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>处理节点 4</strong>：</p>
<ul>
<li>从优先队列中取出 <code>(7, 4)</code>。</li>
<li>节点 <code>4</code> 没有邻居节点，不再更新。</li>
</ul>
</li>
</ol>
<h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><ul>
<li><code>dist[0] = 0</code> (到自身)</li>
<li><code>dist[1] = 1</code> (通过边 <code>0 → 1</code>)</li>
<li><code>dist[2] = 3</code> (通过边 <code>0 → 1 → 2</code>)</li>
<li><code>dist[3] = 6</code> (通过边 <code>0 → 1 → 2 → 3</code>)</li>
<li><code>dist[4] = 7</code> (通过边 <code>0 → 1 → 2 → 3 → 4</code>)</li>
</ul>
<h2 id="对于一次性获得所有路径间的最小路径（包括负权）-可以用floyd算法"><a href="#对于一次性获得所有路径间的最小路径（包括负权）-可以用floyd算法" class="headerlink" title="对于一次性获得所有路径间的最小路径（包括负权）,可以用floyd算法"></a>对于一次性获得所有路径间的最小路径（包括负权）,可以用floyd算法</h2><p>下面是Floyd-Warshall算法的C++实现。该实现使用一个二维数组来表示图的邻接矩阵，并通过三重循环来更新所有节点对之间的最短路径。</p>
<h3 id="Floyd-Warshall-C-实现"><a href="#Floyd-Warshall-C-实现" class="headerlink" title="Floyd-Warshall C++ 实现"></a>Floyd-Warshall C++ 实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义无穷大，表示节点之间不可达</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Floyd-Warshall算法实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floydWarshall</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化距离矩阵</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dist = graph;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三重循环，逐个更新通过每个中间节点的路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">// 更新dist[i][j]，如果通过k节点可以缩短路径</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] &lt; INF &amp;&amp; dist[k][j] &lt; INF) &#123;</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终的最短路径矩阵</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The following matrix shows the shortest distances between every pair of vertices:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i][j] == INF)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;INF&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="comment">// 邻接矩阵表示的图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; graph = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">        &#123;INF, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, INF&#125;,</span><br><span class="line">        &#123;INF, INF, <span class="number">0</span>, <span class="number">3</span>, INF&#125;,</span><br><span class="line">        &#123;INF, INF, INF, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;INF, INF, INF, INF, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Floyd-Warshall算法</span></span><br><span class="line">    <span class="built_in">floydWarshall</span>(graph, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li><code>INF</code> 定义为一个非常大的数，用于表示节点之间不可达。这里用 <code>1e9</code> (即 $10^9$) 来表示。</li>
<li><code>graph</code> 是一个二维数组，表示图的邻接矩阵。</li>
</ul>
</li>
<li><p><strong>核心算法</strong>：</p>
<ul>
<li>三重循环遍历所有节点 <code>k</code>，<code>i</code> 和 <code>j</code>，其中 <code>k</code> 是中间节点。检查是否通过 <code>k</code> 作为中间节点可以使 <code>i</code> 到 <code>j</code> 的路径更短。</li>
<li>如果通过节点 <code>k</code> 可以使 <code>dist[i][j]</code> 更短，那么就更新 <code>dist[i][j]</code>。</li>
<li><code>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);</code> 这就是动态规划的更新公式。</li>
</ul>
</li>
<li><p><strong>输出结果</strong>：</p>
<ul>
<li>最终 <code>dist</code> 数组中保存了所有节点对之间的最短距离。</li>
<li>如果节点对不可达，显示 <code>INF</code>。</li>
</ul>
</li>
</ol>
<h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h3><p>对于上面的代码，输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following matrix shows the shortest distances between every pair of vertices:</span><br><span class="line">0   1   3   6   7   </span><br><span class="line">INF 0   2   5   6   </span><br><span class="line">INF INF 0   3   4   </span><br><span class="line">INF INF INF 0   1   </span><br><span class="line">INF INF INF INF 0   </span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>时间复杂度：$O(n^3)$，其中 $n$ 是图的节点数。</li>
<li>空间复杂度：$O(n^2)$，因为使用了二维数组存储距离矩阵。</li>
</ul>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>单源最短路径问题</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针与滑动窗口</title>
    <url>/2024/09/24/%E5%8F%8C%E6%8C%87%E9%92%88%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h1><p>题目：给定一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要<strong>原地</strong>移除所有数值等于 <code>val</code> 的元素.元素的顺序可以改变.然后返回数组中与 <code>val</code> 不同的元素的数量.</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，你需要执行以下操作：</p>
<ul>
<li>修改 <code>nums</code> 数组，使得 <code>nums</code> 的前 <code>k</code> 个元素包含所有不等于 <code>val</code> 的元素.</li>
<li>返回 <code>k</code> 的值.<code>nums</code> 中的其他元素和数组大小不重要.</li>
</ul>
<h1 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h1><h2 id="思路及算法："><a href="#思路及算法：" class="headerlink" title="思路及算法："></a>思路及算法：</h2><p>由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上.可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置.</p>
<p>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>
<p>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位.</p>
<p>整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val.当左右指针遍历完输入数组以后，left 的值就是输出数组的长度.</p>
<p>这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        for (int right = 0; right &lt; n; right++) &#123;</span><br><span class="line">            if (nums[right] != val) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 n 为序列的长度.我们只需要遍历该序列至多两次.</p>
<p>空间复杂度：O(1).我们只需要常数的空间保存若干变量.</p>
<h1 id="方法二：双指针优化"><a href="#方法二：双指针优化" class="headerlink" title="方法二：双指针优化"></a>方法二：双指针优化</h1><h2 id="思路与算法："><a href="#思路与算法：" class="headerlink" title="思路与算法："></a>思路与算法：</h2><p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位.注意到题目中说：「元素的顺序可以改变」.实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求.这个优化在序列中 val 元素的数量较少时非常有效.</p>
<p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列.</p>
<p>如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，然后右指针 right 左移一位.如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止.</p>
<p>当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素.</p>
<p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次.与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int left = 0, right = nums.size();</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            if (nums[left] == val) &#123;</span><br><span class="line">                nums[left] = nums[right - 1];</span><br><span class="line">                right--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n)，其中 n 为序列的长度.我们只需要遍历该序列至多一次.</p>
<p>空间复杂度：O(1).我们只需要常数的空间保存若干变量.</p>
<h1 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h1><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>.</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**.**如果不存在符合条件的子数组，返回 <code>0</code> .</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组.</span><br></pre></td></tr></table></figure>

<h1 id="方法一：暴力解法（会超时）"><a href="#方法一：暴力解法（会超时）" class="headerlink" title="方法一：暴力解法（会超时）"></a>方法一：暴力解法（会超时）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                if (sum &gt;= s) &#123;</span><br><span class="line">                    ans = min(ans, j - i + 1);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n的平方），其中 n 是数组的长度.需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组.</p>
<p>空间复杂度：O(1).</p>
<h1 id="方法二：前缀和-二分查找"><a href="#方法二：前缀和-二分查找" class="headerlink" title="方法二：前缀和 + 二分查找"></a>方法二：前缀和 + 二分查找</h1><p>方法一的时间复杂度是 O(n的平方)，因为在确定每个子数组的开始下标后，找到长度最小的子数组需要 O(n) 的时间.如果使用二分查找，则可以将时间优化到 O(logn).</p>
<p>为了使用二分查找，需要额外创建一个数组 sums 用于存储数组 nums 的前缀和，其中 sums[i] 表示从 nums[0] 到 nums[i−1] 的元素和.得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标 bound，使得 sums[bound]−sums[i−1]≥s，并更新子数组的最小长度（此时子数组的长度是 bound−(i−1)）.</p>
<p>因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性.如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了.</p>
<p>在很多语言中，都有现成的库和函数来为我们实现这里二分查找大于等于某个数的第一个位置的功能，比如 C++ 的 lower_bound.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = INT_MAX;</span><br><span class="line">        vector&lt;int&gt; sums(n + 1, 0); </span><br><span class="line">        // 为了方便计算，令 size = n + 1 </span><br><span class="line">        // sums[0] = 0 意味着前 0 个元素的前缀和为 0</span><br><span class="line">        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span><br><span class="line">        // 以此类推</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - 1] + nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int target = s + sums[i - 1];</span><br><span class="line">            auto bound = lower_bound(sums.begin(), sums.end(), target);</span><br><span class="line">            if (bound != sums.end()) &#123;</span><br><span class="line">                ans = min(ans, static_cast&lt;int&gt;((bound - sums.begin()) - (i - 1)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans == INT_MAX ? 0 : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="方法三：滑动窗口"><a href="#方法三：滑动窗口" class="headerlink" title="方法三：滑动窗口"></a>方法三：滑动窗口</h1><p>在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高.为了降低时间复杂度，可以使用滑动窗口的方法.</p>
<p>定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）.</p>
<p>初始状态下，start 和 end 都指向下标 0，sum 的值为 0.</p>
<p>每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum&lt;s，在此过程中同样更新子数组的最小长度.在每一轮迭代的最后，将 end 右移.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int result=100001;</span><br><span class="line">        int sum=0;</span><br><span class="line">        int i=0;</span><br><span class="line">        int subLength=0;</span><br><span class="line">        for(int j=0;j&lt;nums.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            while(sum&gt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">                subLength=j-i+1;</span><br><span class="line">                result=result&lt;subLength?result:subLength;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result==100001?0:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>数据结构与算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>可调用对象的绑定器和包装器</title>
    <url>/2025/01/12/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%E5%8C%85%E8%A3%85%E5%99%A8/</url>
    <content><![CDATA[<p>在 C++ 中，<strong>可调用对象的绑定器和包装器</strong>是用来简化或增强对函数（包括普通函数、成员函数、函数对象、Lambda 表达式等）的调用操作的工具。它们广泛用于泛型编程和 STL 算法中，以便将函数灵活地传递给算法或动态控制其行为。</p>
<hr>
<h2 id="1-可调用对象的绑定器"><a href="#1-可调用对象的绑定器" class="headerlink" title="1. 可调用对象的绑定器"></a><strong>1. 可调用对象的绑定器</strong></h2><p>绑定器的作用是<strong>将一个可调用对象的一部分参数提前绑定</strong>，从而生成一个新的可调用对象。</p>
<p>C++11 起引入了 <code>std::bind</code>，用于创建一个可调用对象并绑定部分参数；在现代 C++（C++20）中，更推荐使用 <strong>Lambda 表达式</strong> 替代 <code>std::bind</code>。</p>
<h3 id="1-1-std-bind"><a href="#1-1-std-bind" class="headerlink" title="1.1 std::bind"></a><strong>1.1 std::bind</strong></h3><p><code>std::bind</code> 是一个函数模板，它可以接受一个可调用对象（如普通函数、成员函数、函数对象等）及部分参数，并返回一个新的可调用对象，该对象可以像函数一样调用。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind 所在的头文件</span></span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">bind</span>(callable, arg1, arg2, ..., argN);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>callable</code>：要绑定的可调用对象。</li>
<li><code>arg1, arg2, ..., argN</code>：可调用对象的参数，其中可以使用占位符 <code>_1</code>, <code>_2</code>, … 来延迟绑定。</li>
</ul>
<p>占位符 <code>_1</code>, <code>_2</code>, … 来自头文件 <code>&lt;functional&gt;</code>，表示绑定时保留的参数位置。</p>
<hr>
<h4 id="例子-1：绑定普通函数"><a href="#例子-1：绑定普通函数" class="headerlink" title="例子 1：绑定普通函数"></a><strong>例子 1：绑定普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind, std::placeholders</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; <span class="comment">// 使用占位符 _1, _2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add_five = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, _1); <span class="comment">// 绑定第一个参数为 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_five</span>(<span class="number">10</span>) &lt;&lt; endl;          <span class="comment">// 输出 15（5 + 10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>std::bind(add, 5, _1)</code> 创建了一个新函数对象 <code>add_five</code>，它将 <code>add</code> 的第一个参数固定为 <code>5</code>，第二个参数保留动态输入。</li>
<li>调用 <code>add_five(10)</code> 等价于调用 <code>add(5, 10)</code>。</li>
</ul>
<hr>
<h4 id="例子-2：绑定成员函数"><a href="#例子-2：绑定成员函数" class="headerlink" title="例子 2：绑定成员函数"></a><strong>例子 2：绑定成员函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> bound_fn = std::<span class="built_in">bind</span>(&amp;MyClass::display, &amp;obj, _1); <span class="comment">// 绑定成员函数</span></span><br><span class="line">    <span class="built_in">bound_fn</span>(<span class="number">42</span>); <span class="comment">// 输出 Value: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>成员函数绑定时，需要提供对象指针（如 <code>&amp;obj</code>）作为隐式的 <code>this</code> 参数。</li>
<li><code>std::bind(&amp;MyClass::display, &amp;obj, _1)</code> 将成员函数的调用与对象绑定。</li>
</ul>
<hr>
<h3 id="1-2-替代-std-bind-的-Lambda-表达式"><a href="#1-2-替代-std-bind-的-Lambda-表达式" class="headerlink" title="1.2 替代 std::bind 的 Lambda 表达式"></a><strong>1.2 替代 std::bind 的 Lambda 表达式</strong></h3><p>在现代 C++ 中，Lambda 表达式更简洁，功能更强，因此可以用 Lambda 替代 <code>std::bind</code>。</p>
<p>以上绑定普通函数的例子，用 Lambda 表达式可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_five = [](<span class="type">int</span> b) &#123; <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">5</span>, b); &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add_five</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>

<p>绑定成员函数的例子，用 Lambda 表达式可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bound_fn = [&amp;obj](<span class="type">int</span> x) &#123; obj.<span class="built_in">display</span>(x); &#125;;</span><br><span class="line"><span class="built_in">bound_fn</span>(<span class="number">42</span>); <span class="comment">// 输出 Value: 42</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-可调用对象的包装器"><a href="#2-可调用对象的包装器" class="headerlink" title="2. 可调用对象的包装器"></a><strong>2. 可调用对象的包装器</strong></h2><p>包装器的作用是<strong>将一个可调用对象封装起来，允许在运行时管理其调用行为</strong>。</p>
<h3 id="2-1-std-function"><a href="#2-1-std-function" class="headerlink" title="2.1 std::function"></a><strong>2.1 std::function</strong></h3><p><code>std::function</code> 是一个通用的函数包装器，用来存储和调用任何符合特定签名的可调用对象。<br>它可以存储：</p>
<ul>
<li>普通函数</li>
<li>函数指针</li>
<li>成员函数指针</li>
<li>Lambda 表达式</li>
<li>仿函数</li>
</ul>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::function 所在的头文件</span></span></span><br><span class="line"></span><br><span class="line">std::function&lt;R(Args...)&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>R</code>：函数的返回类型。</li>
<li><code>Args...</code>：函数的参数类型列表。</li>
</ul>
<hr>
<h4 id="例子-1：包装普通函数"><a href="#例子-1：包装普通函数" class="headerlink" title="例子 1：包装普通函数"></a><strong>例子 1：包装普通函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::function</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add; <span class="comment">// 包装普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;              <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="例子-2：包装-Lambda-表达式"><a href="#例子-2：包装-Lambda-表达式" class="headerlink" title="例子 2：包装 Lambda 表达式"></a><strong>例子 2：包装 Lambda 表达式</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;; <span class="comment">// 包装 Lambda</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;                                            <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="例子-3：包装仿函数"><a href="#例子-3：包装仿函数" class="headerlink" title="例子 3：包装仿函数"></a><strong>例子 3：包装仿函数</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Multiply</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = <span class="built_in">Multiply</span>(); <span class="comment">// 包装仿函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">6</span>, <span class="number">7</span>) &lt;&lt; endl;                    <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-std-function-与-std-bind-配合使用"><a href="#2-2-std-function-与-std-bind-配合使用" class="headerlink" title="2.2 std::function 与 std::bind 配合使用"></a><strong>2.2 std::function 与 std::bind 配合使用</strong></h3><p><code>std::function</code> 可以与 <code>std::bind</code> 结合使用，将部分参数绑定后存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, _1); <span class="comment">// 绑定第一个参数为 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; endl;                             <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-std-function-的灵活性"><a href="#2-3-std-function-的灵活性" class="headerlink" title="2.3 std::function 的灵活性"></a><strong>2.3 std::function 的灵活性</strong></h3><p><code>std::function</code> 允许运行时动态更改存储的可调用对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func;</span><br><span class="line"></span><br><span class="line">    func = add; <span class="comment">// 动态存储 add</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 输出 15</span></span><br><span class="line"></span><br><span class="line">    func = subtract; <span class="comment">// 动态存储 subtract</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-区别与应用场景"><a href="#3-区别与应用场景" class="headerlink" title="3. 区别与应用场景"></a><strong>3. 区别与应用场景</strong></h2><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>std::bind</strong></th>
<th><strong>std::function</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>用于绑定函数的部分参数，生成新的可调用对象</td>
<td>用于包装函数，统一管理所有可调用对象</td>
</tr>
<tr>
<td><strong>参数绑定</strong></td>
<td>支持占位符 <code>_1</code>, <code>_2</code> 等</td>
<td>不支持参数绑定</td>
</tr>
<tr>
<td><strong>运行时动态性</strong></td>
<td>固定绑定时传入的函数和参数</td>
<td>可以运行时动态更改存储的可调用对象</td>
</tr>
<tr>
<td><strong>替代方案</strong></td>
<td>Lambda 表达式可以完全替代</td>
<td>无明显替代方案（功能独特）</td>
</tr>
</tbody></table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li>**<code>std::bind</code>**：用于将函数的部分参数提前绑定生成一个新的可调用对象，但在现代 C++ 中，通常使用更直观的 <strong>Lambda 表达式</strong> 代替。</li>
<li>**<code>std::function</code>**：是一个灵活的函数包装器，可以统一存储和调用各种可调用对象（普通函数、Lambda、仿函数等），适用于需要动态改变函数行为的场景。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>四种强制类型转换操作符</title>
    <url>/2024/11/25/%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p>在 C++ 中，有四种强制类型转换操作符，分别是：</p>
<ol>
<li><strong><code>static_cast</code></strong></li>
<li><strong><code>dynamic_cast</code></strong></li>
<li><strong><code>const_cast</code></strong></li>
<li><strong><code>reinterpret_cast</code></strong></li>
</ol>
<p>这四种类型转换都属于强制类型转换，它们的应用场景和功能有所不同。下面详细介绍每一种。</p>
<h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><code>static_cast</code> 用于在类型之间进行转换时，进行编译时类型检查。它适用于转换那些在语义上兼容的类型，例如基本数据类型、类之间的转换等。</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><ul>
<li><strong>类之间的转换</strong>（如父类和子类的转换）。</li>
<li><strong>基本数据类型之间的转换</strong>。</li>
<li><strong>指针类型之间的转换</strong>，当有继承关系时，可以转换指向基类的指针和指向派生类的指针。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Base* 转换为 Derived*，这里是安全的</span></span><br><span class="line">    Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 上行是通过 static_cast</span></span><br><span class="line">    d-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出 &quot;Derived&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x);  <span class="comment">// 基本数据类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="comment">// 输出 10.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>static_cast</code> 会进行类型检查，并且不允许不兼容的类型之间的转换。</li>
</ul>
<h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><code>dynamic_cast</code> 主要用于处理类层次结构中的指针或引用转换。它用于在类之间进行转换时，确保类型安全。<code>dynamic_cast</code> 在运行时进行类型检查，因此它适用于多态类型的转换（即包含虚函数的类）。</p>
<h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于处理继承体系中的转换，确保安全的类型转换。</li>
<li>可以用于将基类指针或引用转换为派生类指针或引用，前提是基类至少有一个虚函数（多态）。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// 错误的转换，d会为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">        d-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;  <span class="comment">// 输出 Conversion failed!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dynamic_cast</code> 在运行时检查类型，如果转换失败，返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。它主要用于确保在继承关系中指针或引用的类型转换安全。</li>
</ul>
<h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><code>const_cast</code> 用于修改对象的常量性。它允许去除或添加 <code>const</code> 限定符。常见的用途包括将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型，或者反之。</p>
<h4 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>去除 <code>const</code> 限定符：可以将 <code>const</code> 类型的指针或引用转换为非 <code>const</code> 类型。</li>
<li>添加 <code>const</code> 限定符：可以将非 <code>const</code> 类型的指针或引用转换为 <code>const</code> 类型。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 去除 const 限定符，允许修改对象</span></span><br><span class="line">    <span class="type">int</span>* modifiablePtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);</span><br><span class="line">    *modifiablePtr = <span class="number">20</span>;  <span class="comment">// 修改原对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除 const 限定符</span></span><br><span class="line">    <span class="built_in">modify</span>(ptr);  <span class="comment">// 此处会导致未定义行为</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 未定义行为，x值不可预测</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>警告</strong>：如果你去除 <code>const</code> 限定符并修改对象，该对象实际上可能是常量，修改它会导致未定义行为，因此这种转换应谨慎使用。</li>
</ul>
<h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><code>reinterpret_cast</code> 是最强大的类型转换操作符，它允许将一种类型的指针或引用转换为另一种完全不相关类型的指针或引用。它不进行任何类型检查，因此使用时必须非常小心。</p>
<h4 id="用法：-3"><a href="#用法：-3" class="headerlink" title="用法："></a>用法：</h4><ul>
<li>主要用于进行指针或引用之间的转换，即使它们在类型上没有任何继承关系。</li>
<li>可以将指针转换为整数类型，或将整数转换为指针类型。</li>
</ul>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> int_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pointer as integer: &quot;</span> &lt;&lt; int_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回指针</span></span><br><span class="line">    <span class="type">int</span>* new_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(int_ptr);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dereferenced pointer: &quot;</span> &lt;&lt; *new_ptr &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reinterpret_cast</code> 可以将指针转换为整数，或将整数转换为指针，甚至可以在没有任何类型关系的类型之间进行转换。使用时需要非常小心，因为它可以绕过编译器的类型检查。</li>
</ul>
<h3 id="总结：四种类型转换的对比"><a href="#总结：四种类型转换的对比" class="headerlink" title="总结：四种类型转换的对比"></a>总结：四种类型转换的对比</h3><table>
<thead>
<tr>
<th>转换操作符</th>
<th>适用场景</th>
<th>编译时检查</th>
<th>运行时检查</th>
<th>类型安全</th>
</tr>
</thead>
<tbody><tr>
<td><code>static_cast</code></td>
<td>基本类型转换，类之间的转换，指针之间的转换</td>
<td>是</td>
<td>否</td>
<td>高</td>
</tr>
<tr>
<td><code>dynamic_cast</code></td>
<td>类之间的安全转换，主要用于多态（继承）</td>
<td>是</td>
<td>是</td>
<td>高</td>
</tr>
<tr>
<td><code>const_cast</code></td>
<td>修改对象的常量性（去除或添加 <code>const</code> 限定符）</td>
<td>是</td>
<td>否</td>
<td>中</td>
</tr>
<tr>
<td><code>reinterpret_cast</code></td>
<td>强制转换，指针与整数之间的转换，指针之间的任意转换</td>
<td>否</td>
<td>否</td>
<td>低（非常危险）</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>static_cast</code></strong> 用于编译时类型安全转换，适合大多数常规类型转换。</li>
<li><strong><code>dynamic_cast</code></strong> 用于多态类型的安全转换，尤其是指针和引用之间的转换，支持运行时类型检查。</li>
<li><strong><code>const_cast</code></strong> 用于修改 <code>const</code> 限定符（添加或去除 <code>const</code>）。</li>
<li><strong><code>reinterpret_cast</code></strong> 用于底层转换，指针和整数之间的转换，不进行类型检查，需要小心使用。</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树的调整(左旋与右旋)</title>
    <url>/2024/10/30/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B0%83%E6%95%B4-%E5%B7%A6%E6%97%8B%E4%B8%8E%E5%8F%B3%E6%97%8B/</url>
    <content><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树（Balanced Binary Tree）是一种特殊的二叉树，它在结构上保持一定的平衡，以确保在最坏情况下依然具有较好的查找、插入和删除性能。</p>
<h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><p><strong>平衡</strong>的具体定义可以根据不同类型的平衡树略有不同。一般来说，一个二叉树是平衡的，当其任意节点的左右子树高度差的绝对值不超过某个特定值（通常是1）时。</p>
<h3 id="常见类型的平衡二叉树"><a href="#常见类型的平衡二叉树" class="headerlink" title="常见类型的平衡二叉树"></a>常见类型的平衡二叉树</h3><ol>
<li><p><strong>AVL树</strong>：</p>
<ul>
<li><p>每个节点的左右子树高度差（平衡因子）只允许为 -1、0 或 1。</p>
</li>
<li><p>在插入或删除节点后，如果导致不平衡，会通过旋转操作来恢复平衡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt; // 用于 std::max</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 节点结构</span><br><span class="line">struct Node &#123;</span><br><span class="line">    int key;       // 节点值</span><br><span class="line">    Node* left;    // 左子节点</span><br><span class="line">    Node* right;   // 右子节点</span><br><span class="line">    int height;    // 节点高度</span><br><span class="line"></span><br><span class="line">    Node(int k) : key(k), left(nullptr), right(nullptr), height(1) &#123;&#125; // 初始化节点</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 获取节点的高度</span><br><span class="line">int getHeight(Node* node) &#123;</span><br><span class="line">    return node ? node-&gt;height : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取平衡因子</span><br><span class="line">int getBalanceFactor(Node* node) &#123;</span><br><span class="line">    return node ? getHeight(node-&gt;left) - getHeight(node-&gt;right) : 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新节点的高度</span><br><span class="line">void updateHeight(Node* node) &#123;</span><br><span class="line">    node-&gt;height = max(getHeight(node-&gt;left), getHeight(node-&gt;right)) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 右旋操作</span><br><span class="line">Node* rightRotate(Node* y) &#123;</span><br><span class="line">    Node* x = y-&gt;left;</span><br><span class="line">    Node* T2 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">    // 右旋转</span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line"></span><br><span class="line">    // 更新高度</span><br><span class="line">    updateHeight(y);</span><br><span class="line">    updateHeight(x);</span><br><span class="line"></span><br><span class="line">    // 返回新的根节点</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 左旋操作</span><br><span class="line">Node* leftRotate(Node* x) &#123;</span><br><span class="line">    Node* y = x-&gt;right;</span><br><span class="line">    Node* T2 = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    // 左旋转</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;right = T2;</span><br><span class="line"></span><br><span class="line">    // 更新高度</span><br><span class="line">    updateHeight(x);</span><br><span class="line">    updateHeight(y);</span><br><span class="line"></span><br><span class="line">    // 返回新的根节点</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入节点并保持平衡</span><br><span class="line">Node* insert(Node* node, int key) &#123;</span><br><span class="line">    // 1. 标准的二叉搜索树插入</span><br><span class="line">    if (!node) return new Node(key);</span><br><span class="line"></span><br><span class="line">    if (key &lt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    &#125; else if (key &gt; node-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 不允许插入重复值</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 更新当前节点的高度</span><br><span class="line">    updateHeight(node);</span><br><span class="line"></span><br><span class="line">    // 3. 计算平衡因子</span><br><span class="line">    int balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">    // 4. 根据平衡因子进行相应的旋转操作</span><br><span class="line">    // 左左情况</span><br><span class="line">    if (balanceFactor &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        return rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右右情况</span><br><span class="line">    if (balanceFactor &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        return leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 左右情况</span><br><span class="line">    if (balanceFactor &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">        return rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 右左情况</span><br><span class="line">    if (balanceFactor &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">        return leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回不变的节点指针</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中序遍历树以显示结果</span><br><span class="line">void inOrder(Node* root) &#123;</span><br><span class="line">    if (root) &#123;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; root-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数测试AVL树</span><br><span class="line">int main() &#123;</span><br><span class="line">    Node* root = nullptr;</span><br><span class="line"></span><br><span class="line">    // 插入一些节点</span><br><span class="line">    root = insert(root, 10);</span><br><span class="line">    root = insert(root, 20);</span><br><span class="line">    root = insert(root, 30);</span><br><span class="line">    root = insert(root, 40);</span><br><span class="line">    root = insert(root, 50);</span><br><span class="line">    root = insert(root, 25);</span><br><span class="line"></span><br><span class="line">    // 中序遍历 AVL 树</span><br><span class="line">    cout &lt;&lt; &quot;中序遍历 AVL 树: &quot;;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>红黑树</strong>：</p>
<ul>
<li>是一种自平衡的二叉搜索树，每个节点都有一个颜色属性（红色或黑色），并遵循特定的颜色规则。</li>
<li>保证从根到叶的路径上的黑色节点数量相同，从而保持树的平衡性。</li>
</ul>
</li>
</ol>
<h3 id="平衡二叉树的特点"><a href="#平衡二叉树的特点" class="headerlink" title="平衡二叉树的特点"></a>平衡二叉树的特点</h3><ul>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li>查找、插入和删除操作的时间复杂度通常为 O(\log n)，这使得平衡二叉树非常高效，特别是在大量数据的情况下。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：</p>
<ul>
<li>平衡二叉树的空间复杂度为 O(n)，与普通的二叉树相同。</li>
</ul>
</li>
<li><p><strong>自我平衡</strong>：</p>
<ul>
<li>在插入或删除节点时，通过旋转和调整树的结构，保持树的平衡，从而避免退化成链表。</li>
</ul>
</li>
</ul>
<p> 旋转操作是平衡二叉树（如 AVL 树和红黑树）中的重要技术，用于在插入或删除节点后恢复树的平衡。旋转操作可以分为两种类型：左旋（Left Rotation）和右旋（Right Rotation）。以下是这两种旋转的详细介绍及其实现。</p>
<h1 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h1><p>首先注意，右旋（L）实际上是将树向左旋转，左旋则是将树向右旋转</p>
<h3 id="1-右旋（Right-Rotation）"><a href="#1-右旋（Right-Rotation）" class="headerlink" title="1. 右旋（Right Rotation）"></a>1. 右旋（Right Rotation）</h3><p>右旋操作是将某个节点（称为“失衡节点”）的左子节点提升为新的根节点，同时将失衡节点降为新根节点的右子节点。</p>
<h4 id="右旋的步骤"><a href="#右旋的步骤" class="headerlink" title="右旋的步骤"></a>右旋的步骤</h4><ol>
<li>设失衡节点为 <code>y</code>，其左子节点为 <code>x</code>。</li>
<li>将 <code>x</code> 的右子节点（如果存在）连接到 <code>y</code> 的左子节点。</li>
<li>将 <code>x</code> 提升为新的根节点。</li>
<li>将 <code>y</code> 设为 <code>x</code> 的右子节点。</li>
</ol>
<h4 id="右旋的伪代码"><a href="#右旋的伪代码" class="headerlink" title="右旋的伪代码"></a>右旋的伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="type">int</span> height; <span class="comment">// 用于 AVL 树的高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋操作</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">rightRotate</span><span class="params">(TreeNode* y)</span> </span>&#123;</span><br><span class="line">    TreeNode* x = y-&gt;left;           <span class="comment">// 让 x 指向 y 的左子节点</span></span><br><span class="line">    TreeNode* T2 = x-&gt;right;         <span class="comment">// 保存 x 的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    x-&gt;right = y;                    <span class="comment">// 将 y 设置为 x 的右子节点</span></span><br><span class="line">    y-&gt;left = T2;                    <span class="comment">// 将 T2 设置为 y 的左子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度（如果需要）</span></span><br><span class="line">    y-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-左旋（Left-Rotation）"><a href="#2-左旋（Left-Rotation）" class="headerlink" title="2. 左旋（Left Rotation）"></a>2. 左旋（Left Rotation）</h3><p>左旋操作是将某个节点的右子节点提升为新的根节点，同时将失衡节点降为新根节点的左子节点。</p>
<h4 id="左旋的步骤"><a href="#左旋的步骤" class="headerlink" title="左旋的步骤"></a>左旋的步骤</h4><ol>
<li>设失衡节点为 <code>x</code>，其右子节点为 <code>y</code>。</li>
<li>将 <code>y</code> 的左子节点（如果存在）连接到 <code>x</code> 的右子节点。</li>
<li>将 <code>y</code> 提升为新的根节点。</li>
<li>将 <code>x</code> 设为 <code>y</code> 的左子节点。</li>
</ol>
<h4 id="左旋的伪代码"><a href="#左旋的伪代码" class="headerlink" title="左旋的伪代码"></a>左旋的伪代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 左旋操作</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">leftRotate</span><span class="params">(TreeNode* x)</span> </span>&#123;</span><br><span class="line">    TreeNode* y = x-&gt;right;         <span class="comment">// 让 y 指向 x 的右子节点</span></span><br><span class="line">    TreeNode* T2 = y-&gt;left;         <span class="comment">// 保存 y 的左子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    y-&gt;left = x;                    <span class="comment">// 将 x 设置为 y 的左子节点</span></span><br><span class="line">    x-&gt;right = T2;                  <span class="comment">// 将 T2 设置为 x 的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新高度（如果需要）</span></span><br><span class="line">    x-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(x-&gt;left), <span class="built_in">height</span>(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    y-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(y-&gt;left), <span class="built_in">height</span>(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y; <span class="comment">// 返回新的根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-组合旋转"><a href="#3-组合旋转" class="headerlink" title="3. 组合旋转"></a>3. 组合旋转</h3><h4 id="AVL有且只有的四种情况（LL-LR-RL-RR）"><a href="#AVL有且只有的四种情况（LL-LR-RL-RR）" class="headerlink" title="AVL有且只有的四种情况（LL,LR,RL,RR）"></a>AVL有且只有的四种情况（LL,LR,RL,RR）</h4><p>图片来自<a href="https://blog.csdn.net/a6892255/article/details/117001282?ops_request_misc=%7B%22request_id%22:%22EBCFF1FE-F5C1-4776-B879-A508C09E98D5%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=EBCFF1FE-F5C1-4776-B879-A508C09E98D5&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117001282-null-null.142%5Ev100%5Epc_search_result_base8&utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B&spm=1018.2226.3001.4187">数据结构之AVL树(平衡二叉树)的理解_avl左右旋-CSDN博客</a></p>
<h4 id="1-LL"><a href="#1-LL" class="headerlink" title="1.LL"></a>1.LL</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/edea4edc378247e01a490437e164a51f.png" alt="LL"></p>
<h4 id="2-LR"><a href="#2-LR" class="headerlink" title="2.LR"></a>2.LR</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dc372fd873d281a3bb0b8a92eaae54fa.png" alt="LR(1)"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/30204ce4046bd0a9c2316159496d1886.png" alt="LR(2)"></p>
<h4 id="3-RL"><a href="#3-RL" class="headerlink" title="3.RL"></a>3.RL</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d60980e235068364f15691ef822690de.png" alt="RL(1)"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/084bc177d55d0797ab75c3caf6963405.png" alt="RL(2)"></p>
<h4 id="4-RR"><a href="#4-RR" class="headerlink" title="4.RR"></a>4.RR</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/60bb25e94471951b5602f0507a5b232c.png" alt="RR2"></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>指向常量的指针与常量指针</title>
    <url>/2024/11/17/%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>好久没有更新博客了，与最近考试多有关，也与个人怠惰有关</p>
<p>今天的内容是指向常量的指针（pointer to const）与指针常量（const pointer），这是昨天在阅读《c++ primer》中重新理解的内容，有了些许新的感悟，趁热打铁，发在博客上</p>
<h3 id="在讲那两个之前，先说一下const与对常量的引用（reference-to-const）"><a href="#在讲那两个之前，先说一下const与对常量的引用（reference-to-const）" class="headerlink" title="在讲那两个之前，先说一下const与对常量的引用（reference to const）"></a>在讲那两个之前，先说一下const与对常量的引用（reference to const）</h3><h4 id="const修饰词"><a href="#const修饰词" class="headerlink" title="const修饰词"></a>const修饰词</h4><p>使用const修饰词修饰的变量，即常量，是必须初始化的，且初始化后不能修改其值</p>
<p>初始化时除了用如下方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a=1;</span><br></pre></td></tr></table></figure>

<p>同样可以用非常量但同类型的值进行赋值（拷贝）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">const int b=a;</span><br><span class="line">a=b;</span><br></pre></td></tr></table></figure>

<p>const修饰的对象在编译时直接替换，类似define，即提前将所有出现其的位置替换成对应的数值，不申请额外空间</p>
<p>以下场景除外(都要等具体的值才能初始化)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a =fun();</span><br><span class="line">const int &amp;b=c;</span><br></pre></td></tr></table></figure>

<p>同时const对象仅在文件内部有效，要实现在一个文件中定义，在多个文件中声明并使用，要用extern 关键字修饰所有const对象</p>
<h4 id="对const的引用（常量引用）"><a href="#对const的引用（常量引用）" class="headerlink" title="对const的引用（常量引用）"></a>对const的引用（常量引用）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常量引用本身是常量，无法修改引用的对象</span><br><span class="line">const int a=1;</span><br><span class="line">const int b=2;</span><br><span class="line">const int &amp;r =a;</span><br><span class="line">r=b;//错误，不可修改</span><br><span class="line">r=2;//错误，不可修改</span><br></pre></td></tr></table></figure>

<p>常量引用不能改变引用的值（毕竟常量的值无法改变）</p>
<p>要对常量使用引用，也只能使用常量引用</p>
<h2 id="但是，常量引用可以引用非常量的同类型变量"><a href="#但是，常量引用可以引用非常量的同类型变量" class="headerlink" title="但是，常量引用可以引用非常量的同类型变量"></a>但是，常量引用可以引用非常量的同类型变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">const int &amp;r =i;//正确</span><br><span class="line"></span><br><span class="line">const int &amp;r2=r1*2;//正确</span><br><span class="line"></span><br><span class="line">i=4;//i不是常量，可以修改，同样会导致r的值变动</span><br></pre></td></tr></table></figure>

<p>这种场景经常出现，甚至比引用常量更多，主要应用场景在函数参数传递时，传递参数的常量引用，可以确保参数不被修改，同时避免拷贝的花销。</p>
<p>在接口等地方非常常见，可以参考《effective c++》中的建议</p>
<p>可以理解为常量引用引用的是一个临时常量，变量的值赋给了临时变量。</p>
<p>ok.到此为止，下面是指向常量的指针与常量指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line"></span><br><span class="line">常量指针</span><br><span class="line">int* const p1 = &amp;a;</span><br><span class="line">*p1 = 6;</span><br><span class="line">// const pointer,本身是个常量，不能改变指向的对象</span><br><span class="line">//只能指向变量，无法指向常量</span><br><span class="line">//如果指向的对象并非是常量，指向对象的值还是可以修改的</span><br><span class="line"></span><br><span class="line">指向常量的指针</span><br><span class="line">const int* p2 = &amp;a;</span><br><span class="line">p2 = &amp;b;//正确，pointer to const,本身不是常量，可以改变指向的对象</span><br><span class="line">*p2=3;//错误，无法通过这种方式修改指向的变量的值</span><br><span class="line">//类似常量引用，可以指向常量，也可以指向变量</span><br><span class="line"></span><br><span class="line">const int* const p3 = &amp;a;//指向常量的常量指针</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="顶层const与底层const"><a href="#顶层const与底层const" class="headerlink" title="顶层const与底层const"></a>顶层const与底层const</h3><p>顶层const表示其本身是常量，即常量和常量指针，无法修改其值（常量指针无法修改指向的对象，即地址，也就是其值）</p>
<p>底层const表示指向（引用）的对象是一个“常量”（常量或变量），无法修改指向（引用）对象的值，即常量引用和指向常量的指针等</p>
<p>拷贝时，两者区别非常明显</p>
<p>顶层const，可以随意赋给变量做值</p>
<p>底层const,不可以赋给变量做值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">const int *r1=a;</span><br><span class="line">int *const r2=a;</span><br><span class="line"></span><br><span class="line">int *p=r1;//错误，底层const无法赋值</span><br><span class="line">int *p=r2;//正确</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>指针</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2025/01/12/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><strong>智能指针</strong>是一种在编程中管理动态内存资源的对象。它封装了原始指针（raw pointer），并提供额外的功能，例如自动释放资源、避免内存泄漏和管理对象的生命周期。智能指针广泛用于需要动态分配内存的语言（如 C++），通过 RAII（Resource Acquisition Is Initialization）原则实现内存管理。</p>
<p>在 C++ 中，智能指针主要在 <strong><code>&lt;memory&gt;</code></strong> 头文件中定义，包括以下几种类型：</p>
<hr>
<h3 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1. std::unique_ptr"></a><strong>1. <code>std::unique_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>独占所有权（一个对象只能有一个 <code>unique_ptr</code> 拥有它）。</li>
<li>不可复制，但可以通过 <code>std::move</code> 转移所有权。</li>
<li>适合需要明确单一所有权的场景。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 创建智能指针</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;                      <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 离开作用域时，自动释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2. std::shared_ptr"></a><strong>2. <code>std::shared_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>共享所有权（多个智能指针可以共享同一个资源）。</li>
<li>通过引用计数管理资源生命周期，计数归零时释放资源。</li>
<li>使用场景：多个对象需要共享同一资源。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享同一资源</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl; <span class="comment">// 输出 42, 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 所有 `shared_ptr` 离开作用域时释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a><strong>3. <code>std::weak_ptr</code></strong></h3><ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>与 <code>shared_ptr</code> 配合使用，弱引用（不增加引用计数）。</li>
<li>用于解决循环引用问题（两个对象通过 <code>shared_ptr</code> 相互引用，导致资源无法释放）。</li>
<li>在访问资源前需要检查是否有效。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// 创建弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> locked = weak.<span class="built_in">lock</span>()) &#123; <span class="comment">// 检查资源是否有效</span></span><br><span class="line">        std::cout &lt;&lt; *locked &lt;&lt; std::endl; <span class="comment">// 输出 42</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 资源离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ol>
<li><strong>避免内存泄漏</strong>：智能指针会自动释放资源，无需手动调用 <code>delete</code>。</li>
<li><strong>安全性</strong>：通过封装原始指针，减少指针操作中的错误（如悬空指针、重复释放）。</li>
<li><strong>易于使用</strong>：支持语义清晰的接口和自动管理生命周期。</li>
</ol>
<hr>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><ol>
<li>引入了额外的内存开销（如 <code>shared_ptr</code> 的引用计数）。</li>
<li>需要注意循环引用问题（可通过 <code>weak_ptr</code> 避免）。</li>
<li>不适用于所有场景，例如实时性能要求特别高的代码。</li>
</ol>
<hr>
<h3 id="智能指针-vs-原始指针"><a href="#智能指针-vs-原始指针" class="headerlink" title="智能指针 vs 原始指针"></a><strong>智能指针 vs 原始指针</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>智能指针</strong></th>
<th><strong>原始指针</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存管理</strong></td>
<td>自动释放</td>
<td>手动释放</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>更安全（防止悬空指针等问题）</td>
<td>容易出错</td>
</tr>
<tr>
<td><strong>使用复杂度</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>略有开销（如引用计数）</td>
<td>无开销</td>
</tr>
</tbody></table>
<p>智能指针在现代 C++ 中被广泛使用，是 C++11 引入的重要功能之一，极大地提高了代码的安全性和可维护性。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树:Prim 算法和Kruskal 算法</title>
    <url>/2024/10/16/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim-%E7%AE%97%E6%B3%95%E5%92%8CKruskal-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在 C++ 中，实现最小生成树（MST）的常用算法有两种：<strong>Prim 算法</strong>和<strong>Kruskal 算法</strong>。这两种算法适用于加权无向图，用于寻找包含所有顶点的边的集合，使得边的总权重最小，且没有环路。</p>
<h3 id="1-Prim-算法"><a href="#1-Prim-算法" class="headerlink" title="1. Prim 算法"></a>1. Prim 算法</h3><p>Prim 算法通过贪心策略来构建 MST，从任意起始顶点开始，每次选择权重最小的边扩展 MST。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>初始化一个集合 <code>MST</code>，包含图中的任意一个顶点。</li>
<li>找到从集合 <code>MST</code> 到剩余顶点中权重最小的边，并将该边加入 <code>MST</code>。</li>
<li>重复步骤 2，直到所有顶点都包含在 <code>MST</code> 中。</li>
</ol>
<h4 id="C-实现示例（使用优先队列）"><a href="#C-实现示例（使用优先队列）" class="headerlink" title="C++ 实现示例（使用优先队列）"></a>C++ 实现示例（使用优先队列）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来表示边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Prim 算法计算最小生成树的总权重</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">primMST</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();  <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inMST</span><span class="params">(n, <span class="literal">false</span>)</span></span>;  <span class="comment">// 标记顶点是否在 MST 中</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;  <span class="comment">// 最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, start&#125;);  <span class="comment">// 起始顶点的权重为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [weight, u] = pq.<span class="built_in">top</span>();  <span class="comment">// 获取权重最小的边</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inMST[u]) <span class="keyword">continue</span>;  <span class="comment">// 如果已经在 MST 中，跳过</span></span><br><span class="line"></span><br><span class="line">        inMST[u] = <span class="literal">true</span>;  <span class="comment">// 标记顶点 u 在 MST 中</span></span><br><span class="line">        totalWeight += weight;  <span class="comment">// 累加边的权重</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 u 的所有邻接边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : graph[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = edge.to;</span><br><span class="line">            <span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!inMST[v]) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;w, v&#125;);  <span class="comment">// 将未加入 MST 的顶点及其权重放入优先队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个无向加权图</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;  <span class="comment">// 图中顶点数</span></span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    graph[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    graph[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line">    graph[<span class="number">4</span>].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点 0 开始计算最小生成树的总权重</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="built_in">primMST</span>(graph, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><ul>
<li><code>graph</code> 是一个邻接表，每个顶点的邻接边存储在一个 <code>vector</code> 中。</li>
<li><code>priority_queue</code> 用于选择当前权重最小的边。</li>
<li><code>inMST</code> 数组用于标记哪些顶点已经在 MST 中。</li>
<li>算法的时间复杂度为 (O(E \log V))，其中 (E) 是边数，(V) 是顶点数。</li>
</ul>
<h3 id="2-Kruskal-算法"><a href="#2-Kruskal-算法" class="headerlink" title="2. Kruskal 算法"></a>2. Kruskal 算法</h3><p>Kruskal 算法通过贪心策略来构建 MST，每次选择权重最小的边，添加到 MST 中，前提是不会形成环。</p>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>将图中的所有边按权重从小到大排序。</li>
<li>初始化一个并查集，用于判断是否会形成环。</li>
<li>依次选择权重最小的边，如果该边连接的两个顶点属于不同的集合，则将其加入 MST。</li>
<li>重复步骤 3，直到 MST 包含 (V-1) 条边。</li>
</ol>
<h4 id="C-实现示例（使用并查集）"><a href="#C-实现示例（使用并查集）" class="headerlink" title="C++ 实现示例（使用并查集）"></a>C++ 实现示例（使用并查集）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体来表示边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, weight;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">from</span>(f), <span class="built_in">to</span>(t), <span class="built_in">weight</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent, rank;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) : <span class="built_in">parent</span>(n), <span class="built_in">rank</span>(n, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u != parent[u]) &#123;</span><br><span class="line">            parent[u] = <span class="built_in">find</span>(parent[u]);  <span class="comment">// 路径压缩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootU = <span class="built_in">find</span>(u);</span><br><span class="line">        <span class="type">int</span> rootV = <span class="built_in">find</span>(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootU == rootV) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// u 和 v 在同一个集合中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 联合集合，按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootU] &gt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootU] &lt; rank[rootV]) &#123;</span><br><span class="line">            parent[rootU] = rootV;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootV] = rootU;</span><br><span class="line">            ++rank[rootU];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Kruskal 算法计算最小生成树的总权重</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskalMST</span><span class="params">(<span class="type">int</span> n, vector&lt;Edge&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将边按权重从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [](<span class="type">const</span> Edge&amp; a, <span class="type">const</span> Edge&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &lt; b.weight;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;  <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> edgesUsed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">unionSets</span>(edge.from, edge.to)) &#123;</span><br><span class="line">            totalWeight += edge.weight;</span><br><span class="line">            edgesUsed++;</span><br><span class="line">            <span class="keyword">if</span> (edgesUsed == n - <span class="number">1</span>) <span class="keyword">break</span>;  <span class="comment">// 当使用的边数达到 n-1 时，停止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;  <span class="comment">// 图中顶点数</span></span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最小生成树的总权重</span></span><br><span class="line">    <span class="type">int</span> totalWeight = <span class="built_in">kruskalMST</span>(n, edges);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum Spanning Tree Total Weight: &quot;</span> &lt;&lt; totalWeight &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h4><ul>
<li>使用 <code>Edge</code> 结构体来表示边，包括起点、终点和权重。</li>
<li>使用 <code>UnionFind</code> 类来实现并查集，用于检测是否形成环。</li>
<li>将所有边按权重排序，然后使用贪心算法构建 MST。</li>
<li>算法的时间复杂度为 (O(E \log E))，因为排序耗时 (O(E \log E))，而并查集的操作近似为 (O(\log V))。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Prim 算法</strong>适用于稠密图（边多），通常使用邻接表和优先队列实现。</li>
<li><strong>Kruskal 算法</strong>适用于稀疏图（边少），通过边排序和并查集来实现。</li>
</ul>
<p>这两种算法都能高效地找到图的最小生成树，但适用的场景略有不同。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>最小生成树</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/2024/10/09/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>米娜桑好久不见，国庆期间没有更新博客，属实有点摆烂</p>
<p>今天我们的主题是树与二叉树的转换，以及树的储存方法，遍历方法与二叉树的区别等</p>
<p>首先，我们要明白的是，树可以有多个子节点，而二叉树最多只有两个，所以二叉树是特殊的树</p>
<h1 id="一-树的存储与转换"><a href="#一-树的存储与转换" class="headerlink" title="一.树的存储与转换"></a>一.树的存储与转换</h1><h3 id="1-父亲表示法（双亲表示法）"><a href="#1-父亲表示法（双亲表示法）" class="headerlink" title="1.父亲表示法（双亲表示法）"></a>1.<strong>父亲表示法</strong>（双亲表示法）</h3><ul>
<li><p>使用一个数组来存储每个节点，其中每个节点只包含一个指针（或索引），指向其父节点。这种表示法的缺点是无法快速找到子节点，但优点是节省了存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;</span><br><span class="line">    int parentIndex; // 指向父节点在数组中的索引</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-孩子链表表示法"><a href="#2-孩子链表表示法" class="headerlink" title="2.孩子链表表示法"></a>2.<strong>孩子链表表示法</strong></h3><ul>
<li><p>使用一个数组来存储每个节点，每个节点包含一个链表，链表中的每个节点指向该节点的子节点。这样，查找子节点的时间较快，但会增加空间开销。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 孩子链表中的节点</span><br><span class="line">struct ChildNode &#123;</span><br><span class="line">    int childIndex;        // 子节点的索引（或指针）</span><br><span class="line">    ChildNode* next;       // 指向下一个子节点的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 树的节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;              // 数据域，存储该节点的值</span><br><span class="line">    ChildNode* childList;  // 指向孩子链表的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（1）孩子链表表示法的特点"><a href="#（1）孩子链表表示法的特点" class="headerlink" title="（1）孩子链表表示法的特点"></a>（1）<strong>孩子链表表示法的特点</strong></h5><ol>
<li><strong>灵活性</strong>：<ul>
<li>每个节点的子节点数量不受限制，子节点数量可以动态扩展，因此这种表示法适合<strong>多叉树</strong>（即节点可以有多个子节点的树）。</li>
</ul>
</li>
<li><strong>存储空间</strong>：<ul>
<li>每个节点只存储一个指向其孩子链表的指针，而不是为所有可能的子节点预留空间，因此相比顺序存储更加节省空间，特别适合子节点数量较不确定的树结构。</li>
</ul>
</li>
<li><strong>节点操作</strong>：<ul>
<li><strong>插入节点</strong>：插入新子节点只需要在孩子链表的末尾添加一个节点，操作比较简单。</li>
<li><strong>删除节点</strong>：删除某个子节点时，只需要从孩子链表中移除相应的节点，但需要额外处理该子节点的所有子节点。</li>
<li><strong>查找子节点</strong>：查找某个节点的子节点时，需要遍历该节点的孩子链表，这可能导致查找子节点的效率较低。</li>
</ul>
</li>
</ol>
<h5 id="（2）孩子链表表示法的示例"><a href="#（2）孩子链表表示法的示例" class="headerlink" title="（2）孩子链表表示法的示例"></a>（2）<strong>孩子链表表示法的示例</strong></h5><p>假设有如下树结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line"> / | \</span><br><span class="line">2  3  4</span><br><span class="line">  / \</span><br><span class="line"> 5   6</span><br></pre></td></tr></table></figure>

<p>对应的孩子链表表示法如下：</p>
<ul>
<li>节点 1 的孩子链表指向节点 2、3 和 4。</li>
<li>节点 3 的孩子链表指向节点 5 和 6。</li>
</ul>
<p>图解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeNode(1) -&gt; ChildList -&gt; [TreeNode(2)] -&gt; [TreeNode(3)] -&gt; [TreeNode(4)] -&gt; NULL</span><br><span class="line">TreeNode(3) -&gt; ChildList -&gt; [TreeNode(5)] -&gt; [TreeNode(6)] -&gt; NULL</span><br></pre></td></tr></table></figure>

<p>对应的代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义孩子链表中的节点</span><br><span class="line">struct ChildNode &#123;</span><br><span class="line">    int childIndex;         // 孩子的索引或指针</span><br><span class="line">    ChildNode* next;        // 下一个孩子的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义树的节点</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int data;               // 节点的值</span><br><span class="line">    ChildNode* childList;   // 孩子链表的头指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 示例：创建节点和孩子链表</span><br><span class="line">TreeNode node1, node2, node3, node4, node5, node6;</span><br><span class="line">node1.data = 1;</span><br><span class="line">node2.data = 2;</span><br><span class="line">node3.data = 3;</span><br><span class="line">node4.data = 4;</span><br><span class="line">node5.data = 5;</span><br><span class="line">node6.data = 6;</span><br><span class="line"></span><br><span class="line">// 为节点1创建孩子链表</span><br><span class="line">ChildNode* child1 = new ChildNode&#123;2, NULL&#125;;  // 指向节点2</span><br><span class="line">ChildNode* child2 = new ChildNode&#123;3, NULL&#125;;  // 指向节点3</span><br><span class="line">ChildNode* child3 = new ChildNode&#123;4, NULL&#125;;  // 指向节点4</span><br><span class="line"></span><br><span class="line">child1-&gt;next = child2;</span><br><span class="line">child2-&gt;next = child3;</span><br><span class="line">node1.childList = child1;  // 节点1的孩子链表</span><br><span class="line"></span><br><span class="line">// 为节点3创建孩子链表</span><br><span class="line">ChildNode* child5 = new ChildNode&#123;5, NULL&#125;;  // 指向节点5</span><br><span class="line">ChildNode* child6 = new ChildNode&#123;6, NULL&#125;;  // 指向节点6</span><br><span class="line">child5-&gt;next = child6;</span><br><span class="line">node3.childList = child5;  // 节点3的孩子链表</span><br></pre></td></tr></table></figure>

<h3 id="3-孩子兄弟表示法"><a href="#3-孩子兄弟表示法" class="headerlink" title="3.孩子兄弟表示法"></a>3.孩子兄弟表示法</h3><p>在树结构中，<strong>孩子</strong>和<strong>兄弟</strong>是指节点之间的一种关系：</p>
<h5 id="孩子（Child）："><a href="#孩子（Child）：" class="headerlink" title="孩子（Child）："></a><strong>孩子（Child）</strong>：</h5><ul>
<li><strong>孩子节点</strong>是指某个节点的直接下级节点。</li>
<li>如果一个节点有若干子节点，这些子节点就是它的孩子。</li>
<li>每个树节点可以有0个、1个或多个孩子。</li>
</ul>
<h5 id="兄弟（Sibling）："><a href="#兄弟（Sibling）：" class="headerlink" title="兄弟（Sibling）："></a><strong>兄弟（Sibling）</strong>：</h5><ul>
<li><strong>兄弟节点</strong>是指同一个父节点的多个子节点之间的关系。</li>
<li>如果两个或多个节点有相同的父节点，这些节点互为兄弟。</li>
</ul>
<h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>孩子兄弟表示法，是以左孩子的形式存储最左边的孩子，以右孩子的形式存储第一个右兄弟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义多叉树节点结构</span><br><span class="line">struct MultiTreeNode &#123;</span><br><span class="line">    int data;                    // 数据域</span><br><span class="line">    vector&lt;MultiTreeNode*&gt; children; // 子节点列表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 定义二叉树节点结构</span><br><span class="line">struct BinaryTreeNode &#123;</span><br><span class="line">    int data;                    // 数据域</span><br><span class="line">    BinaryTreeNode* left;        // 左子节点，表示第一个子节点</span><br><span class="line">    BinaryTreeNode* right;       // 右子节点，表示兄弟节点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这样的形式将树以二叉树的形式存储了起来，进而实现了树向二叉树的转换</p>
<h4 id="转换步骤："><a href="#转换步骤：" class="headerlink" title="转换步骤："></a><strong>转换步骤</strong>：</h4><ol>
<li><strong>保持第一个子节点为左孩子</strong>：<ul>
<li>在多叉树中，某个节点的第一个子节点转换为二叉树中的左孩子。</li>
</ul>
</li>
<li><strong>其他子节点变为右兄弟</strong>：<ul>
<li>在多叉树中，该节点的第二个及以后的子节点依次作为第一个子节点的右兄弟节点。</li>
</ul>
</li>
<li><strong>兄弟之间的关系通过右子节点表示</strong>：<ul>
<li>在二叉树中，右子节点用来表示多叉树中的兄弟节点。</li>
</ul>
</li>
</ol>
<h4 id="转换示意图"><a href="#转换示意图" class="headerlink" title="转换示意图"></a><strong>转换示意图</strong></h4><p>假设有如下的多叉树结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     A</span><br><span class="line">   / | \</span><br><span class="line">  B  C  D</span><br><span class="line"> / \</span><br><span class="line">E   F</span><br></pre></td></tr></table></figure>

<p>转换成二叉树的步骤如下：</p>
<ol>
<li>节点 <code>A</code> 的第一个子节点 <code>B</code> 作为 <code>A</code> 的左孩子，<code>C</code> 和 <code>D</code> 作为 <code>B</code> 的右兄弟。</li>
<li>节点 <code>B</code> 的第一个子节点 <code>E</code> 作为 <code>B</code> 的左孩子，<code>F</code> 作为 <code>E</code> 的右兄弟。</li>
</ol>
<p>转换成二叉树后的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    A</span><br><span class="line">   /</span><br><span class="line">  B</span><br><span class="line"> / \</span><br><span class="line">E   C</span><br><span class="line"> \   \</span><br><span class="line">  F   D</span><br></pre></td></tr></table></figure>

<p>可以看到，在转换后的二叉树中：</p>
<ul>
<li><p>原来多叉树中节点 <code>A</code> 的子节点 <code>B、C、D</code> 被通过左孩子和右兄弟关系串联在一起。</p>
</li>
<li><p>原来节点 <code>B</code> 的子节点 <code>E、F</code> 也通过相同的方式连接。</p>
<p>  &#x2F;&#x2F; 多叉树转二叉树的递归转换函数<br>  BinaryTreeNode* convertToBinaryTree(MultiTreeNode* root)<br>  {<br>  if (root &#x3D;&#x3D; nullptr) return nullptr;<br>  &#x2F;&#x2F; 创建对应的二叉树节点<br>  BinaryTreeNode* newNode &#x3D; new BinaryTreeNode();<br>  newNode-&gt;data &#x3D; root-&gt;data;<br>  newNode-&gt;left &#x3D; nullptr;<br>  newNode-&gt;right &#x3D; nullptr;</p>
<p>  if (!root-&gt;children.empty())<br>  {<br>  &#x2F;&#x2F; 将第一个孩子作为左子树<br>  newNode-&gt;left &#x3D; convertToBinaryTree(root-&gt;children[0]);<br><br>  &#x2F;&#x2F; 将其他孩子作为兄弟通过右子树连接<br>  BinaryTreeNode* current &#x3D; newNode-&gt;left;<br>  for (size_t i &#x3D; 1; i &lt; root-&gt;children.size(); ++i)<br>  {<br>      current-&gt;right &#x3D; convertToBinaryTree(root-&gt;children[i]);<br>      current &#x3D; current-&gt;right;<br>  }<br>  }</p>
<p>  return newNode;<br>  }</p>
</li>
</ul>
<h3 id="4-森林与二叉树的转换"><a href="#4-森林与二叉树的转换" class="headerlink" title="4.森林与二叉树的转换"></a>4.森林与二叉树的转换</h3><p>将森林中的每棵树都转换成二叉树</p>
<p>然后从第二棵树开始，每棵树的根节点都是前一棵树的根节点的兄弟</p>
<h1 id="二-树和森林的遍历"><a href="#二-树和森林的遍历" class="headerlink" title="二.树和森林的遍历"></a>二.树和森林的遍历</h1><h3 id="1-树的遍历"><a href="#1-树的遍历" class="headerlink" title="1.树的遍历"></a>1.树的遍历</h3><p>树的前序遍历和其转换成的二叉树的前序遍历相同</p>
<p>树的后序遍历与其转换成的二叉树的中序遍历相同</p>
<h5 id="树的中序遍历"><a href="#树的中序遍历" class="headerlink" title="树的中序遍历"></a>树的中序遍历</h5><p>中序遍历树最左边的孩子，访问根节点，再依次访问中序遍历其他孩子</p>
<h3 id="2-森林的遍历：依次遍历每棵树"><a href="#2-森林的遍历：依次遍历每棵树" class="headerlink" title="2.森林的遍历：依次遍历每棵树"></a>2.森林的遍历：依次遍历每棵树</h3>]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>树</tag>
        <tag>链表</tag>
        <tag>森林</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2025/01/12/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="模板（Template）概述"><a href="#模板（Template）概述" class="headerlink" title="模板（Template）概述"></a><strong>模板（Template）概述</strong></h3><p>模板是 C++ 中的一种<strong>泛型编程机制</strong>，允许编写通用的代码，可以在不指定具体数据类型的情况下定义函数、类或结构体。模板的主要目的是提供代码的复用性和灵活性，从而支持处理多种数据类型的能力。</p>
<p>C++ 中的模板主要分为两种：</p>
<ol>
<li><strong>函数模板</strong>（Function Template）</li>
<li><strong>类模板</strong>（Class Template）</li>
</ol>
<hr>
<h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a><strong>1. 函数模板</strong></h2><p>函数模板是定义一个可以操作多种数据类型的函数。通过模板，函数可以在调用时根据传递的参数类型自动生成具体的函数。</p>
<h3 id="1-1-函数模板的基本语法"><a href="#1-1-函数模板的基本语法" class="headerlink" title="1.1 函数模板的基本语法"></a><strong>1.1 函数模板的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;    <span class="comment">// 显式指定类型为 int</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">4.2</span>) &lt;&lt; endl;    <span class="comment">// 隐式推导类型为 double</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">7.7</span><br></pre></td></tr></table></figure>

<h3 id="1-2-关键点"><a href="#1-2-关键点" class="headerlink" title="1.2 关键点"></a><strong>1.2 关键点</strong></h3><ul>
<li><code>template &lt;typename T&gt;</code>：定义模板，其中 <code>T</code> 是占位符，表示数据类型。<ul>
<li>也可以使用 <code>class</code> 代替 <code>typename</code>（两者在模板声明中等价）。</li>
</ul>
</li>
<li>模板函数的具体类型可以<strong>显式指定</strong>（如 <code>add&lt;int&gt;(3, 4)</code>），也可以通过参数<strong>隐式推导</strong>（如 <code>add(3.5, 4.2)</code>）。</li>
</ul>
<hr>
<h3 id="1-3-函数模板的特例化"><a href="#1-3-函数模板的特例化" class="headerlink" title="1.3 函数模板的特例化"></a><strong>1.3 函数模板的特例化</strong></h3><p>有时我们希望对某些特定类型提供专门的实现，可以通过模板特例化实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例化版本（针对 const char* 类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="built_in">max</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>) ? a : b; <span class="comment">// 字符串比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; endl;             <span class="comment">// 输出 7</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>) &lt;&lt; endl; <span class="comment">// 输出 banana</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>特例化版本定义了针对 <code>const char*</code> 类型的专门实现。</li>
<li>当模板匹配到 <code>const char*</code> 类型时，会优先使用特例化版本。</li>
</ul>
<hr>
<h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2. 类模板"></a><strong>2. 类模板</strong></h2><p>类模板是为实现通用的类而设计的，允许类操作不同类型的数据而不需要重复编写代码。</p>
<h3 id="2-1-类模板的基本语法"><a href="#2-1-类模板的基本语法" class="headerlink" title="2.1 类模板的基本语法"></a><strong>2.1 类模板的基本语法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;      <span class="comment">// int 类型</span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">obj2</span><span class="params">(<span class="number">3.14</span>)</span></span>; <span class="comment">// double 类型</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Value: 10</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Value: 3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>template &lt;typename T&gt;</code> 定义了一个类模板。</li>
<li>模板类实例化时，需要为模板参数 <code>T</code> 提供具体类型，如 <code>MyClass&lt;int&gt;</code>。</li>
</ul>
<hr>
<h3 id="2-2-类模板的特例化"><a href="#2-2-类模板的特例化" class="headerlink" title="2.2 类模板的特例化"></a><strong>2.2 类模板的特例化</strong></h3><p>和函数模板一样，类模板也可以为某些特定类型提供特例化实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Generic template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例化版本（针对 int 类型）</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Specialized template for int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj1; <span class="comment">// 使用通用模板</span></span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj2;    <span class="comment">// 使用特例化模板</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Generic template</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Specialized template for int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>通用模板适用于所有类型，但当实例化类型为 <code>int</code> 时，会使用特例化版本。</li>
</ul>
<hr>
<h3 id="2-3-类模板的部分特例化"><a href="#2-3-类模板的部分特例化" class="headerlink" title="2.3 类模板的部分特例化"></a><strong>2.3 类模板的部分特例化</strong></h3><p>类模板还支持<strong>部分特例化</strong>，即只对部分模板参数进行特例化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Generic template&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分特例化（当第二个类型参数是 int 时）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Partial specialization for second type int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">double</span>&gt; obj1; <span class="comment">// 通用模板</span></span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">int</span>&gt; obj2;   <span class="comment">// 部分特例化模板</span></span><br><span class="line"></span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Generic template</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Partial specialization for second type int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>部分特例化可以只针对某些类型参数组合，提供更灵活的设计。</li>
</ul>
<hr>
<h2 id="3-模板的其他用法"><a href="#3-模板的其他用法" class="headerlink" title="3. 模板的其他用法"></a><strong>3. 模板的其他用法</strong></h2><h3 id="3-1-模板默认参数"><a href="#3-1-模板默认参数" class="headerlink" title="3.1 模板默认参数"></a><strong>3.1 模板默认参数</strong></h3><p>模板参数可以提供默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">display</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;&gt; obj;       <span class="comment">// 使用默认类型 int</span></span><br><span class="line">    MyClass&lt;<span class="type">double</span>&gt; obj2; <span class="comment">// 显式指定类型为 double</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">display</span>();  <span class="comment">// 输出 Type: int</span></span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">display</span>(); <span class="comment">// 输出 Type: double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-模板模板参数"><a href="#3-2-模板模板参数" class="headerlink" title="3.2 模板模板参数"></a><strong>3.2 模板模板参数</strong></h3><p>模板参数本身可以是模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Container&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : c) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass&lt;vector&gt; obj; <span class="comment">// 使用 vector 作为模板模板参数</span></span><br><span class="line">    obj.<span class="built_in">display</span>();       <span class="comment">// 输出 1 2 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>template &lt;template &lt;typename, typename&gt; class Container&gt;</code> 定义了模板模板参数。</li>
<li>实例化时，<code>vector</code> 作为模板模板参数被传递。</li>
</ul>
<hr>
<h2 id="4-编译期计算与模板"><a href="#4-编译期计算与模板" class="headerlink" title="4. 编译期计算与模板"></a><strong>4. 编译期计算与模板</strong></h2><p>模板可以用于<strong>编译期计算</strong>，例如实现递归的斐波那契数列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Fibonacci&lt;<span class="number">10</span>&gt;::value &lt;&lt; endl; <span class="comment">// 输出 55</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>模板通过递归定义实现了编译期的斐波那契数列计算。</li>
<li><code>Fibonacci&lt;10&gt;</code> 会在编译时计算出结果。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>模板是 C++ 强大的泛型编程工具，其主要特点包括：</p>
<ol>
<li><strong>函数模板</strong> 和 <strong>类模板</strong>。</li>
<li>支持特例化（全特例化和部分特例化）。</li>
<li>提供了编译期计算能力。</li>
<li>与 STL 紧密结合，广泛用于算法和容器中。</li>
</ol>
<p>模板大大提高了代码的复用性和通用性，但模板的编译错误通常比较复杂，因此需要小心使用。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树及其遍历</title>
    <url>/2024/09/25/%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h1><h3 id="以下是实现该结构并进行中序遍历的代码："><a href="#以下是实现该结构并进行中序遍历的代码：" class="headerlink" title="以下是实现该结构并进行中序遍历的代码："></a>以下是实现该结构并进行中序遍历的代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义线索二叉树节点的结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;                      <span class="comment">// 节点的值</span></span><br><span class="line">    ThreadedNode* left;             <span class="comment">// 指向左子节点</span></span><br><span class="line">    ThreadedNode* right;            <span class="comment">// 指向右子节点</span></span><br><span class="line">    <span class="type">bool</span> lThread;                   <span class="comment">// 左指针是否为线索</span></span><br><span class="line">    <span class="type">bool</span> rThread;                   <span class="comment">// 右指针是否为线索</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化节点值，并将左右指针初始化为空，线索标志初始化为 false</span></span><br><span class="line">    <span class="built_in">ThreadedNode</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">lThread</span>(<span class="literal">false</span>), <span class="built_in">rThread</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点并构建线索二叉树的函数</span></span><br><span class="line"><span class="function">ThreadedNode* <span class="title">insert</span><span class="params">(ThreadedNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新节点</span></span><br><span class="line">    ThreadedNode* newNode = <span class="keyword">new</span> <span class="built_in">ThreadedNode</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树为空，直接返回新节点作为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `current` 用于跟踪当前节点，`parent` 用于跟踪当前节点的父节点</span></span><br><span class="line">    ThreadedNode* current = root;</span><br><span class="line">    ThreadedNode* parent = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要插入的位置</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        parent = current;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入左子树</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; current-&gt;value) &#123;</span><br><span class="line">            <span class="comment">// 如果左指针不是线索，继续向左子树移动</span></span><br><span class="line">            <span class="keyword">if</span> (!current-&gt;lThread)</span><br><span class="line">                current = current-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 遇到线索停止</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 插入右子树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果右指针不是线索，继续向右子树移动</span></span><br><span class="line">            <span class="keyword">if</span> (!current-&gt;rThread)</span><br><span class="line">                current = current-&gt;right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 遇到线索停止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据值的大小决定插入到左子树还是右子树</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; parent-&gt;value) &#123;</span><br><span class="line">        <span class="comment">// 左子树插入</span></span><br><span class="line">        newNode-&gt;left = parent-&gt;left;  <span class="comment">// 新节点的左指针指向父节点的左指针</span></span><br><span class="line">        newNode-&gt;right = parent;       <span class="comment">// 新节点的右指针指向父节点</span></span><br><span class="line">        parent-&gt;lThread = <span class="literal">false</span>;       <span class="comment">// 插入后，父节点的左指针不再是线索</span></span><br><span class="line">        parent-&gt;left = newNode;        <span class="comment">// 父节点的左子树变为新节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 右子树插入</span></span><br><span class="line">        newNode-&gt;right = parent-&gt;right; <span class="comment">// 新节点的右指针指向父节点的右指针</span></span><br><span class="line">        newNode-&gt;left = parent;         <span class="comment">// 新节点的左指针指向父节点</span></span><br><span class="line">        parent-&gt;rThread = <span class="literal">false</span>;        <span class="comment">// 插入后，父节点的右指针不再是线索</span></span><br><span class="line">        parent-&gt;right = newNode;        <span class="comment">// 父节点的右子树变为新节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到中序遍历的起点（即最左边的节点）</span></span><br><span class="line"><span class="function">ThreadedNode* <span class="title">leftmost</span><span class="params">(ThreadedNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 一直移动到没有左子节点的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!node-&gt;lThread) </span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线索化二叉树的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraversal</span><span class="params">(ThreadedNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最左边的节点开始</span></span><br><span class="line">    ThreadedNode* current = <span class="built_in">leftmost</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个树</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出当前节点的值</span></span><br><span class="line">        cout &lt;&lt; current-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点的右指针是线索，直接跳到下一个中序节点</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;rThread)</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则找到当前节点右子树中的最左节点</span></span><br><span class="line">            current = <span class="built_in">leftmost</span>(current-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadedNode* root = <span class="literal">nullptr</span>;  <span class="comment">// 创建一个空的线索二叉树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点，构建线索二叉树</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">5</span>);  <span class="comment">// 插入根节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">3</span>);  <span class="comment">// 插入左子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">8</span>);  <span class="comment">// 插入右子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">2</span>);  <span class="comment">// 插入左子树中的左子节点</span></span><br><span class="line">    root = <span class="built_in">insert</span>(root, <span class="number">4</span>);  <span class="comment">// 插入左子树中的右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线索化后的中序遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrderTraversal</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a>代码说明：</h3><ol>
<li><p><strong>树的结构</strong>：</p>
<ul>
<li>我们插入节点顺序为 <code>5, 3, 8, 2, 4</code>，构造如下的树：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>中序遍历顺序</strong>：</p>
<ul>
<li>中序遍历的顺序是：<strong>先访问左子树，再访问根节点，最后访问右子树</strong>.</li>
<li>对于这棵树的中序遍历顺序是：<code>2 3 4 5 8</code>.</li>
</ul>
</li>
<li><p><strong>关键函数</strong>：</p>
<ul>
<li><code>insert</code>：在二叉树中插入节点，同时维护线索化指针.</li>
<li><code>leftmost</code>：寻找中序遍历中最左边的节点，作为遍历起点.</li>
<li><code>inOrderTraversal</code>：通过线索化指针进行中序遍历.</li>
</ul>
</li>
</ol>
<h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><p>运行此代码，输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中序遍历: 2 3 4 5 8</span><br></pre></td></tr></table></figure>

<h1 id="线索化二叉树解释："><a href="#线索化二叉树解释：" class="headerlink" title="线索化二叉树解释："></a>线索化二叉树解释：</h1><h3 id="1-初始状态："><a href="#1-初始状态：" class="headerlink" title="1. 初始状态："></a>1. <strong>初始状态</strong>：</h3><p>我们创建了一个空的线索二叉树 <code>root</code>，即 <code>root = nullptr</code>.</p>
<h3 id="2-插入节点-5："><a href="#2-插入节点-5：" class="headerlink" title="2. 插入节点 5："></a>2. <strong>插入节点 5</strong>：</h3><ul>
<li>调用 <code>insert(root, 5)</code>.</li>
<li>因为 <code>root</code> 是 <code>nullptr</code>，直接返回新节点 <code>5</code> 作为根节点.此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></li>
<li><code>5</code> 没有子节点，也没有线索.</li>
</ul>
<h3 id="3-插入节点-3："><a href="#3-插入节点-3：" class="headerlink" title="3. 插入节点 3："></a>3. <strong>插入节点 3</strong>：</h3><ul>
<li>调用 <code>insert(root, 3)</code>，即在节点 <code>5</code> 的基础上插入.</li>
<li><code>3 &lt; 5</code>，因此我们将其插入到 <code>5</code> 的左子树中.</li>
<li>节点 <code>3</code> 的右指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">3</span><br><span class="line"> \</span><br><span class="line">  5 (线索)</span><br></pre></td></tr></table></figure></li>
<li><code>5</code> 的左指针不再是线索，它现在有一个真正的左子树（节点 <code>3</code>）.</li>
</ul>
<h3 id="4-插入节点-8："><a href="#4-插入节点-8：" class="headerlink" title="4. 插入节点 8："></a>4. <strong>插入节点 8</strong>：</h3><ul>
<li>调用 <code>insert(root, 8)</code>，即在当前树结构上插入.</li>
<li><code>8 &gt; 5</code>，因此我们将其插入到节点 <code>5</code> 的右子树中.</li>
<li>节点 <code>8</code> 的左指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">3   8</span><br><span class="line"> \</span><br><span class="line">  5 (线索)</span><br><span class="line">  8 (线索)</span><br></pre></td></tr></table></figure></li>
<li>节点 <code>5</code> 的右指针现在指向真正的右子树（节点 <code>8</code>）.</li>
</ul>
<h3 id="5-插入节点-2："><a href="#5-插入节点-2：" class="headerlink" title="5. 插入节点 2："></a>5. <strong>插入节点 2</strong>：</h3><ul>
<li>调用 <code>insert(root, 2)</code>，即在当前树结构上插入.</li>
<li><code>2 &lt; 5</code>，继续向左走，<code>2 &lt; 3</code>，因此我们将其插入到节点 <code>3</code> 的左子树中.</li>
<li>节点 <code>2</code> 的右指针作为线索指向节点 <code>3</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   5 (线索)</span><br><span class="line"> \</span><br><span class="line">  3 (线索)</span><br></pre></td></tr></table></figure></li>
<li>节点 <code>3</code> 的左指针不再是线索，它现在有一个真正的左子树（节点 <code>2</code>）.</li>
</ul>
<h3 id="6-插入节点-4："><a href="#6-插入节点-4：" class="headerlink" title="6. 插入节点 4："></a>6. <strong>插入节点 4</strong>：</h3><ul>
<li>调用 <code>insert(root, 4)</code>，即在当前树结构上插入.</li>
<li><code>4 &lt; 5</code>，继续向左走，<code>4 &gt; 3</code>，因此我们将其插入到节点 <code>3</code> 的右子树中.</li>
<li>节点 <code>4</code> 的右指针作为线索指向节点 <code>5</code>，此时树结构如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br><span class="line">\	 \</span><br><span class="line">3(线) 5 (线索)</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-树的最终结构："><a href="#7-树的最终结构：" class="headerlink" title="7. 树的最终结构："></a>7. <strong>树的最终结构</strong>：</h3><p>经过上述插入操作，最终树的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> / \</span><br><span class="line">2   4</span><br></pre></td></tr></table></figure>

<ul>
<li>左子树是：<code>3 -&gt; 2, 3 -&gt; 4</code>，并且线索指向相应的节点.</li>
</ul>
<h3 id="8-中序遍历过程："><a href="#8-中序遍历过程：" class="headerlink" title="8. 中序遍历过程："></a>8. <strong>中序遍历过程</strong>：</h3><h4 id="步骤-1：找到最左边的节点"><a href="#步骤-1：找到最左边的节点" class="headerlink" title="步骤 1：找到最左边的节点"></a>步骤 1：找到最左边的节点</h4><ul>
<li>调用 <code>leftmost(root)</code>，找到树中最左边的节点，即 <code>2</code>.</li>
</ul>
<h4 id="步骤-2：遍历中序节点"><a href="#步骤-2：遍历中序节点" class="headerlink" title="步骤 2：遍历中序节点"></a>步骤 2：遍历中序节点</h4><ul>
<li>当前节点是 <code>2</code>，输出 <code>2</code>，然后查看 <code>2</code> 的右指针，发现它是线索指向节点 <code>3</code>，因此移动到节点 <code>3</code>.</li>
<li>当前节点是 <code>3</code>，输出 <code>3</code>，然后查看 <code>3</code> 的右指针，发现它指向节点 <code>4</code>，移动到节点 <code>4</code>.</li>
<li>当前节点是 <code>4</code>，输出 <code>4</code>，然后查看 <code>4</code> 的右指针，发现它是线索，指向节点 <code>5</code>，移动到节点 <code>5</code>.</li>
<li>当前节点是 <code>5</code>，输出 <code>5</code>，然后查看 <code>5</code> 的右指针，指向真正的右子树，找到最左边的节点 <code>8</code>.</li>
<li>当前节点是 <code>8</code>，输出 <code>8</code>，然后它没有右子树或线索，遍历结束.</li>
</ul>
<h3 id="9-中序遍历输出："><a href="#9-中序遍历输出：" class="headerlink" title="9. 中序遍历输出："></a>9. <strong>中序遍历输出</strong>：</h3><p>最终中序遍历输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 5 8</span><br></pre></td></tr></table></figure>

<p>这就是整个代码的运行过程和中序遍历结果.</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>赫夫曼树与赫夫曼编码</title>
    <url>/2024/10/09/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h3 id="1-哈夫曼树（Huffman-Tree）："><a href="#1-哈夫曼树（Huffman-Tree）：" class="headerlink" title="1. 哈夫曼树（Huffman Tree）："></a>1. <strong>哈夫曼树（Huffman Tree）</strong>：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>哈夫曼树是一种带权路径长度最短的二叉树，通常用于<strong>数据压缩</strong>。</p>
<h3 id="它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。"><a href="#它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。" class="headerlink" title="它的“最优”体现在权重大的节点离根节点更近，从而使加权路径长度最小。"></a>它的“最优”体现在<strong>权重大的节点离根节点更近</strong>，从而使加权路径长度最小。</h3><h4 id="构造过程："><a href="#构造过程：" class="headerlink" title="构造过程："></a>构造过程：</h4><p>哈夫曼树的构建基于贪心算法，步骤如下：</p>
<ol>
<li>将给定的所有权值看作是森林中的单节点树。</li>
<li>每次选择两个权值最小的节点进行合并，构成一个新的父节点，其权值为两个子节点的权值之和。</li>
<li>重复上述过程，直到所有节点合并成一棵二叉树。</li>
</ol>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><ul>
<li><strong>数据压缩</strong>：哈夫曼树用于<strong>哈夫曼编码</strong>，它通过为高频率字符分配较短的编码，低频率字符分配较长的编码，达到压缩数据的目的。</li>
</ul>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>假设我们有字符集和对应的权值（频率）如下：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>频率</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>5</td>
</tr>
<tr>
<td>B</td>
<td>9</td>
</tr>
<tr>
<td>C</td>
<td>12</td>
</tr>
<tr>
<td>D</td>
<td>13</td>
</tr>
<tr>
<td>E</td>
<td>16</td>
</tr>
<tr>
<td>F</td>
<td>45</td>
</tr>
</tbody></table>
<p>构建哈夫曼树的过程如下：</p>
<ol>
<li>选择频率最小的 <code>A(5)</code> 和 <code>B(9)</code>，合并为一个新节点，权值为 14。</li>
<li>再选择 <code>C(12)</code> 和 <code>D(13)</code> 合并，权值为 25。</li>
<li>合并 <code>14</code> 和 <code>E(16)</code>，权值为 30。</li>
<li>合并 <code>25</code> 和 <code>F(45)</code>，权值为 70。</li>
<li>最后合并 <code>30</code> 和 <code>70</code>，得到哈夫曼树的根节点。</li>
</ol>
<p>这棵树是<strong>最优的</strong>，因为它最小化了每个字符的加权路径长度。</p>
<h5 id="最终生成的最优二叉树如下："><a href="#最终生成的最优二叉树如下：" class="headerlink" title="最终生成的最优二叉树如下："></a>最终生成的最优二叉树如下：</h5><pre><code>        R(100)
       /     \
   N3(30)   N4(70)
    /   \      /   \
 A(5)  E(16) N2(25) F(45)
            /   \
         C(12) D(13)
</code></pre>
<h1 id="2-赫夫曼编码"><a href="#2-赫夫曼编码" class="headerlink" title="2.赫夫曼编码"></a>2.赫夫曼编码</h1><p>为了实现高效率，我们要采取不等长编码原则，以及前缀编码原则</p>
<h3 id="赫夫曼编码过程："><a href="#赫夫曼编码过程：" class="headerlink" title="赫夫曼编码过程："></a>赫夫曼编码过程：</h3><p>向左用0表示，向右用1表示</p>
<p>根据树的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         R(100)</span><br><span class="line">        /     \</span><br><span class="line">    N3(30)   N4(70)</span><br><span class="line">   /   \      /   \</span><br><span class="line">A(5)  E(16) N2(25) F(45)</span><br><span class="line">           /   \</span><br><span class="line">        C(12) D(13)</span><br></pre></td></tr></table></figure>

<p>生成的赫夫曼编码应该是：</p>
<ul>
<li><strong>A</strong>: 00</li>
<li><strong>E</strong>: 01</li>
<li><strong>C</strong>: 100</li>
<li><strong>D</strong>: 101</li>
<li><strong>F</strong>: 11</li>
</ul>
<h3 id="对应的编码表："><a href="#对应的编码表：" class="headerlink" title="对应的编码表："></a>对应的编码表：</h3><table>
<thead>
<tr>
<th>字符</th>
<th>赫夫曼编码</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>00</td>
</tr>
<tr>
<td>E</td>
<td>01</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>101</td>
</tr>
<tr>
<td>F</td>
<td>11</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二叉树</tag>
        <tag>贪心算法</tag>
        <tag>树</tag>
        <tag>最优二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>邻接表，邻接矩阵和十字链表</title>
    <url>/2024/10/16/%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%8C%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="1-邻接表的实现"><a href="#1-邻接表的实现" class="headerlink" title="1. 邻接表的实现"></a>1. 邻接表的实现</h3><p>邻接表使用一个数组或 <code>vector</code> 来存储每个顶点的边列表。每个顶点的边列表存储在一个链表或 <code>vector</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// 顶点数量</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adj.<span class="built_in">resize</span>(V);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj[i]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; v;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-邻接矩阵的实现"><a href="#2-邻接矩阵的实现" class="headerlink" title="2. 邻接矩阵的实现"></a>2. 邻接矩阵的实现</h3><p>邻接矩阵使用一个二维数组来存储顶点之间的边。每个元素表示顶点之间是否存在边。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="type">int</span> V; <span class="comment">// 顶点数量</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMatrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;V = V;</span><br><span class="line">        adjMatrix.<span class="built_in">resize</span>(V, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjMatrix[u][v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果是无向图，也要添加下面这一行</span></span><br><span class="line">        <span class="comment">// adjMatrix[v][u] = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; V; j++) &#123;</span><br><span class="line">                cout &lt;&lt; adjMatrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-十字链表的实现"><a href="#3-十字链表的实现" class="headerlink" title="3. 十字链表的实现"></a>3. 十字链表的实现</h3><p>十字链表是一种复杂的数据结构，特别适用于有向图。它包含每个顶点的出边和入边链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EdgeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> tail;  <span class="comment">// 边的起点</span></span><br><span class="line">    <span class="type">int</span> head;  <span class="comment">// 边的终点</span></span><br><span class="line">    EdgeNode *nextOut; <span class="comment">// 下一条出边</span></span><br><span class="line">    EdgeNode *nextIn;  <span class="comment">// 下一条入边</span></span><br><span class="line">    <span class="built_in">EdgeNode</span>(<span class="type">int</span> t, <span class="type">int</span> h) : <span class="built_in">tail</span>(t), <span class="built_in">head</span>(h), <span class="built_in">nextOut</span>(<span class="literal">nullptr</span>), <span class="built_in">nextIn</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 顶点的数据</span></span><br><span class="line">    EdgeNode *firstOut; <span class="comment">// 出边链表头节点</span></span><br><span class="line">    EdgeNode *firstIn;  <span class="comment">// 入边链表头节点</span></span><br><span class="line">    <span class="built_in">VertexNode</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(d), <span class="built_in">firstOut</span>(<span class="literal">nullptr</span>), <span class="built_in">firstIn</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrthogonalList</span> &#123;</span><br><span class="line">    vector&lt;VertexNode*&gt; vertices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrthogonalList</span>(<span class="type">int</span> V) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; ++i) &#123;</span><br><span class="line">            vertices.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">VertexNode</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        EdgeNode* edge = <span class="keyword">new</span> <span class="built_in">EdgeNode</span>(u, v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到出边链表</span></span><br><span class="line">        edge-&gt;nextOut = vertices[u]-&gt;firstOut;</span><br><span class="line">        vertices[u]-&gt;firstOut = edge;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到入边链表</span></span><br><span class="line">        edge-&gt;nextIn = vertices[v]-&gt;firstIn;</span><br><span class="line">        vertices[v]-&gt;firstIn = edge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打印出边链表</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;  Out-edges:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode* e = vertices[i]-&gt;firstOut; e != <span class="literal">nullptr</span>; e = e-&gt;nextOut) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; e-&gt;head;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印入边链表</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;  In-edges:&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (EdgeNode* e = vertices[i]-&gt;firstIn; e != <span class="literal">nullptr</span>; e = e-&gt;nextIn) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot; &lt;- &quot;</span> &lt;&lt; e-&gt;tail;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">OrthogonalList <span class="title">g</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">printGraph</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>十字链表</strong>（Orthogonal List）是一种用于表示<strong>有向图</strong>的链式存储结构，它同时包含了每个顶点的<strong>入边</strong>和<strong>出边</strong>信息。十字链表是一种扩展的邻接表，能够方便地访问有向图中的边和顶点的入度、出度关系。该结构特别适合处理复杂的有向图问题。</p>
<h3 id="十字链表的定义"><a href="#十字链表的定义" class="headerlink" title="十字链表的定义"></a>十字链表的定义</h3><p>在十字链表中，每个顶点既有一个<strong>出边链表</strong>，也有一个<strong>入边链表</strong>，分别存储从该顶点出发和指向该顶点的边。具体来说：</p>
<ul>
<li>每条边由两个链表节点表示：<strong>出边节点</strong>（表示从某顶点出发的边）和<strong>入边节点</strong>（表示指向某顶点的边）。</li>
<li>顶点包含两个指针：一个指向该顶点的出边链表的头节点，另一个指向该顶点的入边链表的头节点。</li>
</ul>
<h3 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h3><ul>
<li><strong>顶点结构（Vertex Node）</strong>：每个顶点有两个指针，一个指向该顶点的出边链表（out-edge list），另一个指向该顶点的入边链表（in-edge list）。</li>
<li><strong>边结构（Edge Node）</strong>：每条边有两个指针，一个指向下一个出边（out-edge），另一个指向下一个入边（in-edge）。此外，边节点会记录边的起点和终点信息（通常是用来标识的起点和终点索引）。</li>
</ul>
<h3 id="十字链表的节点结构"><a href="#十字链表的节点结构" class="headerlink" title="十字链表的节点结构"></a>十字链表的节点结构</h3><p>假设有向图有 ( V ) 个顶点， ( E ) 条边，十字链表的基本节点可以定义为以下形式：</p>
<ol>
<li><p><strong>顶点节点（Vertex Node）</strong>：</p>
<ul>
<li><strong>data</strong>：顶点的值或标识。</li>
<li><strong>firstOut</strong>：指向该顶点的<strong>出边链表</strong>的头节点。</li>
<li><strong>firstIn</strong>：指向该顶点的<strong>入边链表</strong>的头节点。</li>
</ul>
</li>
<li><p><strong>边节点（Edge Node）</strong>：</p>
<ul>
<li><strong>tail</strong>：起点（边的出发顶点）。</li>
<li><strong>head</strong>：终点（边的目标顶点）。</li>
<li><strong>nextOut</strong>：指向<strong>出边链表</strong>中的下一条边（从相同顶点出发的下一条边）。</li>
<li><strong>nextIn</strong>：指向<strong>入边链表</strong>中的下一条边（指向相同顶点的下一条边）。</li>
<li><strong>weight</strong>（可选）：如果是加权图，则可以包含边的权重信息。</li>
</ul>
</li>
</ol>
<h3 id="十字链表的示例"><a href="#十字链表的示例" class="headerlink" title="十字链表的示例"></a>十字链表的示例</h3><p>我们通过一个简单的有向图来说明十字链表的结构。假设有如下有向图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">顶点：A, B, C, D</span><br><span class="line">边：A → B, A → C, B → C, C → D</span><br></pre></td></tr></table></figure>

<h4 id="1-顶点的出边链表和入边链表"><a href="#1-顶点的出边链表和入边链表" class="headerlink" title="1. 顶点的出边链表和入边链表"></a>1. 顶点的出边链表和入边链表</h4><ul>
<li>顶点 A 的<strong>出边链表</strong>：A → B, A → C</li>
<li>顶点 A 的<strong>入边链表</strong>：无</li>
<li>顶点 B 的<strong>出边链表</strong>：B → C</li>
<li>顶点 B 的<strong>入边链表</strong>：A → B</li>
<li>顶点 C 的<strong>出边链表</strong>：C → D</li>
<li>顶点 C 的<strong>入边链表</strong>：A → C, B → C</li>
<li>顶点 D 的<strong>入边链表</strong>：C → D</li>
</ul>
<h4 id="2-十字链表表示"><a href="#2-十字链表表示" class="headerlink" title="2. 十字链表表示"></a>2. 十字链表表示</h4><p>顶点节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A: firstOut -&gt; (A → B), firstIn -&gt; null</span><br><span class="line">B: firstOut -&gt; (B → C), firstIn -&gt; (A → B)</span><br><span class="line">C: firstOut -&gt; (C → D), firstIn -&gt; (A → C)</span><br><span class="line">D: firstOut -&gt; null,      firstIn -&gt; (C → D)</span><br></pre></td></tr></table></figure>

<p>边节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(A → B): nextOut -&gt; (A → C), nextIn -&gt; null</span><br><span class="line">(A → C): nextOut -&gt; null,      nextIn -&gt; null</span><br><span class="line">(B → C): nextOut -&gt; null,      nextIn -&gt; (A → C)</span><br><span class="line">(C → D): nextOut -&gt; null,      nextIn -&gt; null</span><br></pre></td></tr></table></figure>

<p>在这个结构中，顶点 A 通过 <code>firstOut</code> 链接了出边 <code>(A → B)</code>，并通过 <code>nextOut</code> 指向下一条出边 <code>(A → C)</code>，而 <code>firstIn</code> 为 <code>null</code>，因为没有指向 A 的边。同样，边 <code>(A → B)</code> 的 <code>nextIn</code> 为空，因为没有指向 B 的其他边。</p>
<h3 id="十字链表的优缺点"><a href="#十字链表的优缺点" class="headerlink" title="十字链表的优缺点"></a>十字链表的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>方便处理有向图</strong>：十字链表同时存储了<strong>出边</strong>和<strong>入边</strong>信息，因此可以方便地遍历从顶点出发的边以及指向该顶点的边。这使得在处理有向图的算法中（如拓扑排序、求解强连通分量等）非常高效。</li>
<li><strong>高效的边操作</strong>：可以快速获取某个顶点的所有出边和入边，适合需要频繁查询边信息的场景。</li>
<li><strong>适合稀疏图</strong>：十字链表只存储实际存在的边，因此在边数较少的稀疏图中节省空间。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>复杂性高</strong>：相比于普通的邻接表或邻接矩阵，十字链表的数据结构较为复杂，构建和维护成本较高。每条边需要维护两个链表，代码实现上较为复杂。</li>
<li><strong>空间占用较大</strong>：由于每条边需要存储两个链表指针（<code>nextOut</code> 和 <code>nextIn</code>），十字链表比简单的邻接表占用更多的空间。</li>
</ol>
<h3 id="十字链表的时间复杂度"><a href="#十字链表的时间复杂度" class="headerlink" title="十字链表的时间复杂度"></a>十字链表的时间复杂度</h3><ul>
<li><strong>空间复杂度</strong>：由于每条边都需要额外维护两个指针，十字链表的空间复杂度为 ( O(V + 2E) )，即每个顶点存储两个指针，每条边也存储两个指针。</li>
<li><strong>遍历所有出边&#x2F;入边</strong>：从某个顶点出发，遍历所有出边或入边的时间复杂度是 ( O(d) )，其中 ( d ) 是该顶点的度数。</li>
<li><strong>查找特定边</strong>：查找某个顶点的所有出边或入边仍然需要遍历整个链表，时间复杂度为 ( O(d) )。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p><strong>有向图的遍历</strong>：十字链表适合处理需要同时遍历出边和入边的有向图算法，例如：</p>
<ul>
<li><strong>拓扑排序</strong>：需要同时考虑入度和出度，十字链表方便在 O(1) 时间内访问这些信息。</li>
<li><strong>强连通分量</strong>算法：在求解强连通分量时，需要遍历有向图的逆图，十字链表能够高效支持这种操作。</li>
</ul>
</li>
<li><p><strong>网络流</strong>：在最大流或最小费用流等问题中，十字链表能够高效表示网络中的有向边及其流量信息。</p>
</li>
</ul>
<p><strong>十字链表</strong>是一种用于表示<strong>有向图</strong>的链式结构，通过同时维护顶点的出边和入边链表，能够高效处理有向图的遍历和操作，尤其适用于那些需要频繁查询边信息和入度、出度关系的应用场景。虽然其空间开销较大，结构复杂，但在有向图的高级算法中，十字链表提供了很高的效率。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>邻接表</strong>适用于稀疏图，空间效率高，但查询特定边的时间复杂度较高。</li>
<li><strong>邻接矩阵</strong>适用于稠密图，查询特定边的时间复杂度为 $O(1)$，但空间效率较低。</li>
<li><strong>十字链表</strong>适用于有向图，能够高效地处理出边和入边的操作，适合复杂的有向图算法。</li>
</ul>
<p>通过这些实现，我们可以根据具体问题的需求选择合适的数据结构来表示图。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
</search>
